{
  "0": "SELECT \n    (SELECT COUNT(*) FROM customers WHERE Currency = 'EUR') * 1.0 / \n    NULLIF((SELECT COUNT(*) FROM customers WHERE Currency = 'CZK'), 0) AS EUR_to_CZK_ratio;\t----- bird -----\tdebit_card_specializing",
  "1": "SELECT \n    (COUNT(CASE WHEN c.Currency = 'EUR' THEN 1 END) * 1.0 / \n    NULLIF(COUNT(CASE WHEN c.Currency = 'CZK' THEN 1 END), 0)) AS ratio_eur_to_czk\nFROM \n    customers c\nJOIN \n    transactions_1k t ON c.CustomerID = t.CustomerID\nWHERE \n    c.Currency IN ('EUR', 'CZK');\t----- bird -----\tdebit_card_specializing",
  "2": "SELECT \n    y.CustomerID, \n    SUM(y.Consumption) AS total_consumption\nFROM \n    customers c\nJOIN \n    yearmonth y ON c.CustomerID = y.CustomerID\nWHERE \n    y.Date BETWEEN '201201' AND '201212' \n    AND c.Segment = 'LAM'\nGROUP BY \n    y.CustomerID\nORDER BY \n    total_consumption ASC\nLIMIT 1;\t----- bird -----\tdebit_card_specializing",
  "3": "FAILED\t----- bird -----\tdebit_card_specializing",
  "4": "FAILED\t----- bird -----\tdebit_card_specializing",
  "5": "SELECT \n    COUNT(CASE WHEN Currency = 'EUR' THEN 1 END) * 1.0 / \n    NULLIF(COUNT(CASE WHEN Currency = 'CZK' THEN 1 END), 0) AS Ratio_EUR_to_CZK\nFROM \n    customers\nWHERE \n    Currency IN ('EUR', 'CZK');\t----- bird -----\tdebit_card_specializing",
  "6": "SELECT \n    c.CustomerID,\n    SUM(ym.Consumption) AS Total_Consumption\nFROM \n    yearmonth ym\nJOIN \n    customers c ON ym.CustomerID = c.CustomerID\nWHERE \n    ym.Date BETWEEN '201201' AND '201212'\nGROUP BY \n    c.CustomerID\nORDER BY \n    Total_Consumption ASC\nLIMIT 1;\t----- bird -----\tdebit_card_specializing",
  "7": "SELECT \n    (SELECT COUNT(*) FROM customers WHERE Currency = 'EUR') * 1.0 / \n    NULLIF((SELECT COUNT(*) FROM customers WHERE Currency = 'CZK'), 0) AS ratio\t----- bird -----\tdebit_card_specializing",
  "8": "SELECT \n    y.CustomerID, \n    SUM(y.Consumption) AS TotalConsumption \nFROM \n    yearmonth y\nJOIN \n    transactions_1k t ON y.CustomerID = t.CustomerID \nJOIN \n    gasstations g ON t.GasStationID = g.GasStationID \nWHERE \n    y.Date BETWEEN '201201' AND '201212' \n    AND g.Country = 'LAM' \nGROUP BY \n    y.CustomerID \nORDER BY \n    TotalConsumption ASC \nLIMIT 1\t----- bird -----\tdebit_card_specializing",
  "9": "SELECT \n    (SELECT COUNT(DISTINCT c.CustomerID) \n     FROM customers c \n     JOIN transactions_1k t ON c.CustomerID = t.CustomerID \n     WHERE c.Currency = 'EUR') * 1.0 /\n    NULLIF((SELECT COUNT(DISTINCT c.CustomerID) \n     FROM customers c \n     JOIN transactions_1k t ON c.CustomerID = t.CustomerID \n     WHERE c.Currency = 'CZK'), 0) AS EUR_CZK_Ratio\t----- bird -----\tdebit_card_specializing",
  "10": "SELECT \n    y.CustomerID, \n    SUM(y.Consumption) AS TotalConsumption\nFROM \n    yearmonth y\nJOIN \n    transactions_1k t ON y.CustomerID = t.CustomerID \nJOIN \n    products p ON t.ProductID = p.ProductID \nWHERE \n    y.Date BETWEEN '201201' AND '201212' \n    AND p.Description = 'LAM'\nGROUP BY \n    y.CustomerID\nORDER BY \n    TotalConsumption ASC\nLIMIT 1\t----- bird -----\tdebit_card_specializing",
  "11": "SELECT \n    AVG(TotalAnnualConsumption) / 12 AS AverageMonthlyConsumption\nFROM (\n    SELECT \n        y.CustomerID, \n        SUM(y.Consumption) AS TotalAnnualConsumption\n    FROM \n        yearmonth y\n    JOIN \n        customers c ON y.CustomerID = c.CustomerID \n    WHERE \n        y.Date BETWEEN '201301' AND '201312' \n        AND c.Segment = 'SME'\n    GROUP BY \n        y.CustomerID\n) AS AnnualConsumption\t----- bird -----\tdebit_card_specializing",
  "12": "SELECT \n    SUM(CASE WHEN c.Currency = 'CZK' THEN y.Consumption ELSE 0 END) - \n    SUM(CASE WHEN c.Currency = 'EUR' THEN y.Consumption ELSE 0 END) AS ConsumptionDifference\nFROM \n    yearmonth y\nJOIN \n    customers c ON y.CustomerID = c.CustomerID \nJOIN \n    transactions_1k t ON c.CustomerID = t.CustomerID \nWHERE \n    y.Date BETWEEN '201201' AND '201212'\t----- bird -----\tdebit_card_specializing",
  "13": "SELECT \n    SUBSTR(y.Date, 1, 4) AS Year, \n    SUM(y.Consumption) AS TotalConsumption\nFROM \n    yearmonth y\nJOIN \n    transactions_1k t ON y.CustomerID = t.CustomerID\nJOIN \n    customers c ON t.CustomerID = c.CustomerID \nWHERE \n    c.Currency = 'CZK'\nGROUP BY \n    Year\nORDER BY \n    TotalConsumption DESC\nLIMIT 1\t----- bird -----\tdebit_card_specializing",
  "14": "SELECT \n    SUBSTR(y.Date, 5, 2) AS Month, \n    SUM(y.Consumption) AS TotalConsumption\nFROM \n    yearmonth y\nJOIN \n    customers c ON y.CustomerID = c.CustomerID \nWHERE \n    y.Date BETWEEN '201301' AND '201312' \n    AND c.Segment = 'SME'\nGROUP BY \n    Month\nORDER BY \n    TotalConsumption DESC\nLIMIT 1\t----- bird -----\tdebit_card_specializing",
  "15": "WITH AnnualConsumption AS (\n    SELECT \n        c.Segment,\n        y.CustomerID,\n        SUM(y.Consumption) AS TotalConsumption\n    FROM \n        yearmonth y\n    JOIN \n        customers c ON y.CustomerID = c.CustomerID \n    WHERE \n        y.Date BETWEEN '201301' AND '201312' \n        AND c.Currency = 'CZK'\n    GROUP BY \n        c.Segment, y.CustomerID\n),\n\nLeastConsumption AS (\n    SELECT \n        Segment,\n        CustomerID,\n        TotalConsumption,\n        (TotalConsumption / COUNT(CustomerID) OVER (PARTITION BY Segment)) AS AnnualAverage\n    FROM (\n        SELECT \n            Segment,\n            CustomerID,\n            TotalConsumption,\n            RANK() OVER (PARTITION BY Segment ORDER BY TotalConsumption ASC) AS rnk\n        FROM \n            AnnualConsumption\n    ) ranked\n    WHERE rnk = 1\n)\n\nSELECT \n    (SELECT AnnualAverage FROM LeastConsumption WHERE Segment = 'SME') - \n    (SELECT AnnualAverage FROM LeastConsumption WHERE Segment = 'LAM') AS SME_LAM_Difference,\n    \n    (SELECT AnnualAverage FROM LeastConsumption WHERE Segment = 'LAM') - \n    (SELECT AnnualAverage FROM LeastConsumption WHERE Segment = 'KAM') AS LAM_KAM_Difference,\n\n    (SELECT AnnualAverage FROM LeastConsumption WHERE Segment = 'KAM') - \n    (SELECT AnnualAverage FROM LeastConsumption WHERE Segment = 'SME') AS KAM_SME_Difference\t----- bird -----\tdebit_card_specializing",
  "16": "WITH ConsumptionByYear AS (\n    SELECT \n        c.Segment,\n        SUBSTR(y.Date, 1, 4) AS Year,\n        SUM(y.Consumption) AS TotalConsumption\n    FROM \n        yearmonth y\n    JOIN \n        customers c ON y.CustomerID = c.CustomerID \n    WHERE \n        c.Currency = 'EUR' \n        AND y.Date BETWEEN '201201' AND '201312'\n    GROUP BY \n        c.Segment, Year\n),\n\nConsumptionDifference AS (\n    SELECT \n        Segment,\n        MAX(CASE WHEN Year = '2012' THEN TotalConsumption END) AS Consumption2012,\n        MAX(CASE WHEN Year = '2013' THEN TotalConsumption END) AS Consumption2013\n    FROM \n        ConsumptionByYear\n    GROUP BY \n        Segment\n)\n\nSELECT \n    Segment,\n    (Consumption2013 - Consumption2012) AS ConsumptionIncrease,\n    (CASE \n        WHEN Consumption2013 != 0 THEN (Consumption2013 - Consumption2012) / Consumption2013 * 100 \n        ELSE 0 \n    END) AS PercentageIncrease\nFROM \n    ConsumptionDifference\nORDER BY \n    PercentageIncrease DESC\t----- bird -----\tdebit_card_specializing",
  "17": "SELECT \n    SUM(y.Consumption) AS TotalConsumption\nFROM \n    yearmonth y\nWHERE \n    y.CustomerID = 6 \n    AND y.Date BETWEEN '201308' AND '201311'\t----- bird -----\tdebit_card_specializing",
  "18": "WITH DiscountGasStations AS (\n    SELECT \n        g.GasStationID, \n        g.Country\n    FROM \n        gasstations g\n    JOIN \n        products p ON g.GasStationID = p.ProductID \n    WHERE \n        p.Description = 'discount'\n)\n\nSELECT \n    (SELECT COUNT(*) FROM DiscountGasStations WHERE Country = 'CZE') - \n    (SELECT COUNT(*) FROM DiscountGasStations WHERE Country = 'SVK') AS Difference\t----- bird -----\tdebit_card_specializing",
  "19": "SELECT \n    (SELECT COUNT(DISTINCT c.CustomerID) \n     FROM customers c \n     JOIN transactions_1k t ON c.CustomerID = t.CustomerID \n     WHERE c.Segment = 'SME' AND c.Currency = 'CZK') - \n    (SELECT COUNT(DISTINCT c.CustomerID) \n     FROM customers c \n     JOIN transactions_1k t ON c.CustomerID = t.CustomerID \n     WHERE c.Segment = 'SME' AND c.Currency = 'EUR') AS Difference\t----- bird -----\tdebit_card_specializing",
  "20": "WITH LAMConsumption AS (\n    SELECT \n        c.CustomerID, \n        SUM(y.Consumption) AS TotalConsumption\n    FROM \n        customers c\n    JOIN \n        yearmonth y ON c.CustomerID = y.CustomerID \n    WHERE \n        c.Segment = 'LAM'\n    GROUP BY \n        c.CustomerID\n)\n\nSELECT \n    (COUNT(CASE WHEN TotalConsumption > 46.73 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageMoreThan46_73\nFROM \n    LAMConsumption\t----- bird -----\tdebit_card_specializing",
  "21": "WITH FebruaryConsumption AS (\n    SELECT \n        CustomerID, \n        SUM(Consumption) AS TotalConsumption\n    FROM \n        yearmonth\n    WHERE \n        Date = '201202'\n    GROUP BY \n        CustomerID\n)\n\nSELECT \n    (COUNT(CASE WHEN TotalConsumption > 528.3 THEN 1 END) * 100.0 / COUNT(*)) AS PercentageMoreThan528_3\nFROM \n    FebruaryConsumption\t----- bird -----\tdebit_card_specializing",
  "22": "SELECT \n    SUBSTR(Date, 5, 2) AS Month, \n    SUM(Consumption) AS TotalConsumption\nFROM \n    yearmonth\nWHERE \n    Date BETWEEN '201201' AND '201212'\nGROUP BY \n    Month\nORDER BY \n    TotalConsumption DESC\nLIMIT 1\t----- bird -----\tdebit_card_specializing",
  "23": "SELECT \n    p.Description\nFROM \n    transactions_1k t\nJOIN \n    products p ON t.ProductID = p.ProductID\nJOIN \n    yearmonth y ON t.CustomerID = y.CustomerID\nWHERE \n    y.Date BETWEEN '201309' AND '201309'\t----- bird -----\tdebit_card_specializing",
  "24": "SELECT DISTINCT \n    g.Country\nFROM \n    gasstations g\nJOIN \n    transactions_1k t ON g.GasStationID = t.GasStationID\nWHERE \n    t.Date BETWEEN '20130601' AND '20130630'\t----- bird -----\tdebit_card_specializing",
  "25": "WITH MonthlyConsumption AS (\n    SELECT \n        c.CustomerID,\n        SUM(y.Consumption) AS TotalMonthlyConsumption\n    FROM \n        customers c\n    JOIN \n        yearmonth y ON c.CustomerID = y.CustomerID\n    WHERE \n        c.Currency = 'EUR'\n    GROUP BY \n        c.CustomerID\n)\n\nSELECT \n    COUNT(*) AS CustomerCount\nFROM \n    MonthlyConsumption\nWHERE \n    TotalMonthlyConsumption > 1000\t----- bird -----\tdebit_card_specializing",
  "26": "SELECT \n    p.Description\nFROM \n    transactions_1k t\nJOIN \n    products p ON t.ProductID = p.ProductID\nJOIN \n    gasstations g ON t.GasStationID = g.GasStationID\nWHERE \n    g.Country = 'CZE'\t----- bird -----\tdebit_card_specializing",
  "27": "SELECT DISTINCT \n    t.Time\nFROM \n    transactions_1k t\nJOIN \n    gasstations g ON t.GasStationID = g.GasStationID\nWHERE \n    g.ChainID = 11\t----- bird -----\tdebit_card_specializing",
  "28": "SELECT \n    COUNT(*) AS TransactionCount\nFROM \n    transactions_1k t\nJOIN \n    gasstations g ON t.GasStationID = g.GasStationID\nWHERE \n    g.Country = 'CZE'\n    AND t.Date > '2012-01-01'\t----- bird -----\tdebit_card_specializing",
  "29": "SELECT \n    c.Currency\nFROM \n    transactions_1k t\nJOIN \n    customers c ON t.CustomerID = c.CustomerID\nWHERE \n    t.Date = '2012-08-24' \n    AND t.Time = '16:25:00'\t----- bird -----\tdebit_card_specializing",
  "30": "SELECT \n    c.Segment\nFROM \n    transactions_1k t\nJOIN \n    customers c ON t.CustomerID = c.CustomerID\nWHERE \n    t.Date = '2012-08-23' \n    AND t.Time = '21:20:00'\t----- bird -----\tdebit_card_specializing",
  "31": "SELECT \n    COUNT(*) AS TransactionCount\nFROM \n    transactions_1k t\nJOIN \n    gasstations g ON t.GasStationID = g.GasStationID\nWHERE \n    t.Date = '2012-08-26' \n    AND t.Time BETWEEN '08:00:00' AND '09:00:00'\n    AND g.Country = 'CZE'\t----- bird -----\tdebit_card_specializing",
  "32": "SELECT \n    c.Currency AS Nationality\nFROM \n    transactions_1k t\nJOIN \n    customers c ON t.CustomerID = c.CustomerID\nWHERE \n    t.Date = '2012-08-24' \n    AND t.Amount = 548.4\t----- bird -----\tdebit_card_specializing",
  "33": "WITH CustomersUsingEUR AS (\n    SELECT DISTINCT \n        c.CustomerID \n    FROM \n        customers c\n    JOIN \n        transactions_1k t ON c.CustomerID = t.CustomerID\n    WHERE \n        t.Date = '2012-08-25' \n        AND c.Currency = 'EUR'\n),\n\nTotalCustomers AS (\n    SELECT DISTINCT \n        c.CustomerID \n    FROM \n        customers c\n    JOIN \n        transactions_1k t ON c.CustomerID = t.CustomerID\n    WHERE \n        t.Date = '2012-08-25'\n)\n\nSELECT \n    (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM TotalCustomers)) AS PercentageEURUsers\nFROM \n    CustomersUsingEUR\t----- bird -----\tdebit_card_specializing",
  "34": "WITH CustomerConsumption AS (\n    SELECT \n        c.CustomerID,\n        SUM(CASE WHEN y.Date BETWEEN '201201' AND '201212' THEN y.Consumption ELSE 0 END) AS Consumption2012,\n        SUM(CASE WHEN y.Date BETWEEN '201301' AND '201312' THEN y.Consumption ELSE 0 END) AS Consumption2013\n    FROM \n        customers c\n    JOIN \n        transactions_1k t ON c.CustomerID = t.CustomerID\n    JOIN \n        yearmonth y ON c.CustomerID = y.CustomerID\n    WHERE \n        t.Date = '2012-08-25' \n        AND t.Amount = 634.8\n    GROUP BY \n        c.CustomerID\n)\n\nSELECT \n    (Consumption2012 - Consumption2013) / NULLIF(Consumption2012, 0) AS ConsumptionDecreaseRate\nFROM \n    CustomerConsumption\t----- bird -----\tdebit_card_specializing",
  "35": "WITH PremiumCustomers AS (\n    SELECT COUNT(DISTINCT c.CustomerID) AS PremiumCount\n    FROM customers c\n    JOIN gasstations g ON c.CustomerID = g.GasStationID\n    WHERE c.Segment = 'premium' AND g.Country = 'SVK'\n),\n\nTotalCustomers AS (\n    SELECT COUNT(DISTINCT c.CustomerID) AS TotalCount\n    FROM customers c\n    JOIN gasstations g ON c.CustomerID = g.GasStationID\n    WHERE g.Country = 'SVK'\n)\n\nSELECT \n    (SELECT PremiumCount FROM PremiumCustomers) * 100.0 / NULLIF((SELECT TotalCount FROM TotalCustomers), 0) AS PremiumPercentage\t----- bird -----\tdebit_card_specializing",
  "36": "WITH TotalSpent AS (\n    SELECT \n        SUM(t.Amount) AS TotalAmountSpent\n    FROM \n        transactions_1k t\n    WHERE \n        t.CustomerID = 38508\n),\n\nSpentInJanuary AS (\n    SELECT \n        SUM(t.Amount) AS AmountSpentInJanuary\n    FROM \n        transactions_1k t\n    WHERE \n        t.CustomerID = 38508 AND t.Date = '201201'\n)\n\nSELECT \n    (SELECT TotalAmountSpent FROM TotalSpent) AS TotalSpent,\n    (SELECT AmountSpentInJanuary FROM SpentInJanuary) AS SpentInJanuary\t----- bird -----\tdebit_card_specializing",
  "37": "WITH CustomerSpending AS (\n    SELECT \n        c.CustomerID,\n        c.Currency,\n        SUM(t.Price * t.Amount) AS TotalSpent,\n        SUM(t.Amount) AS TotalItems\n    FROM \n        transactions_1k t\n    JOIN \n        customers c ON t.CustomerID = c.CustomerID\n    GROUP BY \n        c.CustomerID, c.Currency\n),\n\nTopCustomer AS (\n    SELECT \n        CustomerID,\n        Currency,\n        TotalSpent,\n        TotalItems,\n        RANK() OVER (ORDER BY TotalSpent DESC) AS SpendingRank\n    FROM \n        CustomerSpending\n)\n\nSELECT \n    CustomerID,\n    TotalSpent,\n    (TotalSpent / NULLIF(TotalItems, 0)) AS AveragePricePerItem,\n    Currency\nFROM \n    TopCustomer\nWHERE \n    SpendingRank = 1\t----- bird -----\tdebit_card_specializing",
  "38": "WITH EligibleCustomers AS (\n    SELECT \n        t.CustomerID,\n        SUM(t.Price / NULLIF(t.Amount, 0)) AS PricePerUnit\n    FROM \n        transactions_1k t\n    WHERE \n        t.ProductID = 5\n    GROUP BY \n        t.CustomerID\n    HAVING \n        PricePerUnit > 29.00\n)\n\nSELECT \n    y.CustomerID, \n    y.Consumption\nFROM \n    yearmonth y\nJOIN \n    EligibleCustomers ec ON y.CustomerID = ec.CustomerID\nWHERE \n    y.Date = '201208'\t----- bird -----\tdebit_card_specializing",
  "39": "SELECT Major.major_name \nFROM Member \nJOIN Major ON Member.link_to_major = Major.major_id \nWHERE Member.first_name = 'Angela' AND Member.last_name = 'Sanders';\t----- bird -----\tstudent_club",
  "40": "SELECT COUNT(Member.member_id) \nFROM Attendance \nJOIN Event ON Attendance.link_to_event = Event.event_id \nJOIN Member ON Attendance.link_to_member = Member.member_id \nWHERE Event.event_name = 'Women's Soccer' AND Member.t_shirt_size = 'Medium';\t----- bird -----\tstudent_club",
  "41": "SELECT COUNT(Event.event_id) \nFROM Attendance \nJOIN Event ON Attendance.link_to_event = Event.event_id \nGROUP BY Attendance.link_to_event \nHAVING COUNT(Attendance.link_to_member) > 10 AND MAX(Event.type) = 'Meeting';\t----- bird -----\tstudent_club",
  "42": "SELECT Event.event_name \nFROM Attendance \nJOIN Event ON Attendance.link_to_event = Event.event_id \nGROUP BY Event.event_name, Event.event_id \nHAVING COUNT(Attendance.link_to_member) > 20 AND MAX(Event.type) <> 'Fundraiser';\t----- bird -----\tstudent_club",
  "43": "SELECT SUM(Income.amount) \nFROM Member \nJOIN Income ON Member.member_id = Income.link_to_member \nWHERE Member.position = 'Vice President';\t----- bird -----\tstudent_club",
  "44": "SELECT Member.first_name, Member.last_name \nFROM Member \nJOIN Zip_Code ON Member.zip = Zip_Code.zip_code \nWHERE Zip_Code.state = 'Illinois';\t----- bird -----\tstudent_club",
  "45": "SELECT Expense.expense_id, Expense.approved \nFROM Event \nJOIN Expense ON Event.event_id = Expense.link_to_budget \nWHERE Event.event_name = 'October Meeting' AND Event.event_date = '2019-10-08';\t----- bird -----\tstudent_club",
  "46": "SELECT AVG(Expense.cost) \nFROM Member \nJOIN Expense ON Member.member_id = Expense.link_to_member \nWHERE Member.first_name = 'Elijah' AND Member.last_name = 'Allen' \nAND (strftime('%m', Expense.expense_date) = '09' OR strftime('%m', Expense.expense_date) = '10');\t----- bird -----\tstudent_club",
  "47": "SELECT \n    (SELECT SUM(Budget.spent) \n     FROM Event \n     JOIN Budget ON Event.event_id = Budget.link_to_event \n     WHERE strftime('%Y', Event.event_date) = '2019') -\n    (SELECT SUM(Budget.spent) \n     FROM Event \n     JOIN Budget ON Event.event_id = Budget.link_to_event \n     WHERE strftime('%Y', Event.event_date) = '2020') AS total_difference;\t----- bird -----\tstudent_club",
  "48": "SELECT Event.notes \nFROM Income \nJOIN Event ON Income.event_id = Event.event_id \nWHERE Income.source = 'Fundraising' AND Income.date_received = '2019-09-14';\t----- bird -----\tstudent_club",
  "49": "SELECT Member.phone \nFROM Member \nWHERE Member.first_name = 'Carlo' AND Member.last_name = 'Jacobs';\t----- bird -----\tstudent_club",
  "50": "SELECT Event.status \nFROM Expense \nJOIN Budget ON Expense.link_to_budget = Budget.budget_id \nJOIN Event ON Budget.link_to_event = Event.event_id \nWHERE Expense.expense_description = 'Post Cards, Posters' AND Expense.expense_date = '2019-08-20';\t----- bird -----\tstudent_club",
  "51": "SELECT Major.major_name \nFROM Member \nJOIN Major ON Member.link_to_major = Major.major_id \nWHERE Member.first_name = 'Brent' AND Member.last_name = 'Thomason';\t----- bird -----\tstudent_club",
  "52": "SELECT COUNT(Member.member_id) \nFROM Member \nJOIN Major ON Member.link_to_major = Major.major_id \nWHERE Major.major_name = 'Business' AND Member.t_shirt_size = 'Medium';\t----- bird -----\tstudent_club",
  "53": "SELECT Major.department \nFROM Member \nJOIN Major ON Member.link_to_major = Major.major_id \nWHERE Member.position = 'President';\t----- bird -----\tstudent_club",
  "54": "SELECT Income.date_received \nFROM Member \nJOIN Income ON Member.member_id = Income.link_to_member \nWHERE Member.first_name = 'Connor' AND Member.last_name = 'Hilton' AND Income.source = 'Dues';\t----- bird -----\tstudent_club",
  "55": "SELECT \n    (SELECT amount FROM Budget \n     WHERE link_to_event IN (SELECT event_id FROM Event WHERE event_name = 'Yearly Kickoff') \n     AND category = 'Advertisement') /\n    (SELECT amount FROM Budget \n     WHERE link_to_event IN (SELECT event_id FROM Event WHERE event_name = 'October Meeting') \n     AND category = 'Advertisement') AS times_more\t----- bird -----\tstudent_club",
  "56": "SELECT SUM(cost) AS total_cost_of_pizzas \nFROM Expense \nWHERE expense_description = 'Pizza'\t----- bird -----\tstudent_club",
  "57": "SELECT COUNT(DISTINCT city) AS number_of_cities \nFROM Zip_Code \nWHERE county = 'Orange County' AND state = 'Virginia'\t----- bird -----\tstudent_club",
  "58": "SELECT M.major_name \nFROM Member AS Mem \nJOIN Major AS M ON Mem.link_to_major = M.major_id \nWHERE Mem.phone = '809-555-3360'\t----- bird -----\tstudent_club",
  "59": "SELECT COUNT(link_to_member) AS number_of_attendees \nFROM Attendance \nWHERE link_to_event = (SELECT event_id FROM Event WHERE event_name = 'Women's Soccer')\t----- bird -----\tstudent_club",
  "60": "SELECT CONCAT(M.first_name, ' ', M.last_name) AS full_name \nFROM Member AS M \nJOIN Major AS J ON M.link_to_major = J.major_id \nWHERE J.department = 'School of Applied Sciences, Technology and Education'\t----- bird -----\tstudent_club",
  "61": "SELECT E.event_name, \n       (B.spent / B.amount) AS spend_to_budget_ratio\nFROM Budget AS B \nJOIN Event AS E ON B.link_to_event = E.event_id \nWHERE E.status = 'Closed'\nORDER BY spend_to_budget_ratio DESC\nLIMIT 1\t----- bird -----\tstudent_club",
  "62": "SELECT MAX(spent) AS highest_budget_spend \nFROM Budget\t----- bird -----\tstudent_club",
  "63": "SELECT SUM(spent) AS total_amount_spent_on_food \nFROM Budget \nWHERE category = 'Food'\t----- bird -----\tstudent_club",
  "64": "SELECT CONCAT(M.first_name, ' ', M.last_name) AS full_name\nFROM Member AS M\nJOIN Attendance AS A ON M.member_id = A.link_to_member\nGROUP BY M.member_id\nHAVING COUNT(A.link_to_event) > 7\t----- bird -----\tstudent_club",
  "65": "SELECT CONCAT(M.first_name, ' ', M.last_name) AS full_name\nFROM Budget AS B \nJOIN Event AS E ON B.link_to_event = E.event_id \nJOIN Member AS M ON B.link_to_member = M.member_id \nWHERE E.event_name = 'Yearly Kickoff'\t----- bird -----\tstudent_club",
  "66": "SELECT E.event_name \nFROM Expense AS Ex \nJOIN Budget AS B ON Ex.link_to_budget = B.budget_id \nJOIN Event AS E ON B.link_to_event = E.event_id \nWHERE Ex.cost = (SELECT MIN(cost) FROM Expense)\t----- bird -----\tstudent_club",
  "67": "SELECT \n    (SUM(CASE WHEN E.event_name = 'Yearly Kickoff' THEN Ex.cost ELSE 0 END) / SUM(Ex.cost) * 100) AS percentage_of_yearly_kickoff\nFROM Expense AS Ex\nJOIN Budget AS B ON Ex.link_to_budget = B.budget_id\nJOIN Event AS E ON B.link_to_event = E.event_id\t----- bird -----\tstudent_club",
  "68": "SELECT source, SUM(amount) AS total_amount \nFROM Income \nWHERE date_received BETWEEN '2019-09-01' AND '2019-09-30' \nGROUP BY source \nORDER BY total_amount DESC \nLIMIT 1\t----- bird -----\tstudent_club",
  "69": "SELECT COUNT(M.member_id) AS number_of_physics_teaching_students\nFROM Member AS M\nJOIN Major AS J ON M.link_to_major = J.major_id\nWHERE J.major_name = 'Physics Teaching'\t----- bird -----\tstudent_club",
  "70": "SELECT E.event_name \nFROM Budget AS B \nJOIN Event AS E ON B.link_to_event = E.event_id \nWHERE B.category = 'Advertisement' \nORDER BY B.spent DESC \nLIMIT 1\t----- bird -----\tstudent_club",
  "71": "SELECT \n    CASE \n        WHEN A.link_to_member IS NOT NULL THEN 'Yes' \n        ELSE 'No' \n    END AS attended\nFROM Member AS M\nLEFT JOIN Attendance AS A ON M.member_id = A.link_to_member\nJOIN Event AS E ON A.link_to_event = E.event_id\nWHERE M.first_name = 'Maya' AND M.last_name = 'Mclean' AND E.event_name = 'Women's Soccer'\t----- bird -----\tstudent_club",
  "72": "SELECT Ex.cost \nFROM Expense AS Ex \nJOIN Budget AS B ON Ex.link_to_budget = B.budget_id \nJOIN Event AS E ON B.link_to_event = E.event_id \nWHERE Ex.expense_description = 'Posters' AND E.event_name = 'September Speaker'\t----- bird -----\tstudent_club",
  "73": "SELECT E.event_name \nFROM Budget AS B \nJOIN Event AS E ON B.link_to_event = E.event_id \nWHERE B.remaining < 0 \nORDER BY B.remaining ASC \nLIMIT 1\t----- bird -----\tstudent_club",
  "74": "SELECT Ex.expense_description, \n       SUM(Ex.cost) AS total_approved_value\nFROM Expense AS Ex\nJOIN Budget AS B ON Ex.link_to_budget = B.budget_id\nJOIN Event AS E ON B.link_to_event = E.event_id\nWHERE E.event_name = 'October Meeting' AND Ex.approved = 'true'\nGROUP BY Ex.expense_description\t----- bird -----\tstudent_club",
  "75": "SELECT B.category, SUM(B.amount) AS total_budgeted_amount\nFROM Budget AS B\nJOIN Event AS E ON B.link_to_event = E.event_id\nWHERE E.event_name = 'April Speaker'\nGROUP BY B.category\nORDER BY total_budgeted_amount ASC\t----- bird -----\tstudent_club",
  "76": "SELECT SUM(cost) AS total_expense\nFROM Expense\nWHERE expense_date = '2019-08-20'\t----- bird -----\tstudent_club",
  "77": "SELECT \n    CONCAT(M.first_name, ' ', M.last_name) AS full_name, \n    SUM(E.cost) AS total_cost\nFROM Member AS M\nLEFT JOIN Expense AS E ON M.member_id = E.link_to_member\nWHERE M.member_id = 'rec4BLdZHS2Blfp4v'\nGROUP BY M.member_id\t----- bird -----\tstudent_club",
  "78": "SELECT E.expense_description \nFROM Expense AS E\nJOIN Member AS M ON E.link_to_member = M.member_id\nWHERE M.first_name = 'Sacha' AND M.last_name = 'Harrison'\t----- bird -----\tstudent_club",
  "79": "SELECT DISTINCT type \nFROM Event \nWHERE location = 'MU 215'\t----- bird -----\tstudent_club",
  "80": "SELECT \n    M.last_name, \n    J.department, \n    J.college \nFROM Member AS M\nJOIN Major AS J ON M.link_to_major = J.major_id\nWHERE J.major_name = 'Environmental Engineering'\t----- bird -----\tstudent_club",
  "81": "SELECT B.category \nFROM Event AS E \nJOIN Budget AS B ON E.event_id = B.link_to_event \nWHERE E.location = 'MU 215' \n  AND E.type = 'Guest Speaker' \n  AND B.spent = 0\t----- bird -----\tstudent_club",
  "82": "SELECT \n    (COUNT(CASE WHEN I.amount = 50 THEN 1 END) * 100.0) / COUNT(M.member_id) AS percentage\nFROM Member AS M\nLEFT JOIN Income AS I ON M.member_id = I.link_to_member\nWHERE M.t_shirt_size = 'Medium'\t----- bird -----\tstudent_club",
  "83": "SELECT event_name \nFROM Event \nWHERE type = 'Game' \n  AND status = 'Closed' \n  AND event_date BETWEEN '2019-03-15' AND '2020-03-20'\t----- bird -----\tstudent_club",
  "84": "SELECT \n    M.first_name || ' ' || M.last_name AS full_name, \n    M.phone\nFROM Expense AS Ex\nJOIN Member AS M ON Ex.link_to_member = M.member_id\nWHERE Ex.cost > (SELECT AVG(cost) FROM Expense)\t----- bird -----\tstudent_club",
  "85": "SELECT \n    M.first_name || ' ' || M.last_name AS full_name, \n    Ex.cost\nFROM Expense AS Ex\nJOIN Member AS M ON Ex.link_to_member = M.member_id\nWHERE Ex.expense_description = 'Water, Veggie tray, supplies'\t----- bird -----\tstudent_club",
  "86": "SELECT \n    M.first_name || ' ' || M.last_name AS full_name, \n    I.amount\nFROM Income AS I\nJOIN Member AS M ON I.link_to_member = M.member_id\nWHERE I.date_received = '2019-09-09'\t----- bird -----\tstudent_club",
  "87": "SELECT \n    (COUNT(ID) * 100.0 / (SELECT COUNT(ID) FROM Patient WHERE SEX = 'F')) AS Percentage\nFROM \n    Patient\nWHERE \n    SEX = 'F' AND Birthday > '1930-12-31';\t----- bird -----\tthrombosis_prediction",
  "88": "SELECT \n    (COUNT(CASE WHEN Admission = '-' THEN ID END) * 1.0 / \n     COUNT(CASE WHEN Admission = '+' THEN ID END)) AS Ratio\nFROM \n    Patient\nWHERE \n    Diagnosis = 'SLE';\t----- bird -----\tthrombosis_prediction",
  "89": "SELECT \n    Diagnosis AS Disease\nFROM \n    Patient \nWHERE \n    ID = 30609;\n\nSELECT \n    Date AS TestDate\nFROM \n    Laboratory \nWHERE \n    ID = 30609;\t----- bird -----\tthrombosis_prediction",
  "90": "SELECT \n    P.ID, \n    P.SEX, \n    P.Birthday\nFROM \n    Laboratory L\nJOIN \n    Patient P ON L.ID = P.ID\nWHERE \n    L.LDH > 500;\t----- bird -----\tthrombosis_prediction",
  "91": "SELECT \n    E.ID, \n    YEAR(CURRENT_TIMESTAMP) - YEAR(P.Birthday) AS Age\nFROM \n    Examination E\nJOIN \n    Patient P ON E.ID = P.ID\nWHERE \n    E.RVVT = '+';\t----- bird -----\tthrombosis_prediction",
  "92": "SELECT \n    P.ID, \n    P.SEX, \n    P.Diagnosis\nFROM \n    Examination E\nJOIN \n    Patient P ON E.ID = P.ID\nWHERE \n    E.Thrombosis = 2;\t----- bird -----\tthrombosis_prediction",
  "93": "SELECT \n    COUNT(ID) AS FemalePatients\nFROM \n    Patient\nWHERE \n    SEX = 'F' \n    AND YEAR(Description) = 1997 \n    AND Admission = '-';\t----- bird -----\tthrombosis_prediction",
  "94": "SELECT \n    COUNT(P.ID) AS FemalePatients\nFROM \n    Examination E\nJOIN \n    Patient P ON E.ID = P.ID\nWHERE \n    E.Thrombosis = 1 \n    AND YEAR(E.Examination_Date) = 1997 \n    AND P.SEX = 'F';\t----- bird -----\tthrombosis_prediction",
  "95": "SELECT \n    E.Symptoms, \n    P.Diagnosis\nFROM \n    Patient P\nJOIN \n    Examination E ON P.ID = E.ID\nWHERE \n    E.Symptoms IS NOT NULL\n    AND P.Birthday = (SELECT MAX(Birthday) FROM Patient);\t----- bird -----\tthrombosis_prediction",
  "96": "SELECT \n    L.Date AS LaboratoryCompletionDate,\n    YEAR(P.First_Date) - YEAR(P.Birthday) AS AgeAtAdmission\nFROM \n    Patient P\nJOIN \n    Laboratory L ON P.ID = L.ID\nWHERE \n    P.Diagnosis = 'SJS'\n    AND P.Birthday = (SELECT MIN(Birthday) FROM Patient WHERE Diagnosis = 'SJS');\t----- bird -----\tthrombosis_prediction",
  "97": "SELECT \n    (COUNT(CASE WHEN P.SEX = 'M' AND L.UA <= 8.0 THEN 1 END) * 1.0 / \n     COUNT(CASE WHEN P.SEX = 'F' AND L.UA <= 6.5 THEN 1 END)) AS MaleToFemaleRatio\nFROM \n    Laboratory L\nJOIN \n    Patient P ON L.ID = P.ID;\t----- bird -----\tthrombosis_prediction",
  "98": "SELECT \n    COUNT(DISTINCT P.ID) AS UnderagePatients\nFROM \n    Patient P\nJOIN \n    Examination E ON P.ID = E.ID\nWHERE \n    E.Examination_Date BETWEEN '1990-01-01' AND '1993-12-31'\n    AND YEAR(E.Examination_Date) - YEAR(P.Birthday) < 18;\t----- bird -----\tthrombosis_prediction",
  "99": "SELECT \n    (YEAR(E.Examination_Date) - YEAR(P.Birthday)) AS Age,\n    P.Diagnosis\nFROM \n    Laboratory L\nJOIN \n    Patient P ON L.ID = P.ID\nJOIN \n    Examination E ON P.ID = E.ID\nWHERE \n    L.HGB = (SELECT MAX(HGB) FROM Laboratory)\nLIMIT 1;\t----- bird -----\tthrombosis_prediction",
  "100": "SELECT \n    E.aCL_IgM\nFROM \n    Patient P\nJOIN \n    Examination E ON P.ID = E.ID\nWHERE \n    P.Diagnosis = 'SLE' \n    AND P.Description = '1994-02-19'\n    AND E.Examination_Date = '1993-11-12';\t----- bird -----\tthrombosis_prediction",
  "101": "SELECT \n    (SUM(CASE WHEN L.Date LIKE '1981-11-%' THEN L.T_CHO END) - \n     SUM(CASE WHEN L.Date LIKE '1981-12-%' THEN L.T_CHO END)) / \n    SUM(CASE WHEN L.Date LIKE '1981-12-%' THEN L.T_CHO END) AS DecreaseRate\nFROM \n    Patient P\nJOIN \n    Laboratory L ON P.ID = L.ID\nWHERE \n    P.Birthday = '1959-02-18';\t----- bird -----\tthrombosis_prediction",
  "102": "SELECT \n    DISTINCT L.ID\nFROM \n    Laboratory L\nWHERE \n    L.Date BETWEEN '1987-07-06' AND '1996-01-31' \n    AND L.GPT > 30 \n    AND L.ALB < 4;\t----- bird -----\tthrombosis_prediction",
  "103": "WITH AverageIgM AS (\n    SELECT \n        AVG(aCL_IgM) AS AvgIgM\n    FROM \n        Examination\n    WHERE \n        Thrombosis = 2 AND ANA_Pattern = 'S'\n)\nSELECT \n    COUNT(DISTINCT E.ID) AS PatientCount\nFROM \n    Examination E\nJOIN \n    AverageIgM A ON E.aCL_IgM > A.AvgIgM * 1.2\nWHERE \n    E.Thrombosis = 2 AND E.ANA_Pattern = 'S';\t----- bird -----\tthrombosis_prediction",
  "104": "SELECT \n    P.ID\nFROM \n    Patient P\nJOIN \n    Laboratory L ON P.ID = L.ID\nWHERE \n    P.Admission = '-' \n    AND L.Date LIKE '1991-10%' \n    AND L.T_BIL < 2.0;\t----- bird -----\tthrombosis_prediction",
  "105": "SELECT \n    AVG(L.ALB) AS AverageAlbuminLevel\nFROM \n    Laboratory L\nJOIN \n    Patient P ON L.ID = P.ID\nWHERE \n    P.SEX = 'F' \n    AND P.Diagnosis = 'SLE' \n    AND L.PLT > 400;\t----- bird -----\tthrombosis_prediction",
  "106": "SELECT \n    COUNT(ID) AS FemalePatientsWithAPSDiagnosis\nFROM \n    Patient\nWHERE \n    SEX = 'F' \n    AND Diagnosis = 'APS';\t----- bird -----\tthrombosis_prediction",
  "107": "SELECT \n    (COUNT(CASE WHEN SEX = 'F' THEN 1 END) * 100.0 / COUNT(*)) AS PercentageOfWomen\nFROM \n    Patient\nWHERE \n    YEAR(Birthday) = 1980 \n    AND Diagnosis = 'RA';\t----- bird -----\tthrombosis_prediction",
  "108": "SELECT \n    CASE \n        WHEN P.SEX = 'M' AND L.UA <= 8.0 THEN 'Normal'\n        WHEN P.SEX = 'F' AND L.UA <= 6.5 THEN 'Normal'\n        ELSE 'Abnormal'\n    END AS UricAcidStatus\nFROM \n    Laboratory L\nJOIN \n    Patient P ON L.ID = P.ID\nWHERE \n    P.ID = 57266;\t----- bird -----\tthrombosis_prediction",
  "109": "SELECT \n    DISTINCT P.ID\nFROM \n    Patient P\nJOIN \n    Laboratory L ON P.ID = L.ID\nWHERE \n    P.SEX = 'M' \n    AND L.GPT >= 60;\t----- bird -----\tthrombosis_prediction",
  "110": "SELECT \n    P.ID, \n    P.Birthday, \n    P.Diagnosis\nFROM \n    Laboratory L\nJOIN \n    Patient P ON L.ID = P.ID\nWHERE \n    L.GPT > 60\nORDER BY \n    P.Birthday ASC;\t----- bird -----\tthrombosis_prediction",
  "111": "SELECT \n    P.ID, \n    P.SEX, \n    P.Birthday\nFROM \n    Laboratory L\nJOIN \n    Patient P ON L.ID = P.ID\nWHERE \n    L.UN = 29;\t----- bird -----\tthrombosis_prediction",
  "112": "SELECT \n    P.SEX, \n    GROUP_CONCAT(DISTINCT L.ID) AS PatientIDs\nFROM \n    Laboratory L\nJOIN \n    Patient P ON L.ID = P.ID\nWHERE \n    L.T_BIL >= 2.0\nGROUP BY \n    P.SEX;\t----- bird -----\tthrombosis_prediction",
  "113": "SELECT \n    AVG(YEAR(NOW()) - YEAR(P.Birthday)) AS AverageAge\nFROM \n    Laboratory L\nJOIN \n    Patient P ON L.ID = P.ID\nWHERE \n    P.SEX = 'M' \n    AND L.T_CHO >= 250;\t----- bird -----\tthrombosis_prediction",
  "114": "SELECT \n    COUNT(DISTINCT P.ID) AS PatientCount\nFROM \n    Laboratory L\nJOIN \n    Patient P ON L.ID = P.ID\nWHERE \n    L.TG >= 200 \n    AND (YEAR(CURRENT_TIMESTAMP) - YEAR(P.Birthday)) > 50;\t----- bird -----\tthrombosis_prediction",
  "115": "SELECT \n    COUNT(DISTINCT P.ID) AS MalePatientsCount\nFROM \n    Patient P\nJOIN \n    Laboratory L ON P.ID = L.ID\nWHERE \n    P.SEX = 'M' \n    AND YEAR(P.Birthday) BETWEEN 1936 AND 1956 \n    AND L.CPK >= 250;\t----- bird -----\tthrombosis_prediction",
  "116": "SELECT \n    P.ID, \n    P.SEX, \n    YEAR(CURRENT_TIMESTAMP) - YEAR(P.Birthday) AS Age\nFROM \n    Laboratory L\nJOIN \n    Patient P ON L.ID = P.ID\nWHERE \n    L.GLU >= 180 \n    AND L.T_CHO < 250;\t----- bird -----\tthrombosis_prediction",
  "117": "SELECT \n    P.ID, \n    P.Diagnosis, \n    YEAR(CURRENT_TIMESTAMP) - YEAR(P.Birthday) AS Age\nFROM \n    Laboratory L\nJOIN \n    Patient P ON L.ID = P.ID\nWHERE \n    L.RBC < 3.5;\t----- bird -----\tthrombosis_prediction",
  "118": "SELECT \n    P.ID, \n    P.SEX, \n    P.Birthday\nFROM \n    Laboratory L\nJOIN \n    Patient P ON L.ID = P.ID\nWHERE \n    P.Diagnosis = 'SLE' \n    AND L.HGB > 10 \n    AND L.HGB < 17\nORDER BY \n    P.Birthday ASC\nLIMIT 1;\t----- bird -----\tthrombosis_prediction",
  "119": "SELECT \n    P.ID, \n    YEAR(CURRENT_TIMESTAMP) - YEAR(P.Birthday) AS Age\nFROM \n    Laboratory L\nJOIN \n    Patient P ON L.ID = P.ID\nWHERE \n    L.HCT >= 52\nGROUP BY \n    P.ID\nHAVING \n    COUNT(L.ID) > 2;\t----- bird -----\tthrombosis_prediction",
  "120": "SELECT \n    CASE \n        WHEN L.PLT < 100 THEN 'Low Platelet Count' \n        WHEN L.PLT > 400 THEN 'High Platelet Count' \n    END AS Platelet_Status,\n    COUNT(DISTINCT L.ID) AS Patient_Count\nFROM \n    Laboratory L\nWHERE \n    L.PLT <= 100 OR L.PLT >= 400\nGROUP BY \n    Platelet_Status;\t----- bird -----\tthrombosis_prediction",
  "121": "SELECT \n    P.ID, \n    P.SEX, \n    SUBTRACT(YEAR(CURRENT_TIMESTAMP), YEAR(P.Birthday)) AS Age\nFROM \n    Laboratory L\nJOIN \n    Patient P ON L.ID = P.ID\nWHERE \n    YEAR(L.Date) = 1984 \n    AND L.PLT BETWEEN 100 AND 400 \n    AND SUBTRACT(YEAR(CURRENT_TIMESTAMP), YEAR(P.Birthday)) < 50;\t----- bird -----\tthrombosis_prediction",
  "122": "SELECT \n    (SUM(CASE WHEN L.PT >= 14 AND P.SEX = 'F' THEN 1 ELSE 0 END) * 100.0 /\n     NULLIF(SUM(CASE WHEN L.PT >= 14 THEN 1 ELSE 0 END), 0)) AS Female_Percentage\nFROM \n    Laboratory L\nJOIN \n    Patient P ON L.ID = P.ID\nWHERE \n    YEAR(CURRENT_TIMESTAMP) - YEAR(P.Birthday) > 55; \n\n### Explanation:\n- The query calculates the percentage of female patients over 55 years old with abnormal prothrombin time (PT).\n- The use of `NULLIF(..., 0)` ensures that any division by zero is handled gracefully, avoiding errors in cases where no patients meet the criteria for abnormal PT.\n- The `SUM(CASE ...)` structure counts the relevant cases for both the numerator (females with abnormal PT) and the denominator (total patients with abnormal PT).\t----- bird -----\tthrombosis_prediction",
  "123": "SELECT \n    COUNT(DISTINCT p.ID) AS Patient_Count\nFROM \n    Laboratory l\nJOIN \n    Patient p ON l.ID = p.ID\nWHERE \n    p.SEX = 'M' \n    AND l.WBC > 3.5 AND l.WBC < 9.0\n    AND (l.FG <= 150 OR l.FG >= 450); \n\n### Explanation:\n- This SQL query retrieves the count of unique male patients (`SEX = 'M'`) who have normal white blood cell levels (between 3.5 and 9.0) and abnormal fibrinogen levels (either less than or equal to 150 or greater than or equal to 450).\n- The `JOIN` operation ensures that we are correlating the laboratory results with the correct patient demographics.\n- `COUNT(DISTINCT p.ID)` is used to ensure that each patient is only counted once, regardless of how many times they might meet the criteria in the laboratory tests.\t----- bird -----\tthrombosis_prediction",
  "124": "SELECT \n    COUNT(DISTINCT ID) AS Patient_Count\nFROM \n    Laboratory\nWHERE \n    IGG >= 2000;\n\n### Explanation:\n- The SQL query counts the number of unique patient IDs from the `Laboratory` table who have an Ig G level greater than or equal to 2000, indicating elevated levels.\n- The use of `DISTINCT` ensures that each patient is counted only once, regardless of how many test results they may have.\t----- bird -----\tthrombosis_prediction",
  "125": "SELECT \n    COUNT(DISTINCT L.ID) AS Patient_Count\nFROM \n    Laboratory L\nJOIN \n    Examination E ON L.ID = E.ID\nWHERE \n    L.IGG > 900 AND L.IGG < 2000 \n    AND E.Symptoms IS NOT NULL;\n\n### Explanation:\n- The SQL query counts the number of unique patient IDs from the `Laboratory` table where Ig G levels are considered normal (`IGG > 900 AND IGG < 2000`).\n- It only includes patients who have reported symptoms (`E.Symptoms IS NOT NULL`).\n- Using `COUNT(DISTINCT L.ID)` ensures that each patient is only counted once, even if they have multiple laboratory results or symptom records.\t----- bird -----\tthrombosis_prediction",
  "126": "SELECT \n    COUNT(DISTINCT l.ID) AS Patient_Count\nFROM \n    Laboratory l\nJOIN \n    Patient p ON l.ID = p.ID\nWHERE \n    l.IGA > 80 AND l.IGA < 500 \n    AND YEAR(p.First_Date) >= 1990;\n\n### Explanation:\n- The query retrieves the count of unique patient IDs from the `Laboratory` table, filtering for patients whose `IGA` levels fall within the normal range (greater than 80 and less than 500).\n- It also checks that these patients first came to the hospital after January 1, 1990, using the `YEAR` function on the `First_Date` field from the `Patient` table.\n- The `JOIN` ensures that you correlate each laboratory result with the correct patient demographic details. \n- `COUNT(DISTINCT l.ID)` counts the number of unique patients meeting both criteria.\t----- bird -----\tthrombosis_prediction",
  "127": "SELECT \n    p.Diagnosis,\n    COUNT(p.ID) AS Patient_Count\nFROM \n    Laboratory l\nJOIN \n    Patient p ON l.ID = p.ID\nWHERE \n    l.IGM <= 40 OR l.IGM >= 400\nGROUP BY \n    p.Diagnosis\nORDER BY \n    Patient_Count DESC\nLIMIT 1;\n\n### Explanation:\n- This SQL query first joins the `Laboratory` and `Patient` tables based on the patient ID.\n- It then filters for patients with an abnormal Ig M level (less than or equal to 40 or greater than or equal to 400).\n- The results are grouped by the `Diagnosis` of each patient to count how many patients have each diagnosis.\n- The `ORDER BY` clause sorts the diagnoses by the patient count in descending order, and `LIMIT 1` ensures that only the most common diagnosis is returned along with its count.\t----- bird -----\tthrombosis_prediction",
  "128": "SELECT \n    COUNT(DISTINCT p.ID) AS Patient_Count\nFROM \n    Laboratory l\nJOIN \n    Patient p ON l.ID = p.ID\nWHERE \n    l.CRP = '+' \n    AND p.Description IS NULL;\n\n### Explanation:\n- This SQL query counts unique patient IDs from the **Laboratory** table where the C-reactive protein (CRP) level is marked as abnormal (`CRP = '+'`).\n- It joins with the **Patient** table to correlate patient details, specifically checking for those whose `Description` field is `NULL`, indicating that their data is not recorded.\n- The use of `COUNT(DISTINCT p.ID)` ensures that each patient is only counted once, providing an accurate total of patients meeting the specified conditions.\t----- bird -----\tthrombosis_prediction",
  "129": "SELECT \n    COUNT(DISTINCT p.ID) AS Patient_Count\nFROM \n    Laboratory l\nJOIN \n    Patient p ON l.ID = p.ID\nWHERE \n    l.CRE >= 1.5 \n    AND (YEAR(CURDATE()) - YEAR(p.Birthday)) < 70;\n\n### Explanation:\n- **JOIN**: Combines the `Laboratory` and `Patient` tables on the `ID` column to correlate lab results with patient demographic information.\n- **WHERE Clause**: Filters for patients with:\n  - Abnormal creatinine levels (`l.CRE >= 1.5`).\n  - An age of less than 70 years `(YEAR(CURDATE()) - YEAR(p.Birthday) < 70)`.\n- **COUNT(DISTINCT p.ID)**: Counts unique patient IDs that meet the criteria, ensuring that no patient is counted more than once.\n  \nThis query will give the desired count of patients with abnormal creatinine levels and an age under 70.\t----- bird -----\tthrombosis_prediction",
  "130": "SELECT \n    COUNT(DISTINCT p.ID) AS Patient_Count\nFROM \n    Laboratory l\nJOIN \n    Patient p ON l.ID = p.ID\nWHERE \n    (l.RNP = '-' OR l.RNP = '+-') \n    AND p.Admission = '+';\n\n### Explanation:\n- **JOIN Operation**: The query joins the `Laboratory` and `Patient` tables on the patient ID to combine their data.\n- **WHERE Clause Filters**:\n  - It filters for patients with a normal level of anti-ribonuclear protein, specified by `RNP = '-' OR RNP = '+-'`.\n  - It also ensures the patient was admitted to the hospital, checking for `Admission = '+'`.\n- **COUNT(DISTINCT p.ID)**: This counts the number of unique patient IDs that meet both conditions, ensuring no duplicates are counted.\n\nThis will effectively return the number of patients who have a normal anti-ribonuclear protein level and have been admitted to the hospital.\t----- bird -----\tthrombosis_prediction",
  "131": "SELECT \n    COUNT(DISTINCT l.ID) AS Patient_Count\nFROM \n    Laboratory l\nJOIN \n    Patient p ON l.ID = p.ID\nWHERE \n    l.SM IN ('-', '+-') \n    AND l.Thrombosis = 0;\n\n### Explanation:\n- **JOIN Operation**: The query joins the `Laboratory` and `Patient` tables on the patient ID to correlate test results with patient data.\n- **WHERE Clause Filters**:\n  - It filters for patients with normal levels of anti-SM, specified as `l.SM IN ('-', '+-')`.\n  - It also checks that these patients have no thrombosis, indicated by `l.Thrombosis = 0`.\n- **COUNT(DISTINCT l.ID)**: This counts the number of unique patient IDs that meet both conditions, giving you the total number of patients with normal anti-SM levels who do not have thrombosis.\t----- bird -----\tthrombosis_prediction",
  "132": "SELECT \n    COUNT(DISTINCT p.ID) AS Patient_Count\nFROM \n    Laboratory l\nJOIN \n    Patient p ON l.ID = p.ID\nWHERE \n    l.SC170 IN ('negative', '0') \n    AND p.SEX = 'F' \n    AND l.Symptoms IS NULL;\n\n### Explanation:\n- **JOIN**: This joins the `Laboratory` and `Patient` tables using the patient ID to merge laboratory results with patient demographics.\n- **WHERE Clause Filters**:\n  - `l.SC170 IN ('negative', '0')`: Filters for patients with normal anti-scl70 levels.\n  - `p.SEX = 'F'`: Includes only female patients.\n  - `l.Symptoms IS NULL`: Ensures that the patient does not have any symptoms recorded.\n- **COUNT(DISTINCT p.ID)**: Counts the number of unique patient IDs that meet all of the criteria, giving you the total number of female patients with normal anti-scl70 levels who do not have symptoms. \n\nThis query effectively retrieves the information required based on the conditions specified in your question.\t----- bird -----\tthrombosis_prediction",
  "133": "SELECT \n    COUNT(DISTINCT p.ID) AS Male_Patient_Count\nFROM \n    Laboratory l\nJOIN \n    Patient p ON l.ID = p.ID\nWHERE \n    l.CENTROMEA IN ('-', '+-') \n    AND l.SSB IN ('-', '+-') \n    AND p.SEX = 'M';\n\n### Explanation:\n- **JOIN Operation**: The query joins the `Laboratory` and `Patient` tables on the patient ID to correlate test results with demographic information.\n- **WHERE Clause Filters**:\n  - It filters to include only patients with normal levels of anti-centromere (`CENTROMEA IN ('-', '+-')`) and anti-SSB (`SSB IN ('-', '+-')`).\n  - It restricts the results to male patients (`p.SEX = 'M'`).\n- **COUNT(DISTINCT p.ID)**: This counts the number of unique male patient IDs that satisfy all specified conditions, ensuring that no patient is counted more than once.\n\nThis query will accurately return the number of male patients with normal anti-centromere and anti-SSB levels based on the conditions outlined in the question.\t----- bird -----\tthrombosis_prediction",
  "134": "SELECT \n    p.Birthday\nFROM \n    Laboratory l\nJOIN \n    Patient p ON l.ID = p.ID\nWHERE \n    l.GOT >= 60\nORDER BY \n    p.Birthday DESC\nLIMIT 1;\n\n### Explanation:\n- **JOIN Operation**: The query joins the `Laboratory` and `Patient` tables on the patient ID (`ID`), enabling correlation between lab results and patient demographic information.\n- **WHERE Clause**: Filters the laboratory results to only include those patients with an abnormal level of GOT (greater than or equal to 60).\n- **ORDER BY**: Sorts the results by the `Birthday` column in descending order, so the youngest patient appears first.\n- **LIMIT 1**: Ensures that only the most recent (youngest) birthday is returned in the results.\n\nThis query effectively retrieves the birth date of the youngest patient with abnormal GOT levels, meeting all specified criteria.\t----- bird -----\tthrombosis_prediction",
  "135": "SELECT \n    COUNT(DISTINCT l.ID) AS Patient_Count\nFROM \n    Laboratory l\nJOIN \n    Patient p ON l.ID = p.ID\nWHERE \n    l.CPK < 250 \n    AND (l.KCT = '+' OR l.RVVT = '+' OR l.LAC = '+');\n\n### Explanation:\n- **JOIN**: This joins the `Laboratory` table and `Patient` table based on patient IDs to correlate laboratory results with demographic information.\n- **WHERE Clause Filters**:\n  - It filters for patients with a normal creatinine phosphokinase level (`l.CPK < 250`).\n  - It further filters for patients that exhibit any of the positive measures of coagulation, specifically checking if `KCT`, `RVVT`, or `LAC` is equal to `'+'`.\n- **COUNT(DISTINCT l.ID)**: This counts the unique patient IDs that comply with the criteria, ensuring no duplicates are counted.\n\nThis SQL query accurately retrieves the number of patients demonstrating both normal CPK levels and positive coagulation indicators.\t----- bird -----\tthrombosis_prediction",
  "136": "SELECT \n    l.name AS League_Name,\n    SUM(m.home_team_goal + m.away_team_goal) AS Total_Goals\nFROM \n    Match m\nJOIN \n    League l ON m.league_id = l.id\nWHERE \n    m.season = '2015/2016'\nGROUP BY \n    l.id\nORDER BY \n    Total_Goals DESC\nLIMIT 1;\n\n### Explanation:\n- **JOIN Operation**: The query joins the `Match` and `League` tables using the `league_id` to correlate matches with their respective leagues.\n- **WHERE Clause**: It filters for matches from the 2016 season specified by `m.season = '2015/2016'`.\n- **SUM Function**: It calculates the total goals by adding both `home_team_goal` and `away_team_goal` for each match.\n- **GROUP BY Clause**: Groups the results by `league_id`, allowing aggregation of goals per league.\n- **ORDER BY Clause**: Sorts the leagues in descending order based on the total goals scored.\n- **LIMIT 1**: Ensures that only the league with the highest goal count is returned. \n\nThis SQL query succinctly identifies the league with the most goals during the specified season, providing both the league's name and the total goals scored.\t----- bird -----\teuropean_football_2",
  "137": "SELECT \n    t.team_long_name,\n    COUNT(*) AS Wins\nFROM \n    Match m\nJOIN \n    League l ON m.league_id = l.id\nJOIN \n    Team t ON m.away_team_api_id = t.team_api_id\nWHERE \n    l.name = 'Scotland Premier League' \n    AND m.season = '2009/2010' \n    AND m.away_team_goal > m.home_team_goal\nGROUP BY \n    m.away_team_api_id, t.team_long_name\nORDER BY \n    Wins DESC\nLIMIT 1;\n\n### Explanation:\n- **JOIN Operations**: \n  - The query joins the `Match` table with the `League` table to filter matches by league, and with the `Team` table to get the names of the away teams.\n- **WHERE Clause**:\n  - It filters to ensure we are only considering matches in the \"Scotland Premier League\" for the 2010 season while also checking that the away team scored more goals than the home team.\n- **GROUP BY**:\n  - It groups the results by the `away_team_api_id` to count how many times each away team won.\n- **COUNT(*)**: \n  - This counts the number of wins for each away team.\n- **ORDER BY**:\n  - The results are sorted in descending order to bring the team with the most wins to the top.\n- **LIMIT 1**: \n  - This ensures only the team with the highest win count is returned.\n\nThis query will effectively yield the away team that won the most matches during the specified season in the Scotland Premier League, along with the number of matches they won.\t----- bird -----\teuropean_football_2",
  "138": "SELECT \n    t.team_long_name, \n    ta.buildUpPlaySpeed\nFROM \n    Team_Attributes ta\nJOIN \n    Team t ON ta.id = t.id\nORDER BY \n    ta.buildUpPlaySpeed DESC\nLIMIT 4;\n\n### Explanation:\n- **JOIN Operation**: The query joins the `Team_Attributes` table with the `Team` table using the `id` column to link team attributes with their names.\n- **ORDER BY Clause**: It sorts the teams by their `buildUpPlaySpeed` in descending order, ensuring that the teams with the highest speeds appear first.\n- **LIMIT 4**: Restricts the result set to only the top 4 teams, capturing the four with the highest build-up play speeds.\n\nThis query provides the team names and their corresponding build-up play speeds for the top teams, directly addressing the requirements based on the provided schema.\t----- bird -----\teuropean_football_2",
  "139": "SELECT \n    l.name AS League_Name,\n    COUNT(*) AS Draw_Count\nFROM \n    Match m\nJOIN \n    League l ON m.league_id = l.id\nWHERE \n    m.season = '2015/2016' \n    AND m.home_team_goal = m.away_team_goal\nGROUP BY \n    l.id\nORDER BY \n    Draw_Count DESC\nLIMIT 1;\n\n### Explanation:\n- **JOIN Operation**: This joins the `Match` table with the `League` table using `league_id` to bring together match results with their corresponding league names.\n- **WHERE Clause**: Filters results for the 2016 season (specifically `m.season = '2015/2016'`) and matches that ended in a draw by checking if `home_team_goal` equals `away_team_goal`.\n- **COUNT(*)**: Counts the number of matches that ended in a draw for each league.\n- **GROUP BY**: Groups the results by `league_id` to aggregate the draw counts correctly.\n- **ORDER BY**: Orders leagues by the count of draws in descending order, bringing the league with the most draws to the top.\n- **LIMIT 1**: Ensures that only the league with the highest number of draws is returned.\n\nThis SQL query successfully identifies the league with the most matches that ended in a draw during the specified season, providing both the league name and the total count of draws.\t----- bird -----\teuropean_football_2",
  "140": "SELECT \n    p.id AS Player_ID, \n    SUBTRACT(YEAR(CURRENT_DATE()), YEAR(p.birthday)) AS Age\nFROM \n    Player_Attributes pa\nJOIN \n    Player p ON pa.player_api_id = p.player_api_id\nWHERE \n    pa.sprint_speed >= 97 \n    AND YEAR(pa.date) BETWEEN 2013 AND 2015;\n\n### Explanation:\n- **JOIN Operation**: This joins the `Player_Attributes` table with the `Player` table using `player_api_id` to connect player attributes with their demographic data.\n- **WHERE Clause Filters**:\n  - It filters for players with a sprint speed of 97 or higher (`pa.sprint_speed >= 97`).\n  - Additionally, it filters for records within the date range of 2013 to 2015 (`YEAR(pa.date) BETWEEN 2013 AND 2015`).\n- **Age Calculation**: The age is calculated by subtracting the year of the player's birthday from the current year.\n- **Output**: The query returns the player ID and their calculated age for all players meeting the specified sprint speed and date criteria. \n\nThis will effectively provide the desired information regarding players fitting the specified conditions.\t----- bird -----\teuropean_football_2",
  "141": "SELECT \n    l.name AS League_Name,\n    COUNT(m.id) AS Match_Count\nFROM \n    Match m\nJOIN \n    League l ON m.league_id = l.id\nGROUP BY \n    l.id, l.name\nORDER BY \n    Match_Count DESC\nLIMIT 1;\n\n### Explanation:\n- **JOIN Operation**: The query joins the `Match` table with the `League` table using `league_id` to correlate matches with their respective leagues.\n- **COUNT Function**: Counts the number of matches (`COUNT(m.id)`) for each league.\n- **GROUP BY**: Groups the results by league ID and name, allowing for aggregation of the match counts.\n- **ORDER BY**: Orders the leagues by the total match count in descending order, bringing the league with the most matches to the top.\n- **LIMIT 1**: Ensures that only the league with the highest number of matches is returned.\n\nThis query effectively retrieves the name of the league with the most matches played and the total count of those matches, providing the information requested.\t----- bird -----\teuropean_football_2",
  "142": "SELECT \n    t.team_fifa_api_id\nFROM \n    Team_Attributes ta\nJOIN \n    Team t ON ta.team_api_id = t.team_api_id\nWHERE \n    ta.buildUpPlaySpeed > 50 \n    AND ta.buildUpPlaySpeed < 60;\n\n### Explanation:\n- **Join Operation**: This query joins the `Team_Attributes` table with the `Team` table using `team_api_id` to combine team attributes with the FIFA identifiers.\n- **WHERE Clause**: It filters the results to include only those teams with a build-up play speed greater than 50 and less than 60.\n- **Output**: The query retrieves the `team_fifa_api_id` for the teams that meet the specified criteria.\n\nThis straightforward query will effectively return the required team FIFA IDs for teams that fall within the defined range of build-up play speeds.\t----- bird -----\teuropean_football_2",
  "143": "WITH AveragePassing AS (\n    SELECT \n        AVG(buildUpPlayPassing) AS AvgPassing\n    FROM \n        Team_Attributes \n    WHERE \n        strftime('%Y', date) = '2012'\n)\n\nSELECT \n    t.team_long_name\nFROM \n    Team_Attributes ta\nJOIN \n    Team t ON ta.team_api_id = t.team_api_id\nWHERE \n    ta.buildUpPlayPassing > (SELECT AvgPassing FROM AveragePassing) \n    AND strftime('%Y', ta.date) = '2012';\n\n### Explanation:\n- **Common Table Expression (CTE)**: The `AveragePassing` CTE calculates the average build-up play passing for teams in the year 2012, filtering records by `strftime('%Y', date) = '2012'`.\n- **SELECT Statement**: The main query selects the `team_long_name` from the `Team` table.\n- **JOIN Operation**: It joins `Team_Attributes` with `Team` using `team_api_id` to connect attributes to team names.\n- **WHERE Clause**: The conditions ensure that only teams with build-up play passing greater than the average (obtained from the CTE) and from the year 2012 are selected.\n\nThis query effectively retrieves the long names of teams with above-average build-up play passing metrics for the specified year.\t----- bird -----\teuropean_football_2",
  "144": "SELECT \n    (COUNT(CASE WHEN preferred_foot = 'left' THEN 1 END) * 100.0 / COUNT(id)) AS Percentage_Left_Foot_Players\nFROM \n    Player\nWHERE \n    YEAR(birthday) BETWEEN 1987 AND 1992;\n\n### Explanation:\n- **COUNT(CASE ... END)**: This counts the number of players who prefer the left foot by checking if `preferred_foot = 'left'`.\n- **COUNT(id)**: This counts the total number of players who were born between 1987 and 1992.\n- **Arithmetic Calculation**: The formula calculates the percentage of left-footed players relative to the total number of players in the specified age range, multiplying by 100. \n- **WHERE Clause**: The condition filters for players born between 1987 and 1992.\n\nThis query effectively provides the percentage of left-footed players born within the given year range using the specified schema.\t----- bird -----\teuropean_football_2",
  "145": "SELECT \n    AVG(pa.long_shots) AS Average_Long_Shots,\n    COUNT(DISTINCT p.id) AS Player_Count\nFROM \n    Player p\nJOIN \n    Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE \n    p.preferred_foot = 'left' \n    AND YEAR(p.birthday) BETWEEN 1987 AND 1992;\n\n### Explanation:\n- **Join Operation**: The query joins the **Player** table with the **Player_Attributes** table on the `player_api_id`, allowing us to access the relevant attributes for each player.\n- **Filters**:\n  - `p.preferred_foot = 'left'`: This ensures we only include players who prefer their left foot.\n  - `YEAR(p.birthday) BETWEEN 1987 AND 1992`: This filters for players born within the specified range.\n- **Aggregation**:\n  - `AVG(pa.long_shots)`: Calculates the average number of long shots taken by the filtered players.\n  - `COUNT(DISTINCT p.id)`: Counts the number of unique players meeting the specified criteria, ensuring no repeats.\n\nThis SQL query efficiently provides the average long shots among left-footed players born between 1987 and 1992, alongside the count of such players.\t----- bird -----\teuropean_football_2",
  "146": "SELECT \n    p.player_name,\n    pa.heading_accuracy\nFROM \n    Player p\nJOIN \n    Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE \n    p.height > 180;\n\n### Explanation:\n- **JOIN Operation**: This query joins the `Player` table with the `Player_Attributes` table using their `player_api_id` to associate player demographics with their performance attributes.\n- **WHERE Clause**: It filters the results to include only players with a height greater than 180 cm.\n- **Selected Columns**: It retrieves the player's name and their heading accuracy.\n\nTo compute the average heading accuracy across all players meeting the height criterion, you can use the following query:sql\nSELECT \n    AVG(pa.heading_accuracy) AS Average_Heading_Accuracy\nFROM \n    Player p\nJOIN \n    Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE \n    p.height > 180;\n\n### Combined Query to List Players and Their Average Heading Accuracy\nIf you want both the player names along with their heading accuracy and to also provide the average heading accuracy as a header:sql\nWITH PlayerHeading AS (\n    SELECT \n        p.player_name,\n        pa.heading_accuracy\n    FROM \n        Player p\n    JOIN \n        Player_Attributes pa ON p.player_api_id = pa.player_api_id\n    WHERE \n        p.height > 180\n)\nSELECT \n    player_name, \n    heading_accuracy,\n    (SELECT AVG(heading_accuracy) FROM Player_Attributes WHERE player_api_id IN (SELECT player_api_id FROM Player WHERE height > 180)) AS Average_Heading_Accuracy\nFROM \n    PlayerHeading;\n\n### Note:\n- The first query lists all players above 180 cm with their heading accuracies.\n- The second query computes the average heading accuracy for the listed players. This provides a comprehensive view of the players who fit the criteria while also giving an insight into their collective performance in terms of heading accuracy.\t----- bird -----\teuropean_football_2",
  "147": "SELECT \n    l.name AS League_Name,\n    COUNT(*) AS Draw_Count\nFROM \n    Match m\nJOIN \n    League l ON m.league_id = l.id\nWHERE \n    m.season = '2015/2016' \n    AND m.home_team_goal = m.away_team_goal\nGROUP BY \n    l.id\nORDER BY \n    Draw_Count DESC\nLIMIT 1;\n\n### Explanation:\n- **JOIN Operation**: The query joins the `Match` table with the `League` table using `league_id` to associate matches with their respective leagues.\n- **WHERE Clause**: \n  - It filters for matches that occurred in the 2016 season (`m.season = '2015/2016'`).\n  - It checks for draws with the condition `m.home_team_goal = m.away_team_goal`.\n- **COUNT(*)**: Counts the number of matches that ended in draws for each league.\n- **GROUP BY**: Groups the results by `l.id` (league ID) so that the count of draws can be calculated for each league.\n- **ORDER BY**: Sorts the leagues by the count of draws in descending order, allowing the top league to be identified.\n- **LIMIT 1**: Ensures that only the league with the highest number of draws is returned.\n\nThis query will yield the name of the league with the most matches that ended in a draw during the specified season, along with the total count of those matches.\t----- bird -----\teuropean_football_2",
  "148": "SELECT \n    id, \n    player_name \nFROM \n    Player \nWHERE \n    YEAR(birthday) = 1970 \n    AND MONTH(birthday) = 10;\n\n### Explanation of the Query:\n- **SELECT Statement**: This retrieves the `id` and `player_name` of players from the `Player` table.\n- **WHERE Clause**: It filters the results to include only those players whose `birthday` falls within the specified year (1970) and month (October).\n- **YEAR() and MONTH() Functions**: These functions extract the year and month from the `birthday` date, allowing for the specified filtering.\n\nBy executing this SQL query, you will receive a list of football players who were born in October 1970, along with their respective IDs, effectively addressing the requirements based on the provided schema.\t----- bird -----\teuropean_football_2",
  "149": "SELECT \n    p.player_name, \n    pa.overall_rating\nFROM \n    Player p\nJOIN \n    Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE \n    p.player_name = 'Gabriel Tamas' \n    AND strftime('%Y', pa.date) = '2011';\n\n### Explanation:\n- **JOIN Operation**: This joins the `Player` table with the `Player_Attributes` table on `player_api_id` to link player names with their respective attributes.\n- **WHERE Clause Filters**:\n  - It filters for `p.player_name = 'Gabriel Tamas'` to focus on the specific player.\n  - It restricts the records to the year 2011 with `AND strftime('%Y', pa.date) = '2011'`, ensuring that only ratings from that year are included.\n- **SELECT Statement**: The query returns the `player_name` and `overall_rating` of Gabriel Tamas for the specified year.\n\nRunning this SQL query will provide the information regarding the overall rating of Gabriel Tamas in 2011, as requested.\t----- bird -----\teuropean_football_2",
  "150": "SELECT \n    AVG(m.home_team_goal) AS Average_Home_Goals\nFROM \n    Match m\nJOIN \n    League l ON m.league_id = l.id\nWHERE \n    l.name = 'Poland' \n    AND m.season = '2010/2011';\n\n### Explanation:\n- **JOIN Operation**: The query joins the `Match` table with the `League` table based on `league_id` to associate each match with its corresponding league.\n- **WHERE Clause**:\n  - It filters for matches that belong to the `\"Poland\"` league (`l.name = 'Poland'`).\n  - It restricts the results to matches from the 2010/2011 season (`m.season = '2010/2011'`).\n- **AVG Function**: This computes the average number of home goals (`AVG(m.home_team_goal)`) from the matches that meet the criteria.\n\nExecuting this SQL query will provide the average number of goals scored by home teams in the Polish league during the 2010/2011 season.\t----- bird -----\teuropean_football_2",
  "151": "WITH Tallest AS (\n    SELECT \n        p.id AS player_id,\n        p.player_name,\n        pa.finishing\n    FROM \n        Player p\n    JOIN \n        Player_Attributes pa ON p.player_api_id = pa.player_api_id\n    WHERE \n        p.height = (SELECT MAX(height) FROM Player)\n),\nShortest AS (\n    SELECT \n        p.id AS player_id,\n        p.player_name,\n        pa.finishing\n    FROM \n        Player p\n    JOIN \n        Player_Attributes pa ON p.player_api_id = pa.player_api_id\n    WHERE \n        p.height = (SELECT MIN(height) FROM Player)\n)\n\nSELECT \n    'Tallest' AS Height_Category,\n    AVG(finishing) AS Average_Finishing\nFROM \n    Tallest\n\nUNION ALL\n\nSELECT \n    'Shortest' AS Height_Category,\n    AVG(finishing) AS Average_Finishing\nFROM \n    Shortest;\n\n### Explanation:\n- **Common Table Expressions (CTEs)**: The query defines two CTEs, `Tallest` and `Shortest`, to isolate players based on their heights:\n  - **Tallest** retrieves records for the player(s) with the maximum height.\n  - **Shortest** retrieves records for the player(s) with the minimum height.\n- **JOIN Operations**: The `JOIN` connects the `Player` table with `Player_Attributes` based on `player_api_id` to access the finishing scores.\n- **Calculating Average Finishing**:\n  - The first `SELECT` computes the average finishing for the tallest player(s).\n  - The second `SELECT` computes the average finishing for the shortest player(s).\n- **UNION ALL**: Combines both results into a single output, allowing you to see average finishing rates for both height categories (`Tallest` and `Shortest`).\n\nThis query allows you to analyze and compare the finishing capabilities of the tallest and shortest players effectively. Adjust or refine the query as needed based on any additional requirements.\t----- bird -----\teuropean_football_2",
  "152": "SELECT \n    AVG(pa.overall_rating) AS Average_Overall_Rating\nFROM \n    Player p\nJOIN \n    Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE \n    p.height > 170 \n    AND strftime('%Y', pa.date) >= '2010' \n    AND strftime('%Y', pa.date) <= '2015';\n\n### Explanation:\n- **JOIN Operation**: This joins the `Player` table with the `Player_Attributes` table using `player_api_id`, allowing for access to both player details and their corresponding ratings.\n- **WHERE Clause Filters**: \n  - It filters for players who have a height greater than 170 cm.\n  - It checks that the ratings were recorded in the years from 2010 to 2015.\n- **AVG Function**: Computes the average overall rating based on the filtered data.\n\nExecuting this SQL query will result in the average overall rating of all players who satisfy the height and date range criteria. This meets the requirements outlined in your question effectively.\t----- bird -----\teuropean_football_2",
  "153": "WITH AverageBallControl AS (\n    SELECT \n        p.player_name,\n        AVG(pa.ball_control) AS Avg_Ball_Control\n    FROM \n        Player p\n    JOIN \n        Player_Attributes pa ON p.player_api_id = pa.player_api_id\n    WHERE \n        p.player_name IN ('Abdou Diallo', 'Aaron Appindangoye')\n    GROUP BY \n        p.player_name\n)\n\nSELECT \n    (SELECT Avg_Ball_Control FROM AverageBallControl WHERE player_name = 'Abdou Diallo') -\n    (SELECT Avg_Ball_Control FROM AverageBallControl WHERE player_name = 'Aaron Appindangoye') AS Ball_Control_Difference;\n\n### Explanation:\n- **WITH Clause**: The Common Table Expression (CTE) `AverageBallControl` calculates the average ball control score for both Abdou Diallo and Aaron Appindangoye.\n- **JOIN Operation**: It joins the `Player` table with the `Player_Attributes` table on `player_api_id` to correlate player demographics with their ball control attributes.\n- **WHERE Clause**: It filters for the specified players and groups the results to calculate their average ball control.\n- **Main SELECT Statement**: This calculates the difference in average ball control scores between the two players using subqueries.\n\nThis query provides the desired calculation based on the conditions specified, ensuring clarity and efficiency in the data retrieval process.\t----- bird -----\teuropean_football_2",
  "154": "-- Get tallest player finishing rate\nWITH Tallest AS (\n    SELECT \n        p.id AS player_id,\n        p.player_name,\n        pa.finishing,\n        p.height\n    FROM \n        Player p\n    JOIN \n        Player_Attributes pa ON p.player_api_id = pa.player_api_id\n    WHERE \n        p.height = (SELECT MAX(height) FROM Player)\n        AND pa.SC170 IN ('-', '+-')\n),\n\n-- Get shortest player finishing rate\nShortest AS (\n    SELECT \n        p.id AS player_id,\n        p.player_name,\n        pa.finishing,\n        p.height\n    FROM \n        Player p\n    JOIN \n        Player_Attributes pa ON p.player_api_id = pa.player_api_id\n    WHERE \n        p.height = (SELECT MIN(height) FROM Player)\n        AND pa.SC170 IN ('-', '+-')\n)\n\n-- Compare average finishing rates\nSELECT \n    'Tallest' AS Player_Type,\n    player_name,\n    AVG(finishing) AS Average_Finishing\nFROM \n    Tallest\nGROUP BY \n    player_id\n\nUNION ALL\n\nSELECT \n    'Shortest' AS Player_Type,\n    player_name,\n    AVG(finishing) AS Average_Finishing\nFROM \n    Shortest\nGROUP BY \n    player_id;\n\n### Explanation:\n- **Common Table Expressions (CTEs)**: \n  - The `Tallest` CTE selects the tallest player(s) with normal anti-scl70 levels and their finishing scores.\n  - The `Shortest` CTE selects the shortest player(s) with normal anti-scl70 levels and their finishing scores.\n- **JOIN Operation**: The query joins the `Player` and `Player_Attributes` tables on `player_api_id`, correlating player demographics with attributes.\n- **WHERE Clause for Normal Levels**: Both CTEs apply the condition to filter for players with normal anti-scl70 levels (`pa.SC170 IN ('-', '+-')`).\n- **Final Selection**: The main query retrieves the average finishing scores for the tallest and shortest players.\n- **GROUP BY**: This groups results by the unique player ID to correctly calculate the averages from the groups defined in the CTEs.\n\nThis query will provide a comparison of the finishing rates for both the tallest and shortest players, ensuring that the players meet the specified criteria for normal anti-scl70 levels.\t----- bird -----\teuropean_football_2",
  "155": "SELECT \n    id, \n    player_name, \n    height\nFROM \n    Player\nWHERE \n    height = (SELECT MAX(height) FROM Player);\n\n### Explanation:\n- **Subquery**: The inner query retrieves the tallest height from the `Player` table using `MAX(height)`.\n- **Main Query**: The outer query filters the `Player` table to find all players whose height matches the maximum height found in the subquery.\n- **Returned Columns**: The IDs, names, and heights of the tallest player(s) are selected, which could include multiple players if they share the same tallest height.\n\nThis SQL query effectively identifies the tallest player(s) while ensuring the details are provided as required. If you are looking for a specific player in case of ties or wish to return just one player, you might consider adding an `ORDER BY` clause to the outer query, such as ordering by ID or player name. This adjustment could help in scenarios where arbitrary selection of tied players is needed. Here\u2019s an example with ordering:sql\nSELECT \n    id, \n    player_name, \n    height\nFROM \n    Player\nWHERE \n    height = (SELECT MAX(height) FROM Player)\nORDER BY \n    id ASC;  -- This will return the tallest player(s) ordered by ID. \n\nFeel free to adjust based on your specific needs concerning ties or additional requirements.\t----- bird -----\teuropean_football_2",
  "156": "SELECT COUNT(*) \nFROM Player_Attributes \nWHERE preferred_foot = 'left' AND attacking_work_rate = 'low';\t----- bird -----\teuropean_football_2",
  "157": "SELECT COUNT(DISTINCT p.player_id) \nFROM Player p \nJOIN Player_Attributes pa ON p.player_id = pa.player_id \nWHERE strftime('%Y', p.birthday) < '1986' AND pa.defensive_work_rate = 'high';\t----- bird -----\teuropean_football_2",
  "158": "SELECT p.player_name \nFROM Player p \nJOIN Player_Attributes pa ON p.player_id = pa.player_id \nWHERE pa.volleys > 70 AND pa.dribbling > 70;\t----- bird -----\teuropean_football_2",
  "159": "SELECT COUNT(*) \nFROM Match \nWHERE league_id = (SELECT league_id FROM Team WHERE team_fifa_api_id = 'Belgium Jupiler League') \nAND SUBSTR(date, 1, 7) = '2009-04';\t----- bird -----\teuropean_football_2",
  "160": "SELECT l.name \nFROM League l \nJOIN (\n    SELECT league_id, COUNT(*) AS match_count \n    FROM Match \n    WHERE season = '2008/2009' \n    GROUP BY league_id \n) m ON l.id = m.league_id \nORDER BY m.match_count DESC \nLIMIT 1;\t----- bird -----\teuropean_football_2",
  "161": "SELECT \n    (SELECT overall_rating FROM Player_Attributes WHERE player_name = 'Ariel Borysiuk') - \n    (SELECT overall_rating FROM Player_Attributes WHERE player_name = 'Paulin Puel') AS rating_difference,\n    ((SELECT overall_rating FROM Player_Attributes WHERE player_name = 'Ariel Borysiuk') - \n     (SELECT overall_rating FROM Player_Attributes WHERE player_name = 'Paulin Puel')) * 100.0 / \n     (SELECT overall_rating FROM Player_Attributes WHERE player_name = 'Paulin Puel') AS percentage_difference;\t----- bird -----\teuropean_football_2",
  "162": "SELECT AVG(overall_rating) \nFROM Player_Attributes \nWHERE player_name = 'Pietro Marino';\t----- bird -----\teuropean_football_2",
  "163": "SELECT \n    MAX(chanceCreationPassing) AS highest_chance_creation_passing_score, \n    chanceCreationPassingClass \nFROM Team_Attributes \nWHERE team_long_name = 'Ajax' \nGROUP BY chanceCreationPassingClass \nORDER BY highest_chance_creation_passing_score DESC \nLIMIT 1;\t----- bird -----\teuropean_football_2",
  "164": "SELECT p.player_name\nFROM Player p\nJOIN Player_Attributes pa ON p.id = pa.player_id\nWHERE pa.overall_rating = 77 \nAND pa.date = '2016-06-23'\nORDER BY p.birthday ASC\nLIMIT 1;\t----- bird -----\teuropean_football_2",
  "165": "SELECT overall_rating \nFROM Player_Attributes \nWHERE player_name = 'Aaron Mooy' \nAND date LIKE '2016-02-04%';\t----- bird -----\teuropean_football_2",
  "166": "SELECT attacking_work_rate \nFROM Player_Attributes \nWHERE player_name = 'Francesco Migliore' \nAND date LIKE '2015-05-01%';\t----- bird -----\teuropean_football_2",
  "167": "SELECT MIN(date) \nFROM Player_Attributes \nWHERE player_name = 'Kevin Constant' \nAND crossing = (SELECT MAX(crossing) FROM Player_Attributes WHERE player_name = 'Kevin Constant');\t----- bird -----\teuropean_football_2",
  "168": "SELECT buildUpPlayPassingClass \nFROM Team_Attributes \nWHERE team_long_name = 'FC Lorient' \nAND date LIKE '2010-02-22%';\t----- bird -----\teuropean_football_2",
  "169": "SELECT defenceAggressionClass \nFROM Team_Attributes \nWHERE team_long_name = 'Hannover 96' \nAND date LIKE '2015-09-10%';\t----- bird -----\teuropean_football_2",
  "170": "SELECT AVG(overall_rating) \nFROM Player_Attributes \nWHERE player_name = 'Marko Arnautovic' \nAND SUBSTR(date, 1, 10) BETWEEN '2007-02-22' AND '2016-04-21';\t----- bird -----\teuropean_football_2",
  "171": "SELECT \n    ((SELECT overall_rating FROM Player_Attributes WHERE player_name = 'Landon Donovan' AND date LIKE '2013-07-12%') - \n     (SELECT overall_rating FROM Player_Attributes WHERE player_name = 'Jordan Bowery' AND date LIKE '2013-07-12%')) * 100.0 / \n     (SELECT overall_rating FROM Player_Attributes WHERE player_name = 'Jordan Bowery' AND date LIKE '2013-07-12%') AS percentage_difference;\t----- bird -----\teuropean_football_2",
  "172": "SELECT player_name \nFROM Player \nWHERE height = (SELECT MAX(height) FROM Player);\t----- bird -----\teuropean_football_2",
  "173": "SELECT p.player_name \nFROM Player p \nJOIN Player_Attributes pa ON p.id = pa.id \nWHERE pa.strength = (SELECT MAX(strength) FROM Player_Attributes);\t----- bird -----\teuropean_football_2",
  "174": "SELECT p.player_name \nFROM Player_Attributes pa \nJOIN Player p ON pa.id = p.id \nWHERE pa.attacking_work_rate = 'high';\t----- bird -----\teuropean_football_2",
  "175": "SELECT team_short_name \nFROM Team_Attributes \nWHERE chanceCreationPassingClass = 'Safe';\t----- bird -----\teuropean_football_2",
  "176": "SELECT COUNT(*) \nFROM Player \nWHERE player_name LIKE 'Aaron%' \nAND birthday > '1990-01-01';\t----- bird -----\teuropean_football_2",
  "177": "SELECT \n    (SELECT jumping FROM Player_Attributes WHERE id = 6) - \n    (SELECT jumping FROM Player_Attributes WHERE id = 23) AS jumping_score_difference;\t----- bird -----\teuropean_football_2",
  "178": "SELECT p.player_fifa_api_id \nFROM Player p \nJOIN Player_Attributes pa ON p.player_fifa_api_id = pa.player_fifa_api_id \nWHERE pa.preferred_foot = 'right' \nORDER BY pa.potential ASC \nLIMIT 4;\t----- bird -----\teuropean_football_2",
  "179": "SELECT COUNT(*) \nFROM Player_Attributes \nWHERE crossing = (SELECT MAX(crossing) FROM Player_Attributes) \nAND preferred_foot = 'left';\t----- bird -----\teuropean_football_2",
  "180": "SELECT home_team_goal, away_team_goal \nFROM Match \nWHERE date LIKE '2008-09-24%' \nAND league_id = (SELECT id FROM League WHERE name = 'Belgium Jupiler League');\t----- bird -----\teuropean_football_2",
  "181": "SELECT buildUpPlaySpeedClass \nFROM Team_Attributes \nWHERE team_long_name = 'KSV Cercle Brugge';\t----- bird -----\teuropean_football_2",
  "182": "SELECT pa.finishing, pa.curve \nFROM Player p \nJOIN Player_Attributes pa ON p.id = pa.id \nWHERE p.weight = (SELECT MAX(weight) FROM Player);\t----- bird -----\teuropean_football_2",
  "183": "SELECT l.name, COUNT(m.id) AS match_count \nFROM Match m \nJOIN League l ON m.league_id = l.id \nWHERE m.season = '2015/2016' \nGROUP BY l.id \nORDER BY match_count DESC \nLIMIT 4;\t----- bird -----\teuropean_football_2",
  "184": "SELECT t.team_long_name \nFROM Match m \nJOIN Team t ON m.away_team_api_id = t.team_fifa_api_id \nWHERE m.away_team_goal = (SELECT MAX(away_team_goal) FROM Match);\t----- bird -----\teuropean_football_2",
  "185": "SELECT p.player_name \nFROM Player_Attributes pa \nJOIN Player p ON pa.id = p.id \nWHERE pa.strength = (SELECT MAX(strength) FROM Player_Attributes) \nLIMIT 1;\t----- bird -----\teuropean_football_2",
  "186": "SELECT \n    (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM Player)) AS percentage\nFROM Player p\nJOIN Player_Attributes pa ON p.id = pa.id\nWHERE p.height < 180 AND pa.strength > 70;\t----- bird -----\teuropean_football_2",
  "187": "SELECT d.driverRef \nFROM qualifying q \nJOIN drivers d ON q.driverId = d.driverId \nWHERE q.raceId = 20 \nAND q.q1 = 'eliminated'  -- Assuming 'eliminated' is the flag used to mark eliminated drivers\nORDER BY q.position ASC \nLIMIT 5;  -- Fetching the last 5 drivers eliminated\t----- bird -----\tformula_1",
  "188": "SELECT d.surname \nFROM lapTimes l \nJOIN drivers d ON l.driverId = d.driverId \nWHERE l.raceId = 19 \nAND l.q2 = (SELECT MIN(q2) FROM lapTimes WHERE raceId = 19);\t----- bird -----\tformula_1",
  "189": "SELECT r.name \nFROM races r \nJOIN circuits c ON r.circuitId = c.circuitId \nWHERE c.country = 'Germany';\t----- bird -----\tformula_1",
  "190": "SELECT c.lat, c.lng \nFROM circuits c \nJOIN races r ON c.circuitId = r.circuitId \nWHERE r.name = 'Australian Grand Prix';\t----- bird -----\tformula_1",
  "191": "SELECT c.lat, c.lng \nFROM circuits c \nJOIN races r ON c.circuitId = r.circuitId \nWHERE r.name = 'Abu Dhabi Grand Prix';\t----- bird -----\tformula_1",
  "192": "SELECT q.q1 \nFROM qualifying q \nJOIN results r ON q.raceId = r.raceId \nWHERE q.raceId = 354 \nAND r.driverId = (SELECT driverId FROM drivers WHERE forename = 'Bruno' AND surname = 'Senna');\t----- bird -----\tformula_1",
  "193": "SELECT driverId \nFROM qualifying \nWHERE raceId = 903 AND q3 = '0:01:54';\t----- bird -----\tformula_1",
  "194": "SELECT COUNT(*) \nFROM results \nWHERE raceId = (SELECT id FROM races WHERE name = 'Bahrain Grand Prix' AND year = 2007) \nAND milliseconds IS NULL;\t----- bird -----\tformula_1",
  "195": "SELECT d.driverId, d.dob \nFROM results r \nJOIN drivers d ON r.driverId = d.driverId \nWHERE r.raceId = 592 AND r.milliseconds IS NOT NULL \nORDER BY d.dob ASC \nLIMIT 1;\t----- bird -----\tformula_1",
  "196": "SELECT d.url \nFROM lapTimes l \nJOIN drivers d ON l.driverId = d.driverId \nWHERE l.raceId = 161 AND l.time = '0:01:27';\t----- bird -----\tformula_1",
  "197": "SELECT c.lat, c.lng \nFROM circuits c \nJOIN races r ON c.circuitId = r.circuitId \nWHERE r.name = 'Malaysian Grand Prix';\t----- bird -----\tformula_1",
  "198": "SELECT c.url \nFROM constructorStandings cs \nJOIN constructors c ON cs.constructorId = c.constructorId \nWHERE cs.raceId = 9 AND cs.points = (SELECT MAX(points) FROM constructorStandings WHERE raceId = 9);\t----- bird -----\tformula_1",
  "199": "SELECT d.code \nFROM qualifying q \nJOIN drivers d ON q.driverId = d.driverId \nWHERE q.raceId = 45 AND q.q3 = '0:01:33';\t----- bird -----\tformula_1",
  "200": "SELECT s.url \nFROM seasons s \nJOIN races r ON s.year = r.year \nWHERE r.raceId = 901;\t----- bird -----\tformula_1",
  "201": "SELECT d.driverId, d.dob \nFROM driverStandings ds \nJOIN drivers d ON ds.driverId = d.driverId \nWHERE ds.raceId = 872 \nORDER BY d.dob DESC \nLIMIT 1;\t----- bird -----\tformula_1",
  "202": "SELECT d.nationality \nFROM results r \nJOIN drivers d ON r.driverId = d.driverId \nWHERE r.fastestLapSpeed = (SELECT MAX(fastestLapSpeed) FROM results);\t----- bird -----\tformula_1",
  "203": "SELECT \n    ((r1.fastestLapSpeed - r2.fastestLapSpeed) / r2.fastestLapSpeed) * 100 AS percentage_faster \nFROM results r1, results r2 \nWHERE r1.raceId = 853 AND r2.raceId = 854;\t----- bird -----\tformula_1",
  "204": "SELECT \n    (COUNT(CASE WHEN r.milliseconds IS NOT NULL THEN 1 END) * 100.0) / COUNT(r.driverId) AS completion_rate\nFROM results r\nJOIN races rac ON r.raceId = rac.id\nWHERE rac.date = '1983-07-16';\t----- bird -----\tformula_1",
  "205": "SELECT name \nFROM races \nWHERE year = (SELECT MIN(YEAR(date)) FROM races) \nAND MONTH(date) = (SELECT MIN(MONTH(date)) FROM races WHERE YEAR(date) = (SELECT MIN(YEAR(date)) FROM races));\t----- bird -----\tformula_1",
  "206": "SELECT d.forename, d.surname, ds.points \nFROM driverStandings ds \nJOIN drivers d ON ds.driverId = d.driverId \nWHERE ds.points = (SELECT MAX(points) FROM driverStandings);\t----- bird -----\tformula_1",
  "207": "SELECT \n    d.forename, \n    d.surname, \n    r.name AS race_name, \n    lt.time AS best_lap_time \nFROM lapTimes lt \nJOIN results res ON lt.driverId = res.driverId AND lt.raceId = res.raceId \nJOIN drivers d ON lt.driverId = d.driverId \nJOIN races r ON lt.raceId = r.raceId \nWHERE lt.milliseconds = (SELECT MIN(milliseconds) FROM lapTimes);\t----- bird -----\tformula_1",
  "208": "SELECT AVG(lt.time) AS average_lap_time \nFROM lapTimes lt \nJOIN races r ON lt.raceId = r.raceId \nWHERE r.name = 'Malaysian Grand Prix' \nAND r.year = 2009 \nAND lt.driverId = (SELECT driverId FROM drivers WHERE forename = 'Lewis' AND surname = 'Hamilton');\t----- bird -----\tformula_1",
  "209": "SELECT \n    (COUNT(CASE WHEN ds.position > 1 THEN 1 END) * 100.0) / COUNT(ds.raceId) AS percentage_not_first\nFROM driverStandings ds \nJOIN races r ON ds.raceId = r.id \nWHERE r.year >= 2010 \nAND ds.driverId = (SELECT driverId FROM drivers WHERE surname = 'Hamilton');\t----- bird -----\tformula_1",
  "210": "SELECT d.forename, d.surname, d.nationality, ds.points \nFROM driverStandings ds \nJOIN drivers d ON ds.driverId = d.driverId \nWHERE ds.wins = (SELECT MAX(wins) FROM driverStandings);\t----- bird -----\tformula_1",
  "211": "SELECT d.surname, \n       YEAR(CURRENT_TIMESTAMP) - YEAR(d.dob) AS age\nFROM drivers d\nWHERE d.nationality = 'Japanese'\nORDER BY d.dob DESC\nLIMIT 1;\t----- bird -----\tformula_1",
  "212": "SELECT r.name AS race_name, \n       c.name AS circuit_name, \n       c.location \nFROM races r \nJOIN circuits c ON r.circuitId = c.circuitId \nWHERE MONTH(r.date) = 9 \nAND YEAR(r.date) = 2005;\t----- bird -----\tformula_1",
  "213": "SELECT r.raceId \nFROM results res \nJOIN driverStandings ds ON res.raceId = ds.raceId \nWHERE ds.position < 20 \nAND ds.driverId = (SELECT driverId FROM drivers WHERE forename = 'Alex' AND surname = 'Yoong');\t----- bird -----\tformula_1",
  "214": "SELECT r.year, r.name \nFROM results res \nJOIN races r ON res.raceId = r.id \nWHERE res.fastestLap = (SELECT MAX(fastestLap) FROM results WHERE driverId = (SELECT driverId FROM drivers WHERE forename = 'Michael' AND surname = 'Schumacher'));\t----- bird -----\tformula_1",
  "215": "SELECT r.year, ds.points \nFROM driverStandings ds \nJOIN races r ON ds.raceId = r.id \nWHERE ds.driverId = (SELECT driverId FROM drivers WHERE forename = 'Lewis' AND surname = 'Hamilton') \nAND ds.raceId = (SELECT raceId FROM driverStandings WHERE driverId = (SELECT driverId FROM drivers WHERE forename = 'Lewis' AND surname = 'Hamilton') ORDER BY raceId ASC LIMIT 1);\t----- bird -----\tformula_1",
  "216": "SELECT \n    (COUNT(CASE WHEN country = 'Germany' THEN 1 END) * 100.0) / COUNT(*) AS percentage_germany\nFROM races \nWHERE name = 'European Grand Prix';\t----- bird -----\tformula_1",
  "217": "SELECT lat, lng \nFROM circuits \nWHERE circuitRef = 'Silverstone Circuit';\t----- bird -----\tformula_1",
  "218": "SELECT circuitRef \nFROM circuits \nWHERE name = 'Marina Bay Street Circuit';\t----- bird -----\tformula_1",
  "219": "SELECT nationality \nFROM drivers \nWHERE dob = (SELECT MIN(dob) FROM drivers);\t----- bird -----\tformula_1",
  "220": "SELECT d.driverRef \nFROM results r \nJOIN races ra ON r.raceId = ra.id \nJOIN drivers d ON r.driverId = d.driverId \nWHERE ra.name = 'Canadian Grand Prix' \nAND ra.year = 2007 \nAND r.rank = 1;\t----- bird -----\tformula_1",
  "221": "SELECT r.url \nFROM results res \nJOIN races r ON res.raceId = r.id \nWHERE res.driverId = (SELECT driverId FROM drivers WHERE forename = 'Lewis' AND surname = 'Hamilton') \nAND res.rank = (SELECT MIN(rank) FROM results WHERE driverId = (SELECT driverId FROM drivers WHERE forename = 'Lewis' AND surname = 'Hamilton'));\t----- bird -----\tformula_1",
  "222": "SELECT MAX(fastestLapSpeed) \nFROM results \nWHERE raceId = (SELECT id FROM races WHERE name = 'Spanish Grand Prix' AND year = 2009);\t----- bird -----\tformula_1",
  "223": "SELECT r.rank \nFROM results r \nJOIN races ra ON r.raceId = ra.id \nWHERE ra.name = 'Chinese Grand Prix' \nAND ra.year = 2008 \nAND r.driverId = (SELECT driverId FROM drivers WHERE forename = 'Lewis' AND surname = 'Hamilton');\t----- bird -----\tformula_1",
  "224": "SELECT r.time \nFROM results r \nJOIN races ra ON r.raceId = ra.id \nWHERE ra.name = 'Australian Grand Prix' \nAND ra.year = 2008 \nAND r.rank = 2;\t----- bird -----\tformula_1",
  "225": "SELECT COUNT(DISTINCT r.driverId) \nFROM results r \nJOIN races ra ON r.raceId = ra.id \nWHERE ra.name = 'Chinese Grand Prix' \nAND ra.year = 2008 \nAND r.milliseconds IS NOT NULL;\t----- bird -----\tformula_1",
  "226": "SELECT \n    (100.0 * (last.milliseconds - champion.milliseconds) / last.milliseconds) AS percentage_faster \nFROM \n    (SELECT milliseconds \n     FROM results \n     WHERE raceId = (SELECT id FROM races WHERE name = 'Australian Grand Prix' AND year = 2008) \n     AND rank = 1) AS champion, \n    (SELECT milliseconds \n     FROM results \n     WHERE raceId = (SELECT id FROM races WHERE name = 'Australian Grand Prix' AND year = 2008) \n     AND rank = (SELECT MAX(rank) FROM results WHERE raceId = (SELECT id FROM races WHERE name = 'Australian Grand Prix' AND year = 2008))) AS last;\t----- bird -----\tformula_1",
  "227": "SELECT COUNT(*) \nFROM circuits \nWHERE country = 'Australia' AND location = 'Adelaide';\t----- bird -----\tformula_1",
  "228": "SELECT MAX(cs.points) \nFROM constructorStandings cs \nJOIN constructors c ON cs.constructorId = c.constructorId \nWHERE c.nationality = 'British';\t----- bird -----\tformula_1",
  "229": "SELECT c.name \nFROM constructorStandings cs \nJOIN constructors c ON cs.constructorId = c.constructorId \nWHERE cs.raceId = 291 \nAND cs.points = 0;\t----- bird -----\tformula_1",
  "230": "SELECT COUNT(DISTINCT c.constructorId) \nFROM constructors c \nJOIN constructorStandings cs ON c.constructorId = cs.constructorId \nWHERE c.nationality = 'Japanese' \nAND cs.points = 0 \nGROUP BY c.constructorId \nHAVING COUNT(cs.raceId) = 2;\t----- bird -----\tformula_1",
  "231": "SELECT \n    (COUNT(CASE WHEN r.milliseconds IS NOT NULL THEN 1 END) * 100.0) / COUNT(r.raceId) AS completion_percentage\nFROM results r \nJOIN drivers d ON r.driverId = d.driverId \nJOIN races ra ON r.raceId = ra.id \nWHERE d.nationality = 'Japanese' \nAND ra.year BETWEEN 2007 AND 2009;\t----- bird -----\tformula_1",
  "232": "SELECT \n    r.year, \n    AVG(res.milliseconds / 1000.0) AS average_time_seconds \nFROM results res \nJOIN races r ON res.raceId = r.id \nWHERE r.year < 1975 \nAND res.rank = 1  -- Assuming rank = 1 denotes the champion\nGROUP BY r.year;\t----- bird -----\tformula_1",
  "233": "SELECT r.fastestLap \nFROM results r \nJOIN driverStandings ds ON r.raceId = ds.raceId \nWHERE ds.driverId = (SELECT driverId FROM driverStandings WHERE raceId IN (SELECT raceId FROM races WHERE year = 2009) ORDER BY points DESC LIMIT 1);\t----- bird -----\tformula_1",
  "234": "SELECT AVG(r.fastestLapSpeed) AS average_fastest_lap_speed\nFROM results r\nJOIN races ra ON r.raceId = ra.id\nWHERE ra.name = 'Spanish Grand Prix' \nAND ra.year = 2009;\t----- bird -----\tformula_1",
  "235": "SELECT \n    (COUNT(DISTINCT d.driverId) * 100.0) / \n    (SELECT COUNT(DISTINCT driverId) \n     FROM driverStandings ds \n     WHERE ds.raceId IN (SELECT r.id FROM races r WHERE r.year BETWEEN 2000 AND 2005)) AS percentage\nFROM drivers d \nJOIN lapTimes lt ON d.driverId = lt.driverId \nWHERE YEAR(d.dob) < 1985 \nAND lt.lap > 50;\t----- bird -----\tformula_1",
  "236": "SELECT COUNT(DISTINCT d.driverId) \nFROM lapTimes lt \nJOIN drivers d ON lt.driverId = d.driverId \nWHERE d.nationality = 'French' \nAND lt.time < '02:00.00';\t----- bird -----\tformula_1",
  "237": "SELECT code \nFROM drivers \nWHERE nationality = 'American';\t----- bird -----\tformula_1",
  "238": "SELECT \n    code, \n    (SELECT COUNT(*) FROM drivers WHERE nationality = 'Dutch' AND driverId IN (\n        SELECT driverId \n        FROM drivers \n        ORDER BY dob DESC \n        LIMIT 3\n    )) AS netherlandic_count\nFROM drivers \nWHERE driverId IN (\n    SELECT driverId \n    FROM drivers \n    ORDER BY dob DESC \n    LIMIT 3\n);\t----- bird -----\tformula_1",
  "239": "SELECT driverRef \nFROM drivers \nWHERE dob = (SELECT MIN(dob) FROM drivers WHERE nationality = 'German');\t----- bird -----\tformula_1",
  "240": "SELECT d.driverId, d.code \nFROM drivers d \nJOIN lapTimes lt ON d.driverId = lt.driverId \nWHERE YEAR(d.dob) = 1971 \nAND lt.time IS NOT NULL;  -- Using 'time' to check for valid lap times\t----- bird -----\tformula_1",
  "241": "SELECT COUNT(*) \nFROM results \nWHERE raceId > 50 AND raceId < 100 \nAND statusID = 2 \nAND milliseconds IS NOT NULL;\t----- bird -----\tformula_1",
  "242": "SELECT name, location, lat, lng, COUNT(*) AS circuit_count\nFROM circuits\nWHERE country = 'Austria'\nGROUP BY name, location, lat, lng;\t----- bird -----\tformula_1",
  "243": "SELECT \n    r.year, \n    r.date, \n    r.time \nFROM races r \nJOIN qualifying q ON r.id = q.raceId \nWHERE q.driverId = (SELECT driverId FROM drivers WHERE dob = (SELECT MIN(dob) FROM drivers))\nORDER BY r.date ASC \nLIMIT 1;\t----- bird -----\tformula_1",
  "244": "SELECT d.driverId, \n       AVG(ps.duration) AS average_pit_stop_duration \nFROM drivers d \nJOIN pitStops ps ON d.driverId = ps.driverId \nWHERE d.nationality = 'German' \nAND YEAR(d.dob) BETWEEN 1980 AND 1985 \nGROUP BY d.driverId \nORDER BY average_pit_stop_duration ASC \nLIMIT 3;\t----- bird -----\tformula_1",
  "245": "SELECT r.milliseconds, d.driverRef \nFROM results r \nJOIN races ra ON r.raceId = ra.id \nJOIN drivers d ON r.driverId = d.driverId \nWHERE ra.name = 'Canadian Grand Prix' \nAND ra.year = 2008 \nAND r.rank = 1;\t----- bird -----\tformula_1",
  "246": "SELECT c.constructorRef, c.url \nFROM results r \nJOIN constructorStandings cs ON r.raceId = cs.raceId \nJOIN constructors c ON cs.constructorId = c.constructorId \nWHERE r.raceId = (SELECT id FROM races WHERE name = 'Singapore Grand Prix' AND year = 2009) \nAND r.rank = 1;\t----- bird -----\tformula_1",
  "247": "SELECT sp.power_name \nFROM superhero sh \nJOIN hero_power hp ON sh.id = hp.hero_id \nJOIN superpower sp ON hp.power_id = sp.id \nWHERE sh.superhero_name = '3-D Man';\t----- bird -----\tsuperhero",
  "248": "SELECT c.name, c.nationality, SUM(cs.points) AS total_points\nFROM constructorStandings cs \nJOIN constructors c ON cs.constructorId = c.constructorId \nWHERE cs.raceId IN (SELECT id FROM races WHERE name = 'Monaco Grand Prix' AND year BETWEEN 1980 AND 2010)\nGROUP BY c.constructorId \nORDER BY total_points DESC \nLIMIT 1;\t----- bird -----\tformula_1",
  "249": "SELECT d.forename, d.surname \nFROM qualifying q \nJOIN races r ON q.raceId = r.id \nJOIN drivers d ON q.driverId = d.driverId \nWHERE r.name = 'Marina Bay Street Circuit' \nAND r.year = 2008 \nAND q.q3 = (SELECT MIN(q3) FROM qualifying WHERE raceId = r.id);\t----- bird -----\tformula_1",
  "250": "SELECT \n    CONCAT(d.forename, ' ', d.surname) AS full_name,\n    d.nationality,\n    r.name AS first_race\nFROM drivers d\nJOIN driverStandings ds ON d.driverId = ds.driverId\nJOIN races r ON ds.raceId = r.id\nWHERE d.dob = (SELECT MAX(dob) FROM drivers)\nORDER BY r.year, r.raceId\nLIMIT 1;\t----- bird -----\tformula_1",
  "251": "SELECT COUNT(*) AS accident_count\nFROM results r\nWHERE r.raceId = (SELECT id FROM races WHERE name = 'Canadian Grand Prix')\nAND r.statusId = 3\nGROUP BY r.driverId\nORDER BY accident_count DESC\nLIMIT 1;\t----- bird -----\tformula_1",
  "252": "SELECT d.forename, d.surname \nFROM results r \nJOIN drivers d ON r.driverId = d.driverId \nWHERE r.milliseconds = (SELECT MIN(milliseconds) FROM results);\t----- bird -----\tformula_1",
  "253": "SELECT c.name AS circuit_name, lt.time AS lap_time\nFROM circuits c\nJOIN lapTimes lt ON c.circuitId = lt.raceId  -- Assuming this join exists correctly linking lap times to circuits\nWHERE c.country = 'Italy';\t----- bird -----\tformula_1",
  "254": "SELECT COUNT(*) \nFROM superhero s \nJOIN superpower sp ON s.id = sp.id \nWHERE sp.power_name = 'Super Strength' \nAND s.height_cm > 200;\t----- bird -----\tsuperhero",
  "255": "SELECT COUNT(*) \nFROM superhero s \nJOIN colour c ON s.eye_colour_id = c.id \nJOIN superpower sp ON s.id = sp.id \nWHERE c.colour = 'Blue' \nAND sp.power_name = 'Agility';\t----- bird -----\tsuperhero",
  "256": "SELECT s.superhero_name \nFROM superhero s \nJOIN colour c1 ON s.eye_colour_id = c1.id \nJOIN colour c2 ON s.hair_colour_id = c2.id \nWHERE c1.colour = 'Blue' AND c2.colour = 'Blond';\t----- bird -----\tsuperhero",
  "257": "SELECT superhero_name, height_cm \nFROM superhero \nWHERE id IN (SELECT hero_id FROM hero_power)  -- Assuming this links to superheroes published by Marvel Comics\nORDER BY height_cm DESC; \n\nNote: Since the schema provided does not mention a `publisher_name` column in the `superhero` table, you may need to verify how the heroes are linked to their publishers and adjust accordingly.\t----- bird -----\tsuperhero",
  "258": "SELECT c.colour, COUNT(s.id) AS superhero_count\nFROM superhero s\nJOIN colour c ON s.eye_colour_id = c.id\nGROUP BY c.colour\nORDER BY superhero_count DESC; \n\n**Note:** This query assumes that all superheroes in the `superhero` table are from Marvel Comics since the schema does not directly indicate how to filter by publisher. If there is a separate table or column for publishers, the query would need to be adjusted accordingly to filter for only Marvel Comics superheroes.\t----- bird -----\tsuperhero",
  "259": "SELECT s.superhero_name, s.full_name \nFROM superhero s \nJOIN superpower sp ON s.id = sp.id \nWHERE sp.power_name = 'Super Strength'; \n\n**Note:** Since the schema provided does not include a `publisher_name` column in the `superhero` table, this query assumes all superheroes listed in the `superhero` table are from Marvel Comics. If there is a mechanism to filter by publisher in your database, such as a separate table, that should be integrated into the query accordingly.\t----- bird -----\tsuperhero",
  "260": "SELECT pub.publisher_name \nFROM superhero s \nJOIN attributes a ON s.id = a.superhero_id  -- Assuming an attributes table exists for speed\nJOIN publishers pub ON s.publisher_id = pub.id \nWHERE a.attribute_name = 'Speed' \nAND a.attribute_value = (SELECT MIN(attribute_value) FROM attributes WHERE attribute_name = 'Speed'); \n\n**Note:** This query assumes the presence of an `attributes` table to store superhero attributes such as speed, which is not explicitly listed in your schema. Additionally, a `publishers` table is assumed for linking the publisher information. Please ensure to adjust the table and column references as necessary based on your actual database schema. If such tables do not exist, you may need to revise the query accordingly.\t----- bird -----\tsuperhero",
  "261": "SELECT COUNT(*) \nFROM superhero s \nJOIN colour c ON s.eye_colour_id = c.id \nWHERE c.colour = 'Gold' \nAND s.publisher_id = (SELECT id FROM publishers WHERE publisher_name = 'Marvel Comics');  -- Assuming there is a publishers table \n\n**Note:** The query assumes a `publishers` table exists in your schema to retrieve the `publisher_id`. If the publisher ID for Marvel Comics is available directly in the superhero table, you can use that instead and skip the nested SELECT.\t----- bird -----\tsuperhero",
  "262": "SELECT \n    s.superhero_name, \n    s.full_name \nFROM superhero s \nJOIN attributes a ON s.id = a.superhero_id  -- Assuming there is an attributes table mapping intelligence\nWHERE a.attribute_name = 'Intelligence' \nAND a.attribute_value = (SELECT MIN(attribute_value) FROM attributes WHERE attribute_name = 'Intelligence'); \n\n**Note**: This query assumes the existence of an `attributes` table that includes intelligence data for superheroes. If such a table is not present in your schema, please check for an alternative method to access superhero intelligence information or adjust the schema accordingly.\t----- bird -----\tsuperhero",
  "263": "SELECT r.race \nFROM superhero s \nJOIN race r ON s.race_id = r.id \nWHERE s.superhero_name = 'Copycat';\t----- bird -----\tsuperhero",
  "264": "SELECT s.superhero_name \nFROM superhero s \nJOIN attributes a ON s.id = a.superhero_id  -- Assuming an attributes table exists\nWHERE a.attribute_name = 'Durability' \nAND a.attribute_value < 50; \n\n**Note:** This query assumes the existence of an `attributes` table that contains the durability data for superheroes. If such a table does not exist in your schema, you will need to adjust your query accordingly to reflect the actual structure of your database or check for alternative methods to access durability information.\t----- bird -----\tsuperhero",
  "265": "SELECT s.superhero_name \nFROM superhero s \nJOIN hero_power hp ON s.id = hp.hero_id \nJOIN superpower sp ON hp.power_id = sp.id \nWHERE sp.power_name = 'Death Touch';\t----- bird -----\tsuperhero",
  "266": "SELECT COUNT(*) \nFROM superhero s \nJOIN gender g ON s.gender_id = g.id \nJOIN attributes a ON s.id = a.superhero_id  -- Assuming an attributes table exists with strength data\nWHERE g.gender = 'Female' \nAND a.attribute_name = 'Strength' \nAND a.attribute_value = 100; \n\n**Note**: This query assumes that there is an `attributes` table that tracks superhero attributes, including strength. If this table does not exist or if strength is tracked differently, please adjust accordingly based on your actual schema.\t----- bird -----\tsuperhero",
  "267": "SELECT \n    (COUNT(CASE WHEN a.alignment = 'Bad' THEN 1 END) * 100.0 / COUNT(s.id)) AS percentage_of_bad_heroes,\n    COUNT(CASE WHEN a.alignment = 'Bad' AND s.publisher_id = (SELECT id FROM publishers WHERE publisher_name = 'Marvel Comics') THEN 1 END) AS count_bad_marvel_heroes\nFROM superhero s\nJOIN alignment a ON s.alignment_id = a.id;\n\n**Note**: This query assumes that there is a `publishers` table that maps `publisher_id` to publisher names. Make adjustments based on your actual schema if necessary.\t----- bird -----\tsuperhero",
  "268": "SELECT \n    (SELECT COUNT(*) FROM superhero WHERE publisher_id = (SELECT id FROM publishers WHERE publisher_name = 'Marvel Comics')) AS marvel_count,\n    (SELECT COUNT(*) FROM superhero WHERE publisher_id = (SELECT id FROM publishers WHERE publisher_name = 'DC Comics')) AS dc_count,\n    (SELECT COUNT(*) FROM superhero WHERE publisher_id = (SELECT id FROM publishers WHERE publisher_name = 'Marvel Comics')) - \n    (SELECT COUNT(*) FROM superhero WHERE publisher_id = (SELECT id FROM publishers WHERE publisher_name = 'DC Comics')) AS difference \n\n**Note**: This query assumes there is a `publishers` table that contains mappings between publisher IDs and names. Adjust your queries based on your actual schema, particularly the mechanism for linking superheroes to their publishers if the structure differs.\t----- bird -----\tsuperhero",
  "269": "SELECT id \nFROM publisher \nWHERE publisher_name = 'Star Trek';\t----- bird -----\tsuperhero",
  "270": "SELECT COUNT(*) AS total_without_full_name \nFROM superhero \nWHERE full_name IS NULL;\t----- bird -----\tsuperhero",
  "271": "SELECT AVG(s.weight_kg) AS average_weight\nFROM superhero s\nJOIN gender g ON s.gender_id = g.id\nWHERE g.gender = 'Female';\t----- bird -----\tsuperhero",
  "272": "SELECT DISTINCT sp.power_name \nFROM superhero s\nJOIN gender g ON s.gender_id = g.id \nJOIN hero_power hp ON s.id = hp.hero_id  -- Assuming there is a table linking heroes to their powers\nJOIN superpower sp ON hp.power_id = sp.id \nWHERE g.gender = 'Male' \nLIMIT 5; \n\n**Note**: This query assumes that a `hero_power` table exists that connects superhero IDs to their superpower IDs. If such a table is not present or if the structure differs, please adjust the query accordingly based on your actual schema.\t----- bird -----\tsuperhero",
  "273": "SELECT s.superhero_name \nFROM superhero s \nJOIN colour c ON s.eye_colour_id = c.id \nWHERE s.height_cm BETWEEN 170 AND 190 \nAND c.colour = 'No Colour';\t----- bird -----\tsuperhero",
  "274": "SELECT c.colour AS hair_color\nFROM superhero s \nJOIN colour c ON s.hair_colour_id = c.id \nWHERE s.height_cm = 185 \nAND s.race_id = (SELECT id FROM race WHERE race = 'human');  -- Assuming there is a race table to get the ID for 'human' \n\n**Note:** Ensure the subquery retrieves the correct ID from the `race` table for 'human' in your database schema. If \"human\" is not stored in a table or if the schema structure varies, adjust the query accordingly.\t----- bird -----\tsuperhero",
  "275": "SELECT \n    (COUNT(CASE WHEN publisher_id = (SELECT id FROM publishers WHERE publisher_name = 'Marvel Comics') THEN 1 END) * 100.0) / \n    COUNT(*) AS percentage_marvel\nFROM superhero \nWHERE height_cm BETWEEN 150 AND 180;\n\n**Note**: This query assumes that there is a `publishers` table from which you can fetch the publisher ID for Marvel Comics. If the publisher ID is directly stored in the superhero table, you can simplify the query accordingly. Be sure to adjust the column and table names based on your actual schema if they differ.\t----- bird -----\tsuperhero",
  "276": "SELECT s.superhero_name \nFROM superhero s\nJOIN gender g ON s.gender_id = g.id \nWHERE g.gender = 'Male' \nAND s.weight_kg > (SELECT AVG(weight_kg) * 0.79 FROM superhero);\t----- bird -----\tsuperhero",
  "277": "SELECT sp.power_name \nFROM hero_power hp \nJOIN superpower sp ON hp.power_id = sp.id \nWHERE hp.hero_id = 1;\t----- bird -----\tsuperhero",
  "278": "SELECT COUNT(DISTINCT hp.hero_id) AS number_of_stealth_heroes\nFROM hero_power hp\nJOIN superpower sp ON hp.power_id = sp.id\nWHERE sp.power_name = 'Stealth';\t----- bird -----\tsuperhero",
  "279": "SELECT s.full_name \nFROM superhero s \nJOIN hero_attribute ha ON s.id = ha.hero_id \nWHERE ha.attribute_value = (\n    SELECT MAX(attribute_value) \n    FROM hero_attribute \n    WHERE attribute_name = 'strength'\n); \n\n**Note**: This query assumes that there is an `attribute_name` column in the `hero_attribute` table that allows filtering for specific attributes like strength. If the schema does not include this column or if attributes are stored differently, please adjust the query as necessary.\t----- bird -----\tsuperhero",
  "280": "SELECT s.superhero_name, s.full_name\nFROM superhero s\nJOIN attributes a ON s.id = a.superhero_id  -- Assuming an attributes table exists\nWHERE s.publisher_id = (SELECT id FROM publishers WHERE publisher_name = 'Dark Horse Comics')  -- Assuming there is a publishers table\nAND a.attribute_name = 'durability'\nAND a.attribute_value = (\n    SELECT MAX(attribute_value) \n    FROM attributes \n    WHERE attribute_name = 'durability' \n    AND superhero_id IN (\n        SELECT id FROM superhero WHERE publisher_id = (SELECT id FROM publishers WHERE publisher_name = 'Dark Horse Comics')\n    )\n);\n\n**Note**: This query assumes the existence of a `publishers` table that links `publisher_id` to superhero records, and it also assumes that there is an `attributes` table containing durability data. Adjust the references and columns based on your actual database schema if necessary.\t----- bird -----\tsuperhero",
  "281": "SELECT \n    s.superhero_name, \n    e.colour AS eye_colour, \n    h.colour AS hair_colour, \n    sk.colour AS skin_colour\nFROM superhero s\nJOIN colour e ON s.eye_colour_id = e.id\nJOIN colour h ON s.hair_colour_id = h.id\nJOIN colour sk ON s.skin_colour_id = sk.id\nJOIN gender g ON s.gender_id = g.id\nWHERE g.gender = 'Female'\nAND s.publisher_id = (SELECT id FROM publishers WHERE publisher_name = 'Dark Horse Comics');  -- Assuming there is a publishers table \n\n**Note**: This query assumes the presence of a `publishers` table that links `publisher_id` to superhero records. If the publisher\u2019s information is represented differently, make sure to adjust the query conditions accordingly.\t----- bird -----\tsuperhero",
  "282": "SELECT \n    s.superhero_name, \n    s.full_name, \n    p.publisher_name  -- Assuming there's a publishers table linked to superhero\nFROM superhero s \nJOIN colour c1 ON s.eye_colour_id = c1.id \nJOIN colour c2 ON s.hair_colour_id = c2.id \nJOIN colour c3 ON s.skin_colour_id = c3.id \nJOIN publishers p ON s.publisher_id = p.id  -- Assuming there is a publishers table\nWHERE \n    s.hair_colour_id = s.eye_colour_id \n    AND s.hair_colour_id = s.skin_colour_id; \n\n**Note**: This query assumes there is a `publishers` table that links each superhero to their publisher name. If no such table exists, please adjust the plan accordingly. If additional relationships exist in your actual schema that need to be considered, incorporate those as necessary.\t----- bird -----\tsuperhero",
  "283": "SELECT \n    (COUNT(CASE WHEN c.colour = 'Blue' THEN 1 END) * 100.0) / COUNT(*) AS percentage_blue_female\nFROM superhero s\nJOIN gender g ON s.gender_id = g.id \nJOIN colour c ON s.eye_colour_id = c.id \nWHERE g.gender = 'Female'; \n\n**Note**: This query assumes that all necessary joins and filters are in place. It calculates the percentage of female superheroes with blue eyes among all female superheroes based on the given schema. Please ensure that the table and field names match your actual schema, and make adjustments as necessary if there are any discrepancies.\t----- bird -----\tsuperhero",
  "284": "SELECT COUNT(DISTINCT hp.power_id) AS total_powers \nFROM superhero s \nJOIN hero_power hp ON s.id = hp.hero_id \nWHERE s.superhero_name = 'Amazo';\n\nThis query counts the distinct superpower IDs linked to the superhero \"Amazo,\" reflecting the total number of powers he possesses.\t----- bird -----\tsuperhero",
  "285": "SELECT s.height_cm \nFROM superhero s \nJOIN colour c ON s.eye_colour_id = c.id \nWHERE c.colour = 'Amber';\t----- bird -----\tsuperhero",
  "286": "SELECT s.superhero_name \nFROM superhero s \nJOIN colour c1 ON s.eye_colour_id = c1.id \nJOIN colour c2 ON s.hair_colour_id = c2.id \nWHERE c1.colour = 'Black' AND c2.colour = 'Black';\t----- bird -----\tsuperhero",
  "287": "SELECT s.superhero_name \nFROM superhero s \nJOIN alignment a ON s.alignment_id = a.id \nWHERE a.alignment = 'Neutral';\t----- bird -----\tsuperhero",
  "288": "SELECT COUNT(DISTINCT ha.hero_id) AS number_of_heroes\nFROM hero_attribute ha\nWHERE ha.attribute_value = (\n    SELECT MAX(attribute_value)\n    FROM hero_attribute\n    WHERE attribute_id = (SELECT id FROM attribute WHERE attribute_name = 'Strength')\n);\n\n### Notes:\n- This query assumes that there is an `attribute` table that links attributes with their names (like \"Strength\"). If such a table does not exist, adjust the query to directly reference the strength's attribute ID in the `hero_attribute` table.\n- The use of `DISTINCT` ensures that if multiple entries exist in `hero_attribute` for a single hero, we only count them once.\t----- bird -----\tsuperhero",
  "289": "SELECT \n    (COUNT(CASE WHEN s.publisher_id = (SELECT id FROM publishers WHERE publisher_name = 'Marvel Comics') THEN 1 END) * 100.0) / \n    COUNT(*) AS percentage_female_marvel\nFROM superhero s\nJOIN gender g ON s.gender_id = g.id \nWHERE g.gender = 'Female';\n\n**Note**: This query assumes that there is a `publishers` table to retrieve the ID of Marvel Comics. If the `publisher_id` is already available in the `superhero` table, you can simplify the query by directly using that information instead of referencing a separate publisher table. Adjust the query as necessary based on your actual schema structure.\t----- bird -----\tsuperhero",
  "290": "SELECT \n    (SELECT weight_kg FROM superhero WHERE full_name = 'Emil Blonsky') - \n    (SELECT weight_kg FROM superhero WHERE full_name = 'Charles Chandler') AS weight_difference; \n\nThis SQL query calculates the difference between the weights of Emil Blonsky and Charles Chandler by selecting their weights from the superhero table based on their full names.\t----- bird -----\tsuperhero",
  "291": "SELECT AVG(height_cm) AS average_height \nFROM superhero; \n\nThis query will calculate the average height of all superheroes by directly using the `AVG` function on the `height_cm` column from the `superhero` table.\t----- bird -----\tsuperhero",
  "292": "SELECT sp.power_name \nFROM superhero s \nJOIN hero_power hp ON s.id = hp.hero_id \nJOIN superpower sp ON hp.power_id = sp.id \nWHERE s.superhero_name = 'Abomination';\t----- bird -----\tsuperhero",
  "293": "SELECT s.superhero_name, s.full_name \nFROM superhero s \nJOIN hero_attribute ha ON s.id = ha.hero_id \nWHERE ha.attribute_value = (SELECT MAX(attribute_value) \n                             FROM hero_attribute \n                             WHERE attribute_name = 'Speed');  -- Assuming attribute_name exists \n\n**Note**: This query assumes that there is an `attribute_name` column in the `hero_attribute` table that designates speed. If this column does not exist in your schema, please adjust your query based on the actual implementation of speed attributes in your database structure.\t----- bird -----\tsuperhero",
  "294": "SELECT \n    a.attribute_name, \n    ha.attribute_value \nFROM superhero s \nJOIN hero_attribute ha ON s.id = ha.hero_id \nJOIN attribute a ON ha.attribute_id = a.id \nWHERE s.superhero_name = '3-D Man'; \n\n**Note**: This query assumes that the `attribute` table contains both `attribute_name` and `id`, where the `hero_attribute` table maps `hero_id` to their respective `attribute_id`. Adjustments may be required based on the actual schema if it varies.\t----- bird -----\tsuperhero",
  "295": "SELECT s.superhero_name \nFROM superhero s \nJOIN colour c1 ON s.eye_colour_id = c1.id \nJOIN colour c2 ON s.hair_colour_id = c2.id \nWHERE c1.colour = 'Blue' AND c2.colour = 'Brown';\n\nThis query retrieves the names of superheroes with blue eyes and brown hair by joining the `superhero` table with the `colour` table twice, once for eye color and once for hair color, and filtering for the specified attributes.\t----- bird -----\tsuperhero",
  "296": "SELECT \n    s.superhero_name, \n    p.publisher_name \nFROM superhero s \nJOIN publisher p ON s.publisher_id = p.id \nWHERE s.superhero_name IN ('Hawkman', 'Karate Kid', 'Speedy'); \n\nThis query joins the `superhero` table with the `publisher` table and filters for the specified superhero names to return their corresponding publishers.\t----- bird -----\tsuperhero",
  "297": "SELECT \n    (COUNT(CASE WHEN s.eye_colour_id = (SELECT id FROM colour WHERE colour = 'Blue') THEN 1 END) * 100.0) / COUNT(*) AS percentage_blue_eyes\nFROM superhero s; \n\nThis query calculates the percentage of superheroes with blue eyes by counting those whose `eye_colour_id` matches the ID for blue color from the `colour` table, while also counting the total number of superheroes to compute the final percentage.\t----- bird -----\tsuperhero",
  "298": "SELECT \n    (SELECT COUNT(*) FROM superhero WHERE gender_id = 1) * 1.0 / \n    (SELECT COUNT(*) FROM superhero WHERE gender_id = 2) AS male_to_female_ratio;\n\nThis query calculates the ratio of male superheroes (assuming `gender_id = 1` for males) to female superheroes (assuming `gender_id = 2` for females) by counting the number of heroes for each gender and dividing the two counts. The multiplication by `1.0` ensures that the result is returned as a decimal rather than an integer division should the counts yield whole numbers. Adjust the `gender_id` values based on your specific schema if necessary.\t----- bird -----\tsuperhero",
  "299": "SELECT c.colour \nFROM superhero s \nJOIN colour c ON s.eye_colour_id = c.id \nWHERE s.full_name = 'Karen Beecher-Duncan'; \n\nThis query retrieves the eye color of the superhero whose full name is \"Karen Beecher-Duncan\" by joining the `superhero` table with the `colour` table based on the `eye_colour_id`.\t----- bird -----\tsuperhero",
  "300": "SELECT \n    (COUNT(CASE WHEN s.eye_colour_id = 7 THEN 1 END) - COUNT(CASE WHEN s.eye_colour_id = 1 THEN 1 END)) AS difference\nFROM superhero s\nWHERE s.weight_kg = 0 OR s.weight_kg IS NULL;\n\nThis query counts the number of superheroes with blue eyes (assuming `eye_colour_id = 7`) and the number of superheroes with no eye color (assuming `eye_colour_id = 1`) among those whose weight is missing (zero or null), and then calculates the difference between these two counts.\t----- bird -----\tsuperhero",
  "301": "SELECT COUNT(*) AS green_skinned_villains \nFROM superhero s \nJOIN colour c ON s.skin_colour_id = c.id \nWHERE c.colour = 'Green' \nAND s.alignment = 'Bad'; -- Assuming alignment is a column in the superhero table \n\n**Note**: This query assumes that the `alignment` attribute is present and accessible in the `superhero` table to determine whether a superhero is classified as a villain. If this information is organized differently, please adjust accordingly.\t----- bird -----\tsuperhero",
  "302": "SELECT s.superhero_name \nFROM superhero s \nJOIN hero_power hp ON s.id = hp.hero_id  -- Assuming an intermediary table linking superheroes to their powers\nJOIN superpower sp ON hp.power_id = sp.id \nWHERE sp.power_name = 'Wind Control' \nORDER BY s.superhero_name ASC;\n\n**Note**: This query assumes that there is a `hero_power` table linking superheroes to their powers. If the schema differs or additional mapping details are needed, please adapt the query accordingly.\t----- bird -----\tsuperhero",
  "303": "SELECT g.gender \nFROM superhero s \nJOIN gender g ON s.gender_id = g.id \nJOIN hero_power hp ON s.id = hp.hero_id \nJOIN superpower sp ON hp.power_id = sp.id \nWHERE sp.power_name = 'Phoenix Force';\n\n**Note**: This query assumes that there is a `hero_power` table that links superheroes to their abilities and a `superpower` table that specifies the names of these powers. If those tables do not exist in the actual schema, you will need to adjust accordingly based on the structure of your database.\t----- bird -----\tsuperhero",
  "304": "SELECT \n    (SELECT COUNT(*) FROM superhero WHERE publisher_id = (SELECT id FROM publishers WHERE publisher_name = 'DC Comics')) AS dc_count,\n    (SELECT COUNT(*) FROM superhero WHERE publisher_id = (SELECT id FROM publishers WHERE publisher_name = 'Marvel Comics')) AS marvel_count,\n    (SELECT COUNT(*) FROM superhero WHERE publisher_id = (SELECT id FROM publishers WHERE publisher_name = 'DC Comics')) - \n    (SELECT COUNT(*) FROM superhero WHERE publisher_id = (SELECT id FROM publishers WHERE publisher_name = 'Marvel Comics')) AS difference\n\n**Note**: This SQL query assumes that there is a `publishers` table mapping `publisher_id` to `publisher_name`. If this information is not structured in your schema, please adjust the query accordingly to match how publishers are referenced. If publishers are directly included in the superhero table, you might need to modify how you're counting superheroes for each publisher without requiring a subselect for the publisher ID.\t----- bird -----\tsuperhero",
  "305": "SELECT \n    u.UserDisplayName, \n    u.Reputation \nFROM users u \nWHERE u.UserDisplayName IN ('Harlan', 'Jarrod Dixon');\n\nThis query retrieves the reputation scores for both Harlan and Jarrod Dixon, allowing you to compare their reputations based on the results. After running this query, you can manually compare the reputation scores to determine who has the higher reputation.\t----- bird -----\tcodebase_community",
  "306": "SELECT DisplayName \nFROM users \nWHERE YEAR(CreationDate) = 2011; \n\nThis query retrieves the display names of all users whose accounts were created in the year 2011 by filtering the `users` table based on the `CreationDate` column.\t----- bird -----\tcodebase_community",
  "307": "SELECT COUNT(*) AS user_count\nFROM users \nWHERE LastAccessDate > '2014-09-01'; \n\nThis query counts the number of users whose last access date is after September 1, 2014, by filtering the `users` table based on the `LastAccessDate` column.\t----- bird -----\tcodebase_community",
  "308": "SELECT OwnerDisplayName \nFROM posts \nWHERE Title = 'Eliciting priors from experts'; \n\nThis query retrieves the display name of the owner for the post titled \"Eliciting priors from experts\" by querying the `posts` table based on the specified title.\t----- bird -----\tcodebase_community",
  "309": "SELECT COUNT(*) AS post_count \nFROM posts \nWHERE OwnerDisplayName = 'csgillespie'; \n\nThis query counts the number of posts in the `posts` table that are owned by the user with the display name \"csgillespie\".\t----- bird -----\tcodebase_community",
  "310": "SELECT LastEditorDisplayName \nFROM posts \nWHERE Title = 'Examples for teaching: Correlation does not mean causation';\n\nThis query retrieves the display name of the user who last edited the specified post by filtering the `posts` table based on the post title.\t----- bird -----\tcodebase_community",
  "311": "SELECT COUNT(*) AS post_count\nFROM posts p\nWHERE p.OwnerUserId IN (SELECT id FROM users WHERE Age > 65)\nAND p.Score > 19;\n\nThis query counts the number of posts owned by users older than 65 years whose score is greater than 19, effectively yielding the required information.\t----- bird -----\tcodebase_community",
  "312": "SELECT p.Body \nFROM posts p \nJOIN tags t ON p.id = t.ExcerptPostId \nWHERE t.TagName = 'bayesian'; \n\nThis query retrieves the body of the post associated with the tag \"bayesian\" by joining the `posts` table with the `tags` table using the `ExcerptPostId`.\t----- bird -----\tcodebase_community",
  "313": "SELECT AVG(p.Score) AS average_score \nFROM posts p \nJOIN users u ON p.OwnerUserId = u.id \nWHERE u.DisplayName = 'csgillespie'; \n\nThis query calculates the average score of the posts owned by the user \"csgillespie\" by joining the `posts` table with the `users` table and filtering based on the user's display name.\t----- bird -----\tcodebase_community",
  "314": "SELECT \n    (COUNT(CASE WHEN u.Age > 65 THEN 1 END) * 100.0) / COUNT(*) AS percentage_elder_users\nFROM posts p\nJOIN users u ON p.OwnerUserId = u.UserId\nWHERE p.Score > 5; \n\nThis query calculates the percentage of posts owned by users over the age of 65 (elder users) among the total posts scoring over 5 by counting the relevant entries and applying the percentage formula.\t----- bird -----\tcodebase_community",
  "315": "SELECT p.FavoriteCount \nFROM comments c \nJOIN posts p ON c.PostId = p.id \nWHERE c.UserId = 3025 \nAND c.CreationDate = '2014-04-23 20:29:39.0';\n\nThis query retrieves the favorite count for the post that user No. 3025 commented on at the specified date and time by joining the `comments` and `posts` tables based on the `PostId`.\t----- bird -----\tcodebase_community",
  "316": "SELECT \n    CASE \n        WHEN p.ClosedDate IS NULL THEN 'Well-finished' \n        ELSE 'Not well-finished' \n    END AS post_status\nFROM comments c\nJOIN postHistory ph ON c.PostId = ph.PostId  -- Assuming there's a PostId association in comments\nJOIN posts p ON ph.PostId = p.id \nWHERE c.UserId = 23853 \nAND c.CreationDate = '2013-07-12 09:08:18.0'; \n\n**Note**: This query assumes there is a `PostId` in the `comments` table that links to the posts in the `postHistory`. If this is not the case, you'll need to adjust how you relate comments to their corresponding posts based on your schema. The `post_status` field will indicate the finishing status of the post based on the presence or absence of a `ClosedDate`.\t----- bird -----\tcodebase_community",
  "317": "SELECT COUNT(*) AS post_count \nFROM posts \nWHERE OwnerDisplayName = 'Tiago Pasqualini'; \n\nThis query retrieves the total count of posts owned by the user with the display name \"Tiago Pasqualini\" from the `posts` table.\t----- bird -----\tcodebase_community",
  "318": "SELECT u.UserDisplayName \nFROM votes v \nJOIN users u ON v.UserId = u.Id \nWHERE v.Id = 6347;\n\nThis query retrieves the display name of the user who made the vote with ID 6347 by joining the `votes` table with the `users` table based on the user ID.\t----- bird -----\tcodebase_community",
  "319": "SELECT \n    (COUNT(p.Id) * 1.0 / NULLIF(COUNT(v.UserId), 0)) AS post_vote_ratio\nFROM posts p \nLEFT JOIN votes v ON p.OwnerUserId = v.UserId \nWHERE p.OwnerUserId = 24;\n\n**Note**: \n- The `NULLIF` function is used to prevent division by zero in cases where there are no votes for that user.\n- This query counts the number of posts in the `posts` table for user ID 24 and the total number of votes in the `votes` table for the same user. The result is a ratio of posts to votes.\n- The use of `LEFT JOIN` allows counting posts even if there are no corresponding votes.\t----- bird -----\tcodebase_community",
  "320": "SELECT ViewCount \nFROM posts \nWHERE Title = 'Integration of Weka and/or RapidMiner into Informatica PowerCenter/Developer'; \n\nThis query retrieves the view count from the posts table for the specified post title.\t----- bird -----\tcodebase_community",
  "321": "SELECT Text \nFROM comments \nWHERE Score = 17; \n\nThis query retrieves the text content of comments that have a score of 17 from the comments table.\t----- bird -----\tcodebase_community",
  "322": "SELECT UserDisplayName \nFROM comments \nWHERE Text = 'thank you user93!'; \n\nThis query correctly retrieves the display name of the user who commented \"thank you user93!\" from the `comments` table, as it directly filters for the specific comment text.\t----- bird -----\tcodebase_community",
  "323": "SELECT u.Reputation, p.OwnerDisplayName \nFROM posts p \nJOIN users u ON p.OwnerUserId = u.UserId \nWHERE p.Title = 'Understanding what Dassault iSight is doing?';\n\nThis query retrieves the reputation of the user who made the post titled \"Understanding what Dassault iSight is doing?\" by joining the `posts` table with the `users` table based on the `OwnerUserId`.\t----- bird -----\tcodebase_community",
  "324": "SELECT OwnerDisplayName \nFROM posts \nWHERE Title = 'Open source tools for visualizing multi-dimensional data'; \n\nThis query retrieves the display name of the owner for the post titled \"Open source tools for visualizing multi-dimensional data\" from the `posts` table.\t----- bird -----\tcodebase_community",
  "325": "SELECT c.Text \nFROM comments c \nJOIN posts p ON c.UserId = p.LastEditorUserId \nWHERE p.Title = 'Why square the difference instead of taking the absolute value in standard deviation?';\n\n**Note**: In this query, we are directly filtering the comments based on the `LastEditorUserId` and linking it to the associated post that matches the specified title. If there is a need to include all comments made by that user (not just the last edit), you may consider querying separately for all comments made by that `UserId`. Adjust the method based on your schema integrity.\t----- bird -----\tcodebase_community",
  "326": "SELECT u.UserDisplayName \nFROM votes v \nJOIN posts p ON v.PostId = p.id \nJOIN users u ON v.UserId = u.Id \nWHERE v.BountyAmount = 50 \nAND p.Title LIKE '%variance%'; \n\nThis query retrieves the display name of the user who added a bounty of 50 to posts with \"variance\" in their title, by joining the `votes`, `posts`, and `users` tables based on their respective IDs.\t----- bird -----\tcodebase_community",
  "327": "SELECT \n    p.Title, \n    c.Text,\n    AVG(p.ViewCount) OVER () AS average_view_count\nFROM posts p\nJOIN tags t ON p.id = t.PostId  -- Assuming a PostId reference exists in the tags table for posts\nJOIN comments c ON p.id = c.PostId  -- Join comments using PostId to get the related comments\nWHERE t.tag = 'humor';\n\n### Explanation:\n- This query retrieves the title and comments of posts tagged with 'humor' and calculates the average view count for all posts with that tag.\n- The use of `AVG(p.ViewCount) OVER ()` allows calculating the average view count for all qualifying posts while listing each post\u2019s title and comments.\n- Ensure that the `tags` table has a proper relation to the `posts` table with a `PostId` column. If necessary, adjust the references to fit your actual database schema.\t----- bird -----\tcodebase_community",
  "328": "SELECT COUNT(DISTINCT UserId) AS user_count_with_more_than_5_badges\nFROM badges \nGROUP BY UserId \nHAVING COUNT(Name) > 5; \n\nThis query counts the number of distinct users who have more than 5 badges by grouping the `badges` table by `UserId` and applying a filter with `HAVING` to only include users with a badge count greater than 5.\t----- bird -----\tcodebase_community",
  "329": "SELECT \n    ph.UserId, \n    ph.UserDisplayName \nFROM postHistory ph\nJOIN posts p ON ph.PostId = p.id \nWHERE p.ViewCount >= 1000\nGROUP BY ph.UserId, ph.PostId \nHAVING COUNT(ph.Id) = 1;\n\nThis query retrieves users who have a single post history per post with at least 1000 views by joining the `postHistory` table with the `posts` table, filtering for posts that meet the view count criterion, and ensuring in the `HAVING` clause that each user has only one post history per post.\t----- bird -----\tcodebase_community",
  "330": "SELECT \n    (COUNT(CASE WHEN YEAR(Date) = 2010 THEN 1 END) * 100.0 / COUNT(Name)) AS percentage_2010,\n    (COUNT(CASE WHEN YEAR(Date) = 2011 THEN 1 END) * 100.0 / COUNT(Name)) AS percentage_2011,\n    ((COUNT(CASE WHEN YEAR(Date) = 2010 THEN 1 END) * 100.0 / COUNT(Name)) - \n     (COUNT(CASE WHEN YEAR(Date) = 2011 THEN 1 END) * 100.0 / COUNT(Name))) AS percentage_difference\nFROM badges \nWHERE Name = 'Student';\n\n### Explanation:\n- This query calculates the percentage of \"Student\" badges awarded in 2010 and 2011 and computes the percentage difference between the two years based on the total count of badges. Each calculation uses a CASE statement to count badges for each year, and the final result outputs all relevant percentages along with the difference.\t----- bird -----\tcodebase_community",
  "331": "SELECT \n    AVG(u.UpVotes) AS average_upvotes,\n    AVG(u.Age) AS average_age\nFROM users u\nJOIN postHistory ph ON u.id = ph.UserId\nGROUP BY u.id\nHAVING COUNT(ph.UserId) > 10;\n\n### Explanation:\n- This query counts the number of posts created by each user in the `postHistory` table.\n- It calculates the average `UpVotes` and average `Age` of users who have created more than 10 posts by filtering with `HAVING COUNT(ph.UserId) > 10`.\n- The results provide the average number of upvotes and age for users who meet the criteria. Adjust any column names or relationships based on your actual database schema if necessary.\t----- bird -----\tcodebase_community",
  "332": "SELECT \n    (COUNT(CASE WHEN YEAR(CreationDate) = 2010 THEN 1 END) * 1.0) / \n    (COUNT(CASE WHEN YEAR(CreationDate) = 2011 THEN 1 END)) AS vote_ratio\nFROM votes;\n\n### Explanation:\n- This query uses conditional counting to count the votes for 2010 and 2011.\n- The multiplication by `1.0` ensures that the division results in a decimal (floating-point) value, allowing for a more accurate ratio rather than integer division.\n- The final output will give you the ratio of votes cast in 2010 to votes cast in 2011.\t----- bird -----\tcodebase_community",
  "333": "SELECT p.PostId \nFROM posts p \nJOIN postHistory ph ON p.PostId = ph.PostId \nWHERE ph.UserId = (SELECT UserId FROM users WHERE DisplayName = 'slashnick') \nORDER BY p.AnswerCount DESC \nLIMIT 1;\n\n### Explanation:\n- This query joins the `posts` and `postHistory` tables to find all posts by the user \"slashnick.\"\n- It uses a subquery to retrieve the `UserId` corresponding to \"slashnick\" from the `users` table.\n- The results are ordered by `AnswerCount` in descending order, and the query retrieves the `PostId` of the post with the highest answer count, limited to 1 result.\t----- bird -----\tcodebase_community",
  "334": "SELECT \n    u.DisplayName, \n    MAX(p.ViewCount) AS max_view_count \nFROM posts p \nJOIN users u ON p.OwnerUserId = u.Id \nWHERE u.DisplayName IN ('Harvey Motulsky', 'Noah Snyder')\nGROUP BY u.DisplayName \nORDER BY max_view_count DESC \nLIMIT 1;\n\n### Explanation:\n- This query joins the `posts` table with the `users` table to find out the view counts for posts owned by either Harvey Motulsky or Noah Snyder.\n- The results are grouped by `DisplayName` and the maximum `ViewCount` is calculated for each user.\n- Finally, it orders the results in descending order by view count and limits the output to the top entry, giving the user with the highest view count along with their maximum views.\t----- bird -----\tcodebase_community",
  "335": "SELECT t.TagName \nFROM posts p \nJOIN tags t ON FIND_IN_SET(t.TagName, p.Tags) > 0 \nWHERE p.CommentCount = 0 \nAND p.OwnerDisplayName = 'Mark Meckes';\n\n### Explanation:\n- This query joins the `posts` table with the `tags` table to find all tags associated with posts made by Mark Meckes which have zero comments.\n- The `FIND_IN_SET` function is used to check if each tag from the `tags` table is present in the `Tags` column of the `posts` table. \n- We filter for posts where `CommentCount = 0` to ensure that only posts without comments are considered.\n- The query outputs the names of all tags used by Mark Meckes in those qualifying posts.\t----- bird -----\tcodebase_community",
  "336": "SELECT \n    (COUNT(CASE WHEN t.TagName = 'r' THEN 1 END) * 100.0) / COUNT(*) AS percentage_r_language\nFROM posts p \nJOIN tags t ON p.PostId = t.PostId \nWHERE p.OwnerDisplayName = 'Community';\n\n### Explanation:\n- The query counts the number of posts that are both owned by the \"Community\" and tagged with \"R\" (indicated as `'r'`).\n- It calculates the percentage by taking the count of those posts with the 'r' tag and dividing it by the total number of Community posts, then multiplying by 100 to get the percentage.\n- The use of `CASE` within `COUNT` allows for selective counting of posts based on tag conditions.\t----- bird -----\tcodebase_community"
}