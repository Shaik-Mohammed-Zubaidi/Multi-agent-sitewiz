=====================
Question: What is the ratio of customers who pay in EUR against customers who pay in CZK?
 db_id: debit_card_specializing
Planner: Here's how we can solve this question using SQL:

1.  **Table:** We need the `customers` table because it contains the `Currency` column, which indicates the currency each customer uses.
2.  **Filtering:**  We need to implicitly count customers where `Currency` is EUR and where `Currency` is CZK.
3.  **Aggregation:** We will use COUNT to count number of EUR and CZK records.
4.  **Calculation:**  Divide the count of EUR customers by the count of CZK customers to get the ratio.

NL2SQL: ```sql
SELECT CAST(SUM(CASE WHEN Currency = 'EUR' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN Currency = 'CZK' THEN 1 ELSE 0 END) FROM customers
```
Critic: ```sql
SELECT CAST(SUM(CASE WHEN Currency = 'EUR' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN Currency = 'CZK' THEN 1 ELSE 0 END) FROM Customers
```
=====================
Question: What is the ratio of customers who pay in EUR against customers who pay in CZK?
 db_id: debit_card_specializing
Planner: Here's a plan to determine the ratio of customers paying in EUR versus CZK:

1.  **Table:** Start with the `customers` table as it contains the `Currency` information.
2.  **Filter:** Filter the `customers` table to count customers with `Currency = 'EUR'` and `Currency = 'CZK'`.
3.  **Calculate the ratio:** Divide the count of EUR customers by the count of CZK customers.

NL2SQL: ```sql
SELECT CAST(SUM(CASE WHEN Currency = 'EUR' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN Currency = 'CZK' THEN 1 ELSE 0 END) FROM customers
```
Critic: ```sql
SELECT CAST(SUM(CASE WHEN Currency = 'EUR' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN Currency = 'CZK' THEN 1 ELSE 0 END) FROM Customers
```
=====================
Question: In 2012, who had the least consumption in LAM?
 db_id: debit_card_specializing
Planner: Plan:
1. Filter the `yearmonth` table for records where the year is 2012 using the `Date` column.
2. Filter the `gasstations` table for records where the `Country` is 'LAM'.
3. Join the filtered `yearmonth` table with the `customers` table using the `CustomerID`.
4. Calculate the sum of `Consumption` for each `CustomerID` from the joined table.
5. Find the `CustomerID` with the minimum consumption in LAM for 2012.
6. Select the `CustomerID` with the minimum consumption.

NL2SQL: ```sql
SELECT CustomerID FROM yearmonth WHERE substr(Date, 1, 4) = '2012' GROUP BY CustomerID ORDER BY sum(Consumption) ASC LIMIT 1
```
Critic: ```sql
SELECT CustomerID FROM yearmonth WHERE substr(Date, 1, 4) = '2012' AND CustomerID IN (SELECT CustomerID FROM customers WHERE Segment = 'LAM') GROUP BY CustomerID ORDER BY sum(Consumption) ASC LIMIT 1
```
=====================
Question: What was the average monthly consumption of customers in SME for the year 2013?
 db_id: debit_card_specializing
Planner: Plan:

1.  Join the `yearmonth` and `customers` tables on `CustomerID`.
2.  Filter the data for the year 2013 using the `Date` column from the `yearmonth` table.  We can extract the year from the `Date` column.
3.  Filter the data for customers in the SME segment using the `Segment` column from the `customers` table.
4.  Calculate the average monthly consumption by averaging the `Consumption` and dividing the result by the number of months (12).

NL2SQL: ```sql
SELECT
  AVG(T1.Consumption)
FROM yearmonth AS T1
INNER JOIN customers AS T2
  ON T1.CustomerID = T2.CustomerID
WHERE
  T2.Segment = 'SME' AND T1.Date BETWEEN '201301' AND '201312';
```
Critic: ```sql
SELECT
  AVG(Consumption)
FROM yearmonth AS T1
INNER JOIN customers AS T2
  ON T1.CustomerID = T2.CustomerID
WHERE
  T2.Segment = 'SME' AND STRFTIME('%Y', T1.Date) = '2013';
```
=====================
Question: What was the difference in gas consumption between CZK-paying customers and EUR-paying customers in 2012?
 db_id: debit_card_specializing
Planner: Here's my plan to determine the difference in gas consumption between CZK and EUR-paying customers in 2012:

1.  **Identify CZK and EUR customers:** Use the `customers` table to filter and group customers based on their currency (`Currency`).
2.  **Calculate Consumption for CZK customers in 2012:**
    *   Join `customers` with `yearmonth` on `CustomerID`.
    *   Filter the joined table for customers with `Currency = 'CZK'` and year within the range 201201 to 201212.
    *   Sum the `Consumption` for these customers.
3.  **Calculate Consumption for EUR customers in 2012:**
    *   Join `customers` with `yearmonth` on `CustomerID`.
    *   Filter the joined table for customers with `Currency = 'EUR'` and year within the range 201201 to 201212.
    *   Sum the `Consumption` for these customers.
4.  **Calculate the difference:** Subtract the total consumption of EUR customers from the total consumption of CZK customers.

I'll need the following tables, joins, filters, and columns:

*   **Tables:** `customers`, `yearmonth`
*   **Joins:** `customers.CustomerID = yearmonth.CustomerID`
*   **Filters:**
    *   `customers.Currency IN ('CZK', 'EUR')`
    *   `yearmonth.Date BETWEEN '201201' AND '201212'` (or the appropriate date format for the `yearmonth` table)
*   **Columns:**
    *   `customers.Currency`
    *   `yearmonth.Consumption`

NL2SQL: ```sql
SELECT
  SUM(CASE WHEN T1.Currency = 'CZK' THEN T2.Consumption ELSE 0 END) - SUM(CASE WHEN T1.Currency = 'EUR' THEN T2.Consumption ELSE 0 END)
FROM customers AS T1
INNER JOIN yearmonth AS T2
  ON T1.CustomerID = T2.CustomerID
WHERE
  CAST(SUBSTR(T2.DB_ID, 1, 4) AS INTEGER) = 2012;
```
Critic: ```sql
SELECT
  SUM(CASE WHEN T1.Currency = 'CZK' THEN T2.Consumption ELSE 0 END) - SUM(CASE WHEN T1.Currency = 'EUR' THEN T2.Consumption ELSE 0 END)
FROM customers AS T1
INNER JOIN yearmonth AS T2
  ON T1.CustomerID = T2.CustomerID
WHERE
  T2.DB_ID BETWEEN 201201 AND 201212;
```
=====================
Question: Which year recorded the most consumption of gas paid in CZK?
 db_id: debit_card_specializing
Planner: Plan:
1. Filter `transactions_1k` for transactions where the price currency is CZK. Since there is no currency information, assume that all transactions in the database are in CZK.
2. Extract the year from the `Date` column of the `transactions_1k` table.
3. Calculate the total gas consumption for each year by joining transactions with the extracted year.
4. Find the year with the maximum total gas consumption.
5. Return the year with the highest consumption.

Needed tables: `transactions_1k`
Needed columns: `Date`, `Amount`
Filters: No explicit currency filter, assuming all transactions are in CZK.
Joins: No explicit joins needed, extracting year from date and aggregating.
Aggregations: Sum of `Amount` grouped by year.
Final result: Year with the maximum sum of amount.

NL2SQL: ```sql
SELECT strftime('%Y', Date) AS transaction_year
FROM transactions_1k
GROUP BY transaction_year
ORDER BY SUM(Amount) DESC
LIMIT 1;
```
Critic: ```sql
SELECT strftime('%Y', T2.Date) FROM yearmonth AS T1 JOIN transactions_1k AS T2 ON T1.Consumption = T2.Amount WHERE T2.Price = 'CZK' GROUP BY strftime('%Y', T2.Date) ORDER BY sum(T1.Consumption) DESC LIMIT 1
```
=====================
Question: What was the gas consumption peak month for SME customers in 2013?
 db_id: debit_card_specializing
Planner: Plan:
1. Filter the `yearmonth` table to include only the data from the year 2013. This can be done by filtering the `Date` column to be between 201301 and 201312.
2. Filter the `customers` table to include only SME customers, by filtering the `Segment` column to be SME.
3. Join `yearmonth` table with `customers` table on `CustomerID`.
4. Group the results by month (extracted from the `Date` column) and sum the `Consumption`.
5. Order the results in descending order of `Consumption`.
6. Select the month with the highest consumption.
7. Output the month with the highest consumption.

NL2SQL: ```sql
SELECT
  SUBSTR(Date, 5, 2)
FROM yearmonth
JOIN customers
  ON yearmonth.CustomerID = customers.CustomerID
WHERE
  SUBSTR(Date, 1, 4) = '2013' AND customers.Segment = 'SME'
GROUP BY
  SUBSTR(Date, 5, 2)
ORDER BY
  SUM(Consumption) DESC
LIMIT 1;
```
Critic: ```sql
SELECT
  SUBSTR(Date, 5, 2)
FROM yearmonth
JOIN customers
  ON yearmonth.CustomerID = customers.CustomerID
WHERE
  SUBSTR(Date, 1, 4) = '2013' AND customers.Segment = 'SME'
GROUP BY
  SUBSTR(Date, 5, 2)
ORDER BY
  SUM(Consumption) DESC
LIMIT 1;
```
=====================
Question: What is the difference in the annual average consumption of the customers with the least amount of consumption paid in CZK for 2013 between SME and LAM, LAM and KAM, and KAM and SME?
 db_id: debit_card_specializing
Planner: Plan:
1. Filter the `yearmonth` table for records in the year 2013 using the `Date` column.
2. Join `yearmonth` with the `customers` table using the `CustomerID` to get the segment (SME, LAM, KAM) and currency information.
3. Filter for customers with `Currency` as 'CZK'.
4. Calculate the total consumption for each segment (SME, LAM, KAM) in 2013.
5. Find the customer with the minimum consumption for each segment in 2013.
6. Compute the annual average consumption for the customers with the minimum consumption in each segment by dividing total consumption for the respective segment by the number of customers with lowest consumption in that segment.  In this case, since we found one customer for each segment, the annual average consumption for each segment is simply the consumption of the customer with minimum consumption in that segment for 2013.
7. Calculate the differences in annual average consumption between SME and LAM, LAM and KAM, and KAM and SME.

NL2SQL: ```sql
WITH ConsumptionData AS (
  SELECT
    ym.CustomerID,
    ym.Consumption,
    c.Segment
  FROM yearmonth AS ym
  JOIN customers AS c
    ON ym.CustomerID = c.CustomerID
  WHERE
    SUBSTR(ym.Date, 1, 4) = '2013' AND c.Currency = 'CZK'
), MinConsumption AS (
  SELECT
    Segment,
    MIN(Consumption) AS MinConsumptionValue
  FROM ConsumptionData
  GROUP BY
    Segment
), SegmentConsumption AS (
  SELECT
    cd.Segment,
    cd.Consumption
  FROM ConsumptionData AS cd
  JOIN MinConsumption AS mc
    ON cd.Segment = mc.Segment AND cd.Consumption = mc.MinConsumptionValue
), SegmentValues AS (
  SELECT
    Segment,
    Consumption
  FROM SegmentConsumption
), LAG_KAM_LAM AS (
  SELECT
    (
      (
        SELECT
          Consumption
        FROM SegmentValues
        WHERE
          Segment = 'KAM'
      ) - (
        SELECT
          Consumption
        FROM SegmentValues
        WHERE
          Segment = 'LAM'
      )
    ) AS Kam_Lam
), LAG_LAM_SME AS (
  SELECT
    (
      (
        SELECT
          Consumption
        FROM SegmentValues
        WHERE
          Segment = 'LAM'
      ) - (
        SELECT
          Consumption
        FROM SegmentValues
        WHERE
          Segment = 'SME'
      )
    ) AS Lam_Sme
), LAG_SME_KAM AS (
  SELECT
    (
      (
        SELECT
          Consumption
        FROM SegmentValues
        WHERE
          Segment = 'SME'
      ) - (
        SELECT
          Consumption
        FROM SegmentValues
        WHERE
          Segment = 'KAM'
      )
    ) AS Sme_Kam
)
SELECT
  LAG_SME_KAM.Sme_Kam,
  LAG_KAM_LAM.Kam_Lam,
  LAG_LAM_SME.Lam_Sme
FROM LAG_KAM_LAM, LAG_LAM_SME, LAG_SME_KAM;
```
Critic: ```sql
WITH yearly_consumption AS (
  SELECT
    ym.CustomerID,
    SUM(ym.Consumption) AS total_consumption
  FROM yearmonth AS ym
  WHERE
    STRFTIME('%Y', ym.Date) = '2013'
  GROUP BY
    ym.CustomerID
), customer_segment AS (
  SELECT
    c.CustomerID,
    c.Segment,
    c.Currency
  FROM customers AS c
), joined_data AS (
  SELECT
    cs.Segment,
    yc.total_consumption,
    cs.Currency
  FROM customer_segment AS cs
  JOIN yearly_consumption AS yc
    ON cs.CustomerID = yc.CustomerID
  WHERE
    cs.Currency = 'CZK'
), min_consumption_per_segment AS (
  SELECT
    Segment,
    MIN(total_consumption) AS min_consumption
  FROM joined_data
  GROUP BY
    Segment
), sme_consumption AS (
  SELECT
    min_consumption
  FROM min_consumption_per_segment
  WHERE
    Segment = 'SME'
), lam_consumption AS (
  SELECT
    min_consumption
  FROM min_consumption_per_segment
  WHERE
    Segment = 'LAM'
), kam_consumption AS (
  SELECT
    min_consumption
  FROM min_consumption_per_segment
  WHERE
    Segment = 'KAM'
), sme_lam_diff AS (
  SELECT
    (
      SELECT
        min_consumption
      FROM sme_consumption
    ) - (
      SELECT
        min_consumption
      FROM lam_consumption
    ) AS diff
), lam_kam_diff AS (
  SELECT
    (
      SELECT
        min_consumption
      FROM lam_consumption
    ) - (
      SELECT
        min_consumption
      FROM kam_consumption
    ) AS diff
), kam_sme_diff AS (
  SELECT
    (
      SELECT
        min_consumption
      FROM kam_consumption
    ) - (
      SELECT
        min_consumption
      FROM sme_consumption
    ) AS diff
)
SELECT
  (
    SELECT
      diff
    FROM sme_lam_diff
  ) AS SME_LAM_Difference,
  (
    SELECT
      diff
    FROM lam_kam_diff
  ) AS LAM_KAM_Difference,
  (
    SELECT
      diff
    FROM kam_sme_diff
  ) AS KAM_SME_Difference;
```
=====================
Question: Which of the three segments—SME, LAM and KAM—has the biggest and lowest percentage increases in consumption paid in EUR between 2012 and 2013?
 db_id: debit_card_specializing
Planner: Plan:
1.  Join the `yearmonth` table with the `customers` table on `CustomerID` to get the segment and currency information for each consumption record.
2.  Filter the joined table to include only records where the currency is EUR.
3.  Extract the year from the 'Date' column of the `yearmonth` table.
4.  Calculate the total consumption for each segment (SME, LAM, KAM) for the years 2012 and 2013.
5.  Calculate the percentage increase in consumption between 2012 and 2013 for each segment. The formula is `((consumption_2013 - consumption_2012) / consumption_2012) * 100`.
6.  Find the segment with the maximum and minimum percentage increase.
7.  Return the segment names along with their maximum and minimum percentage increases.

NL2SQL: ```sql
WITH ConsumptionBySegment AS (
  SELECT
    c.Segment,
    CAST(SUBSTR(ym.Date, 1, 4) AS INTEGER) AS Year,
    SUM(ym.Consumption) AS TotalConsumption
  FROM yearmonth AS ym
  JOIN customers AS c
    ON ym.CustomerID = c.CustomerID
  WHERE
    c.Currency = 'EUR'
    AND SUBSTR(ym.Date, 1, 4) IN ('2012', '2013')
  GROUP BY
    c.Segment,
    CAST(SUBSTR(ym.Date, 1, 4) AS INTEGER)
), ConsumptionChange AS (
  SELECT
    Segment,
    (
      SUM(CASE WHEN Year = 2013 THEN TotalConsumption ELSE 0 END) - SUM(CASE WHEN Year = 2012 THEN TotalConsumption ELSE 0 END)
    ) * 100.0 / SUM(CASE WHEN Year = 2012 THEN TotalConsumption ELSE 0 END) AS PercentageChange
  FROM ConsumptionBySegment
  GROUP BY
    Segment
)
SELECT
  (
    SELECT
      Segment
    FROM ConsumptionChange
    ORDER BY
      PercentageChange DESC
    LIMIT 1
  ) AS MaxPercentageIncreaseSegment,
  (
    SELECT
      MAX(PercentageChange)
    FROM ConsumptionChange
  ) AS MaxPercentageIncrease,
  (
    SELECT
      Segment
    FROM ConsumptionChange
    ORDER BY
      PercentageChange
    LIMIT 1
  ) AS MinPercentageIncreaseSegment,
  (
    SELECT
      MIN(PercentageChange)
    FROM ConsumptionChange
  ) AS MinPercentageIncrease;
```
Critic: ```sql
WITH ConsumptionBySegment AS (
  SELECT
    c.Segment,
    SUBSTR(ym.Date, 1, 4) AS Year,
    SUM(ym.Consumption) AS TotalConsumption
  FROM yearmonth AS ym
  JOIN customers AS c
    ON ym.CustomerID = c.CustomerID
  WHERE
    c.Currency = 'EUR'
    AND SUBSTR(ym.Date, 1, 4) IN ('2012', '2013')
  GROUP BY
    c.Segment,
    SUBSTR(ym.Date, 1, 4)
), ConsumptionChange AS (
  SELECT
    Segment,
    (
      SUM(CASE WHEN Year = '2013' THEN TotalConsumption ELSE 0 END) - SUM(CASE WHEN Year = '2012' THEN TotalConsumption ELSE 0 END)
    ) * 100.0 / SUM(CASE WHEN Year = '2012' THEN TotalConsumption ELSE 0 END) AS PercentageChange
  FROM ConsumptionBySegment
  GROUP BY
    Segment
)
SELECT
  (
    SELECT
      Segment
    FROM ConsumptionChange
    ORDER BY
      PercentageChange DESC
    LIMIT 1
  ) AS MaxPercentageIncreaseSegment,
  (
    SELECT
      MAX(PercentageChange)
    FROM ConsumptionChange
  ) AS MaxPercentageIncrease,
  (
    SELECT
      Segment
    FROM ConsumptionChange
    ORDER BY
      PercentageChange
    LIMIT 1
  ) AS MinPercentageIncreaseSegment,
  (
    SELECT
      MIN(PercentageChange)
    FROM ConsumptionChange
  ) AS MinPercentageIncrease;
```
=====================
Question: How much did customer 6 consume in total between August and November 2013?
 db_id: debit_card_specializing
Planner: Plan:
1. Filter the `yearmonth` table to include only records where the `CustomerID` is 6.
2. Filter the `yearmonth` table to include only records where the `Date` falls between 201308 and 201311 (inclusive).
3. Calculate the sum of the `Consumption` for the filtered records.
4. Return the calculated sum.

NL2SQL: ```sql
SELECT
  SUM(Consumption)
FROM yearmonth
WHERE
  CustomerID = 6 AND Date BETWEEN 201308 AND 201311;
```
Critic: ```sql
SELECT
  SUM(Consumption)
FROM yearmonth
WHERE
  CustomerID = 6 AND Date BETWEEN 20130801 AND 20131130;
```
=====================
Question: How many more "discount" gas stations does the Czech Republic have compared to Slovakia?
 db_id: debit_card_specializing
Planner: Plan:
1. Filter the `gasstations` table for gas stations in the Czech Republic (CZE) and where the `Segment` is 'discount'. Count these gas stations.
2. Filter the `gasstations` table for gas stations in Slovakia (SVK) and where the `Segment` is 'discount'. Count these gas stations.
3. Subtract the count of discount gas stations in Slovakia from the count of discount gas stations in the Czech Republic.
4. Return the difference.

NL2SQL: ```sql
SELECT
  (
    SELECT
      COUNT(*)
    FROM gasstations
    WHERE
      Country = 'CZE' AND Segment = 'discount'
  ) - (
    SELECT
      COUNT(*)
    FROM gasstations
    WHERE
      Country = 'SVK' AND Segment = 'discount'
  );
```
Critic: ```sql
SELECT
  (
    SELECT
      COUNT(*)
    FROM gasstations
    WHERE
      Country = 'CZE' AND Segment = 'discount'
  ) - (
    SELECT
      COUNT(*)
    FROM gasstations
    WHERE
      Country = 'SVK' AND Segment = 'discount'
  );
```
=====================
Question: Is it true that more SMEs pay in Czech koruna than in euros? If so, how many more?
 db_id: debit_card_specializing
Planner: Plan:
1. Count the number of SMEs (customers) who pay in Czech koruna (CZK). From the table `customers`, count the distinct `CustomerID` where `Currency` is 'CZK'.
2. Count the number of SMEs (customers) who pay in euros (EUR). From the table `customers`, count the distinct `CustomerID` where `Currency` is 'EUR'.
3. Calculate the difference between the two counts (CZK - EUR).
4. Determine if the difference is positive. If so, the statement is true, and the difference represents how many more SMEs pay in CZK.

NL2SQL: ```sql
SELECT
  CASE
    WHEN (
      SELECT
        COUNT(DISTINCT CustomerID)
      FROM customers
      WHERE
        Currency = 'CZK'
    ) > (
      SELECT
        COUNT(DISTINCT CustomerID)
      FROM customers
      WHERE
        Currency = 'EUR'
    )
    THEN (
      SELECT
        COUNT(DISTINCT CustomerID)
      FROM customers
      WHERE
        Currency = 'CZK'
    ) - (
      SELECT
        COUNT(DISTINCT CustomerID)
      FROM customers
      WHERE
        Currency = 'EUR'
    )
    ELSE 0
  END;
```
Critic: ```sql
SELECT
  SUM(CASE WHEN T1.Currency = 'CZK' THEN 1 ELSE 0 END) - SUM(CASE WHEN T1.Currency = 'EUR' THEN 1 ELSE 0 END)
FROM customers AS T1;
```
=====================
Question: How many percent of LAM customer consumed more than 46.73?
 db_id: debit_card_specializing
Planner: Here's a plan to calculate the percentage of LAM customers who consumed more than 46.73:

1.  **Identify LAM customers:** Filter the `customers` table for customers where `Segment` is 'LAM'.
2.  **Find consumption for LAM customers:** Join the filtered customer data with the `yearmonth` table using `CustomerID` to get the consumption for each LAM customer.
3.  **Filter consumption:** Filter the joined data to include only those LAM customers whose `Consumption` is greater than 46.73.
4.  **Calculate the count of LAM customers with consumption > 46.73:** Count the number of LAM customers with `Consumption` > 46.73
5.  **Calculate the total count of LAM customers:** Count the total number of LAM customers
6.  **Calculate the percentage:** Divide the count from step 4 by the count from step 5 and multiply by 100.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T2.Consumption > 46.73 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.CustomerID)
FROM customers AS T1
INNER JOIN yearmonth AS T2
  ON T1.CustomerID = T2.CustomerID
WHERE
  T1.Segment = 'LAM';
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T2.Consumption > 46.73 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.CustomerID)
FROM customers AS T1
INNER JOIN yearmonth AS T2
  ON T1.CustomerID = T2.CustomerID
WHERE
  T1.Segment = 'LAM';
```
=====================
Question: In February 2012, what percentage of customers consumed more than 528.3?
 db_id: debit_card_specializing
Planner: Plan:
1. Filter the `yearmonth` table for records in February 2012 (Date = '201202').
2. Further filter the `yearmonth` table to include only customers who consumed more than 528.3.
3. Count the number of customers who consumed more than 528.3 in February 2012.
4. Count the total number of customers in February 2012.
5. Calculate the percentage of customers who consumed more than 528.3 in February 2012 by dividing the count from step 3 by the count from step 4 and multiplying by 100.
Columns needed: `yearmonth.CustomerID`, `yearmonth.Consumption`, `yearmonth.Date`.
No joins are needed since all required information is in the `yearmonth` table.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN Consumption > 528.3 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(CustomerID)
FROM yearmonth
WHERE
  Date = '201202';
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN Consumption > 528.3 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(CustomerID)
FROM YearMonth
WHERE
  DATE = '201202';
```
=====================
Question: What is the ratio of customers who pay in EUR against customers who pay in CZK?
 db_id: debit_card_specializing
Planner: Plan:
1. Count the number of customers who pay in EUR. This can be done by filtering the `customers` table where `Currency` is 'EUR' and counting the distinct `CustomerID`.
2. Count the number of customers who pay in CZK.  This can be done by filtering the `customers` table where `Currency` is 'CZK' and counting the distinct `CustomerID`.
3. Divide the count of EUR customers by the count of CZK customers to get the ratio.
4. Return the calculated ratio.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN Currency = 'EUR' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN Currency = 'CZK' THEN 1 ELSE 0 END)
FROM customers;
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN Currency = 'EUR' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN Currency = 'CZK' THEN 1 ELSE 0 END)
FROM Customers;
```
=====================
Question: In 2012, who had the least consumption in LAM?
 db_id: debit_card_specializing
Planner: Here's my plan to determine the customer with the least consumption in LAM in 2012:

1.  **Identify relevant tables:** `yearmonth` and `customers`. We need `yearmonth` to filter by year and get consumption, and `customers` to identify customers located in LAM (assuming LAM is a segment in `customers`).

2.  **Filter for the year 2012:** Filter the `yearmonth` table to include only records where the year is 2012 (the first 4 characters of the `Date` column).

3.  **Filter for LAM customers:** Filter the `customers` table to include only customers in the 'LAM' segment.

4.  **Join the tables:** Join the filtered `yearmonth` and `customers` tables on `CustomerID`.

5.  **Aggregate consumption:** Group the joined data by `CustomerID` and sum the `Consumption` for each customer.

6.  **Find the minimum consumption:** Determine the minimum `Consumption` value across all customers.

7.  **Identify the customer:** Select the `CustomerID` associated with the minimum `Consumption`.

NL2SQL: ```sql
SELECT CustomerID FROM yearmonth WHERE Date BETWEEN '201201' AND '201212' ORDER BY Consumption ASC LIMIT 1
```
Critic: ```sql
SELECT CustomerID FROM yearmonth WHERE substr(Date, 1, 4) = '2012' ORDER BY Consumption ASC LIMIT 1
```
=====================
Question: What was the average monthly consumption of customers in SME for the year 2013?
 db_id: debit_card_specializing
Planner: Plan:
1. Filter the `yearmonth` table for the year 2013 using the `Date` column. This can be achieved by filtering records whose `Date` value starts with '2013'.
2. Filter the `customers` table to select SME customers using the `Segment` column.
3. Join the filtered `yearmonth` table and the filtered `customers` table on the `CustomerID` column.
4. Calculate the average monthly consumption by averaging the `Consumption` column from the joined table and dividing by 12.
5. Return the calculated average monthly consumption.

NL2SQL: ```sql
SELECT
  AVG(T1.Consumption) / 12
FROM yearmonth AS T1
INNER JOIN customers AS T2
  ON T1.CustomerID = T2.CustomerID
WHERE
  T2.Segment = 'SME' AND T1.Date BETWEEN '201301' AND '201312';
```
Critic: ```sql
SELECT
  AVG(T1.Consumption)
FROM yearmonth AS T1
INNER JOIN customers AS T2
  ON T1.CustomerID = T2.CustomerID
WHERE
  T2.Segment = 'SME' AND SUBSTR(T1.Date, 1, 4) = '2013';
```
=====================
Question: What was the difference in gas consumption between CZK-paying customers and EUR-paying customers in 2012?
 db_id: debit_card_specializing
Planner: Here's my plan to determine the difference in gas consumption between CZK and EUR-paying customers in 2012:

1.  **Identify relevant tables:** `customers` (for currency information), `yearmonth` (for consumption data and customer ID), and potentially `transactions_1k` and `gasstations` if further filtering on gas station attributes is required (but the query does not ask for this).
2.  **Filter `yearmonth` table:** Filter the `yearmonth` table to include only records from 2012 (values BETWEEN 201201 and 201212).
3.  **Join `yearmonth` and `customers`:** Join the filtered `yearmonth` table with the `customers` table on `CustomerID` to link consumption data with customer currency.
4.  **Group and aggregate:** Group the joined data by `Currency` and calculate the sum of `Consumption` for each currency group.
5.  **Calculate the difference:** Calculate the difference between the total consumption of customers paying in CZK and the total consumption of customers paying in EUR. Return the difference.

NL2SQL: ```sql
SELECT
  SUM(CASE WHEN T1.Currency = 'CZK' THEN T2.Consumption ELSE 0 END) - SUM(CASE WHEN T1.Currency = 'EUR' THEN T2.Consumption ELSE 0 END)
FROM customers AS T1
INNER JOIN yearmonth AS T2
  ON T1.CustomerID = T2.CustomerID
WHERE
  T2.DB_ID BETWEEN 201201 AND 201212;
```
Critic: ```sql
SELECT
  SUM(CASE WHEN T1.Currency = 'CZK' THEN T2.Consumption ELSE 0 END) - SUM(CASE WHEN T1.Currency = 'EUR' THEN T2.Consumption ELSE 0 END)
FROM customers AS T1
INNER JOIN yearmonth AS T2
  ON T1.CustomerID = T2.CustomerID
WHERE
  SUBSTR(CAST(T2.Date AS TEXT), 1, 4) = '2012';
```
=====================
Question: Which year recorded the most consumption of gas paid in CZK?
 db_id: debit_card_specializing
Planner: Plan:
1. Join `transactions_1k` and `gasstations` tables on `GasStationID` to filter transactions related to CZK.
2. Filter `transactions_1k` table to include only transactions paid in CZK (using `Price` since there is no Currency column). Assume CZK transactions have `Price` > 0.
3. Extract the year from the `Date` column in `transactions_1k`.
4. Calculate the total `Amount` (consumption) for each year.
5. Find the year with the maximum total `Amount`.
6. Return the year with the maximum consumption.

Needed Tables: `transactions_1k`, `gasstations`
Needed Columns: `transactions_1k.GasStationID`, `transactions_1k.Price`, `transactions_1k.Amount`, `transactions_1k.Date`, `gasstations.GasStationID`, `gasstations.Country`
Joins: Join `transactions_1k` and `gasstations` on `GasStationID`
Filters: `gasstations.Country = 'CZK'` (not available, therefore transactions_1k.Price > 0)
Aggregate: Sum `transactions_1k.Amount` grouped by year extracted from `transactions_1k.Date`
Order: Order by total consumption in descending order and limit to 1 to find the year with the maximum consumption.

NL2SQL: ```sql
SELECT
  SUBSTR(T1.Date, 1, 4)
FROM transactions_1k AS T1
INNER JOIN gasstations AS T2
  ON T1.GasStationID = T2.GasStationID
WHERE
  T1.Price > 0
GROUP BY
  SUBSTR(T1.Date, 1, 4)
ORDER BY
  SUM(T1.Amount) DESC
LIMIT 1;
```
Critic: ```sql
SELECT
  SUBSTR(Date, 1, 4)
FROM transactions_1k
WHERE
  Price > 0
GROUP BY
  SUBSTR(Date, 1, 4)
ORDER BY
  SUM(Amount * Price) DESC
LIMIT 1;
```
=====================
Question: What was the gas consumption peak month for SME customers in 2013?
 db_id: debit_card_specializing
Planner: Plan:
1. Filter the `yearmonth` table for the year 2013.  We can extract the year from the `Date` column.
2. Filter `customers` for `Segment = 'SME'`.
3. Join `yearmonth` with `customers` table on `CustomerID`.
4. Group the result by month (extracted from `Date`) and calculate the sum of `Consumption` for each month.
5. Order the result by total consumption in descending order and limit to 1 to find the month with the highest consumption.
6. Return the month (extracted from the `Date` column).

NL2SQL: ```sql
SELECT
  SUBSTR(T1.Date, 5, 2)
FROM yearmonth AS T1
INNER JOIN customers AS T2
  ON T1.CustomerID = T2.CustomerID
WHERE
  T2.Segment = 'SME' AND T1.Date BETWEEN '201301' AND '201312'
GROUP BY
  SUBSTR(T1.Date, 5, 2)
ORDER BY
  SUM(T1.Consumption) DESC
LIMIT 1;
```
Critic: ```sql
SELECT
  SUBSTR(Date, 5, 2)
FROM yearmonth
WHERE
  SUBSTR(Date, 1, 4) = '2013'
GROUP BY
  1
ORDER BY
  SUM(Consumption) DESC
LIMIT 1;
```
=====================
Question: What is the difference in the annual average consumption of the customers with the least amount of consumption paid in CZK for 2013 between SME and LAM, LAM and KAM, and KAM and SME?
 db_id: debit_card_specializing
Planner: Plan:
1. Filter the `yearmonth` table for the year 2013.
2. Join the filtered `yearmonth` table with the `customers` table on `CustomerID`.
3. Filter the joined table for records where `Currency` is 'CZK'.
4. Group the resulting table by customer segment (`Segment`) and calculate the total consumption for each segment.
5. Find the minimum consumption for each segment.
6. Calculate the number of customer for each segment with minimum consumption in that segment
7. Divide the total consumption by total customer
8. Compute the absolute differences in average consumption between the different segments (SME, LAM, KAM).

NL2SQL: ```sql
WITH YearlyConsumption AS (
  SELECT
    ym.CustomerID,
    c.Segment,
    SUM(ym.Consumption) AS TotalConsumption
  FROM yearmonth AS ym
  JOIN customers AS c
    ON ym.CustomerID = c.CustomerID
  WHERE
    SUBSTR(ym.Date, 1, 4) = '2013' AND c.Currency = 'CZK'
  GROUP BY
    ym.CustomerID,
    c.Segment
), MinConsumption AS (
  SELECT
    Segment,
    MIN(TotalConsumption) AS MinConsumptionValue
  FROM YearlyConsumption
  GROUP BY
    Segment
), CustomerCounts AS (
  SELECT
    yc.Segment,
    COUNT(DISTINCT yc.CustomerID) AS CustomerCount
  FROM YearlyConsumption AS yc
  JOIN MinConsumption AS mc
    ON yc.Segment = mc.Segment AND yc.TotalConsumption = mc.MinConsumptionValue
  GROUP BY
    yc.Segment
), TotalConsumptionBySegment AS (
  SELECT
    yc.Segment,
    SUM(yc.TotalConsumption) AS SumConsumption
  FROM YearlyConsumption AS yc
  JOIN MinConsumption AS mc
    ON yc.Segment = mc.Segment AND yc.TotalConsumption = mc.MinConsumptionValue
  GROUP BY
    yc.Segment
), AverageConsumption AS (
  SELECT
    t.Segment,
    t.SumConsumption / c.CustomerCount AS AverageConsumption
  FROM TotalConsumptionBySegment AS t
  JOIN CustomerCounts AS c
    ON t.Segment = c.Segment
), SegmentValues AS (
  SELECT
    SUM(CASE WHEN Segment = 'SME' THEN AverageConsumption ELSE 0 END) AS SME,
    SUM(CASE WHEN Segment = 'LAM' THEN AverageConsumption ELSE 0 END) AS LAM,
    SUM(CASE WHEN Segment = 'KAM' THEN AverageConsumption ELSE 0 END) AS KAM
  FROM AverageConsumption
)
SELECT
  ABS(SME - LAM) AS SME_LAM_Difference,
  ABS(LAM - KAM) AS LAM_KAM_Difference,
  ABS(KAM - SME) AS KAM_SME_Difference
FROM SegmentValues;
```
Critic: ```sql
WITH YearlyConsumption AS (
  SELECT
    ym.CustomerID,
    c.Segment,
    SUM(ym.Consumption) AS TotalConsumption
  FROM yearmonth AS ym
  JOIN customers AS c
    ON ym.CustomerID = c.CustomerID
  WHERE
    SUBSTR(ym.Date, 1, 4) = '2013' AND c.Currency = 'CZK'
  GROUP BY
    ym.CustomerID,
    c.Segment
), MinConsumption AS (
  SELECT
    Segment,
    MIN(TotalConsumption) AS MinConsumptionValue
  FROM YearlyConsumption
  GROUP BY
    Segment
), AverageConsumption AS (
  SELECT
    yc.Segment,
    mc.MinConsumptionValue AS AverageConsumption
  FROM YearlyConsumption AS yc
  JOIN MinConsumption AS mc
    ON yc.Segment = mc.Segment AND yc.TotalConsumption = mc.MinConsumptionValue
  GROUP BY
    yc.Segment,
    mc.MinConsumptionValue
), SegmentValues AS (
  SELECT
    SUM(CASE WHEN Segment = 'SME' THEN AverageConsumption ELSE 0 END) AS SME,
    SUM(CASE WHEN Segment = 'LAM' THEN AverageConsumption ELSE 0 END) AS LAM,
    SUM(CASE WHEN Segment = 'KAM' THEN AverageConsumption ELSE 0 END) AS KAM
  FROM AverageConsumption
)
SELECT
  ABS(SME - LAM) AS SME_LAM_Difference,
  ABS(LAM - KAM) AS LAM_KAM_Difference,
  ABS(KAM - SME) AS KAM_SME_Difference
FROM SegmentValues;
```
=====================
Question: Which of the three segments—SME, LAM and KAM—has the biggest and lowest percentage increases in consumption paid in EUR between 2012 and 2013?
 db_id: debit_card_specializing
Planner: Plan:

1.  **Calculate 2012 and 2013 EUR consumption per segment:**
    *   Join `yearmonth` with `customers` on `CustomerID`.
    *   Filter `yearmonth` to get data for 2012 and 2013 using the `Date` column.
    *   Filter `customers` to only include segments: 'SME', 'LAM', and 'KAM'.
    *   Filter `customers` to only include transactions in 'EUR'.
    *   Sum the `Consumption` for each segment in 2012 and 2013.
2.  **Calculate percentage increase:**
    *   For each segment, calculate the percentage increase in consumption from 2012 to 2013:  `(2013 Consumption - 2012 Consumption) / 2012 Consumption * 100`.
3.  **Find the biggest and lowest percentage increases:**
    *   Order the segments by their percentage increase in descending and ascending order respectively to find the largest and smallest.
4.  **Select the Segment and Percentage Increase.**

NL2SQL: ```sql
WITH SegmentConsumption AS (
  SELECT
    c.Segment,
    CAST(SUBSTR(ym.Date, 1, 4) AS INTEGER) AS Year,
    SUM(ym.Consumption) AS TotalConsumption
  FROM yearmonth AS ym
  JOIN customers AS c
    ON ym.CustomerID = c.CustomerID
  WHERE
    CAST(SUBSTR(ym.Date, 1, 4) AS INTEGER) IN (2012, 2013) AND c.Currency = 'EUR' AND c.Segment IN ('SME', 'LAM', 'KAM')
  GROUP BY
    c.Segment,
    CAST(SUBSTR(ym.Date, 1, 4) AS INTEGER)
), SegmentGrowth AS (
  SELECT
    Segment,
    (
      SUM(CASE WHEN Year = 2013 THEN TotalConsumption ELSE 0 END) - SUM(CASE WHEN Year = 2012 THEN TotalConsumption ELSE 0 END)
    ) * 100.0 / SUM(CASE WHEN Year = 2012 THEN TotalConsumption ELSE 0 END) AS PercentageIncrease
  FROM SegmentConsumption
  GROUP BY
    Segment
)
SELECT
  Segment,
  PercentageIncrease
FROM SegmentGrowth
ORDER BY
  PercentageIncrease DESC
LIMIT 1;
```
Critic: ```sql
WITH SegmentConsumption AS (
  SELECT
    c.Segment,
    SUBSTR(ym.Date, 1, 4) AS Year,
    SUM(ym.Consumption) AS TotalConsumption
  FROM yearmonth AS ym
  JOIN customers AS c
    ON ym.CustomerID = c.CustomerID
  WHERE
    SUBSTR(ym.Date, 1, 4) IN ('2012', '2013') AND c.Currency = 'EUR' AND c.Segment IN ('SME', 'LAM', 'KAM')
  GROUP BY
    c.Segment,
    SUBSTR(ym.Date, 1, 4)
), SegmentGrowth AS (
  SELECT
    Segment,
    (
      SUM(CASE WHEN Year = '2013' THEN TotalConsumption ELSE 0 END) - SUM(CASE WHEN Year = '2012' THEN TotalConsumption ELSE 0 END)
    ) * 100.0 / SUM(CASE WHEN Year = '2012' THEN TotalConsumption ELSE 0 END) AS PercentageIncrease
  FROM SegmentConsumption
  GROUP BY
    Segment
)
SELECT
  Segment,
  PercentageIncrease
FROM SegmentGrowth
ORDER BY
  PercentageIncrease DESC
LIMIT 1;
```
=====================
Question: How much did customer 6 consume in total between August and November 2013?
 db_id: debit_card_specializing
Planner: Plan:
1. Filter the `yearmonth` table to include records where CustomerID is 6 and the Date falls between 201308 and 201311.
2. Sum the `Consumption` from the filtered table.
3. Return the total consumption.

NL2SQL: ```sql
SELECT
  SUM(Consumption)
FROM yearmonth
WHERE
  CustomerID = 6 AND Date BETWEEN 201308 AND 201311;
```
Critic: ```sql
SELECT
  SUM(Consumption)
FROM yearmonth
WHERE
  CustomerID = 6 AND Date BETWEEN 20130801 AND 20131130;
```
=====================
Question: How many more "discount" gas stations does the Czech Republic have compared to Slovakia?
 db_id: debit_card_specializing
Planner: Plan:
1. Filter the `gasstations` table for gas stations in the Czech Republic (Country = 'CZE') and where the segment is "discount". Count the number of such gas stations.
2. Filter the `gasstations` table for gas stations in Slovakia (Country = 'SVK') and where the segment is "discount". Count the number of such gas stations.
3. Subtract the count obtained in step 2 from the count obtained in step 1. This will give the difference in the number of "discount" gas stations between the Czech Republic and Slovakia.
4. Return the calculated difference.

NL2SQL: ```sql
SELECT
  (
    SELECT
      COUNT(*)
    FROM gasstations
    WHERE
      Country = 'CZE' AND Segment = 'discount'
  ) - (
    SELECT
      COUNT(*)
    FROM gasstations
    WHERE
      Country = 'SVK' AND Segment = 'discount'
  );
```
Critic: ```sql
SELECT
  (
    SELECT
      COUNT(*)
    FROM gasstations
    WHERE
      Country = 'CZE' AND Segment = 'Discount'
  ) - (
    SELECT
      COUNT(*)
    FROM gasstations
    WHERE
      Country = 'SVK' AND Segment = 'Discount'
  );
```
=====================
Question: Is it true that more SMEs pay in Czech koruna than in euros? If so, how many more?
 db_id: debit_card_specializing
Planner: Plan:

1.  **Count SMEs paying in Czech koruna (CZK):**
    *   From the `customers` table, count the number of distinct `CustomerID` where `Currency` is 'CZK'.
2.  **Count SMEs paying in euros (EUR):**
    *   From the `customers` table, count the number of distinct `CustomerID` where `Currency` is 'EUR'.
3.  **Calculate the difference:**
    *   Subtract the number of SMEs paying in EUR from the number of SMEs paying in CZK.
4.  **Determine if CZK is more than EUR:**
    *   Check if the calculated difference is greater than zero.
5.  **Return results:**
    *   Return a boolean indicating whether more SMEs pay in CZK than EUR.
    *   Return the difference in the number of SMEs paying in each currency.

NL2SQL: ```sql
SELECT
  CASE
    WHEN (
      SELECT
        COUNT(DISTINCT CustomerID)
      FROM customers
      WHERE
        Currency = 'CZK'
    ) > (
      SELECT
        COUNT(DISTINCT CustomerID)
      FROM customers
      WHERE
        Currency = 'EUR'
    )
    THEN 'True'
    ELSE 'False'
  END,
  (
    SELECT
      COUNT(DISTINCT CustomerID)
    FROM customers
    WHERE
      Currency = 'CZK'
  ) - (
    SELECT
      COUNT(DISTINCT CustomerID)
    FROM customers
    WHERE
      Currency = 'EUR'
  );
```
Critic: ```sql
SELECT
  CASE
    WHEN SUM(CASE WHEN T1.Currency = 'CZK' THEN 1 ELSE 0 END) > SUM(CASE WHEN T1.Currency = 'EUR' THEN 1 ELSE 0 END)
    THEN 'True'
    ELSE 'False'
  END,
  ABS(SUM(CASE WHEN T1.Currency = 'CZK' THEN 1 ELSE 0 END) - SUM(CASE WHEN T1.Currency = 'EUR' THEN 1 ELSE 0 END))
FROM Customers AS T1;
```
=====================
Question: How many percent of LAM customer consumed more than 46.73?
 db_id: debit_card_specializing
Planner: Here's my plan to calculate the percentage of LAM customers who consumed more than 46.73:

1.  **Identify LAM customers:** Filter the `customers` table for customers where the `Segment` is 'LAM'.
2.  **Get consumption for LAM customers:** Join the filtered `customers` table with the `yearmonth` table using `CustomerID` to get the consumption for each LAM customer.
3.  **Filter for consumption > 46.73:** Filter the joined table to include only those LAM customers whose `Consumption` is greater than 46.73.
4.  **Calculate the number of LAM customers with consumption > 46.73:** Count the number of distinct `CustomerID` in the filtered table (step 3).
5.  **Calculate the total number of LAM customers:** Count the number of distinct `CustomerID` in the filtered `customers` table (step 1).
6.  **Calculate the percentage:** Divide the count from step 4 by the count from step 5, and multiply by 100.

I need to retrieve `CustomerID` and `Segment` from `customers` and `Consumption` and `CustomerID` from `yearmonth`.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T2.Consumption > 46.73 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.CustomerID)
FROM customers AS T1
INNER JOIN yearmonth AS T2
  ON T1.CustomerID = T2.CustomerID
WHERE
  T1.Segment = 'LAM'
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T2.Consumption > 46.73 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.CustomerID)
FROM customers AS T1
INNER JOIN yearmonth AS T2
  ON T1.CustomerID = T2.CustomerID
WHERE
  T1.Segment = 'LAM';
```
=====================
Question: In February 2012, what percentage of customers consumed more than 528.3?
 db_id: debit_card_specializing
Planner: Plan:
1. Filter the `yearmonth` table to include only records from February 2012 ('201202').
2. Filter the `yearmonth` table to include only customers who consumed more than 528.3.
3. Count the total number of customers in February 2012.
4. Calculate the percentage of customers who consumed more than 528.3 out of the total number of customers in February 2012.
Tables: `yearmonth`
Columns: `CustomerID`, `Consumption`, `Date`
Filters: `Date` = '201202', `Consumption` > 528.3
Aggregations: COUNT(DISTINCT `CustomerID`)
Calculations: (Number of customers with Consumption > 528.3 / Total number of customers) * 100

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.Consumption > 528.3 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.CustomerID)
FROM yearmonth AS T1
WHERE
  T1.Date = '201202';
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN Consumption > 528.3 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(CustomerID)
FROM yearmonth
WHERE
  DATE = '201202';
```
=====================
Question: What is the highest monthly consumption in the year 2012?
 db_id: debit_card_specializing
Planner: Plan:
1. Filter the `yearmonth` table to include only records from the year 2012.  We can extract the year from the `Date` column.
2. Group the filtered data by month (extract month from Date column) and calculate the sum of `Consumption` for each month.
3. Find the maximum `Consumption` among all the months.
4. Return the maximum `Consumption`.

NL2SQL: ```sql
SELECT MAX(monthly_consumption)
FROM (
    SELECT SUM(Consumption) AS monthly_consumption
    FROM yearmonth
    WHERE SUBSTR(Date, 1, 4) = '2012'
    GROUP BY SUBSTR(Date, 5, 2)
) AS monthly_consumptions;
```
Critic: ```sql
SELECT MAX(Consumption) FROM yearmonth WHERE substr(Date,1,4)='2012'
```
=====================
Question: What is the ratio of customers who pay in EUR against customers who pay in CZK?
 db_id: debit_card_specializing
Planner: Plan:
1. Count the number of customers who pay in EUR. This can be achieved by filtering the `customers` table where `Currency` is 'EUR' and counting the distinct `CustomerID`.
2. Count the number of customers who pay in CZK. This can be achieved by filtering the `customers` table where `Currency` is 'CZK' and counting the distinct `CustomerID`.
3. Calculate the ratio by dividing the count of EUR customers by the count of CZK customers.
Final Answer: The final answer is $\frac{count(EUR)}{count(CZK)}$

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN Currency = 'EUR' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN Currency = 'CZK' THEN 1 ELSE 0 END)
FROM customers;
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN Currency = 'EUR' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN Currency = 'CZK' THEN 1 ELSE 0 END)
FROM customers
WHERE
  Currency IN ('EUR', 'CZK');
```
=====================
Question: In 2012, who had the least consumption in LAM?
 db_id: debit_card_specializing
Planner: Plan:

1.  Filter the `yearmonth` table for records in 2012 (Date LIKE '2012%') and region LAM (need `gasstations` table joined).
2.  Join `yearmonth` table with the `customers` table on `CustomerID`.
3.  Join with `gasstations` to filter countries in LAM region.
4.  Group the results by customer and sum the consumption.
5.  Find the customer with the minimum consumption.
6.  Output the customer ID.

SQL:
```sql
SELECT T1.CustomerID FROM customers AS T1 JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID JOIN gasstations AS T3 ON T1.Country = T3.Country WHERE T3.Country = "LAM" AND T2.Date LIKE "2012%" GROUP BY T1.CustomerID ORDER BY sum(T2.Consumption) ASC LIMIT 1
```
NL2SQL: ```sql
SELECT T1.CustomerID FROM Customers AS T1 INNER JOIN YearMonth AS T2 ON T1.CustomerID = T2.CustomerID INNER JOIN GasStations AS T3 ON T1.Currency = T3.Country WHERE T3.Country = 'LAM' AND T2.Date LIKE '2012%' GROUP BY T1.CustomerID ORDER BY SUM(T2.Consumption) ASC LIMIT 1
```
Critic: ```sql
SELECT CustomerID FROM YearMonth WHERE substr(Date, 1, 4) = '2012' AND CustomerID IN (SELECT CustomerID FROM Customers WHERE Segment = 'LAM') ORDER BY Consumption ASC LIMIT 1
```
=====================
Question: What was the average monthly consumption of customers in SME for the year 2013?
 db_id: debit_card_specializing
Planner: Plan:
1. Filter the `yearmonth` table for the year 2013 using the `Date` column. Extract year from the date value.
2. Filter the `customers` table for customers in the 'SME' segment.
3. Join the filtered `yearmonth` table and the filtered `customers` table using the `CustomerID` column.
4. Calculate the average consumption for each month by grouping by month.
5. Calculate the average monthly consumption for the year by averaging the monthly averages.
6. Return the overall average.

Tables: `yearmonth`, `customers`
Columns: `yearmonth.Consumption`, `yearmonth.CustomerID`, `yearmonth.Date`, `customers.Segment`, `customers.CustomerID`
Filters: `yearmonth.Date` for year 2013, `customers.Segment` for 'SME'
Joins: `yearmonth.CustomerID` = `customers.CustomerID`
Aggregations: AVG(Consumption)
Group By: month extracted from `yearmonth.Date`
Final Aggregation: AVG(monthly average Consumption)

NL2SQL: ```sql
SELECT avg(monthly_avg)
FROM (
    SELECT avg(t1.Consumption) AS monthly_avg
    FROM yearmonth AS t1
    INNER JOIN customers AS t2 ON t1.CustomerID = t2.CustomerID
    WHERE t2.Segment = 'SME' AND SUBSTR(t1.Date, 1, 4) = '2013'
    GROUP BY SUBSTR(t1.Date, 1, 6)
) AS monthly_averages;
```
Critic: ```sql
SELECT AVG(Consumption) FROM yearmonth AS T1 JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.Segment = 'SME' AND T1.Date LIKE '2013%'
```
=====================
Question: What was the difference in gas consumption between CZK-paying customers and EUR-paying customers in 2012?
 db_id: debit_card_specializing
Planner: Here's my plan to determine the difference in gas consumption between CZK and EUR paying customers in 2012:

1.  **Identify CZK and EUR customers:** Use the `customers` table to identify the `CustomerID`s who paid in CZK and EUR.
2.  **Filter transactions for 2012:** In the `yearmonth` table, filter records to include only transactions from the year 2012. We will filter yearmonth table to the range 201201 to 201212.
3.  **Join `yearmonth` and `customers`:** Join `yearmonth` and `customers` tables on the `CustomerID` column. This will link each transaction in 2012 to the customer's currency.
4.  **Calculate total consumption for each currency:**  Sum the `Consumption` for CZK customers and EUR customers separately.
5.  **Calculate the difference:** Subtract the total consumption of EUR customers from the total consumption of CZK customers to find the difference.

I will use the following tables and columns:

*   `customers`: `CustomerID`, `Currency`
*   `yearmonth`: `CustomerID`, `Consumption`

NL2SQL time!

NL2SQL: ```sql
SELECT
  SUM(CASE WHEN T1.Currency = 'CZK' THEN T2.Consumption ELSE 0 END) - SUM(CASE WHEN T1.Currency = 'EUR' THEN T2.Consumption ELSE 0 END)
FROM customers AS T1
INNER JOIN yearmonth AS T2
  ON T1.CustomerID = T2.CustomerID
WHERE
  T2.DB_ID BETWEEN 201201 AND 201212;
```
Critic: ```sql
SELECT
  SUM(CASE WHEN T1.Currency = 'CZK' THEN T2.Consumption ELSE 0 END) - SUM(CASE WHEN T1.Currency = 'EUR' THEN T2.Consumption ELSE 0 END)
FROM Customers AS T1
INNER JOIN YearMonth AS T2
  ON T1.CustomerID = T2.CustomerID
WHERE
  SUBSTR(CAST(T2.YearMonth AS TEXT), 1, 4) = '2012';
```
=====================
Question: Which year recorded the most consumption of gas paid in CZK?
 db_id: debit_card_specializing
Planner: Plan:
1. Filter `transactions_1k` to find transactions where the product was paid in CZK. I assume we do not have this information and will not be able to answer this question.
2. Extract the year from the `Date` column in `transactions_1k`.
3. Calculate the total gas consumption (Amount) for each year.
4. Find the year with the maximum total consumption.
5. Return the year with the highest consumption.

Tables:
- transactions_1k
Columns:
- Date
- Amount

Output:
- year (the year with most consumption)

NL2SQL: ```sql
SELECT strftime('%Y', Date) AS Year
FROM transactions_1k
GROUP BY Year
ORDER BY sum(Amount) DESC
LIMIT 1;
```
Critic: ```sql
SELECT SUBSTR(Date, 1, 4) AS SaleYear
FROM transactions_1k
WHERE PriceUnit = 'CZK'
GROUP BY SaleYear
ORDER BY SUM(Amount * Price) DESC
LIMIT 1;
```
=====================
Question: What was the gas consumption peak month for SME customers in 2013?
 db_id: debit_card_specializing
Planner: Plan:
1. Filter the `yearmonth` table to include only records where the year is 2013.
2. Join `yearmonth` and `customers` table on the `CustomerID` column.
3. Filter the joined table to include only records where the client segment in the `customers` table is 'SME'.
4. Group the result by month (extracted from the 'Date' column) and calculate the sum of 'Consumption' for each month.
5. Order the results in descending order of total consumption.
6. Limit the result to the top 1 month.
7. Select the month.
Tables: yearmonth, customers
Columns: yearmonth.Date, yearmonth.Consumption, customers.Segment, customers.CustomerID
Joins: yearmonth JOIN customers ON yearmonth.CustomerID = customers.CustomerID
Filters: yearmonth.Date BETWEEN '201301' AND '201312', customers.Segment = 'SME'
Aggregations: SUM(yearmonth.Consumption) GROUP BY SUBSTR(yearmonth.Date, 5, 2)
Ordering: SUM(yearmonth.Consumption) DESC
Limiting: 1
Output: month

NL2SQL: ```sql
SELECT SUBSTR(Date, 5, 2) FROM yearmonth JOIN customers ON yearmonth.CustomerID = customers.CustomerID WHERE SUBSTR(Date, 1, 4) = '2013' AND customers.Segment = 'SME' GROUP BY SUBSTR(Date, 5, 2) ORDER BY SUM(Consumption) DESC LIMIT 1
```
Critic: ```sql
SELECT SUBSTR(Date, 5, 2) FROM yearmonth JOIN customers ON yearmonth.CustomerID = customers.CustomerID WHERE SUBSTR(Date, 1, 4) = '2013' AND customers.Segment = 'SME' GROUP BY SUBSTR(Date, 5, 2) ORDER BY SUM(Consumption) DESC LIMIT 1
```
=====================
Question: What is the difference in the annual average consumption of the customers with the least amount of consumption paid in CZK for 2013 between SME and LAM, LAM and KAM, and KAM and SME?
 db_id: debit_card_specializing
Planner: Here's a plan to determine the differences in annual average consumption for 2013 between SME, LAM, and KAM customers with the least consumption paid in CZK:

1.  **Filter Customers:** Select customers with currency 'CZK'.
2.  **Filter Yearmonth Table:** Filter `yearmonth` table for the year 2013. Specifically, filter where the `Date` falls between '201301' and '201312'.
3.  **Join Tables:** Join the filtered `customers` table and the filtered `yearmonth` table on `CustomerID`.
4.  **Calculate Total Consumption per Segment:** Group the joined data by `Segment` (SME, LAM, KAM) and calculate the sum of `Consumption` for each segment.
5.  **Find Customer with the Least Amount of Consumption for each Segment:** Divide the total consumption of each segment from Step 4 by the number of customers in each segment from Step 4.
6.  **Calculate the Differences:**
    *   Calculate the difference between SME and LAM annual average consumption.
    *   Calculate the difference between LAM and KAM annual average consumption.
    *   Calculate the difference between KAM and SME annual average consumption.
7.  **Present the Results:** Display the calculated differences.

NL2SQL: ```sql
WITH CZKCustomers AS (
  SELECT
    CustomerID
  FROM Customers
  WHERE
    Currency = 'CZK'
), Consumption2013 AS (
  SELECT
    CustomerID,
    Consumption
  FROM YearMonth
  WHERE
    Date BETWEEN '201301' AND '201312'
), CustomerSegmentConsumption AS (
  SELECT
    c.Segment,
    SUM(y.Consumption) AS TotalConsumption,
    COUNT(DISTINCT y.CustomerID) AS NumberOfCustomers
  FROM CZKCustomers AS czk
  JOIN Consumption2013 AS y
    ON czk.CustomerID = y.CustomerID
  JOIN Customers AS c
    ON czk.CustomerID = c.CustomerID
  GROUP BY
    c.Segment
), SegmentAverages AS (
  SELECT
    Segment,
    TotalConsumption / NumberOfCustomers AS AverageConsumption
  FROM CustomerSegmentConsumption
)
SELECT
  (
    SELECT
      AverageConsumption
    FROM SegmentAverages
    WHERE
      Segment = 'SME'
  ) - (
    SELECT
      AverageConsumption
    FROM SegmentAverages
    WHERE
      Segment = 'LAM'
  ) AS SME_minus_LAM,
  (
    SELECT
      AverageConsumption
    FROM SegmentAverages
    WHERE
      Segment = 'LAM'
  ) - (
    SELECT
      AverageConsumption
    FROM SegmentAverages
    WHERE
      Segment = 'KAM'
  ) AS LAM_minus_KAM,
  (
    SELECT
      AverageConsumption
    FROM SegmentAverages
    WHERE
      Segment = 'KAM'
  ) - (
    SELECT
      AverageConsumption
    FROM SegmentAverages
    WHERE
      Segment = 'SME'
  ) AS KAM_minus_SME;
```
Critic: ```sql
WITH YearlyConsumptions AS (
  SELECT
    ym.CustomerID,
    SUM(ym.Consumption) AS TotalConsumption
  FROM YearMonth AS ym
  WHERE
    SUBSTR(ym.Date, 1, 4) = '2013'
  GROUP BY
    ym.CustomerID
), SegmentConsumptions AS (
  SELECT
    c.Segment,
    yc.TotalConsumption
  FROM YearlyConsumptions AS yc
  JOIN Customers AS c
    ON yc.CustomerID = c.CustomerID
  WHERE
    c.Currency = 'CZK'
), MinSegmentConsumptions AS (
  SELECT
    Segment,
    MIN(TotalConsumption) AS MinConsumption
  FROM SegmentConsumptions
  GROUP BY
    Segment
), SegmentCustomers AS (
  SELECT
    sc.Segment,
    sc.TotalConsumption
  FROM SegmentConsumptions AS sc
  INNER JOIN MinSegmentConsumptions AS msc
    ON sc.Segment = msc.Segment AND sc.TotalConsumption = msc.MinConsumption
), SegmentAverages AS (
  SELECT
    Segment,
    AVG(TotalConsumption) AS AverageConsumption
  FROM SegmentCustomers
  GROUP BY
    Segment
)
SELECT
  (
    SELECT
      AverageConsumption
    FROM SegmentAverages
    WHERE
      Segment = 'SME'
  ) - (
    SELECT
      AverageConsumption
    FROM SegmentAverages
    WHERE
      Segment = 'LAM'
  ) AS SME_minus_LAM,
  (
    SELECT
      AverageConsumption
    FROM SegmentAverages
    WHERE
      Segment = 'LAM'
  ) - (
    SELECT
      AverageConsumption
    FROM SegmentAverages
    WHERE
      Segment = 'KAM'
  ) AS LAM_minus_KAM,
  (
    SELECT
      AverageConsumption
    FROM SegmentAverages
    WHERE
      Segment = 'KAM'
  ) - (
    SELECT
      AverageConsumption
    FROM SegmentAverages
    WHERE
      Segment = 'SME'
  ) AS KAM_minus_SME;
```
=====================
Question: Which of the three segments—SME, LAM and KAM—has the biggest and lowest percentage increases in consumption paid in EUR between 2012 and 2013?
 db_id: debit_card_specializing
Planner: Plan:

1.  **Calculate consumption for each segment in 2012 and 2013.**
    *   Join `yearmonth` and `customers` tables on `CustomerID` to link consumption data with customer segments and currency.
    *   Filter data for the years 2012 and 2013 using the `Date` column from the `yearmonth` table.
    *   Filter data for the EUR currency using the `Currency` column from the `customers` table.
    *   Group the results by `Segment` and year to calculate the total consumption for each segment in each year.
2.  **Calculate the percentage increase in consumption between 2012 and 2013 for each segment.**
    *   Use the results from the previous step to calculate the percentage increase for each segment using the formula: `((Consumption2013 - Consumption2012) / Consumption2012) * 100`.
3.  **Determine the segment with the biggest and lowest percentage increases.**
    *   Order the results by the percentage increase in descending and ascending order to identify the segments with the highest and lowest increases.
    *   Return the segment names and their corresponding percentage increases.

Required Tables: `yearmonth`, `customers`

Required Columns:

*   `yearmonth`: `CustomerID`, `Consumption`, `Date`
*   `customers`: `CustomerID`, `Segment`, `Currency`

Joins:

*   `yearmonth` JOIN `customers` ON `yearmonth.CustomerID` = `customers.CustomerID`

Filters:

*   `yearmonth.Date` LIKE '2012%' OR `yearmonth.Date` LIKE '2013%'
*   `customers.Currency` = 'EUR'

Group By:

*   `customers.Segment`, year extracted from `yearmonth.Date`

NL2SQL: ```sql
WITH ConsumptionBySegment AS (
  SELECT
    c.Segment,
    SUM(CASE WHEN SUBSTR(ym.Date, 1, 4) = '2012' THEN ym.Consumption ELSE 0 END) AS Consumption2012,
    SUM(CASE WHEN SUBSTR(ym.Date, 1, 4) = '2013' THEN ym.Consumption ELSE 0 END) AS Consumption2013
  FROM yearmonth AS ym
  JOIN customers AS c
    ON ym.CustomerID = c.CustomerID
  WHERE
    SUBSTR(ym.Date, 1, 4) IN ('2012', '2013') AND c.Currency = 'EUR'
  GROUP BY
    c.Segment
)
SELECT
  Segment,
  (
    (Consumption2013 - Consumption2012) * 100.0 / Consumption2012
  ) AS PercentageIncrease
FROM ConsumptionBySegment
ORDER BY
  PercentageIncrease DESC
LIMIT 1;
SELECT
  Segment,
  (
    (Consumption2013 - Consumption2012) * 100.0 / Consumption2012
  ) AS PercentageIncrease
FROM ConsumptionBySegment
ORDER BY
  PercentageIncrease
LIMIT 1;
```
Critic: ```sql
WITH SegmentConsumption AS (
  SELECT
    c.Segment,
    SUM(CASE WHEN STRFTIME('%Y', ym.Date) = '2012' THEN ym.Consumption ELSE 0 END) AS Consumption2012,
    SUM(CASE WHEN STRFTIME('%Y', ym.Date) = '2013' THEN ym.Consumption ELSE 0 END) AS Consumption2013
  FROM yearmonth AS ym
  JOIN customers AS c
    ON ym.CustomerID = c.CustomerID
  WHERE
    STRFTIME('%Y', ym.Date) IN ('2012', '2013') AND c.Currency = 'EUR'
  GROUP BY
    c.Segment
)
SELECT
  'Highest Increase' AS Category,
  Segment
FROM SegmentConsumption
ORDER BY
  (Consumption2013 - Consumption2012) * 100.0 / Consumption2012 DESC
LIMIT 1
UNION ALL
SELECT
  'Lowest Increase' AS Category,
  Segment
FROM SegmentConsumption
ORDER BY
  (Consumption2013 - Consumption2012) * 100.0 / Consumption2012
LIMIT 1;
```
=====================
Question: How much did customer 6 consume in total between August and November 2013?
 db_id: debit_card_specializing
Planner: Plan:
1. Filter the `yearmonth` table to include records where `CustomerID` is 6 and the `Date` falls between 201308 and 201311.
2. Sum the `Consumption` for the filtered records.
3. Return the total consumption.

NL2SQL: ```sql
SELECT
  SUM(Consumption)
FROM yearmonth
WHERE
  CustomerID = 6 AND Date BETWEEN 201308 AND 201311;
```
Critic: ```sql
SELECT
  SUM(Consumption)
FROM yearmonth
WHERE
  CustomerID = 6 AND Date BETWEEN 20130801 AND 20131130;
```
=====================
Question: How many more "discount" gas stations does the Czech Republic have compared to Slovakia?
 db_id: debit_card_specializing
Planner: Plan:
1. Filter the `gasstations` table to find gas stations in the Czech Republic (CZE) and count the number of "discount" gas stations.
2. Filter the `gasstations` table to find gas stations in Slovakia (SVK) and count the number of "discount" gas stations.
3. Subtract the number of "discount" gas stations in Slovakia from the number of "discount" gas stations in the Czech Republic.
4. Return the resulting difference.
Tables: `gasstations`
Columns: `Country`, `Segment`
Filters: `Country` = 'CZE', `Country` = 'SVK', `Segment` = 'Discount'
Aggregation: `COUNT(*)`
Operation: Subtraction

NL2SQL: ```sql
SELECT
  (
    SELECT
      COUNT(*)
    FROM gasstations
    WHERE
      Country = 'CZE' AND Segment = 'Discount'
  ) - (
    SELECT
      COUNT(*)
    FROM gasstations
    WHERE
      Country = 'SVK' AND Segment = 'Discount'
  );
```
Critic: ```sql
SELECT
  (
    SELECT
      COUNT(*)
    FROM gasstations
    WHERE
      Country = 'CZE' AND Segment = 'Discount'
  ) - (
    SELECT
      COUNT(*)
    FROM gasstations
    WHERE
      Country = 'SVK' AND Segment = 'Discount'
  );
```
=====================
Question: Is it true that more SMEs pay in Czech koruna than in euros? If so, how many more?
 db_id: debit_card_specializing
Planner: Plan:
1. Count the number of SMEs paying in Czech koruna (CZK) using the `customers` table and filter by `Currency = 'CZK'`.
2. Count the number of SMEs paying in euros (EUR) using the `customers` table and filter by `Currency = 'EUR'`.
3. Calculate the difference between the two counts.
4. Determine if the difference is positive (i.e., more SMEs pay in CZK).
5. Return whether it is true that more SMEs pay in CZK and the difference in counts.
NL2SQL:
```sql
SELECT
  CASE
    WHEN (
      SELECT
        COUNT(*)
      FROM customers
      WHERE
        Currency = 'CZK'
    ) > (
      SELECT
        COUNT(*)
      FROM customers
      WHERE
        Currency = 'EUR'
    )
    THEN 'Yes'
    ELSE 'No'
  END,
  ABS(
    (
      SELECT
        COUNT(*)
      FROM customers
      WHERE
        Currency = 'CZK'
    ) - (
      SELECT
        COUNT(*)
      FROM customers
      WHERE
        Currency = 'EUR'
    )
  );
```
NL2SQL: ```sql
SELECT CASE WHEN (SELECT count(*) FROM customers WHERE Currency = 'CZK') > (SELECT count(*) FROM customers WHERE Currency = 'EUR') THEN 'Yes' ELSE 'No' END, ABS((SELECT count(*) FROM customers WHERE Currency = 'CZK') - (SELECT count(*) FROM customers WHERE Currency = 'EUR'))
```
Critic: ```sql
SELECT CASE WHEN SUM(CASE WHEN T1.Currency = 'CZK' THEN 1 ELSE 0 END) > SUM(CASE WHEN T1.Currency = 'EUR' THEN 1 ELSE 0 END) THEN SUM(CASE WHEN T1.Currency = 'CZK' THEN 1 ELSE 0 END) - SUM(CASE WHEN T1.Currency = 'EUR' THEN 1 ELSE 0 END) ELSE 0 END
```
=====================
Question: How many percent of LAM customer consumed more than 46.73?
 db_id: debit_card_specializing
Planner: Here's my plan to calculate the percentage of LAM customers who consumed more than 46.73:

1.  **Identify LAM customers:** Filter the `customers` table for customers where `Segment` is 'LAM'.

2.  **Find consumption for LAM customers:** Join the filtered `customers` table with the `yearmonth` table using `CustomerID`.

3.  **Filter consumption above 46.73:** Filter the joined table to include only rows where `Consumption` is greater than 46.73.

4.  **Count total LAM customers:** Count the total number of LAM customers.

5.  **Count LAM customers with consumption > 46.73:** Count the number of LAM customers whose consumption is greater than 46.73.

6.  **Calculate the percentage:** Divide the count of LAM customers with consumption > 46.73 by the total count of LAM customers and multiply by 100.

The tables involved are `customers` and `yearmonth`. The relevant columns are `customers.Segment`, `customers.CustomerID`, `yearmonth.CustomerID`, and `yearmonth.Consumption`.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T2.Consumption > 46.73 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.CustomerID)
FROM customers AS T1
INNER JOIN yearmonth AS T2
  ON T1.CustomerID = T2.CustomerID
WHERE
  T1.Segment = 'LAM';
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T2.Consumption > 46.73 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.CustomerID)
FROM customers AS T1
INNER JOIN yearmonth AS T2
  ON T1.CustomerID = T2.CustomerID
WHERE
  T1.Segment = 'LAM';
```
=====================
Question: In February 2012, what percentage of customers consumed more than 528.3?
 db_id: debit_card_specializing
Planner: Plan:
1. Filter the `yearmonth` table to include only records from February 2012 (Date = '201202').
2. Filter the `yearmonth` table to include only records where consumption is greater than 528.3.
3. Count the number of customers who consumed more than 528.3 in February 2012.
4. Count the total number of distinct customers in February 2012.
5. Calculate the percentage of customers who consumed more than 528.3 by dividing the count from step 3 by the count from step 4 and multiplying by 100.
Tables: yearmonth
Columns: Consumption, CustomerID, Date
Filters: Date = '201202', Consumption > 528.3
Aggregations: COUNT(DISTINCT CustomerID)
Calculations: Percentage = (Count of customers with Consumption > 528.3) / (Total count of customers) * 100

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.Consumption > 528.3 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.CustomerID)
FROM yearmonth AS T1
WHERE
  T1.Date = '201202';
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN Consumption > 528.3 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(CustomerID)
FROM yearmonth
WHERE
  DATE = '201202';
```
=====================
Question: What is the highest monthly consumption in the year 2012?
 db_id: debit_card_specializing
Planner: Plan:

1.  From the `yearmonth` table, filter the records where the year is 2012 using a substring operation on the `Date` column.
2.  Aggregate the consumption by month from the filtered records.
3.  Find the maximum monthly consumption from the aggregated results.
4.  Return the maximum consumption.

NL2SQL: ```sql
SELECT
  MAX(Consumption)
FROM yearmonth
WHERE
  SUBSTR(Date, 1, 4) = '2012';
```
Critic: ```sql
SELECT MAX(Consumption) FROM yearmonth WHERE SUBSTR(Date, 1, 4) = '2012';
```
=====================
Question: Please list the product description of the products consumed in September, 2013.
 db_id: debit_card_specializing
Planner: Plan:

1.  Filter the `yearmonth` table to include only records where the date is '201309'.
2.  Join the filtered `yearmonth` table with the `transactions_1k` table on `Date`.
3.  Join the resulting table with the `products` table on `ProductID`.
4.  Select the `Description` column from the `products` table.

NL2SQL: ```sql
SELECT
  T3.Description
FROM yearmonth AS T1
JOIN transactions_1k AS T2
  ON T1.Date = T2.Date
JOIN products AS T3
  ON T2.ProductID = T3.ProductID
WHERE
  T1.Date = '201309';
```
Critic: ```sql
SELECT DISTINCT
  T1.Description
FROM products AS T1
INNER JOIN transactions_1k AS T2
  ON T1.ProductID = T2.ProductID
WHERE
  SUBSTR(T2.Date, 1, 6) = '201309';
```
=====================
Question: Please list the countries of the gas stations with transactions taken place in June, 2013.
 db_id: debit_card_specializing
Planner: Plan:
1.  Join the `gasstations` and `transactions_1k` tables on `GasStationID`.
2.  Filter the joined table to include only transactions that occurred in June 2013 by extracting the year and month from the `Date` column of the `transactions_1k` table and comparing it to '201306'.
3.  Select the `Country` column from the `gasstations` table.
4.  Return distinct country names.

NL2SQL: ```sql
SELECT DISTINCT
  g.Country
FROM gasstations AS g
JOIN transactions_1k AS t
  ON g.GasStationID = t.GasStationID
WHERE
  SUBSTR(t.Date, 1, 4) || SUBSTR(t.Date, 5, 2) = '201306';
```
Critic: ```sql
SELECT DISTINCT
  g.Country
FROM gasstations AS g
JOIN transactions_1k AS t
  ON g.GasStationID = t.GasStationID
WHERE
  SUBSTR(t.Date, 1, 4) = '2013' AND SUBSTR(t.Date, 5, 2) = '06';
```
=====================
Question: Among the customers who paid in euro, how many of them have a monthly consumption of over 1000?
 db_id: debit_card_specializing
Planner: Plan:

1.  Filter the `customers` table to find customers who paid in euro (Currency = 'EUR').
2.  Join the filtered `customers` table with the `yearmonth` table on `CustomerID` to get the monthly consumption for each customer.
3.  Filter the joined table to select customers with a monthly consumption of over 1000 (Consumption > 1000).
4.  Count the number of distinct customers who meet both criteria.

Tables: `customers`, `yearmonth`
Joins: `customers` JOIN `yearmonth` ON `customers`.`CustomerID` = `yearmonth`.`CustomerID`
Filters: `customers`.`Currency` = 'EUR', `yearmonth`.`Consumption` > 1000
Columns: COUNT(DISTINCT `customers`.`CustomerID`)

NL2SQL: ```sql
SELECT COUNT(DISTINCT T1.CustomerID) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Currency = 'EUR' AND T2.Consumption > 1000
```
Critic: ```sql
SELECT COUNT(DISTINCT T1.CustomerID) FROM Customers AS T1 INNER JOIN YearMonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Currency = 'EUR' AND T2.Consumption > 1000
```
=====================
Question: Please list the product descriptions of the transactions taken place in the gas stations in the Czech Republic.
 db_id: debit_card_specializing
Planner: Plan:
1. Filter `gasstations` table for `Country` = 'CZE'.
2. Join `transactions_1k` table with the filtered `gasstations` table on `GasStationID`.
3. Join `products` table with the joined table from step 2 on `ProductID`.
4. Select the `Description` column from the `products` table.

NL2SQL: ```sql
SELECT
  T3.Description
FROM gasstations AS T1
INNER JOIN transactions_1k AS T2
  ON T1.GasStationID = T2.GasStationID
INNER JOIN products AS T3
  ON T2.ProductID = T3.ProductID
WHERE
  T1.Country = 'CZE';
```
Critic: ```sql
SELECT
  T3.Description
FROM gasstations AS T1
INNER JOIN transactions_1k AS T2
  ON T1.GasStationID = T2.GasStationID
INNER JOIN products AS T3
  ON T2.ProductID = T3.ProductID
WHERE
  T1.Country = 'CZE';
```
=====================
Question: Please list the disparate time of the transactions taken place in the gas stations from chain no. 11.
 db_id: debit_card_specializing
Planner: Plan:
1. Filter gasstations table for ChainID = 11.
2. Join the gasstations table with the transactions_1k table on GasStationID.
3. Select the distinct Time from the joined table.

NL2SQL: ```sql
SELECT DISTINCT T1.Time FROM transactions_1k AS T1 JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T2.ChainID = 11
```
Critic: ```sql
SELECT DISTINCT Time FROM transactions_1k AS T1 JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T2.ChainID = 11
```
=====================
Question: Among the transactions made in the gas stations in the Czech Republic, how many of them are taken place after 2012/1/1?
 db_id: debit_card_specializing
Planner: Plan:
1. Filter the `gasstations` table to only include gas stations in the Czech Republic (CZE).
2. Join the filtered `gasstations` table with the `transactions_1k` table using `GasStationID`.
3. Filter the joined table to include transactions after 2012/1/1.
4. Count the number of transactions that satisfy both conditions.
Needed tables: `gasstations`, `transactions_1k`
Needed columns: `gasstations.Country`, `gasstations.GasStationID`, `transactions_1k.GasStationID`, `transactions_1k.Date`
Filters: `gasstations.Country` = 'CZE', `transactions_1k.Date` > '2012-01-01'
Joins: `gasstations.GasStationID` = `transactions_1k.GasStationID`
Aggregation: `COUNT(*)`

NL2SQL: ```sql
SELECT
  COUNT(*)
FROM gasstations AS T1
INNER JOIN transactions_1k AS T2
  ON T1.GasStationID = T2.GasStationID
WHERE
  T1.Country = 'CZE' AND T2.Date > '2012-01-01'
```
Critic: ```sql
SELECT
  count(*)
FROM gasstations AS t1
INNER JOIN transactions_1k AS t2
  ON t1.GasStationID = t2.GasStationID
WHERE
  t1.Country = 'CZE' AND t2.Date > '2012-01-01'
```
=====================
Question: What kind of currency did the customer paid at 16:25:00 in 2012/8/24?
 db_id: debit_card_specializing
Planner: Plan:
1. Filter the `transactions_1k` table by `Date` = '2012-08-24' and `Time` = '16:25:00'.
2. Get the `CustomerID` from the filtered `transactions_1k` table.
3. Join the `customers` table with the `transactions_1k` table on `CustomerID`.
4. Retrieve the `Currency` from the joined table.

NL2SQL: ```sql
SELECT
  T1.Currency
FROM customers AS T1
INNER JOIN transactions_1k AS T2
  ON T1.CustomerID = T2.CustomerID
WHERE
  T2.Date = '2012-08-24' AND T2.Time = '16:25:00';
```
Critic: ```sql
SELECT
  T1.Currency
FROM customers AS T1
INNER JOIN transactions_1k AS T2
  ON T1.CustomerID = T2.CustomerID
WHERE
  T2.Date = '2012-08-24' AND T2.Time = '16:25:00';
```
=====================
Question: What segment did the customer have at 2012/8/23 21:20:00?
 db_id: debit_card_specializing
Planner: Plan:
1. Filter the `transactions_1k` table based on the date and time provided in the question.
2. Retrieve the `CustomerID` from the filtered `transactions_1k` table.
3. Join the `customers` table with the `transactions_1k` table on `CustomerID` to retrieve the `Segment` information.
4. Return the `Segment` value for the customer at the specified date and time.
Columns:
- transactions_1k: Date, Time, CustomerID
- customers: CustomerID, Segment
Tables:
- transactions_1k
- customers
Joins:
- transactions_1k JOIN customers ON transactions_1k.CustomerID = customers.CustomerID
Filters:
- transactions_1k.Date = '2012-08-23' and transactions_1k.Time = '21:20:00'
Final Answer:
Segment

NL2SQL: ```sql
SELECT
  T1.Segment
FROM customers AS T1
INNER JOIN transactions_1k AS T2
  ON T1.CustomerID = T2.CustomerID
WHERE
  T2.Date = '2012-08-23' AND T2.Time = '21:20:00';
```
Critic: ```sql
SELECT
  T1.Segment
FROM customers AS T1
INNER JOIN transactions_1k AS T2
  ON T1.CustomerID = T2.CustomerID
WHERE
  T2.Date = '2012-08-23' AND T2.Time = '21:20:00';
```
=====================
Question: For all the transactions happened during 8:00-9:00 in 2012/8/26, how many happened in CZE?
 db_id: debit_card_specializing
Planner: Here's the plan to solve the question:

1.  **Filter `transactions_1k` table:**
    *   Filter by `Date` equal to '2012-08-26'.
    *   Filter by `Time` between '08:00:00' and '09:00:00'.
2.  **Join with `gasstations` table:**
    *   Join `transactions_1k` and `gasstations` tables on `GasStationID`.
3.  **Filter by Country:**
    *   Filter the joined table where `Country` is 'CZE'.
4.  **Count the transactions:**
    *   Count the number of `TransactionID` in the filtered and joined table.

NL2SQL: ```sql
SELECT
  COUNT(T1.TransactionID)
FROM transactions_1k AS T1
INNER JOIN gasstations AS T2
  ON T1.GasStationID = T2.GasStationID
WHERE
  T1.Date = '2012-08-26'
  AND T1.Time BETWEEN '08:00:00' AND '09:00:00'
  AND T2.DB_ID = 'CZE';
```
Critic: ```sql
SELECT
  COUNT(T1.TransactionID)
FROM transactions_1k AS T1
INNER JOIN gasstations AS T2
  ON T1.GasStationID = T2.GasStationID
WHERE
  T1.Date = '2012-08-26'
  AND T1.Time BETWEEN '08:00:00' AND '09:00:00'
  AND T2.Country = 'CZE';
```
=====================
Question: What's the nationality of the customer who spent 548.4 in 2012/8/24?
 db_id: debit_card_specializing
Planner: Plan:
1.  Filter the `transactions_1k` table to find transactions with a 'Date' equal to '2012-08-24' and 'Price' equal to 548.4.
2.  Retrieve the corresponding 'CustomerID' from the filtered table.
3.  Join the `customers` table with the filtered `transactions_1k` table on 'CustomerID' to retrieve the 'Currency' of the customer.
SQL:
```sql
SELECT DISTINCT
  T1.Currency
FROM customers AS T1
INNER JOIN transactions_1k AS T2
  ON T1.CustomerID = T2.CustomerID
WHERE
  T2.Date = '2012-08-24' AND T2.Price = 548.4;
```
NL2SQL: ```sql
SELECT DISTINCT
  T1.Currency
FROM customers AS T1
INNER JOIN transactions_1k AS T2
  ON T1.CustomerID = T2.CustomerID
WHERE
  T2.Date = '2012-08-24' AND T2.Price = 548.4;
```
Critic: ```sql
SELECT
  T1.Currency
FROM customers AS T1
INNER JOIN transactions_1k AS T2
  ON T1.CustomerID = T2.CustomerID
WHERE
  T2.Date = '2012-08-24' AND T2.Price = 548.4;
```
=====================
Question: What is the percentage of the customers who used EUR in 2012/8/25?
 db_id: debit_card_specializing
Planner: Here's my plan to determine the percentage of customers who used EUR on 2012-08-25:

1.  **Identify relevant tables:** `customers` (to get customer currency information) and `transactions_1k` (to filter transactions by date and CustomerID).
2.  **Filter transactions:** Select transactions from `transactions_1k` where the transaction date is '2012-08-25'.
3.  **Join tables:** Join the filtered transactions with the `customers` table using `CustomerID` to link transactions to customer currency.
4.  **Filter by currency:** Filter the joined data to include only customers who used EUR.
5.  **Calculate EUR customer count:** Count the number of unique customers who used EUR on that date.
6.  **Calculate total customer count:** Count the total number of unique customers in the `transactions_1k` table on that date.
7.  **Calculate percentage:** Divide the EUR customer count by the total customer count and multiply by 100 to get the percentage.
8.  **Handle potential division by zero:**  Consider the case where there are no transactions on the specified date and handle the potential division by zero.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.Currency = 'EUR' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.Currency)
FROM customers AS T1
INNER JOIN transactions_1k AS T2
  ON T1.CustomerID = T2.CustomerID
WHERE
  DATE(T2.Date) = '2012-08-25';
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.Currency = 'EUR' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.CustomerID)
FROM customers AS T1
INNER JOIN yearmonth AS T2
  ON T1.CustomerID = T2.CustomerID
WHERE
  T2.CustomerID IN (
    SELECT
      CustomerID
    FROM transactions_1k
    WHERE
      DATE(Date) = '2012-08-25'
  );
```
=====================
Question: For the customer who paid 634.8 in 2012/8/25, what was the consumption decrease rate from Year 2012 to 2013?
 db_id: debit_card_specializing
Planner: Plan:

1.  Find the `CustomerID` of the customer who paid 634.8 on '2012-08-25' from the `yearmonth` table. Filter by `Date` = '2012-08-25' and `Consumption` = 634.8.
2.  Calculate the total consumption for the customer in the year 2012. Filter the `yearmonth` table by `CustomerID` and year(Date) = 2012. Calculate sum of `Consumption`.
3.  Calculate the total consumption for the customer in the year 2013. Filter the `yearmonth` table by `CustomerID` and year(Date) = 2013. Calculate sum of `Consumption`.
4.  Calculate the consumption decrease rate using the formula: (consumption\_2012 - consumption\_2013) / consumption\_2012.

NL2SQL: ```sql
SELECT
  (
    (
      SUM(CASE WHEN STRFTIME('%Y', Date) = '2012' THEN Consumption ELSE 0 END) - SUM(CASE WHEN STRFTIME('%Y', Date) = '2013' THEN Consumption ELSE 0 END)
    ) * 1.0 / SUM(CASE WHEN STRFTIME('%Y', Date) = '2012' THEN Consumption ELSE 0 END)
  )
FROM yearmonth
WHERE
  "Customer ID" = (
    SELECT
      "Customer ID"
    FROM yearmonth
    WHERE
      Date = '2012-08-25' AND Consumption = 634.8
  );
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN STRFTIME('%Y', Date) = '2012' THEN Consumption ELSE 0 END) - SUM(CASE WHEN STRFTIME('%Y', Date) = '2013' THEN Consumption ELSE 0 END) AS REAL) * 100 / SUM(CASE WHEN STRFTIME('%Y', Date) = '2012' THEN Consumption ELSE 0 END)
FROM yearmonth
WHERE
  "Customer ID" = (
    SELECT
      "Customer ID"
    FROM yearmonth
    WHERE
      Date = '2012-08-25' AND Consumption = 634.8
  );
```
=====================
Question: What is the percentage of "premium" against the overall segment in Country = "SVK"?
 db_id: debit_card_specializing
Planner: Plan:
1. Join `transactions_1k` with `gasstations` on `GasStationID` to filter by `Country`.
2. Join `transactions_1k` with `customers` on `CustomerID` to get the `Segment`.
3. Filter by `Country = "SVK"`.
4. Calculate the total number of customers within the specified country.
5. Calculate the number of "premium" customers within the specified country.
6. Calculate the percentage of "premium" customers relative to the total number of customers.
Needed columns:
*   From `transactions_1k`: `CustomerID`
*   From `gasstations`: `Country`
*   From `customers`: `Segment`
Needed tables:
*   `transactions_1k`
*   `gasstations`
*   `customers`

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T2.Segment = 'premium' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.CustomerID)
FROM transactions_1k AS T1
INNER JOIN customers AS T2
  ON T1.CustomerID = T2.CustomerID
INNER JOIN gasstations AS T3
  ON T1.GasStationID = T3.GasStationID
WHERE
  T3.Country = 'SVK';
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T2.Segment = 'premium' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.CustomerID)
FROM transactions_1k AS T1
INNER JOIN customers AS T2
  ON T1.CustomerID = T2.CustomerID
INNER JOIN gasstations AS T3
  ON T1.GasStationID = T3.GasStationID
WHERE
  T3.Country = 'SVK';
```
=====================
Question: What is the amount spent by customer "38508" at the gas stations? How much had the customer spent in January 2012?
 db_id: debit_card_specializing
Planner: Plan:
1. Find all gas station IDs from the `gasstations` table.
2. Filter transactions in `transactions_1k` table by the gas station IDs retrieved from the previous step.
3. Filter transactions in `yearmonth` table by customer ID = "38508".
4. Join `transactions_1k` table and `yearmonth` table on CustomerID and Date to get the amount spent by customer "38508" at gas stations in each month.
5. Sum the amount spent by customer "38508" at gas stations.
6. Filter the joined table to only include transactions in January 2012 (Date = "201201").
7. Sum the amount spent by customer "38508" at gas stations in January 2012.

NL2SQL: ```sql
SELECT
  SUM(CASE WHEN T2.Consumption = '201201' THEN T1.Amount ELSE 0 END),
  SUM(T1.Amount)
FROM transactions_1k AS T1
INNER JOIN yearmonth AS T2
  ON T1.GasStationID = T2.CustomerID
WHERE
  T2.CustomerID = '38508';
```
Critic: ```sql
SELECT
  SUM(CASE WHEN T2.Date = '201201' THEN T1.Amount ELSE 0 END),
  SUM(T1.Amount)
FROM transactions_1k AS T1
INNER JOIN yearmonth AS T2
  ON T2.CustomerID = '38508'
WHERE
  T1.GasStationID = T2.CustomerID;
```
=====================
Question: Who is the top spending customer and how much is the average price per single item purchased by this customer? What currency was being used?
 db_id: debit_card_specializing
Planner: Here's a plan to determine the top spending customer, their average price per item, and the currency used:

1.  **Find the top spending customer:**
    *   Table: `transactions_1k`
    *   Aggregate: `SUM(Price)` for each `CustomerID`.
    *   Order: Order by total spending in descending order.
    *   Limit: Select the top `CustomerID`.

2.  **Calculate the average price per item for the top customer:**
    *   Table: `transactions_1k`
    *   Filter: `CustomerID` equals the top spending customer found in step 1.
    *   Calculate: `SUM(Price) / SUM(Amount)` for this customer.

3.  **Retrieve the currency used by the top customer:**
    *   Table: `customers`
    *   Filter: `CustomerID` equals the top spending customer found in step 1.
    *   Select: the `Currency` column.

4.  **Combine Results:** present the top customer, the average price per item, and the currency.

NL2SQL: ```sql
SELECT
  c.Currency,
  SUM(t.Price) / SUM(t.Amount) AS avg_price_per_item
FROM customers AS c
JOIN transactions_1k AS t
  ON c.CustomerID = t.CustomerID
WHERE
  c.CustomerID = (
    SELECT
      CustomerID
    FROM transactions_1k
    GROUP BY
      CustomerID
    ORDER BY
      SUM(Price) DESC
    LIMIT 1
  )
GROUP BY
  c.Currency;
```
Critic: ```sql
SELECT
  T1.Currency,
  SUM(T2.Price) / SUM(T2.Amount),
  T3.CustomerID
FROM customers AS T1
INNER JOIN transactions_1k AS T2
  ON T1.CustomerID = T2.CustomerID
INNER JOIN (
  SELECT
    CustomerID
  FROM transactions_1k
  GROUP BY
    CustomerID
  ORDER BY
    SUM(Price) DESC
  LIMIT 1
) AS T3
  ON T1.CustomerID = T3.CustomerID
GROUP BY
  T1.Currency,
  T3.CustomerID;
```
=====================
Question: For all the people who paid more than 29.00 per unit of product id No.5. Give their consumption status in the August of 2012.
 db_id: debit_card_specializing
Planner: Plan:
1. Filter `transactions_1k` table for ProductID = 5.
2. Calculate the price per unit (Price / Amount).
3. Filter the transactions where the price per unit is greater than 29.00.
4. Extract the Date and customer id (if exists) to filter the table yearmonth.
5. From `yearmonth` table, filter data using date '201208'.
6. Get consumption status for the corresponding CustomerID.
7. Return the consumption status
Tables: `transactions_1k`, `yearmonth`
Columns:
*   `transactions_1k`: `ProductID`, `Price`, `Amount`, `Date`
*   `yearmonth`: `CustomerID`, `Consumption`, `Date`
Filters:
*   `transactions_1k`: `ProductID` = 5, `Price` / `Amount` > 29.00
*   `yearmonth`: `Date` = '201208'
Join:
*   Join `transactions_1k` and `yearmonth` on `CustomerID` (assuming `CustomerID` exists in `transactions_1k` or it can be derived).  If `CustomerID` is not directly present in `transactions_1k`, and cannot be derived, then this is an unfulfillable query given the available schema.

Output: `Consumption` from `yearmonth`

NL2SQL: ```sql
SELECT T2.Consumption FROM transactions_1k AS T1 INNER JOIN yearmonth AS T2 ON T1.Date = T2.Date WHERE T1.ProductID = 5 AND T1.Price / T1.Amount > 29.00 AND T2.Date = '201208'
```
Critic: ```sql
SELECT T1.Consumption FROM yearmonth AS T1 INNER JOIN transactions_1k AS T2 ON T1.CustomerID = T2.ProductID WHERE T2.ProductID = 5 AND T2.Price / T2.Amount > 29 AND T1.Date = 201208
```
=====================
Question: What's Angela Sanders's major?
 db_id: student_club
Planner: Plan:
1. Find the member ID for Angela Sanders from the Member table using her email.
2. Use the member ID to find the major ID from the Member table.
3. Use the major ID to find the major name from the Major table.
4. Return the major name.

Tables:
*   Member: To find the member ID and link to major.
*   Major: To find the major name.

Columns:
*   Member: email, link_to_major
*   Major: major_id, major_name

Joins:
*   Join Member and Major on Member.link_to_major = Major.major_id

Filters:
*   Member.email = 'Angela.Sanders@example.com'

NL2SQL: ```sql
SELECT
  T2.major_name
FROM Member AS T1
INNER JOIN Major AS T2
  ON T1.link_to_major = T2.major_id
WHERE
  T1.email = 'Angela.Sanders@example.com';
```
Critic: ```sql
SELECT
  T2.major_name
FROM Member AS T1
INNER JOIN Major AS T2
  ON T1.link_to_major = T2.major_id
WHERE
  T1.email = 'Angela.Sanders@example.com';
```
=====================
Question: Among the students from the Student_Club who attended the event "Women's Soccer", how many of them want a T-shirt that's in medium size?
 db_id: student_club
Planner: Plan:
1. Filter the `Event` table to find the event ID for "Women's Soccer".
2. Join `Attendance` table with the filtered `Event` table on `link_to_event` to find the members who attended the "Women's Soccer" event.
3. Join `Member` table with the result from step 2 on `link_to_member` to find the members who attended the event and their t-shirt sizes.
4. Filter the result from step 3 where `t_shirt_size` is "Medium".
5. Count the number of members that satisfy the above conditions.
Needed tables: Event, Attendance, Member
Needed columns: Event.event_id, Event.name, Attendance.link_to_member, Attendance.link_to_event, Member.link_to_member, Member.t_shirt_size

NL2SQL: ```sql
SELECT
  COUNT(T1.link_to_member)
FROM Member AS T1
INNER JOIN Attendance AS T2
  ON T1.link_to_member = T2.link_to_member
INNER JOIN Event AS T3
  ON T2.link_to_event = T3.event_id
WHERE
  T3.name = 'Women''s Soccer' AND T1.t_shirt_size = 'Medium';
```
Critic: ```sql
SELECT
  COUNT(T1.link_to_member)
FROM Member AS T1
INNER JOIN Attendance AS T2
  ON T1.link_to_member = T2.link_to_member
INNER JOIN Event AS T3
  ON T2.link_to_event = T3.event_id
WHERE
  T3.name = 'Women''s Soccer' AND T1.t_shirt_size = 'M';
```
=====================
Question: Among the events attended by more than 10 members of the Student_Club, how many of them are meetings?
 db_id: student_club
Planner: Plan:
1. Find events attended by more than 10 members using the Attendance table. Group by link_to_event and filter with COUNT > 10.
2. Filter events that are 'Meeting' events.
3. Count the number of such events.
Tables:
*   Event: to filter events of type 'Meeting'.
*   Attendance: to count the number of attendees for each event.

Columns:
*   Event.type: to identify 'Meeting' events.
*   Attendance.link_to_event: to group by event.

NL2SQL: ```sql
SELECT
  COUNT(T1.event_id)
FROM Event AS T1
INNER JOIN (
  SELECT
    link_to_event
  FROM Attendance
  GROUP BY
    link_to_event
  HAVING
    COUNT(*) > 10
) AS T2
  ON T1.event_id = T2.link_to_event
WHERE
  T1.type = 'Meeting';
```
Critic: ```sql
SELECT
  COUNT(T1.event_id)
FROM Event AS T1
INNER JOIN (
  SELECT
    link_to_event
  FROM Attendance
  GROUP BY
    link_to_event
  HAVING
    COUNT(*) > 10
) AS T2
  ON T1.event_id = T2.link_to_event
WHERE
  T1.type = 'Meeting';
```
=====================
Question: List all the names of events that had an attendance of over 20 students but were not fundraisers.
 db_id: student_club
Planner: Plan:
1. Find the events that had an attendance of over 20 students using the Attendance table and group by the event id, filtering by count > 20.
2. Filter out the events that are fundraisers using the Event table.
3. Select the names of the events that satisfy both conditions.

Tables:
*   Attendance: to count the number of attendees for each event.
*   Event: to get event names and filter by event type (not fundraisers).

Columns:
*   Attendance: link_to_event
*   Event: event_name, type
SQL:
```sql
SELECT
  e.event_name
FROM Event AS e
JOIN (
  SELECT
    link_to_event,
    COUNT(*) AS attendance_count
  FROM Attendance
  GROUP BY
    link_to_event
  HAVING
    COUNT(*) > 20
) AS a
  ON e.event_id = a.link_to_event
WHERE
  e.type <> 'Fundraiser';
```
NL2SQL: ```sql
SELECT
  T1.event_name
FROM Event AS T1
INNER JOIN Attendance AS T2
  ON T1.event_id = T2.link_to_event
WHERE
  T1.type <> 'Fundraiser'
GROUP BY
  T2.link_to_event
HAVING
  count(*) > 20;
```
Critic: ```sql
SELECT
  event_name
FROM Event AS T1
INNER JOIN Attendance AS T2
  ON T1.event_id = T2.link_to_event
WHERE
  T1.type <> 'Fundraiser'
GROUP BY
  T1.event_name
HAVING
  COUNT(T2.link_to_event) > 20;
```
=====================
Question: What is the amount of the funds that the Vice President received?
 db_id: student_club
Planner: Plan:
1. Identify the member who is the Vice President. The Member table might have a position or title column.
2. Filter the Income table to find the amount of funds.
3. Join the Member and Income tables, using a where condition to get the fund amount where the member is the 'Vice President'.
4. Return the amount.

Tables: Member, Income
Columns: Member.member_id, Member.position, Income.amount, Income.member_id
Filters: Member.position = 'Vice President'
Joins: Income.member_id = Member.member_id
Output: Income.amount

NL2SQL: ```sql
SELECT
  T1.amount
FROM Income AS T1
INNER JOIN Member AS T2
  ON T1.member_id = T2.member_id
WHERE
  T2.position = 'Vice President';
```
Critic: ```sql
SELECT
  amount
FROM Income
WHERE
  notes LIKE '%Vice President%';
```
=====================
Question: List the full name of the Student_Club members that grew up in Illinois state.
 db_id: student_club
Planner: Plan:
1. Filter the `Zip_Code` table to find the zip codes corresponding to Illinois state.
2. Join the `Member` table with the filtered `Zip_Code` table on the `zip` column.
3. Select the `first_name` and `last_name` columns from the joined table to get the full name of members.
NL2SQL:
```sql
SELECT
  T1.first_name,
  T1.last_name
FROM Member AS T1
INNER JOIN Zip_Code AS T2
  ON T1.zip = T2.zip_code
WHERE
  T2.state = 'Illinois';
```
NL2SQL: ```sql
SELECT
  first_name,
  last_name
FROM Member
WHERE
  zip IN (
    SELECT
      zip_code
    FROM Zip_Code
    WHERE
      state = 'Illinois'
  );
```
Critic: ```sql
SELECT
  T1.first_name,
  T1.last_name
FROM Member AS T1
INNER JOIN Zip_Code AS T2
  ON T1.zip = T2.zip_code
WHERE
  T2.state = 'Illinois';
```
=====================
Question: Was each expense in October Meeting on October 8, 2019 approved?
 db_id: student_club
Planner: Plan:
1. Find the event ID for 'October Meeting' on '2019-10-08' from the Event table.
2. Find the budget ids using the event ID from the Budget table.
3. Filter expenses associated with the budget ids identified in step 2.
4. Check if all the filtered expenses are approved.
5. Output True or False depending on the approval status.
Tables:
*   Event: To get the event ID for 'October Meeting' on '2019-10-08'.
*   Budget: To link event ID to budget IDs.
*   Expense: To retrieve expense records.

Columns:
*   Event: event_name, event_date, event_id
*   Budget: link_to_event, link_to_budget
*   Expense: link_to_budget, approved

NL2SQL: ```sql
SELECT
  CASE
    WHEN SUM(CASE WHEN T1.approved = 'FALSE' THEN 1 ELSE 0 END) > 0
    THEN 'FALSE'
    ELSE 'TRUE'
  END
FROM Expense AS T1
INNER JOIN Budget AS T2
  ON T1.link_to_budget = T2.link_to_budget
INNER JOIN Event AS T3
  ON T2.link_to_event = T3.event_id
WHERE
  T3.event_name = 'October Meeting' AND T3.event_date = '2019-10-08';
```
Critic: ```sql
SELECT
  CASE
    WHEN COUNT(*) = SUM(CASE WHEN approved = 'TRUE' THEN 1 ELSE 0 END)
    THEN 'Yes'
    ELSE 'No'
  END
FROM Expense AS T1
INNER JOIN Budget AS T2
  ON T1.link_to_budget = T2.link_to_budget
INNER JOIN Event AS T3
  ON T2.link_to_event = T3.event_id
WHERE
  T3.event_name = 'October Meeting' AND T3.event_date = '2019-10-08';
```
=====================
Question: Calculate the total average cost that Elijah Allen spent in the events on September and October.
 db_id: student_club
Planner: Plan:
1. Find the member ID of Elijah Allen from the Member table based on his first name and last name.
2. Filter the Expense table to include expenses incurred by Elijah Allen (using the member ID obtained in step 1) and expenses incurred in September or October.
3. Calculate the average cost from the filtered Expense table.

Tables:
- Member: To find Elijah Allen's member ID.
- Expense: To find the expenses incurred by Elijah Allen in September and October, and to calculate the average cost.

Columns:
- Member: member_id, first_name, last_name
- Expense: link_to_member, cost, expense_date

Filters:
- Member: first_name = 'Elijah', last_name = 'Allen'
- Expense: link_to_member = (Elijah Allen's member_id), month(expense_date) in (9, 10)

Joins:
- None
Aggregations:
- AVG(cost)

NL2SQL: ```sql
SELECT avg(T1.cost) FROM Expense AS T1 JOIN Member AS T2 ON T1.link_to_member = T2.member_id WHERE T2.first_name = "Elijah" AND T2.last_name = "Allen" AND STRFTIME('%m', T1.expense_date) IN ('09', '10')
```
Critic: ```sql
SELECT avg(T1.cost) FROM Expense AS T1 JOIN Member AS T2 ON T1.link_to_member = T2.member_id WHERE T2.first_name = "Elijah" AND T2.last_name = "Allen" AND (STRFTIME('%m', T1.expense_date) = '09' OR STRFTIME('%m', T1.expense_date) = '10')
```
=====================
Question: Calculate the difference of the total amount spent in all events by the Student_Club in year 2019 and 2020.
 db_id: student_club
Planner: Here's my plan to calculate the difference in total amounts spent by the Student_Club in 2019 and 2020:

1.  **Identify relevant tables:**
    *   `Event`: To filter events by year.
    *   `Budget`: To retrieve the `spent` amount for each event.

2.  **Filter data by year:**
    *   Select events from the `Event` table where the year is 2019.
    *   Select events from the `Event` table where the year is 2020.

3.  **Join tables:**
    *   Join `Event` and `Budget` tables to link events to their corresponding `spent` amounts in the `Budget` table.

4.  **Calculate total spent for each year:**
    *   Sum the `spent` amounts for the 2019 events.
    *   Sum the `spent` amounts for the 2020 events.

5.  **Calculate the difference:**
    *   Subtract the total spent in 2020 from the total spent in 2019.

NL2SQL: ```sql
SELECT
  SUM(CASE WHEN STRFTIME('%Y', T1.event_date) = '2019' THEN T2.spent ELSE 0 END) - SUM(CASE WHEN STRFTIME('%Y', T1.event_date) = '2020' THEN T2.spent ELSE 0 END)
FROM Event AS T1
INNER JOIN Budget AS T2
  ON T1.event_id = T2.event_status;
```
Critic: ```sql
SELECT
  SUM(CASE WHEN STRFTIME('%Y', T1.event_date) = '2019' THEN T2.spent ELSE 0 END) - SUM(CASE WHEN STRFTIME('%Y', T1.event_date) = '2020' THEN T2.spent ELSE 0 END)
FROM Event AS T1
INNER JOIN Budget AS T2
  ON T1.event_id = T2.event_status;
```
=====================
Question: What was the notes of the fundraising on 2019/9/14?
 db_id: student_club
Planner: Plan:
1. Identify the relevant table: Based on the question and the table descriptions, the `Income` table contains the fundraising information with notes and date_received columns.
2. Filter the table: Filter the `Income` table where `date_received` is equal to '2019-09-14'.
3. Select the required column: Select the `notes` column from the filtered table.

NL2SQL: ```sql
SELECT
  notes
FROM Income
WHERE
  date_received = '2019-09-14';
```
Critic: ```sql
SELECT
  notes
FROM Income
WHERE
  date_received = '2019-09-14';
```
=====================
Question: Tell the phone number of "Carlo Jacobs".
 db_id: student_club
Planner: Plan:
1. Filter the Member table to find the member whose last name is "Jacobs".
2. Retrieve the 'phone' number for that member.

Tables:
- Member

Columns:
- Member: phone, last_name

NL2SQL: ```sql
SELECT
  phone
FROM Member
WHERE
  last_name = 'Jacobs';
```
Critic: ```sql
SELECT
  phone
FROM Member
WHERE
  last_name = 'Jacobs';
```
=====================
Question: What is the status of the event which bought "Post Cards, Posters" on 2019/8/20?
 db_id: student_club
Planner: Plan:
1. Filter the Expense table to find the record with expense_date = '2019-08-20' and description = 'Post Cards, Posters'.
2. Extract the corresponding event_status from the Budget table using the expense_id as the link.
3. Return the event_status.

Tables: Expense, Budget
Columns: Expense.expense_date, Expense.description, Budget.event_status, Expense.expense_id, Budget.link_to_expense
Filters: Expense.expense_date = '2019-08-20', Expense.description = 'Post Cards, Posters'
Joins: Expense.expense_id = Budget.link_to_expense
Output: Budget.event_status

NL2SQL: ```sql
SELECT
  T2.event_status
FROM Expense AS T1
INNER JOIN Budget AS T2
  ON T1.expense_id = T2.link_to_expense
WHERE
  T1.expense_date = '2019-08-20' AND T1.description = 'Post Cards, Posters';
```
Critic: ```sql
SELECT
  T1.status
FROM Event AS T1
INNER JOIN Income AS T2
  ON T1.event_id = T2.link_to_event
WHERE
  T2.date_received = '2019-08-20' AND T2.description = 'Post Cards, Posters';
```
=====================
Question: What was Brent Thomason's major?
 db_id: student_club
Planner: Plan:
1. Find the `major_id` of the major of Brent Thomason from the `Member` table, filtering by `first_name` equal to 'Brent' and `last_name` equal to 'Thomason'.
2. Retrieve the `major_name` from the `Major` table where `major_id` matches the `link_to_major` from the `Member` table.
Tables needed: Member, Major
Join condition: Member.link_to_major = Major.major_id
Filters: Member.first_name = 'Brent', Member.last_name = 'Thomason'
Columns: Major.major_name

NL2SQL: ```sql
SELECT
  T1.major_name
FROM Major AS T1
INNER JOIN Member AS T2
  ON T1.major_id = T2.link_to_major
WHERE
  T2.first_name = 'Brent' AND T2.last_name = 'Thomason';
```
Critic: ```sql
SELECT
  T1.major_name
FROM Major AS T1
INNER JOIN Member AS T2
  ON T1.major_id = T2.link_to_major
WHERE
  T2.first_name = 'Brent';
```
=====================
Question: For all the club members from "Business" major, how many of them wear medium size t-shirt?
 db_id: student_club
Planner: Plan:
1. Find the `major_id` for the "Business" major from the `Major` table.
2. In the `Member` table, filter by `link_to_major` using the `major_id` found in step 1.
3. Further filter the `Member` table by `t_shirt_size` = "Medium".
4. Count the number of members that satisfy the conditions.

NL2SQL: ```sql
SELECT
  COUNT(member_id)
FROM Member
WHERE
  link_to_major = (
    SELECT
      major_id
    FROM Major
    WHERE
      college = 'Business'
  )
  AND t_shirt_size = 'Medium';
```
Critic: ```sql
SELECT
  COUNT(T1.member_id)
FROM Member AS T1
INNER JOIN Major AS T2
  ON T1.link_to_major = T2.major_id
WHERE
  T2.college = 'Business' AND T1.t_shirt_size = 'Medium';
```
=====================
Question: Which department was the President of the club in?
 db_id: student_club
Planner: Plan:
1. Find the member ID of the member who is the President from the `Member` table.
2. Find the major ID associated with that member using `link_to_major`.
3. Find the department corresponding to that major ID from the `Major` table.
4. Return the department name.
Tables:
- Member: To find the member ID of the President and their major ID (`link_to_major`).
- Major: To find the department corresponding to the major ID.
Columns:
- Member: `member_id`, `position`, `link_to_major`
- Major: `department`
Joins:
- Join `Member` and `Major` tables on `Member.link_to_major = Major.major_id`.
Filters:
- Filter `Member` table where `position = 'President'`.
- Select the `department` from the joined table.

NL2SQL: ```sql
SELECT
  T2.department
FROM Member AS T1
INNER JOIN Major AS T2
  ON T1.link_to_major = T2.major_id
WHERE
  T1.position = 'President';
```
Critic: ```sql
SELECT
  T1.department
FROM Major AS T1
INNER JOIN Member AS T2
  ON T1.major_id = T2.link_to_major
WHERE
  T2.position = 'President';
```
=====================
Question: State the date Connor Hilton paid his/her dues.
 db_id: student_club
Planner: Plan:
1. Find the member ID of Connor Hilton from the Member table.
2. Filter the Income table by 'Dues' in the 'source' column and the member ID obtained in the previous step.
3. Select the 'date_received' from the filtered Income table.
Tables:
- Member: to find the member ID of Connor Hilton
- Income: to find the date Connor Hilton paid their dues

Columns:
- Member: first_name, last_name, member_id
- Income: member_id, date_received, source

Filters:
- Member: first_name = 'Connor', last_name = 'Hilton'
- Income: source = 'Dues' and member_id = (member_id of Connor Hilton)

Joins:
- None

NL2SQL: ```sql
SELECT
  T1.date_received
FROM Income AS T1
INNER JOIN Member AS T2
  ON T1.member_id = T2.member_id
WHERE
  T2.first_name = 'Connor' AND T2.last_name = 'Hilton' AND T1.source = 'Dues';
```
Critic: ```sql
SELECT
  T1.date_received
FROM Income AS T1
INNER JOIN Member AS T2
  ON T1.member_id = T2.member_id
WHERE
  T2.first_name = 'Connor' AND T2.last_name = 'Hilton' AND T1.source = 'Dues';
```
=====================
Question: How many times was the budget in Advertisement for "Yearly Kickoff" meeting more than "October Meeting"?
 db_id: student_club
Planner: Plan:
1. Find the event ID for "Yearly Kickoff" meeting and "October Meeting" from the `Event` table.
2. Filter the `Budget` table for the 'Advertisement' category.
3. Join the `Budget` table with the `Event` table on their respective event ID columns (`link_to_event` and `event_id`).
4. Calculate the budget amount for 'Advertisement' for "Yearly Kickoff" meeting and "October Meeting".
5. Calculate the ratio of the budget for "Yearly Kickoff" meeting to the budget for "October Meeting".
6. Return this ratio.

NL2SQL: ```sql
SELECT
  SUM(CASE WHEN T1.event_name = 'Yearly Kickoff' THEN T2.amount ELSE 0 END) / SUM(CASE WHEN T1.event_name = 'October Meeting' THEN T2.amount ELSE 0 END)
FROM Event AS T1
INNER JOIN Budget AS T2
  ON T1.event_id = T2.link_to_event
WHERE
  T2.category = 'Advertisement';
```
Critic: ```sql
SELECT
  SUM(CASE WHEN T1.event_name = 'Yearly Kickoff' THEN T2.amount ELSE 0 END) / SUM(CASE WHEN T1.event_name = 'October Meeting' THEN T2.amount ELSE 0 END)
FROM Event AS T1
INNER JOIN Budget AS T2
  ON T1.event_id = T2.link_to_event
WHERE
  T2.category = 'Advertisement';
```
=====================
Question: What is the total cost of the pizzas for all the events?
 db_id: student_club
Planner: Plan:
1. Filter the `Expense` table to only include expenses where `expense_description` is 'Pizza'.
2. Sum the `cost` column of the filtered table.
3. Return the sum.
Tables: Expense
Columns: cost, expense_description
Filters: expense_description = 'Pizza'
Aggregation: SUM(cost)

NL2SQL: ```sql
SELECT sum(cost) FROM Expense WHERE expense_description = 'Pizza'
```
Critic: ```sql
SELECT SUM(cost) FROM Expense WHERE expense_description = 'Pizza';
```
=====================
Question: How many cities are there in Orange County, Virginia?
 db_id: student_club
Planner: Plan:
1. Use the Zip_Code table.
2. Filter for records where county is 'Orange County' and state is 'Virginia'.
3. Count the distinct cities.
4. Return the count.

NL2SQL: ```sql
SELECT count(DISTINCT city) FROM Zip_Code WHERE county = 'Orange County' AND state = 'Virginia'
```
Critic: ```sql
SELECT count(DISTINCT city) FROM Zip_Code WHERE county = 'Orange County' AND state = 'Virginia'
```
=====================
Question: What does the person with the phone number "809-555-3360" major in?
 db_id: student_club
Planner: Plan:
1. Find the `major_id` of the member with the phone number "809-555-3360" from the `Member` table.
2. Use the `major_id` to find the corresponding `major_name` from the `Major` table.
3. Return the `major_name`.

Tables: Member, Major
Columns:
* Member: phone, link_to_major
* Major: major_id, major_name
Joins:
* Member.link_to_major = Major.major_id
Filters:
* Member.phone = "809-555-3360"
Output: Major.major_name

NL2SQL: ```sql
SELECT
  T2.major_name
FROM Member AS T1
INNER JOIN Major AS T2
  ON T1.link_to_major = T2.major_id
WHERE
  T1.phone = '809-555-3360';
```
Critic: ```sql
SELECT
  T2.major_name
FROM Member AS T1
INNER JOIN Major AS T2
  ON T1.link_to_major = T2.major_id
WHERE
  T1.phone = '809-555-3360';
```
=====================
Question: How many members attended the "Women's Soccer" event?
 db_id: student_club
Planner: Plan:
1. Find the `event_id` from the `Event` table where `event_name` is "Women's Soccer".
2. Use the `event_id` to filter the `Attendance` table, counting the distinct `link_to_member`.
3. Return the count.
Tables:
- Event: To get the `event_id`.
- Attendance: To count the members who attended the event.
Columns:
- Event: `event_id`, `event_name`
- Attendance: `link_to_member`, `link_to_event`
Joins: None
Filters:
- Event: `event_name` = "Women's Soccer"
Aggregations:
- COUNT(DISTINCT `link_to_member`)

NL2SQL: ```sql
SELECT COUNT(DISTINCT link_to_member) FROM Attendance WHERE link_to_event = (SELECT event_id FROM Event WHERE event_name = "Women's Soccer")
```
Critic: ```sql
SELECT COUNT(T1.link_to_member) FROM Attendance AS T1 JOIN Event AS T2 ON T1.link_to_event = T2.event_id WHERE T2.event_name = "Women's Soccer"
```
=====================
Question: List all the members of the "School of Applied Sciences, Technology and Education" department.
 db_id: student_club
Planner: Plan:
1.  Find the `link_to_major` from the `Major` table where `department` is "School of Applied Sciences, Technology and Education".
2.  Use the `link_to_major` to filter the `Member` table.
3.  Select the `first_name` and `last_name` from the `Member` table.

NL2SQL: ```sql
SELECT
  first_name,
  last_name
FROM Member
WHERE
  link_to_major IN (
    SELECT
      link_to_major
    FROM Major
    WHERE
      department = 'School of Applied Sciences, Technology and Education'
  );
```
Critic: ```sql
SELECT
  T1.first_name,
  T1.last_name
FROM Member AS T1
INNER JOIN Major AS T2
  ON T1.link_to_major = T2.link_to_major
WHERE
  T2.department = 'School of Applied Sciences, Technology and Education';
```
=====================
Question: Among all the closed events, which event has the highest spend-to-budget ratio?
 db_id: student_club
Planner: Plan:
1. Filter the 'Event' table to select only closed events (status = 'Closed').
2. Join 'Budget' table with 'Event' table using the 'link_to_event' column.
3. Calculate the spend-to-budget ratio (spent / amount) for each event.
4. Find the maximum spend-to-budget ratio among all closed events.
5. Retrieve the event that has the maximum spend-to-budget ratio.
Tables: Event, Budget
Columns: Event.link_to_event, Budget.spent, Budget.amount, Event.status
Filters: Event.status = 'Closed'
Joins: Event.link_to_event = Budget.link_to_event
Aggregate Function: MAX(Budget.spent / Budget.amount)
Output: Event.link_to_event (or any event information) corresponding to the maximum ratio.

NL2SQL: ```sql
SELECT
  T1.link_to_event
FROM Budget AS T1
INNER JOIN Event AS T2
  ON T1.link_to_event = T2.link_to_event
WHERE
  T2.status = 'Closed'
ORDER BY
  CASE
    WHEN T1.amount = 0
    THEN 0
    ELSE T1.spent / T1.amount
  END DESC
LIMIT 1;
```
Critic: ```sql
SELECT
  link_to_event
FROM Budget
WHERE
  event_status = 'Closed' AND amount != 0
ORDER BY
  spent / amount DESC
LIMIT 1;
```
=====================
Question: What is the highest amount of budget spend for an event?
 db_id: student_club
Planner: Plan:

1.  Find the table containing budget information and spending. This is the "Budget" table.
2.  Identify the column representing the amount spent. This is the "spent" column.
3.  Use the MAX aggregate function on the "spent" column to find the highest amount.

NL2SQL: ```sql
SELECT
  MAX(spent)
FROM Budget;
```
Critic: ```sql
SELECT
  MAX(spent)
FROM Budget;
```
=====================
Question: What is the total amount of money spent for food?
 db_id: student_club
Planner: Plan:
1. Filter the Budget table to select rows where the category is 'Food'.
2. Calculate the sum of the 'spent' column from the filtered data.
3. Return the calculated sum as the total amount spent for food.

NL2SQL: ```sql
SELECT sum(spent) FROM Budget WHERE category = 'Food'
```
Critic: ```sql
SELECT sum(spent) FROM Budget WHERE category = 'Food'
```
=====================
Question: List the name of students that have attended more than 7 events.
 db_id: student_club
Planner: Plan:
1. Join the Attendance table with the Member table using the link_to_member column.
2. Group the results by member ID (member_id) and student's first name and last name (first_name, last_name).
3. Filter the groups to include only those where the count of distinct event IDs (link_to_event) is greater than 7.
4. Select the first name and last name columns to display the names of students who meet the criteria.
Tables:
- Attendance
- Member

Columns:
- Attendance: link_to_member, link_to_event
- Member: member_id, first_name, last_name

Joins:
- Attendance JOIN Member ON Attendance.link_to_member = Member.member_id

Filters:
- COUNT(DISTINCT Attendance.link_to_event) > 7

NL2SQL: ```sql
SELECT T2.first_name, T2.last_name
FROM Attendance AS T1 JOIN Member AS T2 ON T1.link_to_member = T2.member_id
GROUP BY T2.member_id, T2.first_name, T2.last_name
HAVING COUNT(T1.link_to_event) > 7
```
Critic: ```sql
SELECT T2.first_name, T2.last_name
FROM Attendance AS T1 JOIN Member AS T2 ON T1.link_to_member = T2.member_id
GROUP BY T2.member_id
HAVING COUNT(T1.link_to_event) > 7
```
=====================
Question: Which student has been entrusted to manage the budget for the Yearly Kickoff?
 db_id: student_club
Planner: Plan:
1. Find the `event_id` for the event named 'Yearly Kickoff' from the `Event` table.
2. Find the `member_id` from the `Member` table where the `role` is manager.
3. Filter the `Budget` table by `link_to_event` using the `event_id` found in step 1.
4. Join `Member` and `Budget` table on the event id.
5. Get the student `first_name` and `last_name` from the `Member` table.

NL2SQL: ```sql
SELECT
  T1.first_name,
  T1.last_name
FROM Member AS T1
INNER JOIN Event AS T2
  ON T1.member_id = T2.manager
WHERE
  T2.event_name = 'Yearly Kickoff';
```
Critic: ```sql
SELECT
  T1.first_name,
  T1.last_name
FROM Member AS T1
INNER JOIN Event AS T2
  ON T1.member_id = T2.manager
WHERE
  T2.event_name = 'Yearly Kickoff';
```
=====================
Question: Which event has the lowest cost?
 db_id: student_club
Planner: Plan:
1. Find the cost of each event using the Budget table. Cost can be represented by the spent amount.
2. Find the minimum cost from all the event costs.
3. Find the event name that corresponds to this minimum cost using Event table.
4. Return the event_name with the minimum cost.

Tables:
- Budget: To get the cost (spent) of each event.
- Event: To get the event name.

Columns:
- Budget: spent, link_to_event.
- Event: event_name, event_id.

Joins:
- Join Budget and Event tables on Budget.link_to_event = Event.event_id

Filters:
- None
Aggregations:
- MIN(Budget.spent)

NL2SQL: ```sql
SELECT T1.event_name FROM Event AS T1 JOIN Budget AS T2 ON T1.event_id = T2.link_to_event ORDER BY T2.spent ASC LIMIT 1
```
Critic: ```sql
SELECT T1.event_name FROM Event AS T1 JOIN Budget AS T2 ON T1.event_id = T2.link_to_event ORDER BY T2.amount ASC LIMIT 1
```
=====================
Question: Based on the total cost for all event, what is the percentage of cost for Yearly Kickoff event?
 db_id: student_club
Planner: Plan:
1. Calculate the total cost for all events using the Expense table.
2. Calculate the total cost for the 'Yearly Kickoff' event. Need to join the Event table and the Expense table.
3. Calculate the percentage of the 'Yearly Kickoff' event cost relative to the total cost of all events.
4. Return the percentage.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.event_name = 'Yearly Kickoff' THEN T2.cost ELSE 0 END) AS REAL) * 100 / SUM(T2.cost)
FROM Event AS T1
INNER JOIN Expense AS T2
  ON T1.event_name = T1.event_name;
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.event_name = 'Yearly Kickoff' THEN T2.cost ELSE 0 END) AS REAL) * 100 / SUM(T2.cost)
FROM Event AS T1
INNER JOIN Expense AS T2
  ON T1.event_name = T2.event_name;
```
=====================
Question: Indicate the top source of funds received in September 2019 based on their amount.
 db_id: student_club
Planner: Plan:
1. Filter the Income table by date_received to include only records from September 2019.
2. Group the filtered Income records by source and sum the amount for each source.
3. Order the results in descending order based on the total amount.
4. Select the source with the highest total amount.
Tables: Income
Columns: date_received, source, amount
Filters: date_received BETWEEN '2019-09-01' AND '2019-09-30'
Aggregate: SUM(amount) grouped by source
Order: SUM(amount) DESC
Limit: 1

NL2SQL: ```sql
SELECT source FROM Income WHERE date_received BETWEEN '2019-09-01' AND '2019-09-30' GROUP BY source ORDER BY SUM(amount) DESC LIMIT 1
```
Critic: ```sql
SELECT source FROM Income WHERE date_received BETWEEN '2019-09-01' AND '2019-09-30' GROUP BY source ORDER BY SUM(amount) DESC LIMIT 1
```
=====================
Question: How many members of the Student_Club have major in 'Physics Teaching'?
 db_id: student_club
Planner: Plan:
1. Find the major_id for 'Physics Teaching' in the Major table.
2. Count the number of members in the Member table where link_to_major matches the major_id found in the previous step.

Tables:
- Major: to find major_id
- Member: to count members

Columns:
- Major: major_id, major_name
- Member: link_to_major

NL2SQL: ```sql
SELECT count(*) FROM Member WHERE link_to_major = (SELECT major_id FROM Major WHERE major_name = 'Physics Teaching')
```
Critic: ```sql
SELECT count(*) FROM Member WHERE link_to_major = (SELECT major_id FROM Major WHERE department = 'Physics Teaching')
```
=====================
Question: Name the event with the highest amount spent on advertisement.
 db_id: student_club
Planner: Plan:
1.  Join the Budget table and Event table on the link_to_event column.
2.  Filter by category = 'Advertisement'.
3.  Find the maximum amount spent.
4.  Select the event name corresponding to that maximum amount.

NL2SQL: ```sql
SELECT
  T2.event_name
FROM Budget AS T1
INNER JOIN Event AS T2
  ON T1.link_to_event = T2.event_id
WHERE
  T1.category = 'Advertisement'
ORDER BY
  T1.spent DESC
LIMIT 1;
```
Critic: ```sql
SELECT
  T2.event_name
FROM Budget AS T1
INNER JOIN Event AS T2
  ON T1.link_to_event = T2.event_id
WHERE
  T1.category = 'Advertisement'
ORDER BY
  T1.spent DESC
LIMIT 1;
```
=====================
Question: Did Maya Mclean attend the 'Women's Soccer' event?
 db_id: student_club
Planner: Plan:
1. Find the member ID of Maya Mclean from the Member table.
2. Find the event ID of the 'Women's Soccer' event from the Event table.
3. Check if there is an entry in the Attendance table with the member ID and event ID found in the previous steps.
4. Return 'Yes' if such an entry exists, and 'No' otherwise.

Tables: Member, Event, Attendance
Columns:
*   Member: first_name, last_name, member_id
*   Event: event_name, event_id
*   Attendance: link_to_member, link_to_event
Filters:
*   Member: first_name = 'Maya' and last_name = 'Mclean'
*   Event: event_name = 'Women\'s Soccer'
Joins:
*   Attendance with Member on Attendance.link_to_member = Member.member_id
*   Attendance with Event on Attendance.link_to_event = Event.event_id

NL2SQL: ```sql
SELECT
  CASE WHEN EXISTS (
    SELECT
      1
    FROM Member AS T1
    INNER JOIN Attendance AS T2
      ON T1.member_id = T2.link_to_member
    INNER JOIN Event AS T3
      ON T2.link_to_event = T3.event_id
    WHERE
      T1.first_name = 'Maya' AND T1.last_name = 'Mclean' AND T3.event_name = 'Women''s Soccer'
  )
  THEN 'Yes'
  ELSE 'No'
END;
```
Critic: ```sql
SELECT
  CASE WHEN EXISTS (
    SELECT
      1
    FROM Member AS T1
    INNER JOIN Attendance AS T2
      ON T1.member_id = T2.link_to_member
    INNER JOIN Event AS T3
      ON T2.link_to_event = T3.event_id
    WHERE
      T1.first_name = 'Maya' AND T1.last_name = 'Mclean' AND T3.event_name = 'Women''s Soccer'
  ) THEN 'Yes' ELSE 'No' END;
```
=====================
Question: Indicate the cost of posters for 'September Speaker' event.
 db_id: student_club
Planner: Plan:
1. Find the `link_to_event` for the 'September Speaker' event from the `Event` table.
2. Find the `link_to_budget` from the `Budget` table using the `link_to_event` obtained in the previous step.
3. Retrieve the `cost` from the `Expense` table where the `expense_description` is 'Posters' and `link_to_budget` matches the `link_to_budget` obtained from step 2.

Tables needed: Event, Budget, Expense
Columns needed: Event.link_to_event, Event.notes, Budget.link_to_event, Budget.link_to_budget, Expense.link_to_budget, Expense.cost, Expense.expense_description
Filters: Event.notes = 'September Speaker', Expense.expense_description = 'Posters'
Joins: Budget with Event on Budget.link_to_event = Event.link_to_event, Expense with Budget on Expense.link_to_budget = Budget.link_to_budget

NL2SQL: ```sql
SELECT
  T1.cost
FROM Expense AS T1
INNER JOIN Budget AS T2
  ON T1.link_to_budget = T2.link_to_budget
INNER JOIN Event AS T3
  ON T2.link_to_event = T3.link_to_event
WHERE
  T3.notes = 'September Speaker' AND T1.expense_description = 'Posters';
```
Critic: ```sql
SELECT
  T1.cost
FROM Expense AS T1
INNER JOIN Budget AS T2
  ON T1.link_to_budget = T2.link_to_budget
INNER JOIN Event AS T3
  ON T2.link_to_event = T3.event_id
WHERE
  T3.notes = 'September Speaker' AND T1.expense_description = 'Posters';
```
=====================
Question: Indicate the name of the closed event whose cost has exceeded the budget the most.
 db_id: student_club
Planner: Plan:

1.  Filter the `Event` table to find closed events (`status` = 'Closed').
2.  Join the `Budget` table with the filtered `Event` table using `link_to_event`.
3.  Calculate the amount by which the cost has exceeded the budget (remaining < 0). `remaining` can be calculated by `amount` - `spent`.
4.  Find the closed event with the minimum `remaining` (the most exceeded budget).
5.  Select the name of the event with the minimum remaining.

NL2SQL: ```sql
SELECT
  T1.event_name
FROM Event AS T1
INNER JOIN Budget AS T2
  ON T1.event_id = T2.link_to_event
WHERE
  T1.status = 'Closed' AND T2.remaining < 0
ORDER BY
  T2.remaining
LIMIT 1;
```
Critic: ```sql
SELECT
  T1.event_name
FROM Event AS T1
INNER JOIN Budget AS T2
  ON T1.event_id = T2.link_to_event
WHERE
  T1.status = 'Closed'
ORDER BY
  T2.amount - T2.spent
LIMIT 1;
```
=====================
Question: Identify the type of expenses and their total value approved for 'October Meeting' event.
 db_id: student_club
Planner: Plan:
1. Find the `link_to_event` for the event named 'October Meeting' from the `Event` table.
2. Filter the `Budget` table by `link_to_event` obtained in the previous step.
3. Join `Expense` table with the filtered `Budget` table using `link_to_budget`.
4. Filter the joined table by expenses that are `approved`.
5. Group the result by the `category` from the `Budget` table.
6. Calculate the sum of `cost` for each category.
7. Display the `category` and the sum of `cost`.

NL2SQL: ```sql
SELECT
  b.category,
  SUM(e.cost)
FROM Event AS ev
JOIN Budget AS b
  ON ev.event_id = b.link_to_event
JOIN Expense AS e
  ON b.link_to_budget = e.link_to_budget
WHERE
  ev.event_name = 'October Meeting' AND e.approved = TRUE
GROUP BY
  b.category;
```
Critic: ```sql
SELECT
  b.category,
  SUM(e.cost)
FROM Event AS ev
JOIN Budget AS b
  ON ev.event_id = b.link_to_event
JOIN Expense AS e
  ON b.link_to_budget = e.link_to_budget
WHERE
  ev.event_name = 'October Meeting' AND e.approved = 1
GROUP BY
  b.category;
```
=====================
Question: Calculate the amount budgeted for 'April Speaker' event. List all the budgeted categories for said event in an ascending order based on their amount budgeted.
 db_id: student_club
Planner: Plan:
1. Find the `link_to_event` for the event 'April Speaker' from the `Event` table.
2. Use the `link_to_event` to filter the `Budget` table.
3. Calculate the total `amount` for each `category` from the filtered `Budget` table.
4. Order the result by the total `amount` in ascending order.
5. Display the `category` and the calculated total `amount`.

NL2SQL: ```sql
SELECT
  category,
  SUM(amount) AS total_amount
FROM Budget
WHERE
  link_to_event = (
    SELECT
      event_id
    FROM Event
    WHERE
      event_name = 'April Speaker'
  )
GROUP BY
  category
ORDER BY
  total_amount;
```
Critic: ```sql
SELECT
  category,
  SUM(amount) AS total_amount
FROM Budget
JOIN Event
  ON Budget.link_to_event = Event.event_id
WHERE
  Event.event_name = 'April Speaker'
GROUP BY
  category
ORDER BY
  total_amount;
```
=====================
Question: Mention the total expense used on 8/20/2019.
 db_id: student_club
Planner: Plan:
1. Select the `Expense` table.
2. Filter the table for `expense_date` equal to '2019-08-20'.
3. Calculate the sum of the `cost` column.

NL2SQL: ```sql
SELECT sum(cost) FROM Expense WHERE expense_date = '2019-08-20'
```
Critic: ```sql
SELECT sum(cost) FROM Expense WHERE expense_date = '2019-08-20'
```
=====================
Question: List out the full name and total cost that member id "rec4BLdZHS2Blfp4v" incurred?
 db_id: student_club
Planner: Plan:
1.  Find the member's full name (first name and last name) from the Member table using the given member ID.
2.  Find the total cost from the Expense table for the given member ID.
3.  Combine the results from steps 1 and 2 to display the full name and total cost.

Tables needed: Member, Expense
Columns needed:
*   Member: first\_name, last\_name, member\_id
*   Expense: link\_to\_member, cost
Filters:
*   Expense: link\_to\_member = "rec4BLdZHS2Blfp4v"
*   Member: member\_id = "rec4BLdZHS2Blfp4v"
Joins: None
Aggregations: SUM(Expense.cost)
Final Output: first\_name, last\_name, total\_cost

NL2SQL: ```sql
SELECT
  M.first_name,
  M.last_name,
  SUM(E.cost) AS total_cost
FROM Member AS M
JOIN Expense AS E
  ON M.member_id = E.link_to_member
WHERE
  M.member_id = 'rec4BLdZHS2Blfp4v';
```
Critic: ```sql
SELECT
  M.first_name,
  M.last_name,
  SUM(E.cost)
FROM Member AS M
JOIN Expense AS E
  ON M.member_id = E.link_to_member
WHERE
  M.member_id = 'rec4BLdZHS2Blfp4v'
GROUP BY
  M.first_name,
  M.last_name;
```
=====================
Question: State what kind of expenses that Sacha Harrison incurred?
 db_id: student_club
Planner: Plan:
1. Find the member ID of Sacha Harrison from the Member table using the first_name and last_name columns.
2. Use the member ID to filter the Expense table using the link_to_member column.
3. Retrieve the expense_description from the filtered Expense table.
Tables:
- Member: to find the member ID of Sacha Harrison.
- Expense: to find the expense descriptions incurred by the member.

Columns:
- Member: first_name, last_name, member_id
- Expense: link_to_member, expense_description

Filters:
- Member: first_name = 'Sacha', last_name = 'Harrison'
- Expense: link_to_member = (member_id from the Member table)

Joins:
- None needed.

NL2SQL: ```sql
SELECT
  T1.expense_description
FROM Expense AS T1
INNER JOIN Member AS T2
  ON T1.link_to_member = T2.member_id
WHERE
  T2.first_name = 'Sacha' AND T2.last_name = 'Harrison';
```
Critic: ```sql
SELECT
  T1.expense_description
FROM Expense AS T1
INNER JOIN Member AS T2
  ON T1.link_to_member = T2.member_id
WHERE
  T2.first_name = 'Sacha' AND T2.last_name = 'Harrison';
```
=====================
Question: State the category of events were held at MU 215.
 db_id: student_club
Planner: Plan:
1. Select the "type" column from the "Event" table.
2. Filter the "Event" table where the "location" column is equal to 'MU 215'.

NL2SQL: ```sql
SELECT
  type
FROM Event
WHERE
  location = 'MU 215';
```
Critic: ```sql
SELECT DISTINCT
  Type
FROM Event
WHERE
  Location = 'MU 215';
```
=====================
Question: List the last name of members with a major in environmental engineering and include its department and college name.
 db_id: student_club
Planner: Plan:
1. Select the `last_name` from the `Member` table.
2. Filter `Member` table using `link_to_major` which can be joined from `Major` table.
3. Select `department` and `college` from the `Major` table.
4. Filter `Major` table with `major_name` = 'Environmental Engineering'.
5. Join `Member` table with `Major` table on `Member.link_to_major` = `Major.major_id`.

NL2SQL: ```sql
SELECT
  m.last_name,
  ma.department,
  ma.college
FROM Member AS m
JOIN Major AS ma
  ON m.link_to_major = ma.major_id
WHERE
  ma.major_name = 'Environmental Engineering';
```
Critic: ```sql
SELECT
  T1.LName,
  T2.dept,
  T2.college
FROM Member AS T1
INNER JOIN Major AS T2
  ON T1.major_id = T2.major_id
WHERE
  T2.major_name = 'Environmental Engineering';
```
=====================
Question: What are the budget category of the events located at MU 215 and a guest speaker type with a 0 budget spent?
 db_id: student_club
Planner: Plan:
1. Filter the Event table to find events with the location 'MU 215'.
2. Filter the Budget table to find budget entries with spent = 0.
3. Join the filtered Event and Budget tables on their respective event ID columns.
4. Filter to get guest speakers
5. Select the 'category' column from the resulting joined table.

NL2SQL: ```sql
SELECT
  T1.category
FROM Budget AS T1
INNER JOIN Event AS T2
  ON T1.link_to_event = T2.event_id
WHERE
  T2.location = 'MU 215' AND T1.spent = 0 AND T2.type = 'Guest Speaker';
```
Critic: ```sql
SELECT
  T1.category
FROM Budget AS T1
INNER JOIN Event AS T2
  ON T1.link_to_event = T2.event_id
WHERE
  T2.location = 'MU 215' AND T1.spent = 0 AND T2.event_type = 'Guest Speaker';
```
=====================
Question: Among the members with t-shirt size of medium, what is the percentage of the amount 50 received by the Student_Club?
 db_id: student_club
Planner: Plan:
1. Filter the `Member` table to find members with t-shirt size 'Medium'.
2. Join the filtered `Member` table with the `Income` table using `link_to_member` to find the amount of income for those members.
3. Filter the results from the join to count the number of incomes that is 50.
4. Count the total number of members with t-shirt size medium.
5. Calculate the percentage of incomes with value 50 among members with t-shirt size medium by dividing count of incomes with value 50 by the total number of members with t-shirt size medium and multiplying by 100.
6. Return the calculated percentage.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.amount = 50 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.amount)
FROM Income AS T1
INNER JOIN Member AS T2
  ON T1.link_to_member = T2.member_id
WHERE
  T2.t_shirt_size = 'Medium';
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.amount = 50 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.amount)
FROM Income AS T1
INNER JOIN Member AS T2
  ON T1.link_to_member = T2.member_id
WHERE
  T2.t_shirt_size = 'Medium';
```
=====================
Question: List the names of closed event as "game" that was closed from 3/15/2019 to 3/20/2020.
 db_id: student_club
Planner: Plan:
1. Filter the `Event` table to find events where the `type` is 'Game', the `status` is 'Closed', and `event_date` is between '2019-03-15' and '2020-03-20'.
2. Select the `event_name` from the filtered results.

NL2SQL: ```sql
SELECT
  event_name AS game
FROM Event
WHERE
  type = 'Game' AND status = 'Closed' AND event_date BETWEEN '2019-03-15' AND '2020-03-20';
```
Critic: ```sql
SELECT
  event_name AS game
FROM Event
WHERE
  status = 'Closed' AND type = 'Game' AND event_date BETWEEN '2019-03-15' AND '2020-03-20';
```
=====================
Question: Give the full name and contact number of members who had to spend more than average on each expense.
 db_id: student_club
Planner: Plan:
1. Calculate the average expense for each expense in the `Expense` table.
2. Filter the `Expense` table to include only expenses where the cost is greater than the average cost.
3. Join the filtered `Expense` table with the `Member` table on `link_to_member` to retrieve the first name, last name, and phone number of the members.
4. Select the first name, last name, and phone number of the members.

Tables:
- Expense: To get the cost and link_to_member.
- Member: To get the first name, last name, and phone number.

Columns:
- Expense: cost, link_to_member
- Member: first_name, last_name, phone

Filters:
- cost > AVG(cost) in Expense table.

Joins:
- Expense JOIN Member ON Expense.link_to_member = Member.member_id

NL2SQL: ```sql
SELECT
  M.first_name,
  M.last_name,
  M.phone
FROM Expense AS E
JOIN Member AS M
  ON E.link_to_member = M.member_id
WHERE
  E.cost > (
    SELECT
      AVG(cost)
    FROM Expense
  );
```
Critic: ```sql
SELECT
  T1.first_name,
  T1.last_name,
  T1.phone
FROM Member AS T1
INNER JOIN Expense AS T2
  ON T1.member_id = T2.link_to_member
WHERE
  T2.cost > (
    SELECT
      avg(cost)
    FROM Expense
  );
```
=====================
Question: Write the full name of the member who spent money for water, veggie tray and supplies and include the cost of it.
 db_id: student_club
Planner: Plan:
1. Filter the 'Expense' table to find records where 'expense_description' matches 'Water, Veggie tray, supplies'.
2. Join the filtered 'Expense' table with the 'Member' table using 'link_to_member' and 'member_id' to retrieve the member's first name and last name.
3. Select the member's full name (first name and last name) and the 'cost' from the joined table.

NL2SQL: ```sql
SELECT
  M.first_name,
  M.last_name,
  E.cost
FROM Expense AS E
JOIN Member AS M
  ON E.link_to_member = M.member_id
WHERE
  E.expense_description = 'Water, Veggie tray, supplies';
```
Critic: ```sql
SELECT
  M.first_name,
  M.last_name,
  E.cost
FROM Expense AS E
JOIN Member AS M
  ON E.link_to_member = M.member_id
WHERE
  E.expense_description IN ('Water', 'Veggie tray', 'supplies');
```
=====================
Question: Write the full names of students who received funds on the date of 9/9/2019 and include the amount received.
 db_id: student_club
Planner: Plan:
1. Find the students who received funds on 9/9/2019 from the Income table.
2. Get the student's first name and last name from the Member table.
3. Join the Income table with the Member table on member_id.
4. Filter the Income table by date_received = 9/9/2019.
5. Select the first name, last name, and amount.

NL2SQL: ```sql
SELECT
  T1.first_name,
  T1.last_name,
  T2.amount
FROM Member AS T1
INNER JOIN Income AS T2
  ON T1.member_id = T2.member_id
WHERE
  T2.date_received = '09/09/2019';
```
Critic: ```sql
SELECT
  T1.first_name,
  T1.last_name,
  T2.amount
FROM Member AS T1
INNER JOIN Income AS T2
  ON T1.member_id = T2.member_id
WHERE
  T2.date_received = '2019-09-09';
```
=====================
Question: Are there more in-patient or outpatient who were male? What is the deviation in percentage?
 db_id: thrombosis_prediction
Planner: Plan:
1. Count the number of male in-patients using `Patient` table where SEX = 'M' and Admission = '+'.
2. Count the number of male outpatients using `Patient` table where SEX = 'M' and Admission = '-'.
3. Calculate the percentage deviation between the two counts: `ABS((inpatient_count - outpatient_count) / outpatient_count) * 100`.
4. Return the counts of inpatient and outpatient and the percentage deviation.

NL2SQL: ```sql
SELECT
  SUM(CASE WHEN Admission = '+' THEN 1 ELSE 0 END) AS inpatient_count,
  SUM(CASE WHEN Admission = '-' THEN 1 ELSE 0 END) AS outpatient_count,
  ABS(
    (
      SUM(CASE WHEN Admission = '+' THEN 1 ELSE 0 END) - SUM(CASE WHEN Admission = '-' THEN 1 ELSE 0 END)
    ) * 1.0 / SUM(CASE WHEN Admission = '-' THEN 1 ELSE 0 END)
  ) * 100 AS percentage_deviation
FROM Patient
WHERE
  SEX = 'M';
```
Critic: ```sql
SELECT
  SUM(CASE WHEN Admission = '+' THEN 1 ELSE 0 END) AS inpatient_count,
  SUM(CASE WHEN Admission = '-' THEN 1 ELSE 0 END) AS outpatient_count,
  ABS(
    (
      SUM(CASE WHEN Admission = '+' THEN 1 ELSE 0 END) - SUM(CASE WHEN Admission = '-' THEN 1 ELSE 0 END)
    ) * 100.0 / SUM(CASE WHEN Admission = '-' THEN 1 ELSE 0 END)
  ) AS percentage_deviation
FROM Patient
WHERE
  SEX = 'M';
```
=====================
Question: What is the percentage of female patient were born after 1930?
 db_id: thrombosis_prediction
Planner: Here's my plan to determine the percentage of female patients born after 1930:

1.  **Table:** Start with the `Patient` table, as it contains the necessary information about patients (gender and birthday).
2.  **Filtering:**
    *   Filter for female patients (`SEX` = 'F').
    *   Filter for patients born after 1930 (`Birthday` year > 1930).
3.  **Aggregation:**
    *   Count the total number of female patients born after 1930.
    *   Count the total number of female patients.
4.  **Calculation:** Divide the number of female patients born after 1930 by the total number of female patients and multiply by 100 to get the percentage.

NL2SQL:
```sql
SELECT CAST(SUM(CASE WHEN STRFTIME('%Y', Birthday) > '1930' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*)
FROM Patient
WHERE SEX = 'F';
```
NL2SQL: ```sql
SELECT CAST(SUM(CASE WHEN STRFTIME('%Y', Birthday) > '1930' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM Patient WHERE Sex = 'F'
```
Critic: ```sql
SELECT CAST(SUM(CASE WHEN STRFTIME('%Y', Birthday) > '1930' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM Patient WHERE SEX = 'F'
```
=====================
Question: What is the ratio of outpatient to inpatient followed up treatment among all the 'SLE' diagnosed patient?
 db_id: thrombosis_prediction
Planner: Plan:
1. Filter the `Patient` table to count the number of SLE diagnosed patients with Admission '+'.
2. Filter the `Patient` table to count the number of SLE diagnosed patients with Admission '-'.
3. Calculate the ratio of the counts from step 1 and step 2.
4. Select the calculated ratio.
Tables: `Patient`
Columns: `Diagnosis`, `Admission`, `ID`
Filters: `Diagnosis` = 'SLE', `Admission` = '+' or '-'
Aggregations: `COUNT(ID)`
Calculations: `COUNT(ID) WHERE Admission = '+' / COUNT(ID) WHERE Admission = '-'`

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN Admission = '+' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN Admission = '-' THEN 1 ELSE 0 END)
FROM Patient
WHERE
  Diagnosis = 'SLE';
```
Critic: ```sql
SELECT CAST(SUM(CASE WHEN Admission = '-' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN Admission = '+' THEN 1 ELSE 0 END) FROM Patient WHERE Diagnosis = 'SLE'
```
=====================
Question: What is the disease patient '30609' diagnosed with. List all the date of laboratory tests done for this patient.
 db_id: thrombosis_prediction
Planner: Plan:
1. Find the diagnosis of the patient '30609' from the Patient table.
2. Find the dates of all laboratory tests performed for patient '30609' from the Laboratory table.
3. Combine the diagnosis and the list of lab test dates for the patient to present the required information.

Tables:
- Patient: to get the diagnosis for the patient.
- Laboratory: to get the dates of the lab tests.

Columns:
- Patient.Diagnosis: the diagnosis of the patient.
- Laboratory.Date: the dates of the lab tests.
- Laboratory.ID: the patient ID.

Filters:
- Patient.ID = '30609'
- Laboratory.ID = '30609'

Joins:
- No joins are needed since the patient information and lab test information are retrieved from separate tables.

NL2SQL: ```sql
SELECT
  p.Diagnosis,
  GROUP_CONCAT(DISTINCT l.Date)
FROM Patient AS p
JOIN Laboratory AS l
  ON p.DB_ID = l.ID
WHERE
  p.DB_ID = '30609';
```
Critic: ```sql
SELECT
  T1.Diagnosis,
  T2.Date
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.DB_ID = T2.ID
WHERE
  T1.DB_ID = '30609';
```
=====================
Question: List the patient ID, sex and birthday of patient with LDH beyond normal range.
 db_id: thrombosis_prediction
Planner: Plan:

1.  **Identify relevant tables:** `Patient` (for patient ID, sex, birthday) and `Laboratory` (for LDH values).
2.  **Filter:** Select records from `Laboratory` where `LDH` > 500 (representing beyond normal range).
3.  **Join:** Join the `Patient` and `Laboratory` tables on the common column `ID` (patient ID).
4.  **Select desired columns:** `ID` (patient ID), `SEX`, and `Birthday` from the joined table.

NL2SQL: ```sql
SELECT
  T1.ID,
  T1.SEX,
  T1.Birthday
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
WHERE
  T2.LDH > '500';
```
Critic: ```sql
SELECT
  ID,
  SEX,
  Birthday
FROM Patient
WHERE
  ID IN (
    SELECT
      ID
    FROM Laboratory
    WHERE
      LDH > 500
  );
```
=====================
Question: State the ID and age of patient with positive degree of coagulation.
 db_id: thrombosis_prediction
Planner: Plan:
1.  From the Patient table, retrieve the ID, and calculate the age (current year - birth year).
2.  From the Examination table, filter the records where RVVT is '+', which represents a positive degree of coagulation.
3.  Join Patient and Examination tables on the common column 'ID'.
4.  Select the patient ID and calculated age.

Tables:
*   Patient
*   Examination

Columns:
*   Patient: ID, Birthday
*   Examination: RVVT

Filters:
*   Examination: RVVT = '+'

Joins:
*   Patient JOIN Examination ON Patient.ID = Examination.ID

NL2SQL: ```sql
SELECT
  T1.ID,
  SUBSTR(CAST((
    JULIANDAY('now') - JULIANDAY(T1.Birthday)
  ) / 365 AS TEXT), 1, 2)
FROM Patient AS T1
INNER JOIN Examination AS T2
  ON T1.ID = T2.ID
WHERE
  T2.RVVT = '+';
```
Critic: ```sql
SELECT
  T1.ID,
  CAST(SUBSTR(DATE('now') - T1.Birthday, 1, 2) AS INTEGER)
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
INNER JOIN Examination AS T3
  ON T2.ID = T3.ID
WHERE
  T3.RVVT = '+';
```
=====================
Question: For patients with severe degree of thrombosis, list their ID, sex and disease the patient is diagnosed with.
 db_id: thrombosis_prediction
Planner: Plan:
1. Filter the `Examination` table for patients with `Thrombosis = 2`.
2. Join the filtered `Examination` table with the `Patient` table on `ID`.
3. Select the `ID`, `SEX`, and `Diagnosis` columns from the joined table.

NL2SQL: ```sql
SELECT
  T1.ID,
  T1.SEX,
  T1.Diagnosis
FROM Patient AS T1
INNER JOIN Examination AS T2
  ON T1.ID = T2.ID
WHERE
  T2.Thrombosis = 2;
```
Critic: ```sql
SELECT
  T1.ID,
  T1.SEX,
  T1.Diagnosis
FROM Patient AS T1
INNER JOIN Examination AS T2
  ON T1.ID = T2.ID
WHERE
  T2.Thrombosis = '2';
```
=====================
Question: How many female patients who came at the hospital in 1997 was immediately followed at the outpatient clinic?
 db_id: thrombosis_prediction
Planner: Plan:

1.  Filter the `Patient` table for female patients (`SEX` = 'F') who came to the hospital in 1997 (year of `Description` = 1997) and were followed at the outpatient clinic (`Admission` = '-').
2.  Count the number of patients that satisfy the conditions.
3.  Select the number of patients ID.

NL2SQL: ```sql
SELECT
  COUNT(ID)
FROM Patient
WHERE
  SEX = 'F' AND STRFTIME('%Y', Description) = '1997' AND Admission = '-';
```
Critic: ```sql
SELECT
  COUNT(ID)
FROM Patient
WHERE
  SEX = 'F' AND STRFTIME('%Y', Description) = '1997' AND Admission = '-';
```
=====================
Question: How many of the patients with the most serious thrombosis cases examined in 1997 are women?
 db_id: thrombosis_prediction
Planner: Plan:
1. Filter the Examination table for records where Thrombosis is 1 (most serious thrombosis).
2. Filter the Laboratory table for records in the year 1997.
3. Join the Examination and Patient tables on the Diagnosis column.
4. Join the resulting table with the Laboratory table on the Diagnosis column.
5. Filter the joined table for female patients (Sex = 'F').
6. Count the number of patients that satisfy all the conditions.

Tables: Examination, Patient, Laboratory
Columns: Examination.Thrombosis, Patient.Diagnosis, Patient.Sex, Laboratory.Date
Filters: Examination.Thrombosis = '1', Laboratory.Date LIKE '97%' and Patient.Sex = 'F'
Joins: Examination.Diagnosis = Patient.Diagnosis AND Patient.Diagnosis = Laboratory.Diagnosis
Aggregation: COUNT

NL2SQL: ```sql
SELECT
  COUNT(T1.Diagnosis)
FROM Patient AS T1
INNER JOIN Examination AS T2
  ON T1.Diagnosis = T2.Diagnosis
INNER JOIN Laboratory AS T3
  ON T1.Diagnosis = T3.Diagnosis
WHERE
  T2.Thrombosis = '1' AND T1.Sex = 'F' AND T3.Date LIKE '97%';
```
Critic: ```sql
SELECT
  COUNT(T1.Diagnosis)
FROM Patient AS T1
INNER JOIN Examination AS T2
  ON T1.Diagnosis = T2.Diagnosis
INNER JOIN Laboratory AS T3
  ON T1.First_Date = T3.Date
WHERE
  T2.Thrombosis = '1' AND T1.Sex = 'F' AND T3.Date LIKE '97%';
```
=====================
Question: What are the symptoms observed by the youngest patient to ever did a medical examination? Identify their diagnosis.
 db_id: thrombosis_prediction
Planner: Here's my plan to determine the symptoms and diagnosis of the youngest patient who underwent a medical examination:

1.  **Find the youngest patient:**
    *   I'll use the `Patient` table.
    *   I'll find the maximum `Birthday` value to identify the youngest patient's ID.

2.  **Retrieve the symptoms and diagnosis:**
    *   I'll use the `Examination` table, filtered by the youngest patient's ID obtained from step 1.
    *   I'll select `Symptoms` and `Diagnosis` from the `Examination` table.

Essentially, I will first identify the youngest patient from the 'Patient' table and then retrieve the symptoms and diagnosis details for that patient from the 'Examination' table.

NL2SQL: ```sql
SELECT
  T1.Symptoms,
  T1.Diagnosis
FROM Examination AS T1
INNER JOIN Patient AS T2
  ON T1.ID = T2.ID
WHERE
  T2.Birthday = (
    SELECT
      MAX(Birthday)
    FROM Patient
  );
```
Critic: ```sql
SELECT
  T1.Symptoms,
  T1.Diagnosis
FROM Examination AS T1
INNER JOIN Patient AS T2
  ON T1.ID = T2.ID
WHERE
  T2.Birthday = (
    SELECT
      MAX(Birthday)
    FROM Patient
  );
```
=====================
Question: The oldest SJS patient's medical laboratory work was completed on what date, and what age was the patient when they initially arrived at the hospital?
 db_id: thrombosis_prediction
Planner: Plan:

1.  Find the oldest patient who has a 'SJS' diagnosis by finding the minimum birthday from the Patient table.
2.  Find the laboratory `Date` associated with that patient from the Laboratory table.
3.  Calculate the age of the patient at their first arrival at the hospital by subtracting the birth year from the first date year.
4.  Return the date of the laboratory work and the age.

Tables:

*   `Patient`: To find the oldest 'SJS' patient's birthday and first date.
*   `Laboratory`: To find the date of the laboratory work.

Columns:

*   `Patient`.`Birthday`: To determine the oldest patient.
*   `Patient`.`First Date`: to determine patient age when they first arrived.
*   `Laboratory`.`Date`: To get the date of the laboratory work.
*   `Laboratory`.`ID`: to join tables Patient and Laboratory

Filters:

*   Filter `Patient` table where `Description` contains `SJS`.

Joins:

*   Join `Patient` and `Laboratory` tables on `Patient.ID` = `Laboratory.ID`.

Final Output:

*   `Laboratory.Date`: the date of laboratory work.
*   `age`: Calculated age when first arriving at the hospital.

NL2SQL: ```sql
SELECT
  T1.Date,
  CAST(SUBSTR(T1."Date", 1, 2) AS INTEGER) + 1900 - CAST(SUBSTR(T2.Birthday, 1, 2) AS INTEGER) + 1900
FROM Laboratory AS T1
INNER JOIN Patient AS T2
  ON T1.ID = T2.ID
WHERE
  T2.Birthday = (
    SELECT
      MIN(Birthday)
    FROM Patient
    WHERE
      Description LIKE '%SJS%'
  );
```
Critic: ```sql
SELECT
  T1.Date,
  SUBSTR(T1.Date, 1, 2) - SUBSTR(T2.Birthday, 1, 2)
FROM Laboratory AS T1
INNER JOIN Patient AS T2
  ON T1.ID = T2.ID
WHERE
  T2.Birthday = (
    SELECT
      MIN(Birthday)
    FROM Patient
    WHERE
      Description = 'SJS'
  );
```
=====================
Question: What is the ratio of male to female patients among all those with abnormal uric acid counts?
 db_id: thrombosis_prediction
Planner: Plan:
1.  Join the Laboratory and Patient tables on the common column ID.
2.  Filter the joined table to include only patients with abnormal uric acid counts.
    *   For males (SEX = 'M'), abnormal uric acid is defined as UA <= 8.0.
    *   For females (SEX = 'F'), abnormal uric acid is defined as UA <= 6.5.
3.  Calculate the number of male patients with abnormal uric acid counts.
4.  Calculate the number of female patients with abnormal uric acid counts.
5.  Divide the number of male patients with abnormal uric acid counts by the number of female patients with abnormal uric acid counts to get the ratio.
NL2SQL:
```sql
SELECT
  CAST(SUM(CASE WHEN T1.SEX = 'M' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN T1.SEX = 'F' THEN 1 ELSE 0 END)
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
WHERE
  (
    T1.SEX = 'M' AND T2.UA <= 8.0
  )
  OR (
    T1.SEX = 'F' AND T2.UA <= 6.5
  );
```
NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.SEX = 'M' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN T1.SEX = 'F' THEN 1 ELSE 0 END)
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
WHERE
  (
    T1.SEX = 'M' AND T2.UA <= 8.0
  )
  OR (
    T1.SEX = 'F' AND T2.UA <= 6.5
  );
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.SEX = 'M' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN T1.SEX = 'F' THEN 1 ELSE 0 END)
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
WHERE
  (
    T1.SEX = 'M' AND T2.UA <= 8.0
  ) OR (
    T1.SEX = 'F' AND T2.UA <= 6.5
  );
```
=====================
Question: How many underage patients were examined during the course of the three-year period from 1990 to 1993?
 db_id: thrombosis_prediction
Planner: Plan:
1. Join the Patient and Examination tables on a common ID. The problem description does not provide the joining column. Therefore, I will use the `Diagnosis` column in both tables. This is because `Diagnosis` is a common and relevant field between `Patient` and `Examination`.
2. Filter the joined table based on the following conditions:
    *   The patient's age is less than 18. Extract the year of birth from the `Birthday` column in the Patient table and calculate the age.
    *   The examination date falls between 1990 and 1993. The problem description does not provide the column. Therefore, I will use the `First Date` column in the Patient table.
3. Count the number of distinct patients that meet the specified criteria.
Tables:
*   Patient
*   Examination

Columns:
*   Patient.Birthday
*   Patient.Diagnosis
*   Patient.First Date
*   Examination.Diagnosis

Filters:
*   Year(Patient.Birthday) < 18
*   Year(Patient.First Date) between 1990 and 1993

Joins:
*   Patient.Diagnosis = Examination.Diagnosis
Aggregations:
*   COUNT(DISTINCT Patient.Diagnosis)

NL2SQL: ```sql
SELECT
  COUNT(DISTINCT T1.Diagnosis)
FROM Patient AS T1
INNER JOIN Examination AS T2
  ON T1.Diagnosis = T2.Diagnosis
WHERE
  CAST(SUBSTR(T1.Birthday, 1, 4) AS INTEGER) < 18
  AND CAST(SUBSTR(T1."First Date", 1, 4) AS INTEGER) BETWEEN 1990 AND 1993;
```
Critic: ```sql
SELECT
  COUNT(DISTINCT T1.Diagnosis)
FROM Patient AS T1
INNER JOIN Examination AS T2
  ON T1.Diagnosis = T2.Diagnosis
WHERE
  SUBSTR(T1.Birthday, 1, 4) < '18'
  AND SUBSTR(T2.Symptoms, 1, 4) BETWEEN '1990' AND '1993';
```
=====================
Question: How old was the patient who had the highest hemoglobin count at the time of the examination, and what is the doctor's diagnosis?
 db_id: thrombosis_prediction
Planner: Here's my plan to answer the question using SQL:

1.  **Find the patient with the highest hemoglobin (HGB) count:** I'll use the `Laboratory` table and `MAX(HGB)` to identify the highest hemoglobin value. I'll need the patient's ID from this table.

2.  **Retrieve the patient's birthdate and examination date:**  I'll use the patient's ID (from step 1) to link to the `Patient` table and get the birthdate. I'll need to link it with the examination table to get the examination date

3.  **Calculate the patient's age at the time of examination:**  I'll subtract the birth year from the examination year to get the age.

4.  **Retrieve the doctor's diagnosis:** I'll use the patient's ID (from step 1) to link to the `Examination` table and get the `Diagnosis`.

5.  **Combine the age and diagnosis:**  The final result will include the calculated age and the diagnosis.

I'll need to join `Laboratory` with both `Patient` and `Examination` tables using ID and possibly other relevant fields to retrieve all the necessary information.

NL2SQL: ```sql
SELECT
  SUBSTR(T2."Diagnosis", 1, LENGTH(T2."Diagnosis"))
FROM Laboratory AS T1
INNER JOIN Examination AS T2
  ON T1.ID = T2.LAC
ORDER BY
  T1.HGB DESC
LIMIT 1;
```
Critic: ```sql
SELECT
  P.Diagnosis,
  CAST(SUBSTR(STRFTIME('%Y', E."Examination Date")) AS INTEGER) - CAST(SUBSTR(STRFTIME('%Y', P.Birthday)) AS INTEGER)
FROM Patient AS P
JOIN Laboratory AS L
  ON P.Diagnosis = L.ID
JOIN Examination AS E
  ON P.Diagnosis = E.Diagnosis
ORDER BY
  L.HGB DESC
LIMIT 1;
```
=====================
Question: For the patient who was diagnosed with SLE on 1994/2/19, what was his/her anti-Cardiolipin antibody concentration status on 1993/11/12?
 db_id: thrombosis_prediction
Planner: Plan:
1. Find the patient ID from the Patient table where Diagnosis is 'SLE' and Description is '1994-02-19'.
2. Use the patient ID to find the aCL IgM value from the Examination table where the Examination Date is '1993-11-12'.

Tables: Patient, Examination
Columns:
- Patient: DB_ID, Diagnosis, Description
- Examination: DB_ID, aCL IgM, Examination Date
Filters:
- Patient: Diagnosis = 'SLE', Description = '1994-02-19'
- Examination: Examination Date = '1993-11-12'
Joins:
- Patient.DB_ID = Examination.DB_ID
Output: aCL IgM from Examination table

NL2SQL: ```sql
SELECT
  T2."aCL IgM"
FROM Patient AS T1
INNER JOIN Examination AS T2
  ON T1.DB_ID = T2.DB_ID
WHERE
  T1.Diagnosis = 'SLE' AND T1.Description = '1994-02-19' AND T2."Examination Date" = '1993-11-12';
```
Critic: ```sql
SELECT
  T1."aCL IgM"
FROM Examination AS T1
INNER JOIN Patient AS T2
  ON T1.DB_ID = T2.DB_ID
WHERE
  T2.Diagnosis = 'SLE' AND T2.Description = '1994-02-19' AND T1."Examination Date" = '1993-11-12';
```
=====================
Question: For the patient who was born on 1959/2/18, what is the decrease rate for his/her total cholesterol from November to December in 1981?
 db_id: thrombosis_prediction
Planner: Plan:
1. Filter the Patient table to find the patient with Birthday = '1959-02-18'.
2. Join the Patient table with the Laboratory table using the common ID column.
3. Filter the joined table to include only records from November and December 1981 (Date like '8111%' and Date like '8112%').
4. Calculate the total cholesterol in November 1981 for that patient.
5. Calculate the total cholesterol in December 1981 for that patient.
6. Calculate the decrease rate for total cholesterol from November to December 1981 using the formula: (November T-CHO - December T-CHO) / December T-CHO.
7. Return the decrease rate.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN STRFTIME('%Y', T2.Birthday) = '1959' AND STRFTIME('%m', T2.Birthday) = '02' AND STRFTIME('%d', T2.Birthday) = '18' AND STRFTIME('%Y', T1.Date) = '1981' AND STRFTIME('%m', T1.Date) = '11' THEN T1."T-CHO" ELSE 0 END) - SUM(CASE WHEN STRFTIME('%Y', T2.Birthday) = '1959' AND STRFTIME('%m', T2.Birthday) = '02' AND STRFTIME('%d', T2.Birthday) = '18' AND STRFTIME('%Y', T1.Date) = '1981' AND STRFTIME('%m', T1.Date) = '12' THEN T1."T-CHO" ELSE 0 END) AS REAL) / SUM(CASE WHEN STRFTIME('%Y', T2.Birthday) = '1959' AND STRFTIME('%m', T2.Birthday) = '02' AND STRFTIME('%d', T2.Birthday) = '18' AND STRFTIME('%Y', T1.Date) = '1981' AND STRFTIME('%m', T1.Date) = '12' THEN T1."T-CHO" ELSE 0 END)
FROM Laboratory AS T1
INNER JOIN Patient AS T2
  ON T1.ID = T2."First Date";
```
Critic: ```sql
SELECT
  CAST((
    SUM(CASE WHEN T2.Birthday = '1959-02-18' AND STRFTIME('%Y-%m', T1.Date) = '1981-11' THEN T1."T-CHO" ELSE 0 END) - SUM(CASE WHEN T2.Birthday = '1959-02-18' AND STRFTIME('%Y-%m', T1.Date) = '1981-12' THEN T1."T-CHO" ELSE 0 END)
  ) AS REAL) * 100 / SUM(CASE WHEN T2.Birthday = '1959-02-18' AND STRFTIME('%Y-%m', T1.Date) = '1981-11' THEN T1."T-CHO" ELSE 0 END)
FROM Laboratory AS T1
INNER JOIN Patient AS T2
  ON T1.ID = T2."First Date";
```
=====================
Question: How many patients who were examined between 1987/7/6 and 1996/1/31 had a GPT level greater than 30 and an ALB level less than 4? List them by their ID.
 db_id: thrombosis_prediction
Planner: Plan:

1.  Join the `Laboratory` and `Patient` tables on `ID`.
2.  Filter the joined table to include only records where `GPT` is greater than 30 and `ALB` is less than 4. (GPT > 30 and ALB < 4)
3.  Filter by the date (Date BETWEEN '1987-07-06' AND '1996-01-31').
4.  Select the distinct `ID` values.
5.  Count the distinct `ID` values.

NL2SQL: ```sql
SELECT
  COUNT(DISTINCT T1.ID)
FROM Laboratory AS T1
INNER JOIN Patient AS T2
  ON T1.ID = T2.ID
WHERE
  T1.GPT > 30
  AND T2.Birthday BETWEEN '1987-07-06' AND '1996-01-31';
```
Critic: ```sql
SELECT DISTINCT
  T1.ID
FROM Laboratory AS T1
INNER JOIN Examination AS T2
  ON T1.ID = T2.ID
WHERE
  T1.GPT > 30
  AND T1.ALB < 4
  AND T2.Date BETWEEN '1987-07-06' AND '1996-01-31';
```
=====================
Question: What number of patients with a degree of thrombosis level 2 and ANA pattern of only S, have a level of anti-Cardiolip in antibody (IgM) 20% higher than average?
 db_id: thrombosis_prediction
Planner: Plan:

1.  Calculate the average 'aCL IgM' from the Examination table.
2.  Calculate the threshold for 'aCL IgM' which is 20% higher than the average 'aCL IgM'.
3.  Filter the Examination table to include only patients with Thrombosis = 2 and ANA = 'S' and 'aCL IgM' greater than the calculated threshold.
4.  Count the distinct number of patients based on the filtered results.

NL2SQL: ```sql
SELECT
  COUNT(DISTINCT CASE WHEN T1.Thrombosis = 2 AND T1.ANA = 'S' AND T1.`aCL IgM` > (
    SELECT
      AVG(T2.`aCL IgM`) * 1.2
    FROM Examination AS T2
  ) THEN T1.PatientID ELSE NULL END)
FROM Examination AS T1;
```
Critic: ```sql
SELECT
  COUNT(CASE WHEN T1.Thrombosis = 2 AND T1.ANA = 'S' AND T1.`aCL IgM` > (SELECT AVG(`aCL IgM`) * 1.2 FROM Examination) THEN 1 ELSE NULL END)
FROM Examination AS T1;
```
=====================
Question: List all patients who were followed up at the outpatient clinic who underwent a laboratory test in October 1991 and had a total blood bilirubin level within the normal range.
 db_id: thrombosis_prediction
Planner: Plan:
1. Identify patients who underwent a laboratory test in October 1991. Use the Laboratory table and filter the Date column for '9110%'.
2. Filter for patients who have total blood bilirubin level (T-BIL) within the normal range (T-BIL < 2.0). Use the Laboratory table and filter the T-BIL column.
3. Identify patients who were followed up at the outpatient clinic. This information might be available in the Examination table where Admission = '-'.
4. Join Laboratory and Examination tables using a common column that identifies the patient (ID in Laboratory table and DB_ID in Examination table seem to be the connecting columns).
5. Select the distinct patient IDs.
Tables:
- Laboratory: To filter by 'Date' and 'T-BIL' to identify lab tests done in October 1991 with normal bilirubin levels.
- Examination: To filter for patients followed up at the outpatient clinic (Admission = '-').
Columns:
- Laboratory.ID: Patient ID in laboratory table
- Laboratory.Date: Date of the lab test
- Laboratory.T-BIL: Total bilirubin level
- Examination.DB_ID: Patient ID in examination table
- Examination.Admission: To filter outpatient visits
Filters:
- Laboratory.Date LIKE '9110%'
- Laboratory.T-BIL < 2.0
- Examination.Admission = '-'
Joins:
- Laboratory JOIN Examination ON Laboratory.ID = Examination.DB_ID
Final Select:
- Select the distinct IDs of the patients.

NL2SQL: ```sql
SELECT DISTINCT L.ID
FROM Laboratory AS L
JOIN Examination AS E ON L.ID = E.DB_ID
WHERE L.Date LIKE '9110%'
  AND L."T-BIL" < 2.0
  AND E.Diagnosis = '-';
```
Critic: ```sql
SELECT DISTINCT L.ID
FROM Laboratory AS L
JOIN Patient AS P ON L.ID = P.ID
JOIN Examination AS E ON P.ID = E.DB_ID
WHERE L.Date LIKE '9110%'
  AND L."T-BIL" < 2.0
  AND E.Evidence = '-';
```
=====================
Question: What is the average blood albumin level for female patients with a PLT greater than 400 who have been diagnosed with SLE?
 db_id: thrombosis_prediction
Planner: Plan:
1.  From the `Patient` table, filter for female patients (`SEX = 'F'`) and patients diagnosed with SLE (`Diagnosis = 'SLE'`).
2.  From the `Laboratory` table, filter for patients with `PLT > 400`.
3.  Join the `Patient` and `Laboratory` tables using the common patient identifier (likely `PatientID`).
4.  Calculate the average `ALB` (albumin) for the joined and filtered data.
5.  Return the calculated average albumin level.

Tables: `Patient`, `Laboratory`

Columns:
*   `Patient`: `PatientID`, `SEX`, `Diagnosis`
*   `Laboratory`: `PatientID`, `ALB`, `PLT`

Filters:
*   `Patient`: `SEX = 'F'`, `Diagnosis = 'SLE'`
*   `Laboratory`: `PLT > 400`

Join: `Patient.PatientID = Laboratory.PatientID`

Aggregation: `AVG(Laboratory.ALB)`

NL2SQL: ```sql
SELECT avg(T1.ALB) FROM Laboratory AS T1 JOIN Patient AS T2 ON T1.PatientID = T2.PatientID WHERE T2.SEX = 'F' AND T2.Diagnosis = 'SLE' AND T1.PLT > 400
```
Critic: ```sql
SELECT avg(T1.ALB) FROM Laboratory AS T1 JOIN Patient AS T2 ON T1.PatientID = T2.PatientID WHERE T2.SEX = 'F' AND T1.PLT > 400 AND T2.Diagnosis = 'SLE'
```
=====================
Question: How many female patients were given an APS diagnosis?
 db_id: thrombosis_prediction
Planner: Plan:
1. Filter the Patient table for female patients (SEX = 'F').
2. Filter the Patient table for patients with an 'APS' diagnosis.
3. Find the intersection of these two filtered sets of patients by counting the number of patients who satisfy both conditions.
4. Count the number of patients that satisfy both conditions.

NL2SQL: ```sql
SELECT
  COUNT(CASE WHEN T1.SEX = 'F' THEN T1.Diagnosis ELSE NULL END)
FROM Patient AS T1
WHERE
  T1.Diagnosis = 'APS';
```
Critic: ```sql
SELECT
  COUNT(*)
FROM Patient
WHERE
  SEX = 'F' AND Diagnosis = 'APS';
```
=====================
Question: What percentage of patients who were born in 1980 and were diagnosed with RA are women?
 db_id: thrombosis_prediction
Planner: Plan:
1. Filter the `Patient` table to include only patients born in 1980 (YEAR(Birthday) = 1980) and diagnosed with RA (Diagnosis = 'RA').
2. Count the total number of patients satisfying these criteria.
3. Count the number of female patients (SEX = 'F') among those patients.
4. Calculate the percentage of female patients by dividing the number of female patients by the total number of patients and multiplying by 100.
5. Return the calculated percentage.
Columns required: Patient.Birthday, Patient.Diagnosis, Patient.SEX
Tables required: Patient
Filters: YEAR(Patient.Birthday) = 1980, Patient.Diagnosis = 'RA', Patient.SEX = 'F'
Aggregations: COUNT(Patient.SEX), SUM(CASE WHEN Patient.SEX = 'F' THEN 1 ELSE 0 END)
Final Calculation: (Number of female patients / Total number of patients) * 100

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN SEX = 'F' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(SEX)
FROM Patient
WHERE
  STRFTIME('%Y', Birthday) = '1980' AND Diagnosis = 'RA';
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN SEX = 'F' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(SEX)
FROM Patient
WHERE
  STRFTIME('%Y', Birthday) = '1980' AND Diagnosis = 'RA';
```
=====================
Question: Was the patient with the number 57266's uric acid within a normal range?
 db_id: thrombosis_prediction
Planner: Plan:
1. Find the patient's sex from the Patient table using the patient ID.
2. Find the patient's uric acid (UA) from the Laboratory table using the patient ID.
3. Compare the patient's uric acid level to the normal range based on their sex.
4. Return 'true' if the uric acid is within the normal range, and 'false' otherwise.

Tables:
- Patient: To get the patient's sex (SEX).
- Laboratory: To get the patient's uric acid (UA).

Columns:
- Patient: ID, SEX
- Laboratory: ID, UA

Filters:
- Patient: ID = 57266
- Laboratory: ID = 57266

Joins:
- None needed, as we'll perform separate queries to the two tables

Conditional Logic:
- If SEX = 'M', then check if UA <= 8.0
- If SEX = 'F', then check if UA <= 6.5
- If either condition is true return true, false otherwise.

NL2SQL: ```sql
SELECT
  CASE
    WHEN (
      SELECT
        SEX
      FROM Patient
      WHERE
        ID = 57266
    ) = 'M'
    AND (
      SELECT
        UA
      FROM Laboratory
      WHERE
        ID = 57266
    ) <= 8.0
    THEN 'true'
    WHEN (
      SELECT
        SEX
      FROM Patient
      WHERE
        ID = 57266
    ) = 'F'
    AND (
      SELECT
        UA
      FROM Laboratory
      WHERE
        ID = 57266
    ) <= 6.5
    THEN 'true'
    ELSE 'false'
  END;
```
Critic: ```sql
SELECT
  CASE
    WHEN T1.SEX = 'M' AND T2.UA > 8.0 THEN 'true'
    WHEN T1.SEX = 'F' AND T2.UA > 6.5 THEN 'true'
    ELSE 'false'
  END
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
WHERE
  T1.ID = 57266
LIMIT 1;
```
=====================
Question: Provide IDs for male patients with ALT glutamic pylvic transaminase (GPT) that have history of ALT glutamic pylvic transaminase (GPT) exceed the normal range.
 db_id: thrombosis_prediction
Planner: Plan:
1. Filter the `Patient` table for male patients (SEX = 'M').
2. Filter the `Laboratory` table for GPT values exceeding the normal range (GPT >= 60).
3. Join `Patient` and `Laboratory` tables on Patient.ID = Laboratory.ID.
4. Select the Patient.ID from the joined table.

NL2SQL: ```sql
SELECT DISTINCT
  T1.ID
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
WHERE
  T1.SEX = 'M' AND T2.GPT >= 60;
```
Critic: ```sql
SELECT DISTINCT
  ID
FROM Patient
WHERE
  SEX = 'M'
  AND ID IN (
    SELECT
      ID
    FROM Laboratory
    WHERE
      GPT >= 60
  );
```
=====================
Question: Please provide the diagnosis of patients with ALT glutamic pylvic transaminase beyond the normal range by ascending order of their date of birth.
 db_id: thrombosis_prediction
Planner: Plan:
1. Filter the Laboratory table for records where GPT > 60.
2. Join the Laboratory table with the Patient table on the ID column.
3. Select the Diagnosis column from the Patient table and the Birthday from the Patient table.
4. Order the results by Birthday in ascending order.

NL2SQL: ```sql
SELECT
  p.Diagnosis
FROM Laboratory AS l
JOIN Patient AS p
  ON l.ID = p.ID
WHERE
  l.GPT > 60
ORDER BY
  p.Birthday;
```
Critic: ```sql
SELECT
  T1.Diagnosis
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
WHERE
  T2.GPT > 60
ORDER BY
  T1.Birthday
ASC;
```
=====================
Question: Provide all ID, sex and birthday of patients whose urea nitrogen (UN) just within the borderline of passing?
 db_id: thrombosis_prediction
Planner: Plan:
The question asks for the ID, sex and birthday of patients with a specific UN value.
1. Select the ID, SEX and Birthday columns from the Patient table.
2. Filter the result based on a condition on the Laboratory table.
3. Join the Patient table and the Laboratory table on the ID column.
4. Filter the joined table where the UN column in the Laboratory table equals 29.

NL2SQL: ```sql
SELECT
  T1.ID,
  T1.SEX,
  T1.Birthday
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
WHERE
  T2.UN = 29;
```
Critic: ```sql
SELECT
  ID,
  Sex,
  Birthday
FROM Patient
WHERE
  ID IN (
    SELECT
      ID
    FROM Laboratory
    WHERE
      UN = 29
  );
```
=====================
Question: List and group all patients by sex for total bilirubin (T-BIL) level not within the normal range.
 db_id: thrombosis_prediction
Planner: Plan:
1. Join the Patient and Laboratory tables on the ID column.
2. Filter the results to include only records where T-BIL is greater than or equal to 2.0.
3. Group the results by sex.
4. Concatenate the IDs for each sex group.
5. Select the sex and concatenated IDs.

NL2SQL: ```sql
SELECT
  p.SEX,
  GROUP_CONCAT(DISTINCT p.ID)
FROM Patient AS p
JOIN Laboratory AS l
  ON p.ID = l.ID
WHERE
  l."T-BIL" >= 2.0
GROUP BY
  p.SEX;
```
Critic: ```sql
SELECT
  p.SEX,
  GROUP_CONCAT(DISTINCT p.ID)
FROM Patient AS p
JOIN Laboratory AS l
  ON p.ID = l.ID
WHERE
  l."T-BIL" >= 2.0
GROUP BY
  p.SEX;
```
=====================
Question: What is the average age of the male patient with high cholesterol?
 db_id: thrombosis_prediction
Planner: Here's my plan to calculate the average age of male patients with high cholesterol:

1.  **Identify the relevant tables:** We need the `Patient` table to get the patient's sex and birthday, and the `Laboratory` table to check their cholesterol level.
2.  **Filter for male patients:** Filter the `Patient` table to include only patients where `SEX` is 'M'.
3.  **Filter for high cholesterol:** Filter the `Laboratory` table to include only records where `T-CHO` (total cholesterol) is greater than or equal to 250.
4.  **Join the tables:** Join the `Patient` and `Laboratory` tables using the `ID` column.
5.  **Calculate age:** Calculate the age of each patient using the formula `YEAR(NOW()) - YEAR(Birthday)`.
6.  **Calculate the average age:** Calculate the average of the calculated ages.
7.  **Return the result:** Return the average age.

```sql
-- Calculate the average age of male patients with high cholesterol
SELECT avg(strftime('%Y', 'now') - strftime('%Y', T1.Birthday))
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
WHERE
  T1.SEX = 'M' AND T2."T-CHO" >= 250;
```

NL2SQL: ```sql
SELECT avg(CAST(strftime('%Y', 'now') AS INTEGER) - CAST(strftime('%Y', T1.Birthday) AS INTEGER)) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'M' AND T2."T-CHO" >= 250
```
Critic: ```sql
SELECT avg(CAST(strftime('%Y', 'now') AS INTEGER) - CAST(strftime('%Y', Birthday) AS INTEGER)) FROM patient WHERE SEX = 'M' INTERSECT SELECT avg(CAST(strftime('%Y', 'now') AS INTEGER) - CAST(strftime('%Y', T1.Birthday) AS INTEGER)) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2."T-CHO" > 250
```
=====================
Question: For all patients with triglyceride (TG) level beyond the normal range, how many are age more than 50 years?
 db_id: thrombosis_prediction
Planner: Plan:
1. Filter the `Laboratory` table to find patients with TG >= 200.
2. Join the filtered `Laboratory` table with the `Patient` table using the `ID` column.
3. Filter the joined table to find patients whose age is greater than 50 years.
4. Count the distinct number of patient IDs satisfying the conditions.
5. Return the count.

NL2SQL: ```sql
SELECT
  COUNT(DISTINCT T1.ID)
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
WHERE
  T2.TG >= 200 AND CAST(SUBSTR(STRFTIME('%Y', 'now'), 3, 2) AS INTEGER) - CAST(SUBSTR(STRFTIME('%Y', T1.Birthday), 3, 2) AS INTEGER) > 50;
```
Critic: ```sql
SELECT
  COUNT(DISTINCT T1.ID)
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
WHERE
  T2.TG >= 200 AND CAST(SUBSTR(STRFTIME('%Y', 'now'), 1, 4) AS INTEGER) - CAST(SUBSTR(STRFTIME('%Y', T1.Birthday), 1, 4) AS INTEGER) > 50;
```
=====================
Question: For patient born between 1936-1956, how many male patients have creatinine phosphokinase beyond the normal range?
 db_id: thrombosis_prediction
Planner: 1.  **Filter Patient Table:** Filter the `Patient` table to include patients born between 1936 and 1956 (inclusive) and whose sex is male ('M').
2.  **Join Patient and Laboratory Tables:** Join the filtered `Patient` table with the `Laboratory` table using the `ID` column.
3.  **Filter Laboratory Table:** Filter the joined table to include only records where `CPK` is greater than or equal to 250.
4.  **Count Distinct Patient IDs:** Count the distinct `ID` values from the resulting table. This represents the number of unique male patients born between 1936 and 1956 with creatinine phosphokinase beyond the normal range (CPK >= 250).

NL2SQL: ```sql
SELECT
  COUNT(DISTINCT T1.ID)
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
WHERE
  STRFTIME('%Y', T1.Birthday) BETWEEN '1936' AND '1956'
  AND T1.SEX = 'M'
  AND T2.CPK >= 250;
```
Critic: ```sql
SELECT
  COUNT(DISTINCT T1.ID)
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
WHERE
  T1.SEX = 'M' AND STRFTIME('%Y', T1.Birthday) BETWEEN '1936' AND '1956' AND T2.CPK >= 250;
```
=====================
Question: Provide ID, sex and age of patient who has blood glucose (GLU) not within normal range but with total cholesterol(T-CHO) within normal range.
 db_id: thrombosis_prediction
Planner: Plan:
1. Filter the `Laboratory` table to find patients with `GLU` >= 180 and `T-CHO` < 250.
2. Join the filtered `Laboratory` table with the `Patient` table using the `ID` column.
3. Calculate the age of each patient using `Birthday` column from `Patient` table.
4. Select `ID`, `SEX`, and calculated age from the joined table.

NL2SQL: ```sql
SELECT
  p.ID,
  p.SEX,
  CAST(SUBSTR(STRFTIME('%Y', 'now'), 3, 2) AS INTEGER) - CAST(SUBSTR(STRFTIME('%Y', p.Birthday), 3, 2) AS INTEGER)
FROM Patient AS p
JOIN Laboratory AS l
  ON p.ID = l.ID
WHERE
  l.GLU >= 180 AND l."T-CHO" < 250;
```
Critic: ```sql
SELECT
  p.ID,
  p.SEX,
  CAST(SUBSTR(STRFTIME('%Y', 'now'), 3, 2) AS INTEGER) - CAST(SUBSTR(STRFTIME('%Y', p.Birthday), 3, 2) AS INTEGER)
FROM Patient AS p
INNER JOIN Laboratory AS l
  ON p.ID = l.ID
WHERE
  l.GLU >= 180 AND l."T-CHO" < 250;
```
=====================
Question: What are the patient's diagnosis for those who has lower red blood blood cell? State their ID and age.
 db_id: thrombosis_prediction
Planner: Plan:
1. Filter the `Laboratory` table for patients with RBC < 3.5.
2. Join the filtered `Laboratory` table with the `Patient` table on `ID`.
3. Select the `ID`, age calculated from `Birthday`, and `Diagnosis` columns.
4. Display the result.

NL2SQL: ```sql
SELECT
  P.ID,
  STRFTIME('%Y', 'now') - STRFTIME('%Y', P.Birthday),
  P.Diagnosis
FROM Patient AS P
JOIN Laboratory AS L
  ON P.ID = L.ID
WHERE
  L.RBC < 3.5;
```
Critic: ```sql
SELECT
  P.ID,
  STRFTIME('%Y', 'now') - STRFTIME('%Y', P.Birthday),
  P.Diagnosis
FROM Patient AS P
JOIN Laboratory AS L
  ON P.ID = L.ID
WHERE
  L.RBC < 3.5;
```
=====================
Question: Among the patients who were diagnosed with SLE, who is the oldest with normal hemoglobin level. Provide the ID and sex.
 db_id: thrombosis_prediction
Planner: Here's my plan to identify the oldest SLE patient with normal hemoglobin:

1.  **Filter Patients with SLE:** Select patients from the `Patient` table where `Diagnosis` is 'SLE'.
2.  **Identify Normal Hemoglobin:** From the `Laboratory` table, filter for records where `HGB` is between 10 and 17.
3.  **Join Tables:** Join the filtered `Patient` and `Laboratory` tables on `ID` to link patient information with their hemoglobin levels.
4.  **Find the Oldest Patient:** Order the results by `Birthday` in ascending order (oldest first) and select the first record.
5.  **Output ID and SEX:** Retrieve the `ID` and `SEX` of the oldest patient.

NL2SQL: ```sql
SELECT
  T1.ID,
  T1.SEX
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
WHERE
  T1.Diagnosis = 'SLE' AND T2.HGB > 10 AND T2.HGB < 17
ORDER BY
  T1.Birthday
LIMIT 1;
```
Critic: ```sql
SELECT
  T1.ID,
  T1.SEX
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
WHERE
  T1.Diagnosis = 'SLE' AND T2.HGB > 10 AND T2.HGB < 17
ORDER BY
  T1.Birthday
LIMIT 1;
```
=====================
Question: Name the ID and age of patient with two or more laboratory examinations which show their hematoclit level exceeded the normal range.
 db_id: thrombosis_prediction
Planner: Here's a plan to retrieve the requested information:

1.  **Join Tables:** We need to join the `Patient` and `Laboratory` tables on the `ID` column to link patient information with their lab results.
2.  **Filter for High Hematocrit:** Filter the joined table to include only records where `HCT` (Hematocrit) is greater than or equal to 52.
3.  **Group by Patient ID:** Group the results by `ID` (patient ID) to count the number of lab examinations with high hematocrit for each patient.
4.  **Filter for Count:** Filter the grouped results to include only patients where the count of high hematocrit examinations is greater than or equal to 2.
5.  **Calculate Age:** Calculate the age of each patient using `Birthday` and the current date.
6.  **Select and Return:** Select the `ID` and calculated `age` for the patients that meet the criteria.

NL2SQL: ```sql
SELECT
  p.ID,
  CAST(SUBSTR(STRFTIME('%Y', 'now'), 3, 2) AS INTEGER) - CAST(SUBSTR(STRFTIME('%Y', p.Birthday), 3, 2) AS INTEGER)
FROM Patient AS p
JOIN Laboratory AS l
  ON p.ID = l.ID
WHERE
  l.HCT >= 52
GROUP BY
  p.ID
HAVING
  COUNT(l.ID) >= 2;
```
Critic: ```sql
SELECT
  p.ID,
  CAST(SUBSTR(STRFTIME('%Y', 'now'), 3, 2) AS INTEGER) - CAST(SUBSTR(STRFTIME('%Y', p.Birthday), 3, 2) AS INTEGER)
FROM Patient AS p
JOIN Laboratory AS l
  ON p.ID = l.ID
WHERE
  l.HCT >= 52
GROUP BY
  p.ID
HAVING
  COUNT(l.ID) >= 2;
```
=====================
Question: For patients with abnormal platelet level, state the number of patients with lower than normal range. How is it compare to the number of patients with higher than normal range?
 db_id: thrombosis_prediction
Planner: Here's my plan to determine the difference between the number of patients with lower than normal and higher than normal platelet levels:

1.  **Identify patients with abnormal platelet levels:** Filter the `Laboratory` table where `PLT` is either less than 100 (lower than normal) or greater than 400 (higher than normal).
2.  **Count patients with lower than normal platelet levels:** Count the number of records where `PLT` is less than 100.
3.  **Count patients with higher than normal platelet levels:** Count the number of records where `PLT` is greater than 400.
4.  **Calculate the difference:** Subtract the count of patients with higher than normal platelet levels from the count of patients with lower than normal platelet levels.

I will use the `Laboratory` table and its `PLT` column.

NL2SQL: ```sql
SELECT
  SUM(CASE WHEN PLT < 100 THEN 1 ELSE 0 END) - SUM(CASE WHEN PLT > 400 THEN 1 ELSE 0 END)
FROM Laboratory;
```
Critic: ```sql
SELECT
  SUM(CASE WHEN PLT < 100 THEN 1 ELSE 0 END),
  SUM(CASE WHEN PLT > 400 THEN 1 ELSE 0 END)
FROM Laboratory;
```
=====================
Question: For laboratory examinations take in 1984, list all patients below 50 years old with normal platelet level.
 db_id: thrombosis_prediction
Planner: Here's the plan to retrieve the required information:

1.  **Join Tables:** Join the `Laboratory` and `Patient` tables on their common `ID` column.
2.  **Filter by Date:** Filter the joined table to include only records where the year of the `Date` column in the `Laboratory` table is 1984.
3.  **Filter by Age:** Filter the joined table to include only patients who are below 50 years old in 1984. The age is calculated based on the current year (for simplicity) and the `Birthday` column in the `Patient` table.
4.  **Filter by Platelet Level:** Filter the joined table to include only records where the `PLT` (platelet) level in the `Laboratory` table is within the normal range (between 100 and 400).
5.  **Select Patient IDs:** Select the `ID` column from the joined table.

NL2SQL: ```sql
SELECT
  T1.ID
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
WHERE
  CAST(strftime('%Y', T2.Date) AS INTEGER) = 1984
  AND CAST(strftime('%Y', 'now') AS INTEGER) - CAST(strftime('%Y', T1.Birthday) AS INTEGER) < 50
  AND T2.PLT BETWEEN 100 AND 400;
```
Critic: ```sql
SELECT
  T1.ID
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
WHERE
  STRFTIME('%Y', T2.Date) = '1984'
  AND STRFTIME('%Y', 'now') - STRFTIME('%Y', T1.Birthday) < 50
  AND T2.PLT BETWEEN 100 AND 400;
```
=====================
Question: For all patients who are older than 55 years old, what is the percentage of female who has abnormal prothrombin time (PT)?
 db_id: thrombosis_prediction
Planner: Plan:
1. Join the `Patient` and `Laboratory` tables on `ID`.
2. Filter for patients older than 55 years old (age can be derived from the `Birthday` column).
3. Filter for abnormal prothrombin time (PT >= 14).
4. Count the number of female patients with abnormal PT.
5. Count the total number of patients with abnormal PT.
6. Calculate the percentage of female patients with abnormal PT out of all patients with abnormal PT.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.SEX = 'F' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.ID)
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
WHERE
  T2.PT >= 14 AND SUBSTR(T1.Birthday, 1, 4) < CAST(STRFTIME('%Y', 'now') AS INTEGER) - 55;
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.SEX = 'F' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.ID)
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
WHERE
  T2.PT >= 14 AND CAST(SUBSTR(T1.Birthday, 1, 4) AS INTEGER) < CAST(STRFTIME('%Y', 'now') AS INTEGER) - 55;
```
=====================
Question: Among the male patients who have a normal level of white blood cells, how many of them have an abnormal fibrinogen level?
 db_id: thrombosis_prediction
Planner: 1.  Filter the `Patient` table to select male patients (SEX = 'M').
2.  Filter the `Laboratory` table to select patients with normal white blood cell levels (WBC > 3.5 and WBC < 9.0) and abnormal fibrinogen levels (FG <= 150 or FG >= 450).
3.  Join the filtered `Patient` and `Laboratory` tables on the common column `ID`.
4.  Count the number of distinct patients.

NL2SQL: ```sql
SELECT
  COUNT(DISTINCT T1.ID)
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
WHERE
  T1.SEX = 'M' AND (
    T2.WBC > 3.5 AND T2.WBC < 9.0
  ) AND (
    T2.FG <= 150 OR T2.FG >= 450
  );
```
Critic: ```sql
SELECT
  COUNT(T1.ID)
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
WHERE
  T1.SEX = 'M' AND T2.WBC > 3.5 AND T2.WBC < 9.0 AND (
    T2.FG <= 150 OR T2.FG >= 450
  );
```
=====================
Question: How many patients with an Ig G higher than normal?
 db_id: thrombosis_prediction
Planner: 1.  Find the relevant table: The `Laboratory` table contains `IGG` (Ig G) values.
2.  Filter the table: Filter the `Laboratory` table to include only records where `IGG` is greater than or equal to 2000.
3.  Count the number of distinct patients: Count the distinct `ID` values in the filtered table. This will give the number of patients with an Ig G higher than normal.

NL2SQL: ```sql
SELECT
  COUNT(DISTINCT ID)
FROM Laboratory
WHERE
  IGG >= 2000;
```
Critic: ```sql
SELECT
  COUNT(DISTINCT ID)
FROM Laboratory
WHERE
  IGG > 2000;
```
=====================
Question: Among the patients with a normal Ig G level, how many of them have symptoms?
 db_id: thrombosis_prediction
Planner: Here's my plan to determine the number of patients with normal Ig G levels who also exhibit symptoms:

1.  **Identify patients with normal Ig G levels:**
    *   Use the `Laboratory` table.
    *   Filter for records where `IGG` is greater than 900 and less than 2000.

2.  **Identify patients with symptoms:**
    *   Use the `Examination` table.
    *   Filter for records where `Symptoms` is not null.

3.  **Join tables:**
    *   Join `Laboratory` and `Examination` tables on the `ID` column.

4.  **Count the matching patients:**
    *   Count the distinct `ID` values from the joined table that satisfy both conditions (normal Ig G and symptoms).

NL2SQL: ```sql
SELECT
  COUNT(DISTINCT T1.ID)
FROM Laboratory AS T1
INNER JOIN Examination AS T2
  ON T1.ID = T2.ID
WHERE
  T1.IGG > 900 AND T1.IGG < 2000 AND T2.Symptoms IS NOT NULL;
```
Critic: ```sql
SELECT
  COUNT(DISTINCT T1.ID)
FROM Laboratory AS T1
INNER JOIN Examination AS T2
  ON T1.ID = T2.ID
WHERE
  T1.IGG > 900 AND T1.IGG < 2000 AND T2.Symptoms IS NOT NULL;
```
=====================
Question: How many patients with a normal Ig A level came to the hospital after 1990/1/1?
 db_id: thrombosis_prediction
Planner: Plan:
1. Filter the Patient table to include only patients with `First Date` after 1990/1/1.
2. Filter the Laboratory table to include only patients with normal IgA levels (IGA > 80 AND IGA < 500).
3. Join the filtered Patient and Laboratory tables on the `ID` column.
4. Count the number of distinct patient IDs in the joined table.
SQL:
```sql
SELECT
  COUNT(DISTINCT p.ID)
FROM Patient AS p
JOIN Laboratory AS l
  ON p.ID = l.ID
WHERE
  p."First Date" >= '1990-01-01' AND l.IGA > 80 AND l.IGA < 500;
```
NL2SQL: ```sql
SELECT
  COUNT(DISTINCT T1.ID)
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
WHERE
  T2.IGA > 80 AND T2.IGA < 500 AND T1."First Date" >= '1990-01-01'
```
Critic: ```sql
SELECT
  COUNT(DISTINCT T1.ID)
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
WHERE
  T2.IGA > 80 AND T2.IGA < 500 AND T1."First Date" >= '1990-01-01'
```
=====================
Question: For the patients with an abnormal Ig M level, what is the most common disease they are diagnosed with?
 db_id: thrombosis_prediction
Planner: Here's the plan to determine the most common diagnosis for patients with abnormal Ig M levels:

1.  **Identify patients with abnormal Ig M:**
    *   Use the `Laboratory` table.
    *   Filter for rows where `IGM <= 40 OR IGM >= 400`.
    *   Select the `ID` (patient ID) from these rows.
2.  **Join with the Patient table:**
    *   Join the result from step 1 with the `Patient` table using the `ID` column.
    *   This will give us the diagnoses for the patients identified in step 1.
3.  **Count diagnoses and find the most common:**
    *   Group the results by `Diagnosis`.
    *   Count the occurrences of each `Diagnosis`.
    *   Order by count descending.
    *   Take the top `Diagnosis` to get the most frequent one.

NL2SQL: ```sql
SELECT Diagnosis FROM Patient WHERE ID IN (SELECT ID FROM Laboratory WHERE IGM <= 40 OR IGM >= 400) GROUP BY Diagnosis ORDER BY COUNT(*) DESC LIMIT 1
```
Critic: ```sql
SELECT Diagnosis FROM Patient WHERE ID IN (SELECT ID FROM Laboratory WHERE IGM <= 40 OR IGM >= 400) GROUP BY Diagnosis ORDER BY COUNT(*) DESC LIMIT 1
```
=====================
Question: How many patients with a abnormal C-reactive protein don't have their data recorded?
 db_id: thrombosis_prediction
Planner: Here's my plan to determine the number of patients with abnormal C-reactive protein who don't have their data recorded:

1.  **Identify patients with abnormal C-reactive protein:** Filter the `Laboratory` table for records where `CRP` is '+'. We need the `ID` column from this filtered table.
2.  **Identify patients with missing data recorded:** Filter the `Patient` table for records where `Description` is NULL. We need the `ID` column from this filtered table.
3.  **Find the intersection:** Find the common `ID`s between the two ID sets created in the first two steps.
4.  **Count the distinct patients:** Count the number of distinct patient IDs resulting from the previous step.

I need the tables `Laboratory` and `Patient`, the columns `Laboratory.ID`, `Laboratory.CRP`, `Patient.ID`, `Patient.Description`.

NL2SQL: ```sql
SELECT
  COUNT(DISTINCT L.ID)
FROM Laboratory AS L
JOIN Patient AS P
  ON L.ID = P.ID
WHERE
  L.CRP = '+' AND P.Description IS NULL;
```
Critic: ```sql
SELECT
  COUNT(CASE WHEN T2.Description IS NULL THEN T1.ID ELSE NULL END)
FROM Laboratory AS T1
INNER JOIN Patient AS T2
  ON T1.ID = T2.ID
WHERE
  T1.CRP = '+';
```
=====================
Question: Among the patients whose creatinine level is abnormal, how many of them aren't 70 yet?
 db_id: thrombosis_prediction
Planner: Plan:
1. Filter the `Laboratory` table to find records where `CRE` >= 1.5.
2. Join the filtered `Laboratory` table with the `Patient` table using `ID`.
3. Filter the joined table to find patients whose age is less than 70, using the formula `YEAR(CURDATE()) - YEAR(Birthday) < 70`.
4. Count the number of distinct patients that satisfy the criteria.
5. Return the count.

NL2SQL: ```sql
SELECT
  COUNT(DISTINCT T1.ID)
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
WHERE
  T2.CRE >= 1.5 AND YEAR(CURDATE()) - YEAR(T1.Birthday) < 70;
```
Critic: ```sql
SELECT
  COUNT(DISTINCT T1.ID)
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
WHERE
  T2.CRE >= 1.5 AND (
    CAST(strftime('%Y', 'now') AS INTEGER) - CAST(strftime('%Y', T1.Birthday) AS INTEGER)
  ) < 70;
```
=====================
Question: How many patients have a normal level of anti-ribonuclear protein and have been admitted to the hospital?
 db_id: thrombosis_prediction
Planner: Here's the plan to answer the question:

1.  **Filter the Patient table:** Select patients who were admitted to the hospital (`Admission = '+'`).
2.  **Filter the Laboratory table:** Select patients whose `RNP` is either '-' or '+-' representing a normal level.
3.  **Join the tables:** Join the `Patient` and `Laboratory` tables on the common column `ID`.
4.  **Count distinct patients:** Count the number of distinct patient IDs to avoid duplicate counts.

The query will need columns `Patient.ID`, `Patient.Admission`, `Laboratory.ID`, and `Laboratory.RNP`.

NL2SQL: ```sql
SELECT
  COUNT(DISTINCT T1.ID)
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
WHERE
  T1.Admission = '+' AND (
    T2.RNP = '-' OR T2.RNP = '+-'
  );
```
Critic: ```sql
SELECT
  COUNT(DISTINCT T1.ID)
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
WHERE
  T1.Admission = '+' AND (
    T2.RNP = '-' OR T2.RNP = '0' OR T2.RNP = '+-'
  );
```
=====================
Question: Among the patients with normal anti-SM, how many of them does not have thrombosis?
 db_id: thrombosis_prediction
Planner: Here's a plan to determine the number of patients with normal anti-SM who do not have thrombosis:

1.  **Identify patients with normal anti-SM:** Filter the `Laboratory` table to include only patients where the `SM` column is either '-' or '+-'.
2.  **Join with the `Examination` table:** Join the filtered `Laboratory` table with the `Examination` table using the `ID` column. This allows us to access the `Thrombosis` information.
3.  **Filter for no thrombosis:** Filter the joined table to include only those patients where `Thrombosis` is 0.
4.  **Count the patients:** Count the number of distinct patient IDs (`ID`) that satisfy both conditions.

The query will use the `Laboratory` and `Examination` tables, joining them on the `ID` column. It will filter based on `SM` and `Thrombosis`. The final result is the count of distinct patient IDs.

NL2SQL: ```sql
SELECT
  COUNT(DISTINCT T1.ID)
FROM Laboratory AS T1
INNER JOIN Examination AS T2
  ON T1.ID = T2.ID
WHERE
  T1.SM IN ('-', '+-') AND T2.Thrombosis = 0;
```
Critic: ```sql
SELECT
  COUNT(DISTINCT T1.ID)
FROM Laboratory AS T1
INNER JOIN Examination AS T2
  ON T1.ID = T2.ID
WHERE
  T1.SM IN ('-', '+-') AND T2.Thrombosis = 0;
```
=====================
Question: Among the patients who has a normal anti-scl70, how many of them are female and does not have any symptom?
 db_id: thrombosis_prediction
Planner: Here's my plan to answer the question:

1.  **Identify the relevant tables:** We need `Patient`, `Laboratory`, and `Examination` tables.
2.  **Filter for patients with normal anti-scl70:** Filter the `Laboratory` table for records where `SC170` is 'negative' or '0'.
3.  **Filter for female patients:** Filter the `Patient` table for records where `SEX` is 'F'.
4.  **Filter for patients without any symptoms:** Filter the `Examination` table for records where `Symptoms` is NULL.
5.  **Join the tables:** Join `Patient` table with `Laboratory` and `Examination` tables on their common column `ID`.
6.  **Count the distinct patients:** Count the number of distinct `ID`s that satisfy all the conditions.

NL2SQL: ```sql
SELECT
  COUNT(DISTINCT T1.ID)
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
INNER JOIN Examination AS T3
  ON T1.ID = T3.ID
WHERE
  T2.SC170 IN ('negative', '0') AND T1.SEX = 'F' AND T3.Symptoms IS NULL;
```
Critic: ```sql
SELECT
  COUNT(DISTINCT T1.ID)
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
LEFT JOIN Examination AS T3
  ON T1.ID = T3.ID
WHERE
  T2.SC170 IN ('negative', '0') AND T1.SEX = 'F' AND T3.Symptoms IS NULL;
```
=====================
Question: Among the patients who has a normal level of anti-centromere and a normal level of anti-SSB, how many of them are male?
 db_id: thrombosis_prediction
Planner: 1.  **Find patients with normal anti-centromere and anti-SSB levels:**
    *   Table: `Laboratory`
    *   Filters: `CENTROMEA IN('-', '+-')` and `SSB IN('-', '+-')`
    *   Columns: `ID`
2.  **Find male patients:**
    *   Table: `Patient`
    *   Filter: `SEX = 'M'`
    *   Columns: `ID`
3.  **Join the two result sets:**
    *   Join `Laboratory` and `Patient` on `Laboratory.ID = Patient.ID`
4.  **Count the distinct number of patients.**


NL2SQL: ```sql
SELECT
  COUNT(DISTINCT T1.ID)
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
WHERE
  T2.CENTROMEA IN ('-', '+-') AND T2.SSB IN ('-', '+-') AND T1.SEX = 'M';
```
Critic: ```sql
SELECT
  COUNT(DISTINCT T1.ID)
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
WHERE
  T2.CENTROMEA IN ('-', '+-') AND T2.SSB IN ('-', '+-') AND T1.SEX = 'Male';
```
=====================
Question: Among the patients who have an abnormal level of glutamic oxaloacetic transaminase, when was the youngest of them born?
 db_id: thrombosis_prediction
Planner: Plan:
1. Filter the `Laboratory` table to find patients with abnormal GOT levels (GOT >= 60).
2. Join the filtered `Laboratory` table with the `Patient` table using the patient ID.
3. Find the maximum (latest) birthday among the patients who satisfy the condition.
4. Return the maximum birthday.

Needed tables: `Laboratory`, `Patient`
Needed columns: `Laboratory.ID`, `Laboratory.GOT`, `Patient.ID`, `Patient.Birthday`
Filters: `Laboratory.GOT >= 60`
Join: `Laboratory.ID = Patient.ID`
Aggregate function: `MAX(Patient.Birthday)`

NL2SQL: ```sql
SELECT
  MAX(T2.Birthday)
FROM Laboratory AS T1
INNER JOIN Patient AS T2
  ON T1.ID = T2.ID
WHERE
  T1.GOT >= 60;
```
Critic: ```sql
SELECT
  MAX(Birthday)
FROM Patient
WHERE
  ID IN (
    SELECT
      ID
    FROM Laboratory
    WHERE
      GOT >= 60
  );
```
=====================
Question: For the patients with a normal range of creatinine phosphokinase, how many of them have a positive measure of degree of coagulation?
 db_id: thrombosis_prediction
Planner: 1.  Filter the `Laboratory` table for patients with normal creatinine phosphokinase (CPK < 250).
2.  Filter the `Examination` table to find the number of patients with a positive measure of degree of coagulation. KCT, RVVT, or LAC equals '+'.
3. Join these two tables on `Patient.ID` = `Laboratory.ID` = `Examination.ID`.
4. Count the number of distinct `Patient.ID`s meeting both criteria.

NL2SQL: ```sql
SELECT
  COUNT(DISTINCT T1.ID)
FROM Laboratory AS T1
INNER JOIN Examination AS T2
  ON T1.ID = T2.ID
WHERE
  T1.CPK < 250 AND (
    T2.KCT = '+' OR T2.RVVT = '+' OR T2.LAC = '+'
  );
```
Critic: ```sql
SELECT
  COUNT(DISTINCT T1.ID)
FROM Laboratory AS T1
INNER JOIN Examination AS T2
  ON T1.ID = T2.ID
WHERE
  T1.CPK < 250 AND (T2.KCT = '+' OR T2.RVVT = '+' OR T2.LAC = '+');
```
=====================
Question: Give the name of the league had the most goals in the 2016 season?
 db_id: european_football_2
Planner: 1. Join `Match` and `League` tables on `league_id` to connect matches to leagues.
2. Filter the `Match` table to include only matches from the '2015/2016' season.
3. Calculate the total goals for each league by summing `home_team_goal` and `away_team_goal`.
4. Group the results by league `name`.
5. Find the league with the maximum total goals.
6. Return the league `name`.

NL2SQL: ```sql
SELECT
  T2.name
FROM Match AS T1
INNER JOIN League AS T2
  ON T1.league_id = T2.id
WHERE
  T1.season = '2015/2016'
GROUP BY
  T2.name
ORDER BY
  SUM(T1.home_team_goal + T1.away_team_goal) DESC
LIMIT 1;
```
Critic: ```sql
SELECT
  T2.name
FROM Match AS T1
INNER JOIN League AS T2
  ON T1.league_id = T2.id
WHERE
  T1.season = '2015/2016'
GROUP BY
  T2.name
ORDER BY
  SUM(T1.home_team_goal + T1.away_team_goal) DESC
LIMIT 1;
```
=====================
Question: In Scotland Premier League, which away team won the most during the 2010 season?
 db_id: european_football_2
Planner: 1. **Filter Matches:** Select matches from the `Match` table where the `season` is '2009/2010'. Also, filter matches where `league_id` corresponds to the Scotland Premier League's `id` from the `League` table.
2. **Determine Away Wins:** Filter the matches where `away_team_goal` is greater than `home_team_goal`.
3. **Count Away Wins per Team:** Group the winning away teams by `away_team_api_id` and count the number of wins for each team.
4. **Find the Maximum Wins:** Determine the maximum number of wins among all away teams.
5. **Identify the Winning Team:** Select the `away_team_api_id` with the maximum wins.
6. **Retrieve Team Name:** Join the result with the `Team` table on `team_api_id` to get the `team_long_name` of the away team that won the most.

NL2SQL: ```sql
SELECT
  T.team_long_name
FROM (
  SELECT
    M.away_team_api_id
  FROM Match AS M
  JOIN League AS L
    ON M.league_id = L.id
  WHERE
    L.name = 'Scotland Premier League' AND M.season = '2009/2010' AND M.away_team_goal > M.home_team_goal
  GROUP BY
    M.away_team_api_id
  ORDER BY
    COUNT(*) DESC
  LIMIT 1
) AS subquery
JOIN Team AS T
  ON subquery.away_team_api_id = T.team_api_id;
```
Critic: ```sql
SELECT
  T.team_long_name
FROM Match AS M
JOIN League AS L
  ON M.league_id = L.id
JOIN Team AS T
  ON M.away_team_api_id = T.team_api_id
WHERE
  L.name = 'Scotland Premier League' AND M.season = '2009/2010' AND M.away_team_goal > M.home_team_goal
GROUP BY
  T.team_long_name
ORDER BY
  COUNT(*) DESC
LIMIT 1;
```
=====================
Question: What are the speed in which attacks are put together of the top 4 teams with the highest build Up Play Speed?
 db_id: european_football_2
Planner: 1. Join `Team_Attributes` and `Team` tables on `team_api_id` to get the team's long name along with its attributes.
2. Calculate the average `buildUpPlaySpeed` for each team.
3. Order the teams by their average `buildUpPlaySpeed` in descending order.
4. Select the top 4 teams.
5. Display the team's long name and their average `buildUpPlaySpeed`.

NL2SQL: ```sql
SELECT
  t.team_long_name,
  AVG(ta.buildUpPlaySpeed) AS avg_buildUpPlaySpeed
FROM Team AS t
JOIN Team_Attributes AS ta
  ON t.team_api_id = ta.team_api_id
GROUP BY
  t.team_long_name
ORDER BY
  avg_buildUpPlaySpeed DESC
LIMIT 4;
```
Critic: ```sql
SELECT
  T1.team_long_name,
  T2.buildUpPlaySpeed
FROM Team AS T1
INNER JOIN Team_Attributes AS T2
  ON T1.team_api_id = T2.team_api_id
ORDER BY
  T2.buildUpPlaySpeed DESC
LIMIT 4;
```
=====================
Question: Give the name of the league had the most matches end as draw in the 2016 season?
 db_id: european_football_2
Planner: 1. Filter the `Match` table for the 2015/2016 season.
2. Identify matches that ended in a draw (where `home_team_goal` equals `away_team_goal`).
3. Group the filtered matches by `league_id`.
4. Count the number of draw matches for each league.
5. Find the league with the maximum number of draw matches.
6. Retrieve the `name` of that league from the `League` table.
7. Join `Match` and `League` using `league_id`.

NL2SQL: ```sql
SELECT
  T2.name
FROM Match AS T1
INNER JOIN League AS T2
  ON T1.league_id = T2.id
WHERE
  T1.season = '2015/2016' AND T1.home_team_goal = T1.away_team_goal
GROUP BY
  T2.name
ORDER BY
  COUNT(T1.id) DESC
LIMIT 1;
```
Critic: ```sql
SELECT
  T2.name
FROM Match AS T1
INNER JOIN League AS T2
  ON T1.league_id = T2.id
WHERE
  T1.season = '2015/2016' AND T1.home_team_goal = T1.away_team_goal
GROUP BY
  T2.name
ORDER BY
  COUNT(*) DESC
LIMIT 1;
```
=====================
Question: At present, calculate for the player's age who have a sprint speed of no less than 97 between 2013 to 2015.
 db_id: european_football_2
Planner: 1.  Join the `Player` table with the `Player_Attributes` table on `player_api_id`.
2.  Filter the `Player_Attributes` table for records where the `sprint_speed` is greater than or equal to 97 and the year of the `date` column is between 2013 and 2015.
3.  Calculate the age of each player by subtracting the `birthday` from the current date.
4.  Select the calculated age.

NL2SQL: ```sql
SELECT
  STRFTIME('%Y', 'now') - STRFTIME('%Y', T1.birthday)
FROM Player AS T1
INNER JOIN Player_Attributes AS T2
  ON T1.player_api_id = T2.player_api_id
WHERE
  T2.sprint_speed >= 97 AND STRFTIME('%Y', T2.date) BETWEEN '2013' AND '2015'
GROUP BY
  T1.player_api_id;
```
Critic: ```sql
SELECT
  STRFTIME('%Y', 'now') - STRFTIME('%Y', T1.birthday)
FROM Player AS T1
INNER JOIN Player_Attributes AS T2
  ON T1.player_api_id = T2.player_api_id
WHERE
  T2.sprint_speed >= 97 AND STRFTIME('%Y', T2.date) BETWEEN '2013' AND '2015';
```
=====================
Question: Give the name of the league with the highest matches of all time and how many matches were played in the said league.
 db_id: european_football_2
Planner: Here's my plan to answer the question:

1.  **Join `Match` and `League` tables:** Join `Match` and `League` tables on `league_id` to link matches to their respective leagues.
2.  **Group by league name:** Group the joined data by `League.name` to count matches per league.
3.  **Count matches per league:** Use `COUNT(*)` to count the number of matches in each league.
4.  **Order by match count:** Order the result in descending order of the match count using `ORDER BY COUNT(*) DESC`.
5.  **Limit to the top league:** Limit the result to the first row using `LIMIT 1` to get the league with the maximum number of matches.
6.  **Select league name and match count:** Select `League.name` and the calculated `COUNT(*)` as `matches_played`.

NL2SQL: ```sql
SELECT
  T1.name,
  COUNT(T2.league_id) AS matches_played
FROM League AS T1
JOIN Match AS T2
  ON T1.id = T2.league_id
GROUP BY
  T1.name
ORDER BY
  matches_played DESC
LIMIT 1;
```
Critic: ```sql
SELECT
  T1.name,
  COUNT(T2.league_id) AS matches_played
FROM League AS T1
INNER JOIN Match AS T2
  ON T1.id = T2.league_id
GROUP BY
  T1.name
ORDER BY
  matches_played DESC
LIMIT 1;
```
=====================
Question: Give the team_fifa_api_id of teams with more than 50 but less than 60 build-up play speed.
 db_id: european_football_2
Planner: 1. Select the `team_fifa_api_id` from the `Team_Attributes` table.
2. Filter the `Team_Attributes` table where `buildUpPlaySpeed` is greater than 50 and less than 60.

NL2SQL: ```sql
SELECT
  team_fifa_api_id
FROM Team_Attributes
WHERE
  buildUpPlaySpeed > 50 AND buildUpPlaySpeed < 60;
```
Critic: ```sql
SELECT DISTINCT
  team_fifa_api_id
FROM Team_Attributes
WHERE
  buildUpPlaySpeed > 50 AND buildUpPlaySpeed < 60;
```
=====================
Question: List the long name of teams with above-average build-up play passing in 2012.
 db_id: european_football_2
Planner: 1.  Calculate the average `buildUpPlayPassing` across all teams in the year 2012 from the `Team_Attributes` table.
2.  Filter `Team_Attributes` records for the year 2012.
3.  Join `Team_Attributes` and `Team` tables on `team_api_id`.
4.  Select the `team_long_name` from the `Team` table where `buildUpPlayPassing` is greater than the calculated average.

NL2SQL: ```sql
SELECT
  T.team_long_name
FROM Team AS T
JOIN Team_Attributes AS TA
  ON T.team_api_id = TA.team_api_id
WHERE
  STRFTIME('%Y', TA.date) = '2012'
  AND TA.buildUpPlayPassing > (
    SELECT
      AVG(buildUpPlayPassing)
    FROM Team_Attributes
    WHERE
      STRFTIME('%Y', date) = '2012'
  );
```
Critic: ```sql
SELECT
  T.team_long_name
FROM Team AS T
JOIN Team_Attributes AS TA
  ON T.team_api_id = TA.team_api_id
WHERE
  STRFTIME('%Y', TA.date) = '2012'
  AND TA.buildUpPlayPassing > (
    SELECT
      AVG(buildUpPlayPassing)
    FROM Team_Attributes
    WHERE
      STRFTIME('%Y', date) = '2012'
  );
```
=====================
Question: Calculate the percentage of players who prefer left foot, who were born between 1987 and 1992.
 db_id: european_football_2
Planner: 1.  Join the `Player` table with the `Player_Attributes` table using `player_api_id`.
2.  Filter the joined table to include players born between 1987 and 1992 using the `birthday` column of the `Player` table.
3.  Filter the table to include players whose preferred foot is left.
4.  Calculate the percentage of players who prefer left foot by dividing the number of players who prefer left foot by the total number of players born between 1987 and 1992, and multiplying by 100.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T2.preferred_foot = 'left' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.player_api_id)
FROM Player AS T1
INNER JOIN Player_Attributes AS T2
  ON T1.player_api_id = T2.player_api_id
WHERE
  STRFTIME('%Y', T1.birthday) BETWEEN '1987' AND '1992';
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T2.preferred_foot = 'left' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.player_api_id)
FROM Player AS T1
INNER JOIN Player_Attributes AS T2
  ON T1.player_api_id = T2.player_api_id
WHERE
  CAST(SUBSTR(T1.birthday, 1, 4) AS INTEGER) BETWEEN 1987 AND 1992;
```
=====================
Question: Find the average number of long-shot done by Ahmed Samir Farag.
 db_id: european_football_2
Planner: Here's my plan to answer the question:
1. Find the `player_api_id` for the player 'Ahmed Samir Farag' from the `Player` table using a `WHERE` clause to filter by `player_name`.
2. Using the `player_api_id` obtained, find all the `long_shots` from the `Player_Attributes` table.
3. Calculate the average of `long_shots`.
4. Return the average.

SQL plan:
1. Join `Player` and `Player_Attributes` table on `player_api_id`.
2. Filter the joined table where `player_name` is 'Ahmed Samir Farag'.
3. Calculate the average of `long_shots`.

NL2SQL: ```sql
SELECT
  AVG(T2.long_shots)
FROM Player AS T1
INNER JOIN Player_Attributes AS T2
  ON T1.player_api_id = T2.player_api_id
WHERE
  T1.player_name = 'Ahmed Samir Farag';
```
Critic: ```sql
SELECT
  AVG(T1.long_shots)
FROM Player_Attributes AS T1
INNER JOIN Player AS T2
  ON T1.player_api_id = T2.player_api_id
WHERE
  T2.player_name = 'Ahmed Samir Farag';
```
=====================
Question: List the top 10 players' names whose heights are above 180 in descending order of average heading accuracy.
 db_id: european_football_2
Planner: 1. Join `Player` and `Player_Attributes` tables on `player_api_id`.
2. Filter the joined table for players with `height` > 180.
3. Group the filtered data by `player_name` and calculate the average `heading_accuracy` for each player.
4. Order the result in descending order of the average `heading_accuracy`.
5. Limit the result to the top 10 players.
6. Select `player_name` as the output.
NL2SQL: ```sql
SELECT
  p.player_name
FROM Player AS p
JOIN Player_Attributes AS pa
  ON p.player_api_id = pa.player_api_id
WHERE
  p.height > 180
GROUP BY
  p.player_name
ORDER BY
  AVG(pa.heading_accuracy) DESC
LIMIT 10;
```
Critic: ```sql
SELECT
  p.player_name
FROM Player AS p
JOIN Player_Attributes AS pa
  ON p.player_api_id = pa.player_api_id
WHERE
  p.height > 180
GROUP BY
  p.player_name
ORDER BY
  AVG(pa.heading_accuracy) DESC
LIMIT 10;
```
=====================
Question: List the name of leagues in which the average goals by the home team is higher than the away team in the 2009/2010 season.
 db_id: european_football_2
Planner: 1.  Filter the `Match` table to include only matches from the '2009/2010' season.
2.  Group the filtered `Match` table by `league_id` to calculate the average home team goals and average away team goals for each league.
3.  Filter the grouped results to include only leagues where the average home team goals are greater than the average away team goals.
4.  Join the `League` table with the filtered results on `League.id` = `Match.league_id` to get the name of the leagues.
5.  Select the `name` column from the `League` table.
NL2SQL: ```sql
SELECT
  T1.name
FROM League AS T1
INNER JOIN Match AS T2
  ON T1.id = T2.league_id
WHERE
  T2.season = '2009/2010'
GROUP BY
  T1.name
HAVING
  AVG(T2.home_team_goal) > AVG(T2.away_team_goal);
```
Critic: ```sql
SELECT
  T1.name
FROM League AS T1
INNER JOIN Match AS T2
  ON T1.id = T2.league_id
WHERE
  T2.season = '2009/2010'
GROUP BY
  T1.name
HAVING
  SUM(T2.home_team_goal) * 1.0 / COUNT(T2.id) > SUM(T2.away_team_goal) * 1.0 / COUNT(T2.id);
```
=====================
Question: List the football players with a birthyear of 1970 and a birthmonth of October.
 db_id: european_football_2
Planner: 1.  **Table Selection:** We need to retrieve player information, so the `Player` table is required.
2.  **Filtering:** We need to filter players based on their birth year and birth month. The `birthday` column in the `Player` table stores the birth date.
3.  **Date Extraction:** Extract the year and month from the birthday column.
4.  **Final Selection:** Select the `player_name` from the filtered results.

NL2SQL:
```sql
SELECT 
  player_name
FROM Player
WHERE
  CAST(SUBSTR(birthday, 1, 4) AS INTEGER) = 1970 AND CAST(SUBSTR(birthday, 6, 2) AS INTEGER) = 10;
```
NL2SQL: ```sql
SELECT player_name FROM Player WHERE CAST(SUBSTR(birthday, 1, 4) AS INTEGER) = 1970 AND CAST(SUBSTR(birthday, 6, 2) AS INTEGER) = 10
```
Critic: ```sql
SELECT player_name FROM Player WHERE SUBSTR(birthday, 1, 4) = '1970' AND SUBSTR(birthday, 6, 2) = '10'
```
=====================
Question: What is the overall rating of the football player Gabriel Tamas in year 2011?
 db_id: european_football_2
Planner: 1. Filter the Player table for the player named "Gabriel Tamas" to get the `player_api_id`.
2. Filter the Player_Attributes table using the `player_api_id` obtained in the previous step.
3. Filter the Player_Attributes table further to include records where the year of the `date` column is 2011. We can use `strftime('%Y', date) = '2011'` for this.
4. Select the `overall_rating` column from the filtered Player_Attributes table.
5. Return the average `overall_rating`.

NL2SQL: ```sql
SELECT
  AVG(T2.overall_rating)
FROM Player AS T1
INNER JOIN Player_Attributes AS T2
  ON T1.player_api_id = T2.player_api_id
WHERE
  T1.player_name = 'Gabriel Tamas' AND STRFTIME('%Y', T2.date) = '2011';
```
Critic: ```sql
SELECT
  AVG(overall_rating)
FROM Player_Attributes AS T1
INNER JOIN Player AS T2
  ON T1.player_api_id = T2.player_api_id
WHERE
  T2.player_name = 'Gabriel Tamas' AND STRFTIME('%Y', T1.date) = '2011';
```
=====================
Question: Calculate the average home team goal in the 2010/2011 season in the country of Poland.
 db_id: european_football_2
Planner: 1. Select the `Match` table to access match-specific information like `home_team_goal`, `country_id`, and `season`.
2. Select the `Country` table to filter by country name.
3. Join `Match` and `Country` tables on `Match.country_id = Country.id`.
4. Filter the matches for the 2010/2011 season (`season = '2010/2011'`) and Poland (`Country.name = 'Poland'`).
5. Calculate the average `home_team_goal` using the AVG aggregate function.
NL2SQL: ```sql
SELECT
  AVG(T1.home_team_goal)
FROM Match AS T1
INNER JOIN Country AS T2
  ON T1.country_id = T2.id
WHERE
  T2.name = 'Poland' AND T1.season = '2010/2011';
```
Critic: ```sql
SELECT
  AVG(home_team_goal)
FROM Match
WHERE
  country_id = (
    SELECT
      id
    FROM Country
    WHERE
      name = 'Poland'
  )
  AND season = '2010/2011';
```
=====================
Question: Who has the highest average finishing rate between the highest and shortest football player?
 db_id: european_football_2
Planner: 1. Find the height of the tallest player and the shortest player using the `Player` table.
2. Find the player IDs that correspond to both players.
3. Find the average finishing for each of these players using `Player_Attributes` table.
4. Find the player with the maximum average finishing and return the player name.
   - Join the `Player` and `Player_Attributes` tables.
   - Filter the result by the player IDs obtained in step 2.
   - Group the result by player name and calculate the average finishing.
   - Find the maximum average finishing and return the corresponding player name.

NL2SQL: ```sql
SELECT
  p.player_name
FROM Player AS p
JOIN Player_Attributes AS pa
  ON p.player_api_id = pa.player_api_id
WHERE
  p.height = (
    SELECT
      MAX(height)
    FROM Player
  ) OR p.height = (
    SELECT
      MIN(height)
    FROM Player
  )
GROUP BY
  p.player_name
ORDER BY
  AVG(pa.finishing) DESC
LIMIT 1;
```
Critic: ```sql
SELECT
  p.player_name
FROM Player AS p
JOIN Player_Attributes AS pa
  ON p.player_api_id = pa.player_api_id
WHERE
  p.height = (
    SELECT
      MAX(height)
    FROM Player
  ) OR p.height = (
    SELECT
      MIN(height)
    FROM Player
  )
GROUP BY
  p.player_name
ORDER BY
  AVG(pa.finishing) DESC
LIMIT 1;
```
=====================
Question: From 2010 to 2015, what was the average overall rating of players who are higher than 170?
 db_id: european_football_2
Planner: 1. Join `Player` and `Player_Attributes` on `player_api_id`.
2. Filter the joined table by `Player.height > 170` and `strftime('%Y', Player_Attributes.date) >= '2010' AND strftime('%Y', Player_Attributes.date) <= '2015'`.
3. Calculate the average `overall_rating` from the filtered table.
4. Output the average `overall_rating`.

NL2SQL: ```sql
SELECT
  AVG(T1.overall_rating)
FROM Player_Attributes AS T1
INNER JOIN Player AS T2
  ON T1.player_api_id = T2.player_api_id
WHERE
  T2.height > 170 AND STRFTIME('%Y', T1.date) BETWEEN '2010' AND '2015';
```
Critic: ```sql
SELECT
  AVG(PA.overall_rating)
FROM Player_Attributes AS PA
INNER JOIN Player AS P
  ON PA.player_api_id = P.player_api_id
WHERE
  P.height > 170 AND STRFTIME('%Y', PA.date) BETWEEN '2010' AND '2015';
```
=====================
Question: What is the difference of the average ball control score between Abdou Diallo and Aaron Appindangoye
?
 db_id: european_football_2
Planner: 1. Find the `player_api_id` for 'Abdou Diallo' from the `Player` table.
2. Find the `player_api_id` for 'Aaron Appindangoye' from the `Player` table.
3. Calculate the average `ball_control` for 'Abdou Diallo' from the `Player_Attributes` table, filtering by `player_api_id` obtained in step 1.
4. Calculate the average `ball_control` for 'Aaron Appindangoye' from the `Player_Attributes` table, filtering by `player_api_id` obtained in step 2.
5. Subtract the average `ball_control` of 'Aaron Appindangoye' from the average `ball_control` of 'Abdou Diallo'.

NL2SQL: ```sql
SELECT
  (
    SELECT
      AVG(T2.ball_control)
    FROM Player AS T1
    INNER JOIN Player_Attributes AS T2
      ON T1.player_api_id = T2.player_api_id
    WHERE
      T1.player_name = 'Abdou Diallo'
  ) - (
    SELECT
      AVG(T2.ball_control)
    FROM Player AS T1
    INNER JOIN Player_Attributes AS T2
      ON T1.player_api_id = T2.player_api_id
    WHERE
      T1.player_name = 'Aaron Appindangoye'
  );
```
Critic: ```sql
SELECT
  AVG(CASE WHEN T1.player_name = 'Abdou Diallo' THEN T2.ball_control ELSE NULL END) - AVG(CASE WHEN T1.player_name = 'Aaron Appindangoye' THEN T2.ball_control ELSE NULL END)
FROM Player AS T1
INNER JOIN Player_Attributes AS T2
  ON T1.player_api_id = T2.player_api_id
WHERE
  T1.player_name = 'Abdou Diallo' OR T1.player_name = 'Aaron Appindangoye';
```
=====================
Question: Which player is older, Aaron Lennon or Abdelaziz Barrada?
 db_id: european_football_2
Planner: 1.  Filter the `Player` table for players named 'Aaron Lennon' and 'Abdelaziz Barrada'.
2.  Retrieve the `player_name` and `birthday` for these players.
3.  Compare their birthdays to determine who is older.
4.  Return the name of the older player.

NL2SQL: ```sql
SELECT
  player_name
FROM Player
WHERE
  player_name = 'Aaron Lennon'
ORDER BY
  birthday
LIMIT 1;
```
Critic: ```sql
SELECT
  CASE WHEN T1.birthday > T2.birthday THEN 'Aaron Lennon' ELSE 'Abdelaziz Barrada' END
FROM Player AS T1
INNER JOIN Player AS T2
  ON T1.player_name = 'Aaron Lennon' AND T2.player_name = 'Abdelaziz Barrada';
```
=====================
Question: Which player is the tallest?
 db_id: european_football_2
Planner: 1.  Find the maximum height from the `Player` table.
2.  Find the player(s) with that maximum height from the `Player` table and select the player name.

Tables needed: `Player`
Columns needed: `player_name`, `height`

NL2SQL: ```sql
SELECT
  player_name
FROM Player
WHERE
  height = (
    SELECT
      MAX(height)
    FROM Player
  );
```
Critic: ```sql
SELECT player_name FROM Player ORDER BY height DESC LIMIT 1
```
=====================
Question: Among the players whose preferred foot was the left foot when attacking, how many of them would remain in his position when the team attacked?
 db_id: european_football_2
Planner: Plan:
1. Filter Player_Attributes table by preferred_foot = 'left'.
2. Filter Player_Attributes table by attacking_work_rate = 'low'.
3. Find the intersection of these two.
4. Count the number of players that satisfy both conditions.
Final Answer:
SELECT count(*) FROM Player_Attributes WHERE preferred_foot = 'left' AND attacking_work_rate = 'low'

NL2SQL: ```sql
SELECT count(*) FROM Player_Attributes WHERE preferred_foot = 'left' AND attacking_work_rate = 'low'
```
Critic: ```sql
SELECT COUNT(DISTINCT T1.player_api_id) FROM Player_Attributes AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T1.preferred_foot = 'left' AND T2.attacking_work_rate = 'low'
```
=====================
Question: Among the players born before the year 1986, how many of them would remain in his position and defense while the team attacked?
 db_id: european_football_2
Planner: 1. Filter the `Player` table to select players born before 1986.
2. Filter the `Player_Attributes` table to find players with a defensive work rate of 'high'.
3. Join the filtered `Player` and `Player_Attributes` tables on `player_api_id`.
4. Count the distinct `player_api_id` to get the number of players satisfying the conditions.

NL2SQL: ```sql
SELECT
  COUNT(DISTINCT T1.player_api_id)
FROM Player AS T1
INNER JOIN Player_Attributes AS T2
  ON T1.player_api_id = T2.player_api_id
WHERE
  STRFTIME('%Y', T1.birthday) < '1986' AND T2.defensive_work_rate = 'high';
```
Critic: ```sql
SELECT
  COUNT(DISTINCT player_api_id)
FROM Player
WHERE
  STRFTIME('%Y', birthday) < '1986';
```
=====================
Question: Please list the names of the players whose volley score and dribbling score are over 70.
 db_id: european_football_2
Planner: 1. We need to find players whose volley score and dribbling score are over 70. This information is available in the `Player_Attributes` table.
2. We need the names of the players. This information is available in the `Player` table.
3. We need to join `Player` and `Player_Attributes` tables on `player_api_id`.
4. Filter the results to include only players where `volleys > 70` and `dribbling > 70`.
5. Select the `player_name` from the `Player` table.

NL2SQL: ```sql
SELECT
  T1.player_name
FROM Player AS T1
INNER JOIN Player_Attributes AS T2
  ON T1.player_api_id = T2.player_api_id
WHERE
  T2.volleys > 70 AND T2.dribbling > 70
GROUP BY
  T1.player_name;
```
Critic: ```sql
SELECT DISTINCT
  T1.player_name
FROM Player AS T1
INNER JOIN Player_Attributes AS T2
  ON T1.player_api_id = T2.player_api_id
WHERE
  T2.volleys > 70 AND T2.dribbling > 70;
```
=====================
Question: How many matches were held in the Belgium Jupiler League in April, 2009?
 db_id: european_football_2
Planner: 1.  Filter the `League` table to find the `id` corresponding to the 'Belgium Jupiler League'.
2.  Use the `League.id` obtained in the previous step to filter the `Match` table.
3.  Filter the `Match` table to select the matches played in April 2009. We will use `date` column and extract `year` and `month`.
4.  Count the number of matches that satisfy the above conditions.

NL2SQL: ```sql
SELECT
  COUNT(id)
FROM Match
WHERE
  STRFTIME('%Y', date) = '2009'
  AND STRFTIME('%m', date) = '04'
  AND league_id = (
    SELECT
      id
    FROM League
    WHERE
      name = 'Belgium Jupiler League'
  );
```
Critic: ```sql
SELECT
  COUNT(id)
FROM Match
WHERE
  date LIKE '2009-04%'
  AND league_id = (
    SELECT
      id
    FROM League
    WHERE
      name = 'Belgium Jupiler League'
  );
```
=====================
Question: Give the name of the league had the most matches in the 2008/2009 season?
 db_id: european_football_2
Planner: 1. Join the `Match` table with the `League` table using the `league_id` column.
2. Filter the joined table to include only matches from the '2008/2009' season.
3. Group the filtered table by league name (`name` column from the `League` table).
4. Count the number of matches in each league using `COUNT(*)`.
5. Order the results in descending order based on the match count.
6. Limit the result to the top 1 league.
7. Select the league name.

NL2SQL: ```sql
SELECT
  T2.name
FROM Match AS T1
INNER JOIN League AS T2
  ON T1.league_id = T2.id
WHERE
  T1.season = '2008/2009'
GROUP BY
  T2.name
ORDER BY
  COUNT(T1.id) DESC
LIMIT 1;
```
Critic: ```sql
SELECT
  T2.name
FROM Match AS T1
INNER JOIN League AS T2
  ON T1.league_id = T2.id
WHERE
  T1.season = '2008/2009'
GROUP BY
  T2.name
ORDER BY
  COUNT(*) DESC
LIMIT 1;
```
=====================
Question: How much higher in percentage is Ariel Borysiuk's overall rating than that of Paulin Puel?
 db_id: european_football_2
Planner: 1. Find the `player_api_id` for Ariel Borysiuk and Paulin Puel from the `Player` table.
2. Find the most recent `overall_rating` for Ariel Borysiuk and Paulin Puel from the `Player_Attributes` table. Use the `player_api_id` found in step 1 and order by date descending and limit 1 to retrieve the latest rating.
3. Calculate the percentage difference between Ariel Borysiuk's overall rating and Paulin Puel's overall rating.  The formula is `((Ariel Borysiuk's rating - Paulin Puel's rating) / Paulin Puel's rating) * 100`.

NL2SQL: ```sql
SELECT
  (
    (
      (
        SELECT
          overall_rating
        FROM Player_Attributes
        WHERE
          player_api_id = (
            SELECT
              player_api_id
            FROM Player
            WHERE
              player_name = 'Ariel Borysiuk'
          )
        ORDER BY
          date DESC
        LIMIT 1
      ) - (
        SELECT
          overall_rating
        FROM Player_Attributes
        WHERE
          player_api_id = (
            SELECT
              player_api_id
            FROM Player
            WHERE
              player_name = 'Paulin Puel'
          )
        ORDER BY
          date DESC
        LIMIT 1
      )
    ) * 100.0
  ) / (
    SELECT
      overall_rating
    FROM Player_Attributes
    WHERE
      player_api_id = (
        SELECT
          player_api_id
        FROM Player
        WHERE
          player_name = 'Paulin Puel'
      )
    ORDER BY
      date DESC
    LIMIT 1
  );
```
Critic: ```sql
SELECT
  (
    (
      (
        SELECT
          overall_rating
        FROM Player_Attributes
        WHERE
          player_api_id = (
            SELECT
              player_api_id
            FROM Player
            WHERE
              player_name = 'Ariel Borysiuk'
          )
        ORDER BY
          date DESC
        LIMIT 1
      ) - (
        SELECT
          overall_rating
        FROM Player_Attributes
        WHERE
          player_api_id = (
            SELECT
              player_api_id
            FROM Player
            WHERE
              player_name = 'Paulin Puel'
          )
        ORDER BY
          date DESC
        LIMIT 1
      )
    ) * 100
  ) / (
    SELECT
      overall_rating
    FROM Player_Attributes
    WHERE
      player_api_id = (
        SELECT
          player_api_id
        FROM Player
        WHERE
          player_name = 'Paulin Puel'
      )
    ORDER BY
      date DESC
    LIMIT 1
  );
```
=====================
Question: Calculate the average overall rating of Pietro Marino.
 db_id: european_football_2
Planner: 1. Find the `player_api_id` for the player named 'Pietro Marino' from the `Player` table.
2. Using the `player_api_id`, join the `Player_Attributes` table to get all overall ratings for that player.
3. Calculate the average overall rating.

Tables needed: `Player`, `Player_Attributes`
Columns needed: `Player.player_api_id`, `Player.player_name`, `Player_Attributes.player_api_id`, `Player_Attributes.overall_rating`

Filters: `Player.player_name` = 'Pietro Marino'
Joins: `Player` JOIN `Player_Attributes` ON `Player.player_api_id` = `Player_Attributes.player_api_id`
Aggregate function: AVG(`Player_Attributes.overall_rating`)

NL2SQL: ```sql
SELECT
  AVG(T1.overall_rating)
FROM Player_Attributes AS T1
INNER JOIN Player AS T2
  ON T1.player_api_id = T2.player_api_id
WHERE
  T2.player_name = 'Pietro Marino';
```
Critic: ```sql
SELECT
  AVG(T1.overall_rating)
FROM Player_Attributes AS T1
INNER JOIN Player AS T2
  ON T1.player_api_id = T2.player_api_id
WHERE
  T2.player_name = 'Pietro Marino';
```
=====================
Question: What is Ajax's highest chance creation passing score and what is it classified as?
 db_id: european_football_2
Planner: 1. Find the `team_api_id` for the team named 'Ajax' from the `Team` table.
2. Using the `team_api_id`, find the maximum `chanceCreationPassing` score and the corresponding `chanceCreationPassingClass` from the `Team_Attributes` table.

NL2SQL: ```sql
SELECT
  MAX(T1.chanceCreationPassing),
  T1.chanceCreationPassingClass
FROM Team_Attributes AS T1
INNER JOIN Team AS T2
  ON T1.team_api_id = T2.team_api_id
WHERE
  T2.team_long_name = 'Ajax';
```
Critic: ```sql
SELECT
  T1.chanceCreationPassing,
  T1.chanceCreationPassingClass
FROM Team_Attributes AS T1
INNER JOIN Team AS T2
  ON T1.team_api_id = T2.team_api_id
WHERE
  T2.team_long_name = 'Ajax'
ORDER BY
  T1.chanceCreationPassing DESC
LIMIT 1;
```
=====================
Question: For the players who had a 77 points overall rating on 2016/6/23, who was the oldest? Give the name of the player.
 db_id: european_football_2
Planner: Here's the plan to determine the oldest player with an overall rating of 77 on 2016-06-23:

1.  **Join `Player_Attributes` and `Player`:** Join `Player_Attributes` and `Player` on `player_api_id` to link player attributes with player information (specifically, the birthday).
2.  **Filter `Player_Attributes`:** Filter `Player_Attributes` to include only records where `overall_rating` is 77 and `date` is '2016-06-23'.
3.  **Select Player Name and Birthday:** Select the player\_name from Player and birthday from the Player table.
4.  **Order by Birthday:** Order the results by `birthday` in ascending order (oldest first) to identify the oldest player.
5.  **Limit 1:** Limit the result to the first row to retrieve only the oldest player.

This plan will efficiently identify the oldest player who meets the specified criteria.

NL2SQL: ```sql
SELECT
  p.player_name
FROM Player AS p
JOIN Player_Attributes AS pa
  ON p.player_api_id = pa.player_api_id
WHERE
  pa.overall_rating = 77 AND pa.date LIKE '2016-06-23%'
ORDER BY
  p.birthday
LIMIT 1;
```
Critic: ```sql
SELECT
  p.player_name
FROM Player AS p
JOIN Player_Attributes AS pa
  ON p.player_api_id = pa.player_api_id
WHERE
  pa.overall_rating = 77 AND pa.date LIKE '2016-06-23%'
ORDER BY
  p.birthday
LIMIT 1;
```
=====================
Question: What was the overall rating for Aaron Mooy on 2016/2/4?
 db_id: european_football_2
Planner: 1. Find the `player_api_id` for Aaron Mooy from the `Player` table using `player_name = 'Aaron Mooy'`.
2. Use the `player_api_id` and `date = '2016-02-04'` to find the `overall_rating` from the `Player_Attributes` table.

NL2SQL: ```sql
SELECT
  T1.overall_rating
FROM Player_Attributes AS T1
INNER JOIN Player AS T2
  ON T1.player_api_id = T2.player_api_id
WHERE
  T2.player_name = 'Aaron Mooy' AND T1.date LIKE '2016-02-04%';
```
Critic: ```sql
SELECT
  T1.overall_rating
FROM Player_Attributes AS T1
INNER JOIN Player AS T2
  ON T1.player_api_id = T2.player_api_id
WHERE
  T2.player_name = 'Aaron Mooy' AND T1.date = '2016-02-04 00:00:00';
```
=====================
Question: How was Francesco Migliore's attacking work rate on 2015/5/1?
 db_id: european_football_2
Planner: 1.  Find the `player_api_id` for the player 'Francesco Migliore' from the `Player` table.
2.  Use the `player_api_id` and the date '2015-05-01' to find the `attacking_work_rate` from the `Player_Attributes` table.
3.  Select the `attacking_work_rate`.

NL2SQL: ```sql
SELECT
  attacking_work_rate
FROM Player_Attributes
WHERE
  player_api_id = (
    SELECT
      player_api_id
    FROM Player
    WHERE
      player_name = 'Francesco Migliore'
  )
  AND DATE LIKE '2015-05-01%';
```
Critic: ```sql
SELECT
  T1.attacking_work_rate
FROM Player_Attributes AS T1
INNER JOIN Player AS T2
  ON T1.player_api_id = T2.player_api_id
WHERE
  T2.player_name = 'Francesco Migliore' AND T1.date = '2015-05-01 00:00:00';
```
=====================
Question: When was the first time did Kevin Constant have his highest crossing score? Give the date.
 db_id: european_football_2
Planner: 1. Find the `player_api_id` for the player named 'Kevin Constant' from the `Player` table.
2. From the `Player_Attributes` table, filter by the `player_api_id` obtained in the previous step.
3. Find the maximum `crossing` score for Kevin Constant.
4. From the `Player_Attributes` table, filter by the `player_api_id` of Kevin Constant and `crossing` score equal to the maximum `crossing` score.
5. Select the minimum `date` from the filtered results. This will give the first date when Kevin Constant had his highest crossing score.

NL2SQL: ```sql
SELECT
  MIN(T1.date)
FROM Player_Attributes AS T1
INNER JOIN Player AS T2
  ON T1.player_api_id = T2.player_api_id
WHERE
  T2.player_name = 'Kevin Constant'
ORDER BY
  T1.date
LIMIT 1;
```
Critic: ```sql
SELECT
  date
FROM Player_Attributes AS T1
INNER JOIN Player AS T2
  ON T1.player_api_id = T2.player_api_id
WHERE
  T2.player_name = 'Kevin Constant'
ORDER BY
  T1.crossing DESC,
  T1.date
LIMIT 1;
```
=====================
Question: Tell the build Up play passing class for "FC Lorient" on 2010/2/22.
 db_id: european_football_2
Planner: 1. Find the `team_api_id` for the team "FC Lorient" from the `Team` table using `team_long_name`.
2. Filter the `Team_Attributes` table by the `team_api_id` found in step 1 and the date '2010-02-22'.
3. Retrieve the `buildUpPlayPassingClass` from the filtered `Team_Attributes` table.

NL2SQL: ```sql
SELECT
  T2.buildUpPlayPassingClass
FROM Team AS T1
INNER JOIN Team_Attributes AS T2
  ON T1.team_api_id = T2.team_api_id
WHERE
  T1.team_long_name = 'FC Lorient' AND T2.date LIKE '2010-02-22%';
```
Critic: ```sql
SELECT
  T1.buildUpPlayPassingClass
FROM Team_Attributes AS T1
INNER JOIN Team AS T2
  ON T1.team_api_id = T2.team_api_id
WHERE
  T2.team_long_name = 'FC Lorient' AND T1.date LIKE '2010-02-22%';
```
=====================
Question: For the team "Hannover 96", what was its defence aggression class on 2015/9/10?
 db_id: european_football_2
Planner: 1. Find the `team_api_id` for the team "Hannover 96" from the `Team` table, where `team_long_name` is "Hannover 96".
2. Use the `team_api_id` and the date "2015-09-10" to filter the `Team_Attributes` table.
3. Select the `defenceAggressionClass` from the filtered `Team_Attributes` table.

NL2SQL: ```sql
SELECT
  T1.defenceAggressionClass
FROM Team_Attributes AS T1
INNER JOIN Team AS T2
  ON T1.team_api_id = T2.team_api_id
WHERE
  T2.team_long_name = 'Hannover 96' AND T1.date LIKE '2015-09-10%';
```
Critic: ```sql
SELECT
  T1.defenceAggressionClass
FROM Team_Attributes AS T1
INNER JOIN Team AS T2
  ON T1.team_api_id = T2.team_api_id
WHERE
  T2.team_long_name = 'Hannover 96' AND T1.date = '2015-09-10 00:00:00';
```
=====================
Question: What was the average overall rating for Marko Arnautovic from 2007/2/22 to 2016/4/21?
 db_id: european_football_2
Planner: 1.  Join the `Player` table with the `Player_Attributes` table on `player_api_id`.
2.  Filter the `Player` table for `player_name = 'Marko Arnautovic'`.
3.  Filter the `Player_Attributes` table for `date` between '2007-02-22' and '2016-04-21'.
4.  Calculate the average `overall_rating`.

NL2SQL: ```sql
SELECT
  AVG(T2.overall_rating)
FROM Player AS T1
INNER JOIN Player_Attributes AS T2
  ON T1.player_api_id = T2.player_api_id
WHERE
  T1.player_name = 'Marko Arnautovic' AND T2.date BETWEEN '2007-02-22' AND '2016-04-21';
```
Critic: ```sql
SELECT
  AVG(T2.overall_rating)
FROM Player AS T1
INNER JOIN Player_Attributes AS T2
  ON T1.player_api_id = T2.player_api_id
WHERE
  T1.player_name = 'Marko Arnautovic' AND T2.date >= '2007-02-22' AND T2.date <= '2016-04-21';
```
=====================
Question: What percentage is Landon Donovan's overall rating higher than Jordan Bowery on 2013/7/12?
 db_id: european_football_2
Planner: 1. Find the `player_api_id` for Landon Donovan and Jordan Bowery from the `Player` table.
2. Find the `overall_rating` for Landon Donovan on '2013-07-12' from the `Player_Attributes` table, using the `player_api_id` found in step 1 and the date.
3. Find the `overall_rating` for Jordan Bowery on '2013-07-12' from the `Player_Attributes` table, using the `player_api_id` found in step 1 and the date.
4. Calculate the percentage difference between Landon Donovan's and Jordan Bowery's overall ratings using the formula: `((Landon Donovan's rating - Jordan Bowery's rating) / Jordan Bowery's rating) * 100`.

SQL Tables: Player, Player_Attributes
SQL Columns: Player.player_api_id, Player.player_name, Player_Attributes.player_api_id, Player_Attributes.overall_rating, Player_Attributes.date
Joins: Player and Player_Attributes on player_api_id
Filters:
- Player.player_name = 'Landon Donovan'
- Player.player_name = 'Jordan Bowery'
- Player_Attributes.date = '2013-07-12'
Calculations: ((Landon Donovan's rating - Jordan Bowery's rating) / Jordan Bowery's rating) * 100

NL2SQL: ```sql
SELECT
  CAST(
    (
      (
        (
          SELECT
            overall_rating
          FROM Player_Attributes
          WHERE
            player_api_id = (
              SELECT
                player_api_id
              FROM Player
              WHERE
                player_name = 'Landon Donovan'
            )
            AND DATE = '2013-07-12'
        ) - (
          SELECT
            overall_rating
          FROM Player_Attributes
          WHERE
            player_api_id = (
              SELECT
                player_api_id
              FROM Player
              WHERE
                player_name = 'Jordan Bowery'
            )
            AND DATE = '2013-07-12'
        )
      ) * 100
    ) AS REAL
  ) / (
    SELECT
      overall_rating
    FROM Player_Attributes
    WHERE
      player_api_id = (
        SELECT
          player_api_id
        FROM Player
        WHERE
          player_name = 'Jordan Bowery'
      )
      AND DATE = '2013-07-12'
  )
FROM Player
LIMIT 1;
```
Critic: ```sql
SELECT
  (
    (
      SELECT
        overall_rating
      FROM Player_Attributes
      WHERE
        player_api_id = (
          SELECT
            player_api_id
          FROM Player
          WHERE
            player_name = 'Landon Donovan'
        )
        AND DATE = '2013-07-12'
    ) - (
      SELECT
        overall_rating
      FROM Player_Attributes
      WHERE
        player_api_id = (
          SELECT
            player_api_id
          FROM Player
          WHERE
            player_name = 'Jordan Bowery'
        )
        AND DATE = '2013-07-12'
    )
  ) * 100 / (
    SELECT
      overall_rating
    FROM Player_Attributes
    WHERE
      player_api_id = (
        SELECT
          player_api_id
        FROM Player
        WHERE
          player_name = 'Jordan Bowery'
      )
      AND DATE = '2013-07-12'
  );
```
=====================
Question: List down most tallest players' name.
 db_id: european_football_2
Planner: 1. Select the `player_name` from the `Player` table.
2. Order the result by `height` in descending order.
3. Limit the result to the top 1.

NL2SQL: ```sql
SELECT
  player_name
FROM Player
ORDER BY
  height DESC
LIMIT 1;
```
Critic: ```sql
SELECT
  player_name
FROM Player
ORDER BY
  height DESC
LIMIT 1;
```
=====================
Question: State the name of the most strongest player.
 db_id: european_football_2
Planner: 1. Join `Player` and `Player_Attributes` tables on `player_api_id`.
2. Find the maximum `overall_rating` from the joined table.
3. Filter the joined table to include only players with the maximum `overall_rating`.
4. Retrieve the `player_name` of the filtered players.

NL2SQL: ```sql
SELECT
  p.player_name
FROM Player AS p
JOIN Player_Attributes AS pa
  ON p.player_api_id = pa.player_api_id
WHERE
  pa.overall_rating = (
    SELECT
      MAX(overall_rating)
    FROM Player_Attributes
  );
```
Critic: ```sql
SELECT
  T1.player_name
FROM Player AS T1
INNER JOIN Player_Attributes AS T2
  ON T1.player_api_id = T2.player_api_id
ORDER BY
  T2.overall_rating DESC
LIMIT 1;
```
=====================
Question: Who are the players that tend to be attacking when their mates were doing attack moves? List down their name.
 db_id: european_football_2
Planner: 1. Filter Player_Attributes table where attacking_work_rate is equal to 'high'.
2. Join Player_Attributes table with Player table on player_api_id to get player name.
3. Select player_name from the joined table.

NL2SQL: ```sql
SELECT
  T2.player_name
FROM Player_Attributes AS T1
INNER JOIN Player AS T2
  ON T1.player_api_id = T2.player_api_id
WHERE
  T1.attacking_work_rate = 'high'
GROUP BY
  T2.player_name;
```
Critic: ```sql
SELECT
  T2.player_name
FROM Player_Attributes AS T1
INNER JOIN Player AS T2
  ON T1.player_api_id = T2.player_api_id
WHERE
  T1.attacking_work_rate = 'high';
```
=====================
Question: What are the short name of team who played safe while creating chance of passing?
 db_id: european_football_2
Planner: 1. Filter Team_Attributes table for `chanceCreationPassingClass` = 'Safe'.
2. Join Team_Attributes table with Team table on `team_api_id`.
3. Select `team_short_name` from the joined table.

NL2SQL: ```sql
SELECT
  T.team_short_name
FROM Team AS T
JOIN Team_Attributes AS TA
  ON T.team_api_id = TA.team_api_id
WHERE
  TA.chanceCreationPassingClass = 'Safe'
GROUP BY
  T.team_short_name;
```
Critic: ```sql
SELECT DISTINCT
  T.team_short_name
FROM Team AS T
JOIN Team_Attributes AS TA
  ON T.team_api_id = TA.team_api_id
WHERE
  TA.chanceCreationPassingClass = 'Safe';
```
=====================
Question: How many football players born after the 1990s have the first name "Aaron"?
 db_id: european_football_2
Planner: 1.  **Select Table:** Player
2.  **Filter by name:**  `player_name` LIKE 'Aaron%'
3.  **Filter by birth year:**  `birthday` > '1990'
4.  **Count:** Count the number of players.

NL2SQL: ```sql
SELECT
  COUNT(id)
FROM Player
WHERE
  player_name LIKE 'Aaron%' AND birthday > '1990';
```
Critic: ```sql
SELECT
  COUNT(id)
FROM Player
WHERE
  player_name LIKE 'Aaron%' AND SUBSTR(birthday, 1, 4) > '1990';
```
=====================
Question: What is the difference between players 6 and 23's jumping scores?
 db_id: european_football_2
Planner: 1. Find the `jumping` score for player with `id` 6 from the `Player_Attributes` table.
2. Find the `jumping` score for player with `id` 23 from the `Player_Attributes` table.
3. Calculate the difference between the two jumping scores.
4. Display the calculated difference.
I need to use the Player and Player_Attributes table. Player to join with Player_Attributes using player_api_id.
I need to filter by player id.
I need to calculate the difference of their jumping attributes.
Player table is not really needed. Player_Attributes is sufficient to compute jumping score difference of players 6 and 23.
```
NL2SQL: ```sql
SELECT
  (
    SELECT
      jumping
    FROM Player_Attributes
    WHERE
      player_api_id = 6
    ORDER BY
      date DESC
    LIMIT 1
  ) - (
    SELECT
      jumping
    FROM Player_Attributes
    WHERE
      player_api_id = 23
    ORDER BY
      date DESC
    LIMIT 1
  );
```
Critic: ```sql
SELECT
  (
    SELECT
      jumping
    FROM Player_Attributes
    WHERE
      player_api_id = (
        SELECT
          player_api_id
        FROM Player
        WHERE
          id = 6
      )
    ORDER BY
      date DESC
    LIMIT 1
  ) - (
    SELECT
      jumping
    FROM Player_Attributes
    WHERE
      player_api_id = (
        SELECT
          player_api_id
        FROM Player
        WHERE
          id = 23
      )
    ORDER BY
      date DESC
    LIMIT 1
  );
```
=====================
Question: Please provide top four football players' IDs who are among the lowest potential players and prefer to use the right foot when attacking.
 db_id: european_football_2
Planner: 1. Select the `player_api_id` from the `Player_Attributes` table.
2. Filter the data to include only players with `preferred_foot` equal to 'right'.
3. Find the minimum potential value.
4. Rank the players by their potential in ascending order.
5. Select only the top 4 players (those with the lowest potential).
6. Return the `player_api_id` of these players.
7. Use the player table to retrieve the player_name corresponding to the selected player_api_ids.

NL2SQL: ```sql
SELECT
  T1.player_api_id
FROM Player AS T1
INNER JOIN Player_Attributes AS T2
  ON T1.player_api_id = T2.player_api_id
WHERE
  T2.preferred_foot = 'right'
ORDER BY
  T2.potential
LIMIT 4;
```
Critic: ```sql
SELECT
  player_api_id
FROM Player_Attributes
WHERE
  preferred_foot = 'right'
ORDER BY
  potential
LIMIT 4;
```
=====================
Question: How many players had the highest potential score for crossing that preferred to use their left foots while attacking?
 db_id: european_football_2
Planner: 1. Find the maximum crossing score from the `Player_Attributes` table.
2. Filter the `Player_Attributes` table to include only players with 'left' as their `preferred_foot` and the maximum crossing score.
3. Count the number of players that satisfy the condition.

NL2SQL: ```sql
SELECT
  COUNT(player_api_id)
FROM Player_Attributes
WHERE
  preferred_foot = 'left' AND crossing = (
    SELECT
      MAX(crossing)
    FROM Player_Attributes
  );
```
Critic: ```sql
SELECT
  COUNT(DISTINCT player_api_id)
FROM Player_Attributes
WHERE
  preferred_foot = 'left'
  AND potential = (
    SELECT
      MAX(potential)
    FROM Player_Attributes
  );
```
=====================
Question: What was the final score for the match on September 24, 2008, in the Belgian Jupiler League between the home team and the away team?
 db_id: european_football_2
Planner: 1.  Filter the `League` table to find the `league_id` for the 'Belgium Jupiler League'.
2.  Filter the `Match` table using the `date` column to find matches played on '2008-09-24'.
3.  Further filter the `Match` table using the `league_id` obtained from the `League` table.
4.  Retrieve the `home_team_goal` and `away_team_goal` columns from the filtered `Match` table to get the final scores.
NL2SQL: ```sql
SELECT
  home_team_goal,
  away_team_goal
FROM Match
WHERE
  date LIKE '2008-09-24%'
  AND league_id = (
    SELECT
      id
    FROM League
    WHERE
      name = 'Belgium Jupiler League'
  );
```
Critic: ```sql
SELECT
  home_team_goal,
  away_team_goal
FROM Match
WHERE
  date = '2008-09-24'
  AND league_id = (
    SELECT
      id
    FROM League
    WHERE
      name = 'Belgium Jupiler League'
  );
```
=====================
Question: Does the KSV Cercle Brugge team have a slow, balanced or fast speed class?
 db_id: european_football_2
Planner: 1. Find the `team_api_id` for 'KSV Cercle Brugge' from the `Team` table.
2. Using the `team_api_id`, retrieve the `buildUpPlaySpeedClass` from the `Team_Attributes` table. Since there are multiple entries in `Team_Attributes` for the same `team_api_id` (for different dates), we'll pick the latest entry for each team.

NL2SQL: ```sql
SELECT
  T2.buildUpPlaySpeedClass
FROM Team AS T1
INNER JOIN Team_Attributes AS T2
  ON T1.team_api_id = T2.team_api_id
WHERE
  T1.team_long_name = 'KSV Cercle Brugge'
ORDER BY
  T2.date DESC
LIMIT 1;
```
Critic: ```sql
SELECT
  buildUpPlaySpeedClass
FROM Team_Attributes
WHERE
  team_api_id = (
    SELECT
      team_api_id
    FROM Team
    WHERE
      team_long_name = 'KSV Cercle Brugge'
  )
ORDER BY
  date DESC
LIMIT 1;
```
=====================
Question: Please state the finishing rate and curve score of the player who has the heaviest weight.
 db_id: european_football_2
Planner: 1. Find the player with the maximum weight using the `Player` table.
2. Get the `player_api_id` of the player found in step 1.
3. Use the `player_api_id` to find the corresponding `finishing` and `curve` scores from the `Player_Attributes` table. Since there are multiple records of attributes for each player, pick the latest record.
4. Return the `finishing` and `curve` scores.

Tables:
- Player
- Player_Attributes

Columns:
- Player: player_api_id, weight
- Player_Attributes: player_api_id, finishing, curve, date

Filters:
- Get the player with the maximum weight

Joins:
- Join Player and Player_Attributes on player_api_id

Aggregations:
- MAX(weight) to find the heaviest player
- MAX(date) to select the latest attribute record for each player

NL2SQL: ```sql
SELECT
  T2.finishing,
  T2.curve
FROM Player AS T1
INNER JOIN Player_Attributes AS T2
  ON T1.player_api_id = T2.player_api_id
WHERE
  T1.weight = (
    SELECT
      MAX(weight)
    FROM Player
  )
ORDER BY
  T2.date DESC
LIMIT 1;
```
Critic: ```sql
SELECT
  T2.finishing,
  T2.curve
FROM Player AS T1
INNER JOIN Player_Attributes AS T2
  ON T1.player_api_id = T2.player_api_id
WHERE
  T1.weight = (
    SELECT
      MAX(weight)
    FROM Player
  )
ORDER BY
  T2.date DESC
LIMIT 1;
```
=====================
Question: Which top 4 leagues had the most games in the 2015-2016 season?
 db_id: european_football_2
Planner: 1.  Filter the `Match` table for the 2015/2016 season.
2.  Join the `Match` table with the `League` table on `league_id`.
3.  Group the results by `League.name` and count the number of matches in each league.
4.  Order the results in descending order based on the match count.
5.  Limit the results to the top 4 leagues.
6.  Select the `League.name` and the corresponding match count.

NL2SQL: ```sql
SELECT
  T1.name
FROM League AS T1
INNER JOIN Match AS T2
  ON T1.id = T2.league_id
WHERE
  T2.season = '2015/2016'
GROUP BY
  T1.name
ORDER BY
  COUNT(T2.id) DESC
LIMIT 4;
```
Critic: ```sql
SELECT
  T2.name
FROM Match AS T1
INNER JOIN League AS T2
  ON T1.league_id = T2.id
WHERE
  T1.season = '2015/2016'
GROUP BY
  T2.name
ORDER BY
  COUNT(*) DESC
LIMIT 4;
```
=====================
Question: Please provide the full name of the away team that scored the most goals.
 db_id: european_football_2
Planner: 1.  Join the `Match` table with the `Team` table on `Match.away_team_api_id = Team.team_api_id`.
2.  Calculate the total goals scored by each away team using `SUM(Match.away_team_goal)`.
3.  Group the results by `Team.team_long_name`.
4.  Order the results by the total goals scored in descending order using `ORDER BY total_goals DESC`.
5.  Limit the result to the top row to get the away team that scored the most goals using `LIMIT 1`.
6.  Select the `Team.team_long_name` as the final output.
NL2SQL: ```sql
SELECT
  T.team_long_name
FROM Match AS M
JOIN Team AS T
  ON M.away_team_api_id = T.team_api_id
GROUP BY
  T.team_long_name
ORDER BY
  SUM(M.away_team_goal) DESC
LIMIT 1;
```
Critic: ```sql
SELECT
  T.team_long_name
FROM Match AS M
JOIN Team AS T
  ON M.away_team_api_id = T.team_api_id
GROUP BY
  T.team_long_name
ORDER BY
  SUM(M.away_team_goal) DESC
LIMIT 1;
```
=====================
Question: Please name one player whose overall strength is the greatest.
 db_id: european_football_2
Planner: 1. Join `Player_Attributes` with `Player` on `player_api_id` to get player names along with their attributes.
2. Find the maximum `overall_rating` from `Player_Attributes`.
3. Filter the joined table to select the player with the maximum overall rating.
4. Select the `player_name` of that player.

NL2SQL: ```sql
SELECT
  T1.player_name
FROM Player AS T1
INNER JOIN Player_Attributes AS T2
  ON T1.player_api_id = T2.player_api_id
WHERE
  T2.overall_rating = (
    SELECT
      MAX(overall_rating)
    FROM Player_Attributes
  )
LIMIT 1;
```
Critic: ```sql
SELECT
  T1.player_name
FROM Player AS T1
INNER JOIN Player_Attributes AS T2
  ON T1.player_api_id = T2.player_api_id
ORDER BY
  T2.overall_rating DESC
LIMIT 1;
```
=====================
Question: What is the percentage of players that are under 180 cm who have an overall strength of more than 70?
 db_id: european_football_2
Planner: 1. Join `Player` and `Player_Attributes` table using `player_api_id`.
2. Filter the joined table to get the players with height less than 180 cm and overall_rating greater than 70.
3. Calculate the total number of players in the `Player` table.
4. Calculate the percentage of players satisfying the condition by dividing the count of players satisfying condition from step 2 by total player count from step 3, and multiply by 100.
5. Return the calculated percentage.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.height < 180 AND T2.overall_rating > 70 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id)
FROM Player AS T1
INNER JOIN Player_Attributes AS T2
  ON T1.player_api_id = T2.player_api_id;
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.height < 180 AND T2.strength > 70 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id)
FROM Player AS T1
INNER JOIN Player_Attributes AS T2
  ON T1.player_api_id = T2.player_api_id;
```
=====================
Question: Please list the reference names of the drivers who are eliminated in the first period in race number 20.
 db_id: formula_1
Planner: Plan:
1. Find the `raceId` for race number 20 from the `Races` table.
2. Find the `statusId` in `Status` table where status is 'Finished', 'Did not qualify', 'Accident', 'Collision', 'Engine', 'Gearbox', 'Transmission', 'Clutch', 'Hydraulics', 'Electrical', 'Radiator', 'Turbo', 'Brakes', 'Suspension', 'Fuel system', 'Tyre', 'Wheel', 'Handling', 'Chassis', 'Power Unit', 'ERS', 'Energy Store', 'Control Electronics', 'Battery', 'Damage', 'Driveshaft', 'Retired', 'Not classified'.
3. Filter the `results` table by `raceId` and `statusId` to identify drivers who were eliminated in the first period in race number 20.
4. Join the filtered `results` table with the `drivers` table using `driverId`.
5. Select the `driverRef` from the joined table.

NL2SQL: ```sql
SELECT
  T2.driverRef
FROM results AS T1
INNER JOIN drivers AS T2
  ON T1.driverId = T2.driverId
WHERE
  T1.raceId = 20
  AND T1.statusId IN (
    SELECT
      statusId
    FROM status
    WHERE
      status IN (
        'Finished', 'Did not qualify', 'Accident', 'Collision', 'Engine', 'Gearbox', 'Transmission', 'Clutch', 'Hydraulics', 'Electrical', 'Radiator', 'Turbo', 'Brakes', 'Suspension', 'Fuel system', 'Tyre', 'Wheel', 'Handling', 'Chassis', 'Power Unit', 'ERS', 'Energy Store', 'Control Electronics', 'Battery', 'Damage', 'Driveshaft', 'Retired', 'Not classified'
      )
  );
```
Critic: ```sql
SELECT
  T2.driverRef
FROM results AS T1
INNER JOIN drivers AS T2
  ON T1.driverId = T2.driverId
WHERE
  T1.raceId = 20
  AND T1.statusId = 1;
```
=====================
Question: What is the surname of the driver with the best lap time in race number 19 in the second qualifying period?
 db_id: formula_1
Planner: Here's the plan to determine the surname of the driver with the best lap time in race number 19 in the second qualifying period (q2):

1.  **Identify relevant tables:**
    *   `qualifying`: Contains raceId, driverId, and q2 (qualifying time for the second period).
    *   `drivers`: Contains driverId and surname.

2.  **Filter for the specific race:**
    *   Filter the `qualifying` table for `raceId = 19`.

3.  **Find the best lap time (minimum q2):**
    *   Determine the minimum `q2` value from the filtered `qualifying` data.

4.  **Identify the driver(s) with the best lap time:**
    *   From the filtered `qualifying` data, select the `driverId` where `q2` equals the minimum `q2` found in the previous step.

5.  **Retrieve the surname:**
    *   Join the `drivers` table with the `qualifying` table on `driverId`.
    *   Filter the joined table to include only the `driverId` found in step 4.
    *   Select the `surname` from the `drivers` table.

NL2SQL: ```sql
SELECT
  T2.surname
FROM qualifying AS T1
INNER JOIN drivers AS T2
  ON T1.driverId = T2.driverId
WHERE
  T1.raceId = 19
ORDER BY
  T1.q2
LIMIT 1;
```
Critic: ```sql
SELECT
  T2.surname
FROM qualifying AS T1
INNER JOIN drivers AS T2
  ON T1.driverId = T2.driverId
WHERE
  T1.raceId = 19
  AND T1.q2 IS NOT NULL
ORDER BY
  T1.q2
LIMIT 1;
```
=====================
Question: Please give the name of the race held on the circuits in Germany.
 db_id: formula_1
Planner: 1. Find the `circuitId` for circuits located in Germany from the `circuits` table using the `country` column.
2. Use the `circuitId` obtained in the previous step to find the corresponding `raceId` from the `races` table.
3. Retrieve the `name` of the race from the `races` table using the `raceId`.
Tables:
* circuits: To get the circuitId of the circuits in Germany.
* races: To get the race name from the circuitId.

Columns:
* circuits.country: To filter the circuits in Germany.
* circuits.circuitId: To join with the races table.
* races.circuitId: To join with the circuits table.
* races.name: To get the name of the race.

Filters:
* circuits.country = "Germany"

Joins:
* circuits JOIN races ON circuits.circuitId = races.circuitId

NL2SQL: ```sql
SELECT
  r.name
FROM circuits AS c
JOIN races AS r
  ON c.circuitId = r.circuitId
WHERE
  c.country = 'Germany';
```
Critic: ```sql
SELECT DISTINCT
  T2.name
FROM circuits AS T1
INNER JOIN races AS T2
  ON T1.circuitId = T2.circuitId
WHERE
  T1.country = 'Germany';
```
=====================
Question: What is the coordinates location of the circuits for Australian grand prix?
 db_id: formula_1
Planner: 1. Find the `circuitId` for the race named 'Australian Grand Prix' from the `races` table.
2. Use the `circuitId` to find the corresponding latitude (`lat`) and longitude (`lng`) from the `circuits` table.
3. Return the `lat` and `lng` values.

NL2SQL: ```sql
SELECT
  T1.lat,
  T1.lng
FROM circuits AS T1
INNER JOIN races AS T2
  ON T1.circuitId = T2.circuitId
WHERE
  T2.name = 'Australian Grand Prix';
```
Critic: ```sql
SELECT
  lat,
  lng
FROM circuits
WHERE
  country = 'Australia';
```
=====================
Question: Give the coordinate position for Abu Dhabi Grand Prix.
 db_id: formula_1
Planner: 1. Find the `raceId` for the race named 'Abu Dhabi Grand Prix' from the `races` table.
2. Use the `raceId` to find the `circuitId` from the `races` table.
3. Use the `circuitId` to find the `lat` and `lng` (latitude and longitude) from the `circuits` table.
4. Return the `lat` and `lng`.

NL2SQL: ```sql
SELECT
  T1.lat,
  T1.lng
FROM circuits AS T1
INNER JOIN races AS T2
  ON T1.circuitId = T2.circuitId
WHERE
  T2.name = 'Abu Dhabi Grand Prix';
```
Critic: ```sql
SELECT
  lat,
  lng
FROM circuits
WHERE
  name = 'Yas Marina Circuit';
```
=====================
Question: What's Bruno Senna's Q1 result in the qualifying race No. 354?
 db_id: formula_1
Planner: Plan:
1. Find the `driverId` for Bruno Senna from the `drivers` table using `forename` and `surname`.
2. Find the `raceId` for race number 354 from the `races` table.
3. Use the `driverId` and `raceId` to retrieve the Q1 result (`q1`) from the `qualifying` table.

NL2SQL: ```sql
SELECT
  T1.q1
FROM qualifying AS T1
INNER JOIN drivers AS T2
  ON T1.driverId = T2.driverId
INNER JOIN races AS T3
  ON T1.raceId = T3.raceId
WHERE
  T2.forename = 'Bruno' AND T2.surname = 'Senna' AND T3.raceId = 354;
```
Critic: ```sql
SELECT
  T1.q1
FROM qualifying AS T1
INNER JOIN drivers AS T2
  ON T1.driverId = T2.driverId
WHERE
  T2.forename = 'Bruno' AND T2.surname = 'Senna' AND T1.raceId = 354;
```
=====================
Question: What is his number of the driver who finished 0:01:54 in the Q3 of qualifying race No.903?
 db_id: formula_1
Planner: Plan:
1. Filter the `races` table by `raceId` to find the matching race based on the race number.
2. Filter the `qualifying` table by `raceId` from the previous step and by `q3` column to match the time constraint (0:01:54).
3. Retrieve the `driverId` from the filtered `qualifying` table.
4. Retrieve the `number` from the `drivers` table using the `driverId` obtained in the previous step.
5. Output the retrieved `number`.

NL2SQL: ```sql
SELECT
  T1.number
FROM drivers AS T1
INNER JOIN qualifying AS T2
  ON T1.driverId = T2.driverId
WHERE
  T2.raceId = 903 AND T2.q3 = '1:54.107';
```
Critic: ```sql
SELECT
  T1.number
FROM drivers AS T1
INNER JOIN qualifying AS T2
  ON T1.driverId = T2.driverId
WHERE
  T2.raceId = 903 AND T2.q3 = '0:01:54.107';
```
=====================
Question: For the Bahrain Grand Prix in 2007, how many drivers not finished the game?
 db_id: formula_1
Planner: 1. Find the `raceId` for the Bahrain Grand Prix in 2007 from the `races` table.  Filter on `year` = 2007 and `name` = 'Bahrain Grand Prix'.
2. From the `results` table, filter by the `raceId` found in the previous step.
3. Join the `results` table with the `status` table using `statusId`.
4. Count the number of drivers where `status` is NOT 'Finished'.
5. Return this count.

NL2SQL: ```sql
SELECT
  COUNT(T1.driverId)
FROM results AS T1
INNER JOIN races AS T2
  ON T1.raceId = T2.raceId
INNER JOIN status AS T3
  ON T1.statusId = T3.statusId
WHERE
  T2.year = 2007 AND T2.name = 'Bahrain Grand Prix' AND T3.status != 'Finished';
```
Critic: ```sql
SELECT
  COUNT(T1.driverId)
FROM results AS T1
INNER JOIN races AS T2
  ON T1.raceId = T2.raceId
WHERE
  T2.year = 2007 AND T2.name = 'Bahrain Grand Prix' AND T1.statusId != 1;
```
=====================
Question: For all the drivers who finished the game in race No. 592, who is the oldest?
 db_id: formula_1
Planner: Plan:
1. Find the `driverId` of the drivers who finished race No. 592. This can be found in the `results` table where `raceId` is 592 and `time` is not NULL.
2. Retrieve the `dob` (date of birth) for each of these `driverId` from the `drivers` table.
3. Find the maximum `dob` (oldest driver) among those drivers.
4. Return the `forename` and `surname` of the driver with the maximum `dob`.

NL2SQL: ```sql
SELECT
  forename,
  surname
FROM drivers
WHERE
  driverId IN (
    SELECT
      driverId
    FROM results
    WHERE
      raceId = 592 AND time IS NOT NULL
  )
ORDER BY
  dob
LIMIT 1;
```
Critic: ```sql
SELECT
  forename,
  surname
FROM drivers
WHERE
  driverId IN (
    SELECT
      driverId
    FROM results
    WHERE
      raceId = 592 AND time IS NOT NULL
  )
ORDER BY
  dob
LIMIT 1;
```
=====================
Question: Who was the player that got the lap time of 0:01:27 in the race No. 161? Show his introduction website.
 db_id: formula_1
Planner: Plan:
1. Find the `driverId` from the `lapTimes` table where `raceId` is 161 and `time` is '0:01:27'.
2. Retrieve the `url` (introduction website) from the `drivers` table using the `driverId` obtained in the previous step.
3. Return the `url`.

NL2SQL: ```sql
SELECT
  T2.url
FROM lapTimes AS T1
INNER JOIN drivers AS T2
  ON T1.driverId = T2.driverId
WHERE
  T1.raceId = 161 AND T1.time = '1:27.821';
```
Critic: ```sql
SELECT
  T2.url
FROM lapTimes AS T1
INNER JOIN drivers AS T2
  ON T1.driverId = T2.driverId
WHERE
  T1.raceId = 161 AND T1.time = '0:01:27';
```
=====================
Question: Where is Malaysian Grand Prix held? Give the location coordinates.
 db_id: formula_1
Planner: 1. Find the `raceId` of the race 'Malaysian Grand Prix' from the `races` table.
2. Use the `raceId` to find the `circuitId` from the `races` table.
3. Use the `circuitId` to find the `lat` and `lng` from the `circuits` table.
4. Return the `lat` and `lng`.

NL2SQL: ```sql
SELECT
  T1.lat,
  T1.lng
FROM circuits AS T1
INNER JOIN races AS T2
  ON T1.circuitId = T2.circuitId
WHERE
  T2.name = 'Malaysian Grand Prix';
```
Critic: ```sql
SELECT
  T1.lat,
  T1.lng
FROM circuits AS T1
JOIN races AS T2
  ON T1.circuitId = T2.circuitId
WHERE
  T2.name = 'Malaysian Grand Prix';
```
=====================
Question: For the constructor which got the highest point in the race No. 9 , what is its introduction website?
 db_id: formula_1
Planner: Plan:
1. Find the `constructorId` of the constructor who got the highest points in race No. 9 from the `constructorResults` table.
2. Get the `url` of the constructor from the `constructors` table using the `constructorId` found in the previous step.

Tables needed:
* `constructorResults`: To find the constructorId with the highest points in race No. 9.
* `constructors`: To find the url of the constructor using the constructorId.

Join condition:
* `constructorResults.constructorId` = `constructors.constructorId`

Columns needed:
* `constructorResults.raceId` to filter race No. 9.
* `constructorResults.points` to find the maximum points.
* `constructorResults.constructorId` to join with the constructors table.
* `constructors.url` to get the introduction website.

NL2SQL: ```sql
SELECT
  T2.url
FROM constructorResults AS T1
INNER JOIN constructors AS T2
  ON T1.constructorId = T2.constructorId
WHERE
  T1.raceId = 9
ORDER BY
  T1.points DESC
LIMIT 1;
```
Critic: ```sql
SELECT
  T2.url
FROM constructorResults AS T1
INNER JOIN constructors AS T2
  ON T1.constructorId = T2.constructorId
WHERE
  T1.raceId = 9
ORDER BY
  T1.points DESC
LIMIT 1;
```
=====================
Question: In the race No. 45, for the driver who had the Q3 time as 0:01:33, what is his abbreviated code?
 db_id: formula_1
Planner: Plan:
1. Find the driverId from the `qualifying` table where `raceId` is 45 and `q3` is '0:01:33'.
2. Retrieve the 'code' from the `drivers` table using the `driverId` found in the previous step.

SQL:
```sql
SELECT
  T2.code
FROM qualifying AS T1
INNER JOIN drivers AS T2
  ON T1.driverId = T2.driverId
WHERE
  T1.raceId = 45 AND T1.q3 = '0:01:33';
```
NL2SQL: ```sql
SELECT
  T2.code
FROM qualifying AS T1
INNER JOIN drivers AS T2
  ON T1.driverId = T2.driverId
WHERE
  T1.raceId = 45 AND T1.q3 = '0:01:33';
```
Critic: ```sql
SELECT
  T2.code
FROM qualifying AS T1
INNER JOIN drivers AS T2
  ON T1.driverId = T2.driverId
WHERE
  T1.raceId = 45 AND T1.q3 = '1:33.000';
```
=====================
Question: Show me the season page of year when the race No. 901 took place.
 db_id: formula_1
Planner: 1. Find the `year` from the `races` table where `raceId` is 901.
2. Find the `url` from the `seasons` table where `year` matches the `year` found in step 1.
3. Display the `url`.

SQL query:
```sql
SELECT
  T2.url
FROM races AS T1
INNER JOIN seasons AS T2
  ON T1.year = T2.year
WHERE
  T1.raceId = 901;
```
NL2SQL: ```sql
SELECT
  T2.url
FROM races AS T1
INNER JOIN seasons AS T2
  ON T1.year = T2.year
WHERE
  T1.raceId = 901;
```
Critic: ```sql
SELECT
  T2.url
FROM races AS T1
INNER JOIN seasons AS T2
  ON T1.year = T2.year
WHERE
  T1.raceId = 901;
```
=====================
Question: For all the drivers who finished the game in race No. 872, who is the youngest?
 db_id: formula_1
Planner: Plan:
1. Find the `driverId` of drivers who finished race No. 872.  This requires joining the `results` table with `races` on `raceId` and filtering by `raceId = 872` and `time IS NOT NULL`.
2. Join the result with the `drivers` table on `driverId`.
3. Find the minimum `dob` among the drivers who finished race No. 872.
4. Output the forename and surname of the youngest driver.

NL2SQL: ```sql
SELECT
  forename,
  surname
FROM drivers
WHERE
  driverId IN (
    SELECT
      driverId
    FROM results
    WHERE
      raceId = 872
  )
ORDER BY
  dob DESC
LIMIT 1;
```
Critic: ```sql
SELECT
  forename,
  surname
FROM drivers
WHERE
  driverId IN (
    SELECT
      driverId
    FROM results
    WHERE
      raceId = 872
  )
ORDER BY
  dob DESC
LIMIT 1;
```
=====================
Question: For the driver who set the fastest lap speed, what is his nationality?
 db_id: formula_1
Planner: 1. Find the maximum `fastestLapSpeed` from the `results` table.
2. Find the `driverId` associated with the maximum `fastestLapSpeed` in the `results` table.
3. Join the `drivers` table with the `results` table on `driverId`.
4. Retrieve the `nationality` of the driver with the fastest lap speed.

NL2SQL: ```sql
SELECT
  T1.nationality
FROM drivers AS T1
INNER JOIN results AS T2
  ON T1.driverId = T2.driverId
ORDER BY
  T2.fastestLapSpeed DESC
LIMIT 1;
```
Critic: ```sql
SELECT
  T1.nationality
FROM drivers AS T1
INNER JOIN results AS T2
  ON T1.driverId = T2.driverId
WHERE
  T2.fastestLapSpeed IS NOT NULL
ORDER BY
  REPLACE(T2.fastestLapSpeed, ',', '') DESC
LIMIT 1;
```
=====================
Question: Paul di Resta was in the No. 853 race, what percent faster did he finish in the 853rd race than the next race for the fastest lap speed?
 db_id: formula_1
Planner: Plan:
1. Find the `driverId` for Paul di Resta from the `drivers` table.
2. Find the `fastestLapSpeed` for the 853rd race for Paul di Resta using the `results` table, joining with `drivers` table on `driverId`.
3. Find the `fastestLapSpeed` for the 854th race for Paul di Resta using the `results` table, joining with `drivers` table on `driverId`.
4. Calculate the percentage difference between the `fastestLapSpeed` in race 853 and race 854: `((fastestLapSpeed_853 - fastestLapSpeed_854) / fastestLapSpeed_853) * 100`.

NL2SQL: ```sql
SELECT
  (
    (
      (
        SELECT
          fastestLapSpeed
        FROM results
        JOIN drivers
          ON results.driverId = drivers.driverId
        WHERE
          results.raceId = 853 AND drivers.forename = 'Paul' AND drivers.surname = 'di Resta'
      ) - (
        SELECT
          fastestLapSpeed
        FROM results
        JOIN drivers
          ON results.driverId = drivers.driverId
        WHERE
          results.raceId = 854 AND drivers.forename = 'Paul' AND drivers.surname = 'di Resta'
      )
    ) / (
      SELECT
        fastestLapSpeed
      FROM results
      JOIN drivers
        ON results.driverId = drivers.driverId
      WHERE
        results.raceId = 853 AND drivers.forename = 'Paul' AND drivers.surname = 'di Resta'
    )
  ) * 100;
```
Critic: ```sql
SELECT
  CAST((
    (
      SELECT
        fastestLapSpeed
      FROM results
      JOIN drivers
        ON results.driverId = drivers.driverId
      WHERE
        results.raceId = 853 AND drivers.forename = 'Paul' AND drivers.surname = 'di Resta'
    ) - (
      SELECT
        fastestLapSpeed
      FROM results
      JOIN drivers
        ON results.driverId = drivers.driverId
      WHERE
        results.raceId = 854 AND drivers.forename = 'Paul' AND drivers.surname = 'di Resta'
    )
  ) AS REAL) * 100 / (
    SELECT
      fastestLapSpeed
    FROM results
    JOIN drivers
      ON results.driverId = drivers.driverId
    WHERE
      results.raceId = 853 AND drivers.forename = 'Paul' AND drivers.surname = 'di Resta'
  );
```
=====================
Question: For the drivers who took part in the race in 1983/7/16, what's their race completion rate?
 db_id: formula_1
Planner: 1.  **Find the relevant race:** Use the `races` table to find the `raceId` for the race on '1983-07-16'.
2.  **Get the drivers in that race:** Use the `results` table, filtering by the `raceId` obtained in step 1, to identify the `driverId` of all drivers who participated in that race.
3.  **Calculate race completion rate:** Use the `results` table to identify the drivers who participated in that race. Count the number of drivers where the `time` column is not null (meaning they finished). Count total number of drivers participated in that race.
4.  **Calculate completion rate:** Divide the number of finished drivers by the total number of drivers.
Tables: races, results
Columns: races.raceId, races.date, results.raceId, results.driverId, results.time
Filters: races.date = '1983-07-16', results.raceId = races.raceId
Joins: races and results tables on raceId
Aggregations: COUNT(results.driverId) where results.time is not null, COUNT(results.driverId)

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.time IS NOT NULL THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.driverId)
FROM results AS T1
INNER JOIN races AS T2
  ON T1.raceId = T2.raceId
WHERE
  T2.date = '1983-07-16';
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.statusId = 1 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.driverId)
FROM results AS T1
INNER JOIN races AS T2
  ON T1.raceId = T2.raceId
WHERE
  T2.date = '1983-07-16';
```
=====================
Question: List the names of all races that occurred in the earliest recorded year and month.
 db_id: formula_1
Planner: 1. Find the earliest recorded date from the `races` table.
2. Extract the year and month from the earliest date.
3. Retrieve the names of the races that occurred in the earliest year and month.
4. Select the name of races.
Tables: `races`
Columns: `date`, `name`
Filters: `year` and `month` from the minimum date.

NL2SQL: ```sql
SELECT
  name
FROM races
WHERE
  STRFTIME('%Y', date) = (
    SELECT
      STRFTIME('%Y', MIN(date))
    FROM races
  )
  AND STRFTIME('%m', date) = (
    SELECT
      STRFTIME('%m', MIN(date))
    FROM races
  );
```
Critic: ```sql
SELECT
  name
FROM races
WHERE
  STRFTIME('%Y-%m', date) = (
    SELECT
      STRFTIME('%Y-%m', MIN(date))
    FROM races
  );
```
=====================
Question: State the driver with the most points scored. Find his full name with that points.
 db_id: formula_1
Planner: Plan:
1. Find the driver with the maximum total points from the `driverStandings` table.
2. Retrieve the `driverId` associated with the maximum points.
3. Join the `drivers` table with the `driverStandings` table on `driverId`.
4. Filter the results to include only the driver with the `driverId` found in step 2.
5. Concatenate the `forename` and `surname` from the `drivers` table to get the full name of the driver.
6. Select the full name of the driver and their corresponding total points.

NL2SQL: ```sql
SELECT
  T1.forename,
  T1.surname
FROM drivers AS T1
INNER JOIN driverStandings AS T2
  ON T1.driverId = T2.driverId
ORDER BY
  T2.points DESC
LIMIT 1;
```
Critic: ```sql
SELECT
  T1.forename,
  T1.surname
FROM drivers AS T1
INNER JOIN driverStandings AS T2
  ON T1.driverId = T2.driverId
ORDER BY
  T2.points DESC
LIMIT 1;
```
=====================
Question: What is the best lap time recorded? List the driver and race with such recorded lap time.
 db_id: formula_1
Planner: 1. Find the minimum `milliseconds` from the `lapTimes` table.
2. Select the `raceId` and `driverId` corresponding to the minimum `milliseconds`.
3. Join `lapTimes` with `drivers` on `driverId` to get `forename` and `surname`.
4. Join `lapTimes` with `races` on `raceId` to get `name` (race name).
5. Display `drivers.forename`, `drivers.surname`, and `races.name`.

NL2SQL: ```sql
SELECT
  T2.forename,
  T2.surname,
  T3.name
FROM lapTimes AS T1
INNER JOIN drivers AS T2
  ON T1.driverId = T2.driverId
INNER JOIN races AS T3
  ON T1.raceId = T3.raceId
WHERE
  T1.milliseconds = (
    SELECT
      MIN(milliseconds)
    FROM lapTimes
  );
```
Critic: ```sql
SELECT
  T1.forename,
  T1.surname,
  T3.name
FROM drivers AS T1
INNER JOIN lapTimes AS T2
  ON T1.driverId = T2.driverId
INNER JOIN races AS T3
  ON T2.raceId = T3.raceId
WHERE
  T2.milliseconds = (
    SELECT
      MIN(milliseconds)
    FROM lapTimes
  );
```
=====================
Question: What is the average lap time for Lewis Hamilton in the 2009 Malaysian Grand Prix?
 db_id: formula_1
Planner: 1. Find the `raceId` for the 2009 Malaysian Grand Prix from the `races` table. Filter `races` by `year = 2009` and `name = 'Malaysian Grand Prix'`.
2. Find the `driverId` for Lewis Hamilton from the `drivers` table. Filter `drivers` by `forename = 'Lewis'` and `surname = 'Hamilton'`.
3. Use the `raceId` and `driverId` to filter the `lapTimes` table.
4. Calculate the average lap time in milliseconds from the filtered `lapTimes` table using the AVG aggregate function on the `milliseconds` column.

NL2SQL: ```sql
SELECT AVG(milliseconds)
FROM lapTimes
WHERE raceId = (SELECT raceId FROM races WHERE YEAR = 2009 AND NAME = "Malaysian Grand Prix")
AND driverId = (SELECT driverId FROM drivers WHERE forename = "Lewis" AND surname = "Hamilton");
```
Critic: ```sql
SELECT AVG(milliseconds) FROM lapTimes WHERE raceId = (SELECT raceId FROM races WHERE YEAR = 2009 AND name = "Malaysian Grand Prix") AND driverId = (SELECT driverId FROM drivers WHERE forename = "Lewis" AND surname = "Hamilton")
```
=====================
Question: Calculate the percentage whereby Hamilton was not at the 1st track of the the f1 circuit since 2010.
 db_id: formula_1
Planner: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.position > 1 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.driverId)
FROM results AS T1
INNER JOIN races AS T2
  ON T1.raceId = T2.raceId
INNER JOIN drivers AS T3
  ON T1.driverId = T3.driverId
WHERE
  T3.surname = 'Hamilton' AND T2.year >= 2010;
```

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.position > 1 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.driverId)
FROM results AS T1
INNER JOIN races AS T2
  ON T1.raceId = T2.raceId
INNER JOIN drivers AS T3
  ON T1.driverId = T3.driverId
WHERE
  T3.surname = 'Hamilton' AND T2.year >= 2010;
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.positionOrder > 1 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.driverId)
FROM results AS T1
INNER JOIN races AS T2
  ON T1.raceId = T2.raceId
INNER JOIN drivers AS T3
  ON T1.driverId = T3.driverId
WHERE
  T3.surname = 'Hamilton' AND T2.year >= 2010;
```
=====================
Question: Name the driver with the most winning. Mention his nationality and what is his maximum point scores.
 db_id: formula_1
Planner: Plan:
1. Find the driver with the most wins using the `driverStandings` table. Group by `driverId` and calculate the sum of `wins`.
2. Find the maximum points of the driver by using `driverStandings`. Group by `driverId` and calculate the sum of `points`.
3. Join the `drivers` table to get the driver's nationality.
4. Select the driver's forename, surname, nationality, and the sum of wins and points.
5. Order the results by the sum of wins in descending order and take the top 1.
6. Retrieve the driver's nationality and maximum point scores.

NL2SQL: ```sql
SELECT
  d.forename,
  d.surname,
  d.nationality,
  SUM(ds.wins) AS total_wins,
  MAX(T2.points)
FROM drivers AS d
JOIN driverStandings AS ds
  ON d.driverId = ds.driverId
JOIN (
  SELECT
    driverId,
    SUM(points) AS points
  FROM driverStandings
  GROUP BY
    driverId
) AS T2
  ON d.driverId = T2.driverId
GROUP BY
  d.driverId,
  d.forename,
  d.surname,
  d.nationality
ORDER BY
  total_wins DESC
LIMIT 1;
```
Critic: ```sql
SELECT
  T1.forename,
  T1.surname,
  T1.nationality,
  SUM(T2.wins),
  MAX(T2.points)
FROM drivers AS T1
INNER JOIN driverStandings AS T2
  ON T1.driverId = T2.driverId
GROUP BY
  T1.driverId
ORDER BY
  SUM(T2.wins) DESC
LIMIT 1;
```
=====================
Question: How old is the youngest Japanese driver? What is his name?
 db_id: formula_1
Planner: Plan:
1. Filter the `drivers` table to select only drivers with nationality 'Japanese'.
2. Find the maximum date of birth (`dob`) among the filtered drivers. This corresponds to the youngest driver.
3. Retrieve the forename and surname of the driver with the maximum `dob`.

NL2SQL: ```sql
SELECT
  forename,
  surname
FROM drivers
WHERE
  nationality = 'Japanese'
ORDER BY
  dob DESC
LIMIT 1;
```
Critic: ```sql
SELECT
  forename,
  surname
FROM drivers
WHERE
  nationality = 'Japanese'
ORDER BY
  dob DESC
LIMIT 1;
```
=====================
Question: Name the races along with its circuit name and location for f1 races hosted in September 2005.
 db_id: formula_1
Planner: 1. Select the circuit `name` and `location` from the `circuits` table.
2. Select the race `name` from the `races` table.
3. Join `races` and `circuits` table on `circuitId`.
4. Filter the `races` table for races where `year` is 2005 and the month of `date` is 9.
5. Return race `name`, circuit `name`, and circuit `location`.

NL2SQL: ```sql
SELECT
  r.name,
  c.name,
  c.location
FROM races AS r
JOIN circuits AS c
  ON r.circuitId = c.circuitId
WHERE
  STRFTIME('%Y', r.date) = '2005' AND STRFTIME('%m', r.date) = '09';
```
Critic: ```sql
SELECT
  r.name,
  c.name,
  c.location
FROM races AS r
JOIN circuits AS c
  ON r.circuitId = c.circuitId
WHERE
  CAST(STRFTIME('%m', r.date) AS INTEGER) = 9 AND CAST(STRFTIME('%Y', r.date) AS INTEGER) = 2005;
```
=====================
Question: Which race was Alex Yoong in when he was in track number less than 20?
 db_id: formula_1
Planner: 1. Find the `driverId` for Alex Yoong from the `drivers` table using `forename` and `surname`.
2. Join the `results` table with the `races` table on `raceId`.
3. Filter the `results` table by the `driverId` obtained in step 1 and filter the results where `position` is less than 20.
4. Select the `name` column from the `races` table to get the name of the races where Alex Yoong's position was less than 20.

NL2SQL: ```sql
SELECT
  T1.name
FROM races AS T1
INNER JOIN results AS T2
  ON T1.raceId = T2.raceId
INNER JOIN drivers AS T3
  ON T2.driverId = T3.driverId
WHERE
  T3.forename = 'Alex' AND T3.surname = 'Yoong' AND T2.position < 20;
```
Critic: ```sql
SELECT
  T1.name
FROM races AS T1
INNER JOIN results AS T2
  ON T1.raceId = T2.raceId
INNER JOIN drivers AS T3
  ON T2.driverId = T3.driverId
WHERE
  T3.forename = 'Alex' AND T3.surname = 'Yoong' AND T2.positionOrder < 20;
```
=====================
Question: State the race and year of race in which Michael Schumacher had his fastest lap.
 db_id: formula_1
Planner: Plan:
1. Find the `driverId` of Michael Schumacher from the `drivers` table.
2. Find the `raceId` and `fastestLapTime` for that `driverId` from the `results` table. Filter for the minimum `fastestLapTime`.
3. Get the `year` from the `races` table using the `raceId`.
4. Retrieve the `nationality` of the driver from the `drivers` table.
5. Return the driver `nationality` and race `year`.

NL2SQL: ```sql
SELECT
  T1.nationality,
  T3.year
FROM drivers AS T1
INNER JOIN results AS T2
  ON T1.driverId = T2.driverId
INNER JOIN races AS T3
  ON T2.raceId = T3.raceId
WHERE
  T1.forename = 'Michael' AND T1.surname = 'Schumacher'
ORDER BY
  T2.fastestLapTime
LIMIT 1;
```
Critic: ```sql
SELECT
  T1.nationality,
  T3.year
FROM drivers AS T1
INNER JOIN lapTimes AS T2
  ON T1.driverId = T2.driverId
INNER JOIN races AS T3
  ON T2.raceId = T3.raceId
WHERE
  T1.forename = 'Michael' AND T1.surname = 'Schumacher'
ORDER BY
  T2.milliseconds
LIMIT 1;
```
=====================
Question: Which was Lewis Hamilton first race? What was his points recorded for his first race event?
 db_id: formula_1
Planner: 1. Find the `driverId` for Lewis Hamilton from the `drivers` table using `forename` and `surname`.
2. Find the first race (`raceId`) of Lewis Hamilton from the `results` table by filtering based on the `driverId` obtained in step 1 and ordering by `raceId` and limiting to 1.
3. Retrieve the `name` of the race using the `raceId` from the `races` table.
4. Retrieve the `points` scored by Lewis Hamilton in his first race from the `results` table using his `driverId` and the `raceId` found in step 2.
5. Return the `name` of the race and `points` scored in that race.

NL2SQL: ```sql
SELECT
  T1.name,
  T2.points
FROM races AS T1
INNER JOIN results AS T2
  ON T1.raceId = T2.raceId
INNER JOIN drivers AS T3
  ON T2.driverId = T3.driverId
WHERE
  T3.forename = 'Lewis' AND T3.surname = 'Hamilton'
ORDER BY
  T1.year,
  T1.round
LIMIT 1;
```
Critic: ```sql
SELECT
  T1.name,
  T2.points
FROM races AS T1
INNER JOIN results AS T2
  ON T1.raceId = T2.raceId
INNER JOIN drivers AS T3
  ON T2.driverId = T3.driverId
WHERE
  T3.forename = 'Lewis' AND T3.surname = 'Hamilton'
ORDER BY
  T1.date
LIMIT 1;
```
=====================
Question: Among all European Grand Prix races, what is the percentage of the races were hosted in Germany?
 db_id: formula_1
Planner: Plan:
1. Find all races named 'European Grand Prix'.
2. Find the races among them that were held in Germany.  We'll need to join `races` and `circuits` to determine the country.
3. Calculate the percentage of 'European Grand Prix' races that were held in Germany.
4. Select `races`.`name`, `circuits`.`country` and `circuits`.`circuitId`
5. Use COUNT and CASE WHEN to calculate the percentage.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T2.country = 'Germany' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.name)
FROM races AS T1
INNER JOIN circuits AS T2
  ON T1.circuitId = T2.circuitId
WHERE
  T1.name = 'European Grand Prix';
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T2.country = 'Germany' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.name)
FROM races AS T1
INNER JOIN circuits AS T2
  ON T1.circuitId = T2.circuitId
WHERE
  T1.name LIKE '%Grand Prix%' AND T2.country = 'Europe';
```
=====================
Question: What's the location coordinates of Silverstone Circuit?
 db_id: formula_1
Planner: 1.  **Tables**: circuits
2.  **Filters**: circuits.name = 'Silverstone Circuit'
3.  **Columns**: circuits.lat, circuits.lng
NL2SQL: ```sql
SELECT
  lat,
  lng
FROM circuits
WHERE
  name = 'Silverstone Circuit';
```
Critic: ```sql
SELECT
  lat,
  lng
FROM circuits
WHERE
  name = 'Silverstone Circuit';
```
=====================
Question: What's the reference name of Marina Bay Street Circuit?
 db_id: formula_1
Planner: 1. Select the `circuitRef` column from the `circuits` table.
2. Filter the `circuits` table by the `name` column to find the row where `name` is 'Marina Bay Street Circuit'.

NL2SQL: ```sql
SELECT
  circuitRef
FROM circuits
WHERE
  name = 'Marina Bay Street Circuit';
```
Critic: ```sql
SELECT
  circuitRef
FROM circuits
WHERE
  name = 'Marina Bay Street Circuit';
```
=====================
Question: Which country is the oldest driver from?
 db_id: formula_1
Planner: 1. Find the oldest driver:
    *   Table: `drivers`
    *   Column: `dob`
    *   Find the minimum date of birth (`MIN(dob)`)
2. Get the nationality of the oldest driver:
    *   Table: `drivers`
    *   Column: `nationality`
    *   Filter: `dob` = (result from step 1)

SQL query:

```sql
SELECT
  nationality
FROM drivers
WHERE
  dob = (
    SELECT
      MIN(dob)
    FROM drivers
  );
```
NL2SQL: ```sql
SELECT
  nationality
FROM drivers
ORDER BY
  dob
LIMIT 1;
```
Critic: ```sql
SELECT
  nationality
FROM drivers
ORDER BY
  dob
LIMIT 1;
```
=====================
Question: Which driver ranked the first in the Canadian Grand Prix in 2007? Please give his reference name.
 db_id: formula_1
Planner: Plan:
1. Find the `raceId` for the 'Canadian Grand Prix' in 2007 from the `races` table.
2. Using the `raceId`, find the `driverId` of the driver who finished in position 1 in the `results` table.
3. Using the `driverId`, find the `driverRef` from the `drivers` table.
Return the `driverRef`.

NL2SQL: ```sql
SELECT
  T2.driverRef
FROM results AS T1
INNER JOIN drivers AS T2
  ON T1.driverId = T2.driverId
INNER JOIN races AS T3
  ON T1.raceId = T3.raceId
WHERE
  T3.name = 'Canadian Grand Prix' AND T3.year = 2007 AND T1.positionOrder = 1;
```
Critic: ```sql
SELECT
  T2.driverRef
FROM results AS T1
INNER JOIN drivers AS T2
  ON T1.driverId = T2.driverId
INNER JOIN races AS T3
  ON T1.raceId = T3.raceId
WHERE
  T3.name = 'Canadian Grand Prix' AND T3.year = 2007 AND T1.position = 1;
```
=====================
Question: In which Formula_1 race did Lewis Hamilton rank the highest?
 db_id: formula_1
Planner: Plan:
1. Find the `driverId` for Lewis Hamilton from the `drivers` table.
2. Use the `driverId` to find all races where Lewis Hamilton participated using the `results` table.  Specifically, select the `raceId` and `rank`.
3. Find the minimum `rank` among all races for Lewis Hamilton.
4. Find the `name` of the race corresponding to the minimum `rank` from the `races` table using `raceId`.
5. Return the `name` of the race.

NL2SQL: ```sql
SELECT
  T2.name
FROM drivers AS T1
INNER JOIN results AS T3
  ON T1.driverId = T3.driverId
INNER JOIN races AS T2
  ON T3.raceId = T2.raceId
WHERE
  T1.forename = 'Lewis' AND T1.surname = 'Hamilton'
ORDER BY
  T3.rank
LIMIT 1;
```
Critic: ```sql
SELECT
  T1.name
FROM races AS T1
INNER JOIN results AS T2
  ON T1.raceId = T2.raceId
INNER JOIN drivers AS T3
  ON T2.driverId = T3.driverId
WHERE
  T3.forename = 'Lewis' AND T3.surname = 'Hamilton'
ORDER BY
  T2.rank
LIMIT 1;
```
=====================
Question: What was the fastest lap speed among all drivers in the 2009 Spanish Grand Prix?
 db_id: formula_1
Planner: 1. Find the `raceId` for the 2009 Spanish Grand Prix from the `races` table. Filter `races` by `year = 2009` and `name = 'Spanish Grand Prix'`.
2. From the `results` table, filter by the `raceId` obtained in the previous step.
3. Select the maximum `fastestLapSpeed` from the filtered results.

NL2SQL: ```sql
SELECT
  MAX(fastestLapSpeed)
FROM results
JOIN races
  ON results.raceId = races.raceId
WHERE
  races.year = 2009 AND races.name = 'Spanish Grand Prix';
```
Critic: ```sql
SELECT
  MAX(T1.fastestLapSpeed)
FROM results AS T1
INNER JOIN races AS T2
  ON T1.raceId = T2.raceId
WHERE
  T2.year = 2009
  AND T2.name = 'Spanish Grand Prix';
```
=====================
Question: What was Lewis Hamilton's final rank in the 2008 Chinese Grand Prix?
 db_id: formula_1
Planner: 1. Find the `raceId` for the 2008 Chinese Grand Prix from the `races` table. Filter `races` by `year` = 2008 and `name` = 'Chinese Grand Prix'.
2. Find the `driverId` for Lewis Hamilton from the `drivers` table. Filter `drivers` by `forename` = 'Lewis' and `surname` = 'Hamilton'.
3. Join `results` table on `raceId` and `driverId` from above to find `positionOrder`.
4. Return `positionOrder`.

NL2SQL: ```sql
SELECT
  T1.positionOrder
FROM results AS T1
INNER JOIN races AS T2
  ON T1.raceId = T2.raceId
INNER JOIN drivers AS T3
  ON T1.driverId = T3.driverId
WHERE
  T2.year = 2008 AND T2.name = 'Chinese Grand Prix' AND T3.forename = 'Lewis' AND T3.surname = 'Hamilton';
```
Critic: ```sql
SELECT
  T1.positionOrder
FROM results AS T1
INNER JOIN races AS T2
  ON T1.raceId = T2.raceId
INNER JOIN drivers AS T3
  ON T1.driverId = T3.driverId
WHERE
  T2.year = 2008 AND T2.name = 'Chinese Grand Prix' AND T3.forename = 'Lewis' AND T3.surname = 'Hamilton';
```
=====================
Question: What's the finish time for the driver who ranked second in 2008's AustChineseralian Grand Prix?
 db_id: formula_1
Planner: Plan:
1. Filter the `races` table to find the `raceId` for the 2008 Australian Grand Prix. The race name should be 'Australian Grand Prix' and year should be 2008.
2. Filter the `results` table using the `raceId` obtained in the previous step and the `positionOrder` should be 2.
3. Select the `time` column from the filtered `results` table, which represents the finish time of the driver.
4. Display the time.

NL2SQL: ```sql
SELECT
  time
FROM results
WHERE
  raceId = (
    SELECT
      raceId
    FROM races
    WHERE
      year = 2008 AND name = 'Australian Grand Prix'
  )
  AND positionOrder = 2;
```
Critic: ```sql
SELECT
  T1.time
FROM results AS T1
INNER JOIN races AS T2
  ON T1.raceId = T2.raceId
WHERE
  T2.year = 2008 AND T2.name = 'Chinese Grand Prix' AND T1.positionOrder = 2;
```
=====================
Question: Among the drivers that finished the race in the 2008 Chinese Grand Prix, how many of them have participated in Formula_1 races?
 db_id: formula_1
Planner: Plan:
1. Find the `raceId` for the 2008 Chinese Grand Prix from the `races` table.
2. Filter the `results` table by the `raceId` found in the previous step and `time` not NULL (indicating that they finished the race).
3. Count the distinct number of `driverId` from the filtered `results` table.
```sql
SELECT count(DISTINCT T1.driverId) FROM results AS T1 JOIN races AS T2 ON T1.raceId  =  T2.raceId WHERE T2.year  =  2008 AND T2.name  =  'Chinese Grand Prix' AND T1.time IS NOT NULL
```
NL2SQL: ```sql
SELECT count(DISTINCT T1.driverId) FROM results AS T1 JOIN races AS T2 ON T1.raceId = T2.raceId WHERE T2.year = 2008 AND T2.name = 'Chinese Grand Prix' AND T1.statusId = 1
```
Critic: ```sql
SELECT COUNT(DISTINCT T1.driverId) FROM results AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId WHERE T2.year = 2008 AND T2.name = "Chinese Grand Prix" AND T1.time IS NOT NULL
```
=====================
Question: How much faster in percentage is the champion than the driver who finished the race last in the 2008 Australian Grand Prix?
 db_id: formula_1
Planner: Plan:
1. Find the `raceId` for the 2008 Australian Grand Prix from the `races` table. Filter by `year = 2008` and `name = 'Australian Grand Prix'`.
2. Find the `driverId` of the champion (first position) for the obtained `raceId` from the `results` table, where `positionOrder = 1`. Also, retrieve champion's `milliseconds`.
3. Find the `driverId` of the driver who finished last for the obtained `raceId` from the `results` table.  To achieve this, order the results by `positionOrder` in descending order and take the first record. Retrieve last driver's `milliseconds`.
4. Calculate the percentage difference: `((last_driver_milliseconds - champion_milliseconds) / last_driver_milliseconds) * 100`.

NL2SQL: ```sql
SELECT
  CAST(
    (
      (
        (
          SELECT
            milliseconds
          FROM results
          WHERE
            raceId = (
              SELECT
                raceId
              FROM races
              WHERE
                year = 2008 AND name = 'Australian Grand Prix'
            )
          ORDER BY
            positionOrder DESC
          LIMIT 1
        ) - (
          SELECT
            milliseconds
          FROM results
          WHERE
            raceId = (
              SELECT
                raceId
              FROM races
              WHERE
                year = 2008 AND name = 'Australian Grand Prix'
            ) AND positionOrder = 1
        )
      ) * 100
    ) AS REAL
  ) / (
    SELECT
      milliseconds
    FROM results
    WHERE
      raceId = (
        SELECT
          raceId
        FROM races
        WHERE
          year = 2008 AND name = 'Australian Grand Prix'
      )
    ORDER BY
      positionOrder DESC
    LIMIT 1
  );
```
Critic: ```sql
SELECT
  CAST(
    (
      (
        (
          SELECT
            milliseconds
          FROM results
          WHERE
            raceId = (
              SELECT
                raceId
              FROM races
              WHERE
                year = 2008 AND name = 'Australian Grand Prix'
            )
          ORDER BY
            positionOrder DESC
          LIMIT 1
        ) - (
          SELECT
            milliseconds
          FROM results
          WHERE
            raceId = (
              SELECT
                raceId
              FROM races
              WHERE
                year = 2008 AND name = 'Australian Grand Prix'
            )
          ORDER BY
            positionOrder ASC
          LIMIT 1
        )
      ) * 100
    ) AS REAL
  ) / (
    SELECT
      milliseconds
    FROM results
    WHERE
      raceId = (
        SELECT
          raceId
        FROM races
        WHERE
          year = 2008 AND name = 'Australian Grand Prix'
      )
    ORDER BY
      positionOrder DESC
    LIMIT 1
  )
FROM results
LIMIT 1;
```
=====================
Question: How many circuits are there in Adelaide, Australia?
 db_id: formula_1
Planner: Plan:
The question asks for the number of circuits in Adelaide, Australia.
Table `circuits` has `location` and `country` columns.

Steps:
1. Filter the `circuits` table by `country` = 'Australia' and `location` = 'Adelaide'.
2. Count the number of circuits.
3. Return the count.

NL2SQL: ```sql
SELECT
  COUNT(*)
FROM circuits
WHERE
  country = 'Australia' AND location = 'Adelaide';
```
Critic: ```sql
SELECT
  COUNT(*)
FROM circuits
WHERE
  country = 'Australia' AND location = 'Adelaide';
```
=====================
Question: What are the maximum points of British constructors?
 db_id: formula_1
Planner: 1. Filter constructors table by nationality = 'British'.
2. Join constructorStandings table with constructors table on constructorId.
3. Find MAX(points) from constructorStandings table.
4. Select MAX(points).

NL2SQL: ```sql
SELECT
  MAX(T2.points)
FROM constructors AS T1
INNER JOIN constructorStandings AS T2
  ON T1.constructorId = T2.constructorId
WHERE
  T1.nationality = 'British';
```
Critic: ```sql
SELECT
  MAX(T2.points)
FROM constructors AS T1
INNER JOIN constructorResults AS T2
  ON T1.constructorId = T2.constructorId
WHERE
  T1.nationality = 'British';
```
=====================
Question: Please list the constructor names with 0 points at race 291.
 db_id: formula_1
Planner: Plan:
1. Filter the `constructorStandings` table to find records where `raceId` is 291 and `points` is 0.
2. Join the filtered `constructorStandings` table with the `constructors` table using `constructorId` to get the constructor names.
3. Select the `name` column from the `constructors` table.

NL2SQL: ```sql
SELECT
  T2.name
FROM constructorStandings AS T1
INNER JOIN constructors AS T2
  ON T1.constructorId = T2.constructorId
WHERE
  T1.raceId = 291 AND T1.points = 0;
```
Critic: ```sql
SELECT
  T2.name
FROM constructorStandings AS T1
INNER JOIN constructors AS T2
  ON T1.constructorId = T2.constructorId
WHERE
  T1.raceId = 291 AND T1.points = 0.0;
```
=====================
Question: How many Japanese constructors have 0 points in 2 races?
 db_id: formula_1
Planner: Plan:
1. Find all Japanese constructors using the `constructors` table and filter by `nationality = 'Japanese'`.
2. Find the `raceId` and `constructorId` from `constructorResults` where `points = 0`.
3. Group by `constructorId` and count the number of races with 0 points.
4. Filter the groups where the count of races is equal to 2.
5. Count the number of constructors that satisfy the condition.

NL2SQL: ```sql
SELECT
  COUNT(DISTINCT T1.constructorId)
FROM constructorResults AS T1
INNER JOIN constructors AS T2
  ON T1.constructorId = T2.constructorId
WHERE
  T2.nationality = 'Japanese' AND T1.points = 0
GROUP BY
  T1.constructorId
HAVING
  COUNT(T1.raceId) = 2;
```
Critic: ```sql
SELECT
  COUNT(DISTINCT T1.constructorId)
FROM constructorResults AS T1
INNER JOIN constructors AS T2
  ON T1.constructorId = T2.constructorId
WHERE
  T2.nationality = 'Japanese' AND T1.points = 0
GROUP BY
  T1.constructorId
HAVING
  COUNT(T1.raceId) = 2;
```
=====================
Question: Please calculate the race completion percentage of Japanese drivers from 2007 to 2009.
 db_id: formula_1
Planner: Plan:
1. Find all races between 2007 and 2009 using the `races` table.
2. Find all Japanese drivers from the `drivers` table.
3. Join the `results` table with `races` and `drivers` tables on corresponding IDs.
4. Calculate the number of race completions for Japanese drivers between 2007 and 2009, which is the count of results where `time` is not NULL.
5. Calculate the total number of races started by Japanese drivers between 2007 and 2009.
6. Calculate the race completion percentage.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.time IS NOT NULL THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.driverId)
FROM results AS T1
INNER JOIN races AS T2
  ON T1.raceId = T2.raceId
INNER JOIN drivers AS T3
  ON T1.driverId = T3.driverId
WHERE
  T3.nationality = 'Japanese' AND T2.year BETWEEN 2007 AND 2009;
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.statusId = 1 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.driverId)
FROM results AS T1
INNER JOIN races AS T2
  ON T1.raceId = T2.raceId
INNER JOIN drivers AS T3
  ON T1.driverId = T3.driverId
WHERE
  T3.nationality = 'Japanese' AND T2.year BETWEEN 2007 AND 2009;
```
=====================
Question: What is the average time in seconds of champion for each year, before year 1975?
 db_id: formula_1
Planner: Plan:
1. Filter races table to include only races before the year 1975.
2. Filter results table to include only results where time is not null.
3. Join the filtered races and results tables on raceId.
4. Calculate the average time in seconds using the milliseconds column from the results table.
5. Return the average time.

NL2SQL: ```sql
SELECT
  AVG(T1.milliseconds) / 1000
FROM results AS T1
INNER JOIN races AS T2
  ON T1.raceId = T2.raceId
WHERE
  T2.year < 1975
  AND T1.time IS NOT NULL;
```
Critic: ```sql
SELECT
  AVG(milliseconds) / 1000
FROM results AS t1
INNER JOIN races AS t2
  ON t1.raceId = t2.raceId
WHERE
  t2.year < 1975;
```
=====================
Question: What is the fastest lap number of the champion in 2009?
 db_id: formula_1
Planner: 1. Find the `raceId` for the 2009 races from the `races` table.
2. Find the `driverId` of the champion for each race from `driverStandings` table where `raceId` matches the ids found in the previous step and `position` is 1.
3. Find the `fastestLap` from the `results` table, where `raceId` and `driverId` match the values found in the previous steps.
4. Return the `fastestLap`.

NL2SQL: ```sql
SELECT
  T2.fastestLap
FROM races AS T1
INNER JOIN results AS T2
  ON T1.raceId = T2.raceId
INNER JOIN driverStandings AS T3
  ON T1.raceId = T3.raceId AND T2.driverId = T3.driverId
WHERE
  T1.year = 2009 AND T3.position = 1;
```
Critic: ```sql
SELECT
  T2.fastestLap
FROM races AS T1
INNER JOIN results AS T2
  ON T1.raceId = T2.raceId
INNER JOIN driverStandings AS T3
  ON T1.raceId = T3.raceId AND T2.driverId = T3.driverId
WHERE
  T1.year = 2009 AND T3.position = 1
LIMIT 1;
```
=====================
Question: What is the average of fastest lap speed in the 2009 Spanish Grand Prix race?
 db_id: formula_1
Planner: Plan:
1. Find the `raceId` for the 2009 Spanish Grand Prix from the `races` table where `year` is 2009 and `name` is 'Spanish Grand Prix'.
2. Using the `raceId` obtained in step 1, calculate the average of `fastestLapSpeed` from the `results` table.
3. Convert the result to a numerical value.

NL2SQL: ```sql
SELECT avg(CAST(fastestLapSpeed AS REAL)) FROM results WHERE raceId = (SELECT raceId FROM races WHERE YEAR = 2009 AND NAME = "Spanish Grand Prix")
```
Critic: ```sql
SELECT avg(fastestLapSpeed) FROM results WHERE raceId = (SELECT raceId FROM races WHERE year = 2009 AND name = "Spanish Grand Prix")
```
=====================
Question: From 2000 to 2005, what percentage of drivers who were born before 1985 and the lap numbers were over 50?
 db_id: formula_1
Planner: 1.  Join `races` and `lapTimes` tables on `raceId` to link race years and lap details.
2.  Join the result with the `drivers` table on `driverId` to get driver DOB.
3.  Filter the data for races between the years 2000 and 2005 and lap numbers greater than 50.
4.  Further filter the data for drivers born before 1985.
5.  Count the number of drivers meeting the above criteria.
6.  Count the total number of drivers in the races between 2000 and 2005 regardless of DOB and lap number.
7.  Divide the number of drivers meeting the criteria (step 5) by the total number of drivers (step 6) and multiply by 100 to get the percentage.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN STRFTIME('%Y', T2.dob) < '1985' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.driverId)
FROM lapTimes AS T1
INNER JOIN drivers AS T2
  ON T1.driverId = T2.driverId
INNER JOIN races AS T3
  ON T1.raceId = T3.raceId
WHERE
  T3.year BETWEEN 2000 AND 2005 AND T1.lap > 50;
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T2.dob < '1985-01-01' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.driverId)
FROM lapTimes AS T1
INNER JOIN drivers AS T2
  ON T1.driverId = T2.driverId
INNER JOIN races AS T3
  ON T1.raceId = T3.raceId
WHERE
  T3.year BETWEEN 2000 AND 2005 AND T1.lap > 50;
```
=====================
Question: How many French drivers who obtain the laptime less than 02:00.00?
 db_id: formula_1
Planner: Plan:
1. Filter drivers table by nationality = 'French'.
2. Join the filtered drivers table with the lapTimes table on driverId.
3. Filter the joined table by time < '02:00.00'.
4. Count the number of distinct driverId.

Columns:
* drivers: driverId, nationality
* lapTimes: driverId, time

Tables:
* drivers
* lapTimes

Filters:
* drivers.nationality = 'French'
* lapTimes.time < '02:00.00'

Joins:
* drivers JOIN lapTimes ON drivers.driverId = lapTimes.driverId

NL2SQL: ```sql
SELECT
  COUNT(DISTINCT T1.driverId)
FROM drivers AS T1
INNER JOIN lapTimes AS T2
  ON T1.driverId = T2.driverId
WHERE
  T1.nationality = 'French' AND T2.time < '02:00.00';
```
Critic: ```sql
SELECT
  COUNT(DISTINCT T1.driverId)
FROM drivers AS T1
INNER JOIN lapTimes AS T2
  ON T1.driverId = T2.driverId
WHERE
  T1.nationality = 'French' AND T2.milliseconds < 120000;
```
=====================
Question: List out the code for drivers who have nationality in American.
 db_id: formula_1
Planner: Plan:
The question asks for the code of drivers with nationality 'American'.
1. Select the `code` column from the `drivers` table.
2. Filter the `drivers` table where `nationality` is 'American'.

NL2SQL: ```sql
SELECT
  code
FROM drivers
WHERE
  nationality = 'American';
```
Critic: ```sql
SELECT
  code
FROM drivers
WHERE
  nationality = 'American';
```
=====================
Question: State code numbers of top 3 yougest drivers. How many Netherlandic drivers among them?
 db_id: formula_1
Planner: Plan:
1. Find the top 3 youngest drivers:
    - Select the `code` from the `drivers` table.
    - Order the drivers by `dob` in descending order.
    - Limit the result to 3.
2. Count Netherlandic drivers among the top 3:
    - Select the `nationality` from the `drivers` table.
    - Filter the drivers based on the nationality is Netherlands and code that has been selected in previous step.
    - Count the number of Netherlands drivers.

NL2SQL: ```sql
SELECT
  SUM(CASE WHEN T1.nationality = 'Dutch' THEN 1 ELSE 0 END)
FROM drivers AS T1
ORDER BY
  T1.dob DESC
LIMIT 3;
```
Critic: ```sql
SELECT
  CASE WHEN T1.nationality = 'Dutch' THEN COUNT(T1.driverId) ELSE 0 END
FROM drivers AS T1
ORDER BY
  T1.dob DESC
LIMIT 3;
```
=====================
Question: Please state the reference name of the oldest German driver.
 db_id: formula_1
Planner: 1. Filter the `drivers` table to select only drivers with nationality 'German'.
2. Find the minimum date of birth (`dob`) among the selected German drivers.
3. Retrieve the `driverRef` of the German driver with the minimum `dob`.

SQL plan:
```sql
SELECT driverRef FROM drivers WHERE nationality = "German" ORDER BY dob ASC LIMIT 1
```
NL2SQL: ```sql
SELECT driverRef FROM drivers WHERE nationality = 'German' ORDER BY dob ASC LIMIT 1
```
Critic: ```sql
SELECT driverRef FROM drivers WHERE nationality = 'German' ORDER BY dob ASC LIMIT 1
```
=====================
Question: Which drivers who were born in 1971 and has the fastest lap time on the race? Give id and code of these drivers.
 db_id: formula_1
Planner: Plan:
1. Filter the `drivers` table to find drivers born in 1971.
2. Filter the `results` table to find the fastest lap time.
3. Join the filtered `drivers` and `results` tables on `driverId`.
4. Select the `driverId` and `code` from the joined table.

NL2SQL: ```sql
SELECT
  T1.driverId,
  T1.code
FROM drivers AS T1
INNER JOIN results AS T2
  ON T1.driverId = T2.driverId
WHERE
  STRFTIME('%Y', T1.dob) = '1971'
  AND T2.fastestLapTime IS NOT NULL;
```
Critic: ```sql
SELECT
  T1.driverId,
  T1.code
FROM drivers AS T1
INNER JOIN results AS T2
  ON T1.driverId = T2.driverId
WHERE
  T1.dob LIKE '1971%'
  AND T2.fastestLapTime IS NOT NULL;
```
=====================
Question: From race no. 50 to 100, how many finishers have been disqualified?
 db_id: formula_1
Planner: 1.  Filter the `races` table to include races with `raceId` between 50 and 100.
2.  Join the `results` table with the filtered `races` table using the `raceId`.
3.  Join the `results` table with the `status` table using `statusId`.
4.  Filter the joined table where `status.status` indicates disqualification.
5.  Count the number of disqualified finishers.

```sql
SELECT
  COUNT(T1.resultId)
FROM results AS T1
INNER JOIN races AS T2
  ON T1.raceId = T2.raceId
INNER JOIN status AS T3
  ON T1.statusId = T3.statusId
WHERE
  T2.raceId BETWEEN 50 AND 100 AND T3.status = 'Disqualified';
```
NL2SQL: ```sql
SELECT
  COUNT(T1.resultId)
FROM results AS T1
INNER JOIN races AS T2
  ON T1.raceId = T2.raceId
INNER JOIN status AS T3
  ON T1.statusId = T3.statusId
WHERE
  T2.raceId BETWEEN 50 AND 100 AND T3.status = 'Disqualified';
```
Critic: ```sql
SELECT
  COUNT(resultId)
FROM results
WHERE
  raceId BETWEEN 50 AND 100 AND statusId = 2;
```
=====================
Question: How many times the circuits were held in Austria? Please give their location and coordinates.
 db_id: formula_1
Planner: Plan:
1. Find circuits located in Austria using the `circuits` table, filtering by `country = 'Austria'`.
2. Count the number of Austrian circuits.
3. Retrieve the `location`, `lat`, and `lng` for each Austrian circuit.
4. Output the count, location and coordinates of circuits in Austria.

NL2SQL: ```sql
SELECT
  COUNT(circuitId),
  location,
  lat,
  lng
FROM circuits
WHERE
  country = 'Austria'
GROUP BY
  location,
  lat,
  lng;
```
Critic: ```sql
SELECT
  COUNT(circuitId),
  location,
  lat,
  lng
FROM circuits
WHERE
  country = 'Austria'
GROUP BY
  location,
  lat,
  lng;
```
=====================
Question: On what year did the youngest driver had his first qualifying race? Also state the name, date and time of the race.
 db_id: formula_1
Planner: Here's a plan to retrieve the required information:

1.  **Find the youngest driver:**
    *   Find the latest `dob` (date of birth) from the `drivers` table.
2.  **Find the first qualifying race of the youngest driver:**
    *   Join `qualifying` with `drivers` on `driverId` to link drivers to their qualifying races.
    *   Join `qualifying` with `races` on `raceId` to get the race details.
    *   Filter by the youngest driver's `driverId`.
    *   Find the minimum `year` from the `races` table, which corresponds to the year of their first qualifying race.
    *   Also retrieve the `name`, `date`, and `time` of the race.
3.  **Combine and present the results:**
    *   Display the year of the first qualifying race, the name of the race, the date of the race and the time of the race.

NL2SQL: ```sql
SELECT
  MIN(T1.year),
  T1.name,
  T1.date,
  T1.time
FROM races AS T1
INNER JOIN qualifying AS T2
  ON T1.raceId = T2.raceId
INNER JOIN drivers AS T3
  ON T2.driverId = T3.driverId
WHERE
  T3.dob = (
    SELECT
      MAX(dob)
    FROM drivers
  );
```
Critic: ```sql
SELECT
  MIN(r.year),
  r.name,
  r.date,
  r.time
FROM drivers AS d
JOIN qualifying AS q
  ON d.driverId = q.driverId
JOIN races AS r
  ON q.raceId = r.raceId
WHERE
  d.driverId = (
    SELECT
      driverId
    FROM drivers
    ORDER BY
      dob DESC
    LIMIT 1
  );
```
=====================
Question: List down top 3 German drivers who has the shortest average pit stop duration and were born between 1980-1985.
 db_id: formula_1
Planner: Plan:
1. Filter drivers by nationality = 'German' and birth year between 1980 and 1985.
2. Join drivers and pitstops tables on driverId.
3. Calculate the average pit stop duration for each driver.
4. Order the drivers by average pit stop duration in ascending order.
5. Limit the result to the top 3 drivers.
6. Select the forename and surname of the drivers.

NL2SQL: ```sql
SELECT
  d.forename,
  d.surname
FROM drivers AS d
JOIN pitStops AS p
  ON d.driverId = p.driverId
WHERE
  d.nationality = 'German' AND STRFTIME('%Y', d.dob) BETWEEN '1980' AND '1985'
GROUP BY
  d.driverId
ORDER BY
  AVG(p.milliseconds)
LIMIT 3;
```
Critic: ```sql
SELECT
  d.forename,
  d.surname
FROM drivers AS d
JOIN pitStops AS p
  ON d.driverId = p.driverId
WHERE
  d.nationality = 'German' AND SUBSTR(d.dob, 1, 4) BETWEEN '1980' AND '1985'
GROUP BY
  d.driverId
ORDER BY
  AVG(p.milliseconds)
LIMIT 3;
```
=====================
Question: Who is the champion of the Canadian Grand Prix in 2008? Indicate his finish time.
 db_id: formula_1
Planner: Plan:
1. Find the `raceId` for the Canadian Grand Prix in 2008 from the `races` table. Filter by `year = 2008` and `name = 'Canadian Grand Prix'`.
2. In the `results` table, filter by the `raceId` obtained in the previous step and `positionOrder = 1` to find the champion's `driverId` and `time`.
3. In the `drivers` table, use the `driverId` obtained in the previous step to find the champion's forename and surname.
4. Output the champion's forename, surname, and finish time.

NL2SQL: ```sql
SELECT
  T2.forename,
  T2.surname,
  T1.time
FROM results AS T1
INNER JOIN drivers AS T2
  ON T1.driverId = T2.driverId
INNER JOIN races AS T3
  ON T1.raceId = T3.raceId
WHERE
  T3.year = 2008 AND T3.name = 'Canadian Grand Prix' AND T1.positionOrder = 1;
```
Critic: ```sql
SELECT
  T1.forename,
  T1.surname,
  T2.time
FROM drivers AS T1
INNER JOIN results AS T2
  ON T1.driverId = T2.driverId
INNER JOIN races AS T3
  ON T2.raceId = T3.raceId
WHERE
  T3.year = 2008 AND T3.name = "Canadian Grand Prix" AND T2.positionOrder = 1;
```
=====================
Question: What is the constructor reference name of the champion in the 2009 Singapore Grand Prix? Please give its website.
 db_id: formula_1
Planner: Plan:
1. Find the raceId for the 2009 Singapore Grand Prix from the `races` table where `year` is 2009 and `name` is 'Singapore Grand Prix'.
2. Find the constructorId of the champion (position = 1) for the race from the `results` table using the raceId found in step 1.
3. Retrieve the constructorRef and url from the `constructors` table using the constructorId found in step 2.
4. Return the constructorRef and url.

NL2SQL: ```sql
SELECT
  T2.constructorRef,
  T2.url
FROM results AS T1
INNER JOIN constructors AS T2
  ON T1.constructorId = T2.constructorId
INNER JOIN races AS T3
  ON T1.raceId = T3.raceId
WHERE
  T3.year = 2009 AND T3.name = 'Singapore Grand Prix' AND T1.positionOrder = 1;
```
Critic: ```sql
SELECT
  T2.constructorRef,
  T2.url
FROM races AS T1
INNER JOIN results AS T3
  ON T1.raceId = T3.raceId
INNER JOIN constructors AS T2
  ON T2.constructorId = T3.constructorId
WHERE
  T1.year = 2009 AND T1.name = 'Singapore Grand Prix' AND T3.positionOrder = 1;
```
=====================
Question: Please list all the superpowers of 3-D Man.
 db_id: superhero
Planner: 1. Find the `id` of the superhero named '3-D Man' in the `superhero` table.
2. Use the superhero `id` to find the corresponding `power_id` in the `hero_power` table.
3. Use the `power_id` to find the `power_name` in the `superpower` table.
4. Return the list of `power_name` values.
Tables: `superhero`, `hero_power`, `superpower`
Columns: `superhero`.`superhero_name`, `superhero`.`id`, `hero_power`.`hero_id`, `hero_power`.`power_id`, `superpower`.`id`, `superpower`.`power_name`
Filters: `superhero`.`superhero_name` = '3-D Man'
Joins: `superhero`.`id` = `hero_power`.`hero_id`, `hero_power`.`power_id` = `superpower`.`id`

NL2SQL: ```sql
SELECT
  T2.power_name
FROM superhero AS T1
INNER JOIN hero_power AS T3
  ON T1.id = T3.hero_id
INNER JOIN superpower AS T2
  ON T3.power_id = T2.id
WHERE
  T1.superhero_name = '3-D Man';
```
Critic: ```sql
SELECT
  T2.power_name
FROM superhero AS T1
INNER JOIN hero_power AS T3
  ON T1.id = T3.hero_id
INNER JOIN superpower AS T2
  ON T3.power_id = T2.id
WHERE
  T1.superhero_name = '3-D Man';
```
=====================
Question: Which constructor scored most points from Monaco Grand Prix between 1980 and 2010? List the score, name and nationality of this team.
 db_id: formula_1
Planner: Plan:
1. Find the `circuitId` for the Monaco Grand Prix from the `circuits` table where `name` is 'Circuit de Monaco'.
2. Find the `raceId` for the Monaco Grand Prix races between 1980 and 2010 from the `races` table, using the `circuitId` from step 1 and filtering the `year` column.
3. Calculate the total points scored by each constructor for these races using the `results` table, joining it with the `races` table on `raceId` and filtering on `raceId`s obtained in step 2. Group by `constructorId` and sum the `points`.
4. Find the constructor with the maximum points from the aggregated results in step 3.
5. Retrieve the `name` and `nationality` of the constructor with the maximum points from the `constructors` table, using the `constructorId` obtained in step 4. Also retrieve the score.

NL2SQL: ```sql
SELECT
  T2.points,
  T1.name,
  T1.nationality
FROM constructors AS T1
INNER JOIN (
  SELECT
    T3.constructorId,
    SUM(T3.points) AS points
  FROM races AS T2
  INNER JOIN results AS T3
    ON T2.raceId = T3.raceId
  WHERE
    T2.circuitId = (
      SELECT
        circuitId
      FROM circuits
      WHERE
        name = 'Circuit de Monaco'
    ) AND T2.year BETWEEN 1980 AND 2010
  GROUP BY
    T3.constructorId
  ORDER BY
    points DESC
  LIMIT 1
) AS T2
  ON T1.constructorId = T2.constructorId;
```
Critic: ```sql
SELECT
  T2.points,
  T1.name,
  T1.nationality
FROM constructors AS T1
INNER JOIN (
  SELECT
    T3.constructorId,
    SUM(T3.points) AS points
  FROM races AS T2
  INNER JOIN constructorResults AS T3
    ON T2.raceId = T3.raceId
  WHERE
    T2.circuitId = (
      SELECT
        circuitId
      FROM circuits
      WHERE
        name = 'Circuit de Monaco'
    ) AND T2.year BETWEEN 1980 AND 2010
  GROUP BY
    T3.constructorId
  ORDER BY
    points DESC
  LIMIT 1
) AS T2
  ON T1.constructorId = T2.constructorId;
```
=====================
Question: What is full name of the racer who ranked 1st in the 3rd qualifying race held in the Marina Bay Street Circuit in 2008?
 db_id: formula_1
Planner: Plan:
1. Find the `raceId` for the race that took place in 2008 and had the name 'Singapore Grand Prix'. Use the `races` table, filtering by `year` = 2008 and `name` containing 'Singapore Grand Prix'.
2. Find the `driverId` from the `qualifying` table where `raceId` matches the `raceId` found in step 1 and `position` is 1.
3. Retrieve the `forename` and `surname` of the driver using the `driverId` found in step 2 from the `drivers` table.
4. Concatenate `forename` and `surname` to get the full name.

NL2SQL: ```sql
SELECT
  T1.forename,
  T1.surname
FROM drivers AS T1
INNER JOIN qualifying AS T2
  ON T1.driverId = T2.driverId
INNER JOIN races AS T3
  ON T2.raceId = T3.raceId
INNER JOIN circuits AS T4
  ON T3.circuitId = T4.circuitId
WHERE
  T3.year = 2008 AND T4.name = 'Marina Bay Street Circuit' AND T2.position = 1
LIMIT 1;
```
Critic: ```sql
SELECT
  T1.forename,
  T1.surname
FROM drivers AS T1
INNER JOIN qualifying AS T2
  ON T1.driverId = T2.driverId
INNER JOIN races AS T3
  ON T2.raceId = T3.raceId
INNER JOIN circuits AS T4
  ON T3.circuitId = T4.circuitId
WHERE
  T3.year = 2008 AND T4.name = 'Marina Bay Street Circuit' AND T3.round = 3 AND T2.position = 1;
```
=====================
Question: As of the present, what is the full name of the youngest racer? Indicate her nationality and the name of the race to which he/she first joined.
 db_id: formula_1
Planner: Here's a plan to retrieve the required information:

1.  **Find the youngest racer:**
    *   Use the `drivers` table.
    *   Find the maximum value of `dob` (date of birth) to identify the youngest racer.
    *   Retrieve the `driverId`, `forename`, `surname`, and `nationality` of the youngest racer.
2.  **Find the first race of the youngest racer:**
    *   Use the `results` table to find all races the youngest racer participated in using `driverId`.
    *   Find the minimum `raceId` from these races.
3.  **Find the race name:**
    *   Use the `races` table and filter by the `raceId` found in the previous step.
    *   Retrieve the `name` of the race.
4.  **Combine the information:**
    *   Combine the full name (`forename` and `surname`), `nationality` from `drivers`, and the race `name` from `races`.

SQL query:
```sql
SELECT
  d.forename,
  d.surname,
  d.nationality,
  r.name
FROM drivers AS d
JOIN (
  SELECT
    results.driverId,
    MIN(results.raceId) AS first_raceId
  FROM results
  GROUP BY
    results.driverId
) AS first_race
  ON d.driverId = first_race.driverId
JOIN races AS r
  ON first_race.first_raceId = r.raceId
WHERE
  d.dob = (
    SELECT
      MAX(dob)
    FROM drivers
  );
```
NL2SQL: ```sql
SELECT T1.forename, T1.surname, T1.nationality, T3.name FROM drivers AS T1 JOIN results AS T2 ON T1.driverId = T2.driverId JOIN races AS T3 ON T2.raceId = T3.raceId WHERE T1.dob = (SELECT max(dob) FROM drivers) GROUP BY T1.driverId
```
Critic: ```sql
SELECT T1.forename, T1.surname, T1.nationality, T3.name FROM drivers AS T1 JOIN results AS T2 ON T1.driverId = T2.driverId JOIN races AS T3 ON T2.raceId = T3.raceId WHERE T1.dob = (SELECT max(dob) FROM drivers) LIMIT 1
```
=====================
Question: How many accidents did the driver who had the highest number accidents in the Canadian Grand Prix have?
 db_id: formula_1
Planner: 1. Find the `raceId` for the Canadian Grand Prix from the `races` table. Filter by `name` = 'Canadian Grand Prix'.
2. Find the `driverId`s involved in accidents (statusId=3) in that race, by joining `results` and `status` tables on the condition `status.statusId  =  results.statusId`.
3. Count the number of accidents for each `driverId`.
4. Find the `driverId` with the maximum number of accidents.
5. Count the number of accidents for that particular `driverId`.

NL2SQL: ```sql
SELECT
  COUNT(T1.driverId)
FROM results AS T1
INNER JOIN races AS T2
  ON T1.raceId = T2.raceId
INNER JOIN status AS T3
  ON T1.statusId = T3.statusId
WHERE
  T2.name = 'Canadian Grand Prix' AND T3.status = 'Accident'
GROUP BY
  T1.driverId
ORDER BY
  COUNT(T1.driverId) DESC
LIMIT 1;
```
Critic: ```sql
SELECT
  COUNT(T1.driverId)
FROM results AS T1
INNER JOIN races AS T2
  ON T1.raceId = T2.raceId
INNER JOIN status AS T3
  ON T1.statusId = T3.statusId
WHERE
  T2.name = 'Canadian Grand Prix' AND T3.statusId = 3
GROUP BY
  T1.driverId
ORDER BY
  COUNT(T1.driverId) DESC
LIMIT 1;
```
=====================
Question: Which top 20 driver created the shortest lap time ever record in a Formula_1 race? Please give them full names.
 db_id: formula_1
Planner: Plan:
1. Find the minimum lap time from the `lapTimes` table.
2. Retrieve the `driverId` associated with the minimum lap time.
3. Join the `drivers` table with `lapTimes` table on `driverId` to get the forename and surname.
4. Order by laptime and limit to top 20.
5. Select forename, surname.

NL2SQL: ```sql
SELECT
  T2.forename,
  T2.surname
FROM lapTimes AS T1
INNER JOIN drivers AS T2
  ON T1.driverId = T2.driverId
ORDER BY
  T1.time
LIMIT 20;
```
Critic: ```sql
SELECT
  T2.forename,
  T2.surname
FROM lapTimes AS T1
INNER JOIN drivers AS T2
  ON T1.driverId = T2.driverId
ORDER BY
  T1.milliseconds
LIMIT 20;
```
=====================
Question: Please list the lap records for the circuits in Italy.
 db_id: formula_1
Planner: Plan:
1. Find the `circuitId` for circuits in Italy from the `circuits` table, filtering by `country = 'Italy'`.
2. Join the `races` table with the `circuits` table on `circuitId` to get `raceId` for the Italian circuits.
3. Join the `lapTimes` table with the `races` table on `raceId`.
4. For each circuit, find the minimum lap time from the `lapTimes` table.
5. Display the circuit name and the corresponding minimum lap time.

Tables:
circuits: To filter for circuits in Italy and get the circuitId.
races: To join with circuits and get the raceId.
lapTimes: To get the lap times for each race.

Columns:
circuits: circuitId, name, country
races: raceId, circuitId
lapTimes: raceId, time

Filters:
circuits: country = 'Italy'

Joins:
circuits JOIN races ON circuits.circuitId = races.circuitId
races JOIN lapTimes ON races.raceId = lapTimes.raceId

NL2SQL: ```sql
SELECT
  c.name,
  MIN(l.time)
FROM circuits AS c
JOIN races AS r
  ON c.circuitId = r.circuitId
JOIN lapTimes AS l
  ON r.raceId = l.raceId
WHERE
  c.country = 'Italy'
GROUP BY
  c.name;
```
Critic: ```sql
SELECT DISTINCT
  T1.name,
  T2.fastestLapTime
FROM circuits AS T1
INNER JOIN results AS T2
  ON T1.circuitid = T2.raceid
WHERE
  T1.country = 'Italy' AND T2.fastestLapTime != '\\N';
```
=====================
Question: Among the superheroes with the super power of "Super Strength", how many of them have a height of over 200cm?
 db_id: superhero
Planner: 1. Find the `id` of the superpower "Super Strength" from the `superpower` table.
2. Use the `hero_power` table to find the `hero_id` of all superheroes that have the "Super Strength" superpower.
3. Use the `superhero` table to filter these superheroes and select those whose `height_cm` is greater than 200.
4. Count the number of such superheroes.

NL2SQL: ```sql
SELECT
  COUNT(T1.id)
FROM superhero AS T1
INNER JOIN hero_power AS T2
  ON T1.id = T2.hero_id
INNER JOIN superpower AS T3
  ON T2.power_id = T3.id
WHERE
  T3.power_name = 'Super Strength' AND T1.height_cm > 200;
```
Critic: ```sql
SELECT
  COUNT(T1.id)
FROM superhero AS T1
INNER JOIN hero_power AS T2
  ON T1.id = T2.hero_id
INNER JOIN superpower AS T3
  ON T2.power_id = T3.id
WHERE
  T3.power_name = 'Super Strength' AND T1.height_cm > 200
```
=====================
Question: Among the superheroes with blue eyes, how many of them have the super power of "Agility"?
 db_id: superhero
Planner: Plan:
1. Find the `id` of the color 'Blue' from the `colour` table.
2. Find the `id` of the power 'Agility' from the `superpower` table.
3. Find the `hero_id` from the `hero_power` table where `power_id` is the `id` of 'Agility'.
4. Find the superheroes from the `superhero` table whose `eye_colour_id` matches the `id` of 'Blue' and whose `id` is in the result of step 3.
5. Count the number of such superheroes.

NL2SQL: ```sql
SELECT
  COUNT(T1.id)
FROM superhero AS T1
INNER JOIN colour AS T2
  ON T1.eye_colour_id = T2.id
INNER JOIN hero_power AS T3
  ON T1.id = T3.hero_id
INNER JOIN superpower AS T4
  ON T3.power_id = T4.id
WHERE
  T2.colour = 'Blue' AND T4.power_name = 'Agility';
```
Critic: ```sql
SELECT
  COUNT(T1.id)
FROM superhero AS T1
INNER JOIN colour AS T2
  ON T1.eye_colour_id = T2.id
INNER JOIN hero_power AS T3
  ON T1.id = T3.hero_id
INNER JOIN superpower AS T4
  ON T3.power_id = T4.id
WHERE
  T2.colour = 'Blue' AND T4.power_name = 'Agility';
```
=====================
Question: Please list the superhero names of all the superheroes that have blue eyes and blond hair.
 db_id: superhero
Planner: 1. Find the `id` of the color 'Blue' in the `colour` table. This `id` will be used to filter superheroes with blue eyes.
2. Find the `id` of the color 'Blond' in the `colour` table. This `id` will be used to filter superheroes with blond hair.
3. From the `superhero` table, select `superhero_name` where `eye_colour_id` matches the 'Blue' color `id` and `hair_colour_id` matches the 'Blond' color `id`.

NL2SQL: ```sql
SELECT
  superhero_name
FROM superhero
WHERE
  eye_colour_id = (
    SELECT
      id
    FROM colour
    WHERE
      colour = 'Blue'
  )
  AND hair_colour_id = (
    SELECT
      id
    FROM colour
    WHERE
      colour = 'Blond'
  );
```
Critic: ```sql
SELECT
  superhero_name
FROM superhero
WHERE
  eye_colour_id IN (
    SELECT
      id
    FROM colour
    WHERE
      colour = 'Blue'
  )
  AND hair_colour_id IN (
    SELECT
      id
    FROM colour
    WHERE
      colour = 'Blond'
  );
```
=====================
Question: Rank heroes published by Marvel Comics by their height in descending order.
 db_id: superhero
Planner: 1.  Join the `superhero` table with the `publisher` table on `publisher_id`.
2.  Filter the results to include only superheroes where the `publisher_name` is 'Marvel Comics'.
3.  Select the `superhero_name` and `height_cm` columns.
4.  Order the results by `height_cm` in descending order.

NL2SQL: ```sql
SELECT
  T1.superhero_name
FROM superhero AS T1
INNER JOIN publisher AS T2
  ON T1.publisher_id = T2.id
WHERE
  T2.publisher_name = 'Marvel Comics'
ORDER BY
  T1.height_cm DESC;
```
Critic: ```sql
SELECT
  superhero_name
FROM superhero
WHERE
  publisher_id = (
    SELECT
      id
    FROM publisher
    WHERE
      publisher_name = 'Marvel Comics'
  )
ORDER BY
  height_cm DESC;
```
=====================
Question: Rank superheroes from Marvel Comics by their eye color popularity, starting with the most common color.
 db_id: superhero
Planner: 1.  Join the `superhero` table with the `colour` table on `eye_colour_id` = `id`.
2.  Filter the `superhero` table by `publisher_id` to include only superheroes from "Marvel Comics".  This requires joining `superhero` and `publisher` table.
3.  Group the results by `colour.colour`.
4.  Count the number of superheroes for each eye color using `COUNT(superhero.id)`.
5.  Order the results in descending order based on the count.
6.  Select the `colour.colour` and the count.

NL2SQL: ```sql
SELECT
  T2.colour,
  COUNT(T1.id)
FROM superhero AS T1
INNER JOIN colour AS T2
  ON T1.eye_colour_id = T2.id
INNER JOIN publisher AS T3
  ON T1.publisher_id = T3.id
WHERE
  T3.publisher_name = 'Marvel Comics'
GROUP BY
  T2.colour
ORDER BY
  COUNT(T1.id) DESC;
```
Critic: ```sql
SELECT
  T2.colour,
  COUNT(T1.id)
FROM superhero AS T1
INNER JOIN colour AS T2
  ON T1.eye_colour_id = T2.id
INNER JOIN publisher AS T3
  ON T1.publisher_id = T3.id
WHERE
  T3.publisher_name = 'Marvel Comics'
GROUP BY
  T2.colour
ORDER BY
  COUNT(T1.id) DESC;
```
=====================
Question: List the superheroes from Marvel Comics who have the super power of 'Super Strength'.
 db_id: superhero
Planner: 1. Find the `id` of the publisher 'Marvel Comics' from the `publisher` table.
2. Find the `id` of the superpower 'Super Strength' from the `superpower` table.
3. Find the `hero_id` from the `hero_power` table where `power_id` matches the id found in step 2.
4. Find the `superhero_name` from the `superhero` table where the `publisher_id` matches the id found in step 1 and `id` matches `hero_id` found in step 3.
5. Display the `superhero_name`.

NL2SQL: ```sql
SELECT
  T1.superhero_name
FROM superhero AS T1
INNER JOIN hero_power AS T2
  ON T1.id = T2.hero_id
INNER JOIN superpower AS T3
  ON T2.power_id = T3.id
INNER JOIN publisher AS T4
  ON T1.publisher_id = T4.id
WHERE
  T3.power_name = 'Super Strength' AND T4.publisher_name = 'Marvel Comics';
```
Critic: ```sql
SELECT
  T1.superhero_name
FROM superhero AS T1
INNER JOIN hero_power AS T2
  ON T1.id = T2.hero_id
INNER JOIN superpower AS T3
  ON T2.power_id = T3.id
INNER JOIN publisher AS T4
  ON T1.publisher_id = T4.id
WHERE
  T3.power_name = 'Super Strength' AND T4.publisher_name = 'Marvel Comics'
GROUP BY
  T1.superhero_name;
```
=====================
Question: Which publisher published the slowest superhero?
 db_id: superhero
Planner: Here's the plan to determine the publisher of the slowest superhero:

1.  **Find the slowest superhero:**
    *   Join `hero_attribute` with `attribute` on `attribute_id` to filter for records where `attribute_name` is 'Speed'.
    *   Find the minimum `attribute_value` from `hero_attribute` for 'Speed'.
    *   Identify the `hero_id` associated with that minimum speed.

2.  **Get the publisher of that superhero:**
    *   Join the result from step 1 (the `hero_id`) with the `superhero` table on `id`.
    *   Get the `publisher_id` from the `superhero` table.

3.  **Find the publisher name:**
    *   Join the `publisher` table with the `superhero` table using `publisher_id`.
    *   Select the `publisher_name` from the `publisher` table.

Final Answer:
```sql
SELECT
  T1.publisher_name
FROM publisher AS T1
INNER JOIN superhero AS T2
  ON T1.id = T2.publisher_id
INNER JOIN hero_attribute AS T3
  ON T2.id = T3.hero_id
INNER JOIN attribute AS T4
  ON T3.attribute_id = T4.id
WHERE
  T4.attribute_name = 'Speed'
ORDER BY
  T3.attribute_value
LIMIT 1;
```
NL2SQL: ```sql
SELECT
  T1.publisher_name
FROM publisher AS T1
INNER JOIN superhero AS T2
  ON T1.id = T2.publisher_id
INNER JOIN hero_attribute AS T3
  ON T2.id = T3.hero_id
INNER JOIN attribute AS T4
  ON T3.attribute_id = T4.id
WHERE
  T4.attribute_name = 'Speed'
ORDER BY
  T3.attribute_value
LIMIT 1;
```
Critic: ```sql
SELECT
  T1.publisher_name
FROM publisher AS T1
INNER JOIN superhero AS T2
  ON T1.id = T2.publisher_id
INNER JOIN hero_attribute AS T3
  ON T2.id = T3.hero_id
INNER JOIN attribute AS T4
  ON T3.attribute_id = T4.id
WHERE
  T4.attribute_name = 'Speed'
ORDER BY
  T3.attribute_value
LIMIT 1;
```
=====================
Question: How many gold-eyed superheroes did Marvel Comics publish?
 db_id: superhero
Planner: 1. Find the `id` of the color 'Gold' from the `colour` table.
2. Find the `id` of the publisher 'Marvel Comics' from the `publisher` table.
3. In the `superhero` table, filter by `eye_colour_id` matching the `id` found in step 1 and `publisher_id` matching the `id` found in step 2.
4. Count the number of superheroes that satisfy both conditions.

NL2SQL: ```sql
SELECT
  COUNT(*)
FROM superhero
JOIN colour
  ON superhero.eye_colour_id = colour.id
JOIN publisher
  ON superhero.publisher_id = publisher.id
WHERE
  colour.colour = 'Gold' AND publisher.publisher_name = 'Marvel Comics';
```
Critic: ```sql
SELECT
  COUNT(*)
FROM superhero AS T1
INNER JOIN colour AS T2
  ON T1.eye_colour_id = T2.id
INNER JOIN publisher AS T3
  ON T1.publisher_id = T3.id
WHERE
  T2.colour = 'Gold' AND T3.publisher_name = 'Marvel Comics';
```
=====================
Question: Who is the dumbest superhero?
 db_id: superhero
Planner: Plan:
1. Find the `id` of the 'Intelligence' attribute from the `attribute` table.
2. Use this `id` to filter the `hero_attribute` table to get the `hero_id` and `attribute_value` for intelligence of all heroes.
3. Find the minimum intelligence score, `MIN(attribute_value)`.
4. Join `hero_attribute` with `superhero` table to get `superhero_name` which has the minimum intelligence value.

NL2SQL: ```sql
SELECT
  T2.superhero_name
FROM hero_attribute AS T1
INNER JOIN superhero AS T2
  ON T1.hero_id = T2.id
INNER JOIN attribute AS T3
  ON T1.attribute_id = T3.id
WHERE
  T3.attribute_name = 'Intelligence'
ORDER BY
  T1.attribute_value
LIMIT 1;
```
Critic: ```sql
SELECT
  T1.superhero_name
FROM superhero AS T1
INNER JOIN hero_attribute AS T2
  ON T1.id = T2.hero_id
INNER JOIN attribute AS T3
  ON T2.attribute_id = T3.id
WHERE
  T3.attribute_name = 'Intelligence'
ORDER BY
  T2.attribute_value
LIMIT 1;
```
=====================
Question: What is Copycat's race?
 db_id: superhero
Planner: 1. Find the `id` of the superhero named "Copycat" from the `superhero` table.
2. Use the `id` found in step 1 to find the `race_id` of Copycat from the `superhero` table.
3. Use the `race_id` found in step 2 to find the race from the `race` table.
4. Return the race name.

NL2SQL: ```sql
SELECT
  T2.race
FROM superhero AS T1
INNER JOIN race AS T2
  ON T1.race_id = T2.id
WHERE
  T1.superhero_name = 'Copycat';
```
Critic: ```sql
SELECT
  T2.race
FROM superhero AS T1
INNER JOIN race AS T2
  ON T1.race_id = T2.id
WHERE
  T1.superhero_name = 'Copycat';
```
=====================
Question: Which superheroes have a durability attribute value of less than 50?
 db_id: superhero
Planner: 1.  Join `hero_attribute` with `attribute` on `attribute_id` to filter for 'Durability'.
2.  Filter the joined table for `attribute_name` = 'Durability' and `attribute_value` < 50.
3.  Join the filtered table with `superhero` on `hero_id` to get the `superhero_name`.
4.  Select the `superhero_name`.


NL2SQL: ```sql
SELECT
  T1.superhero_name
FROM superhero AS T1
INNER JOIN hero_attribute AS T2
  ON T1.id = T2.hero_id
INNER JOIN attribute AS T3
  ON T2.attribute_id = T3.id
WHERE
  T3.attribute_name = 'Durability' AND T2.attribute_value < 50;
```
Critic: ```sql
SELECT
  T1.superhero_name
FROM superhero AS T1
INNER JOIN hero_attribute AS T2
  ON T1.id = T2.hero_id
INNER JOIN attribute AS T3
  ON T2.attribute_id = T3.id
WHERE
  T3.attribute_name = 'Durability' AND T2.attribute_value < 50;
```
=====================
Question: What are the names of the superheroes with the power of death touch?
 db_id: superhero
Planner: 1. Find the `id` of the power named 'Death Touch' in the `superpower` table.
2. Use the `id` from step 1 to filter the `hero_power` table, retrieving `hero_id` values.
3. Use the `hero_id` values from step 2 to filter the `superhero` table, retrieving the `superhero_name` column.

NL2SQL: ```sql
SELECT
  T1.superhero_name
FROM superhero AS T1
INNER JOIN hero_power AS T2
  ON T1.id = T2.hero_id
INNER JOIN superpower AS T3
  ON T2.power_id = T3.id
WHERE
  T3.power_name = 'Death Touch';
```
Critic: ```sql
SELECT
  T1.superhero_name
FROM superhero AS T1
INNER JOIN hero_power AS T2
  ON T1.id = T2.hero_id
INNER JOIN superpower AS T3
  ON T2.power_id = T3.id
WHERE
  T3.power_name = 'Death Touch';
```
=====================
Question: How many female superheroes have a strength value of 100?
 db_id: superhero
Planner: 1. Join the `superhero` table with the `gender` table on `gender_id` to filter for female superheroes.
2. Join the `superhero` table with the `hero_attribute` table on `id` to get the strength value.
3. Join the `attribute` table with the `hero_attribute` table on `id` to filter the attribute as strength.
4. Filter the results based on the condition that gender is 'Female' and the strength value is 100.
5. Count the number of superheroes that satisfy the above conditions.

NL2SQL: ```sql
SELECT
  COUNT(T1.id)
FROM superhero AS T1
INNER JOIN gender AS T2
  ON T1.gender_id = T2.id
INNER JOIN hero_attribute AS T3
  ON T1.id = T3.hero_id
INNER JOIN attribute AS T4
  ON T3.attribute_id = T4.id
WHERE
  T2.gender = 'Female' AND T4.attribute_name = 'Strength' AND T3.attribute_value = 100;
```
Critic: ```sql
SELECT
  COUNT(T1.id)
FROM superhero AS T1
INNER JOIN gender AS T2
  ON T1.gender_id = T2.id
INNER JOIN hero_attribute AS T3
  ON T1.id = T3.hero_id
INNER JOIN attribute AS T4
  ON T3.attribute_id = T4.id
WHERE
  T2.gender = 'Female' AND T4.attribute_name = 'Strength' AND T3.attribute_value = 100;
```
=====================
Question: What is the percentage of superheroes who act in their own self-interest or make decisions based on their own moral code? Indicate how many of the said superheroes were published by Marvel Comics.
 db_id: superhero
Planner: Plan:
1. Calculate the total number of superheroes.
2. Calculate the number of superheroes with alignment 'Bad'.
3. Calculate the percentage of superheroes with alignment 'Bad'.
4. Calculate the number of superheroes with alignment 'Bad' published by Marvel Comics.
5. Combine the percentage and the count of 'Bad' aligned Marvel superheroes in the final result.

Tables:
- superhero
- publisher
- alignment

Columns:
- superhero.id
- superhero.publisher_id
- alignment.alignment
- publisher.publisher_name

Filters:
- alignment.alignment = 'Bad'
- publisher.publisher_name = 'Marvel Comics'

Joins:
- superhero JOIN alignment ON superhero.alignment_id = alignment.id
- superhero JOIN publisher ON superhero.publisher_id = publisher.id

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.alignment = 'Bad' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id),
  SUM(CASE WHEN T1.alignment = 'Bad' AND T2.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END)
FROM alignment AS T1
INNER JOIN superhero AS T3
  ON T1.id = T3.alignment_id
INNER JOIN publisher AS T2
  ON T3.publisher_id = T2.id;
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.alignment = 'Bad' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id),
  SUM(CASE WHEN T1.alignment = 'Bad' AND T2.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END)
FROM alignment AS T1
INNER JOIN superhero AS T3
  ON T1.id = T3.alignment_id
INNER JOIN publisher AS T2
  ON T3.publisher_id = T2.id;
```
=====================
Question: Between DC and Marvel Comics, which publisher has published more superheroes? Find the difference in the number of superheroes they have published.
 db_id: superhero
Planner: 1. **Count Superheroes for Each Publisher:**
   - Join the `superhero` table with the `publisher` table on `publisher_id`.
   - Filter for publishers 'DC Comics' and 'Marvel Comics'.
   - Group by `publisher_name` and count the number of superheroes for each.

2. **Calculate the Difference:**
   - Subtract the count of superheroes for 'DC Comics' from the count of superheroes for 'Marvel Comics'.

3. **Return the Difference:**
   - Return the calculated difference.

NL2SQL: ```sql
SELECT
  SUM(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.publisher_name = 'DC Comics' THEN 1 ELSE 0 END)
FROM superhero AS T1
INNER JOIN publisher AS T2
  ON T1.publisher_id = T2.id
WHERE
  T2.publisher_name = 'DC Comics' OR T2.publisher_name = 'Marvel Comics';
```
Critic: ```sql
SELECT
  SUM(CASE WHEN publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END) - SUM(CASE WHEN publisher_name = 'DC Comics' THEN 1 ELSE 0 END)
FROM publisher AS T1
INNER JOIN superhero AS T2
  ON T1.id = T2.publisher_id;
```
=====================
Question: Give the publisher ID of Star Trek.
 db_id: superhero
Planner: We need to find the `id` from the `publisher` table where the `publisher_name` is 'Star Trek'.
Plan:
1. SELECT the `id` column from the `publisher` table.
2. Filter the results using a WHERE clause where `publisher_name` = 'Star Trek'.

NL2SQL: ```sql
SELECT
  id
FROM publisher
WHERE
  publisher_name = 'Star Trek';
```
Critic: ```sql
SELECT
  id
FROM publisher
WHERE
  publisher_name = 'Star Trek';
```
=====================
Question: What is the total number of superheroes without full name?
 db_id: superhero
Planner: 1. Select the count of superheroes.
2. Filter the superheroes table where the full_name is NULL.

NL2SQL: ```sql
SELECT
  COUNT(id)
FROM superhero
WHERE
  full_name IS NULL;
```
Critic: ```sql
SELECT
  COUNT(id)
FROM superhero
WHERE
  full_name IS NULL;
```
=====================
Question: What is the average weight of all female superheroes?
 db_id: superhero
Planner: 1. Need to find the average weight of female superheroes.
2. Need to join the `superhero` table with the `gender` table on `gender_id`.
3. Filter for gender = 'Female'.
4. Calculate the average weight using AVG(weight_kg).
5. Select the average weight.

NL2SQL: ```sql
SELECT AVG(T1.weight_kg) FROM superhero AS T1 JOIN gender AS T2 ON T1.gender_id = T2.id WHERE T2.gender = 'Female'
```
Critic: ```sql
SELECT avg(T1.weight_kg) FROM superhero AS T1 INNER JOIN gender AS T2 ON T1.gender_id = T2.id WHERE T2.gender = "Female"
```
=====================
Question: List down at least five superpowers of male superheroes.
 db_id: superhero
Planner: 1. Find the gender id for 'Male' in the `gender` table.
2. Find the superhero ids for all male superheroes by filtering `superhero` table on `gender_id`.
3. Use the superhero ids to find the corresponding superpower ids from the `hero_power` table.
4. Retrieve the superpower names from the `superpower` table using the superpower ids.
5. Limit the results to at least 5 superpowers.

NL2SQL: ```sql
SELECT DISTINCT
  T2.power_name
FROM superhero AS T1
INNER JOIN hero_power AS T3
  ON T1.id = T3.hero_id
INNER JOIN superpower AS T2
  ON T3.power_id = T2.id
INNER JOIN gender AS T4
  ON T1.gender_id = T4.id
WHERE
  T4.gender = 'Male'
LIMIT 5;
```
Critic: ```sql
SELECT DISTINCT
  T2.power_name
FROM superhero AS T1
INNER JOIN hero_power AS T3
  ON T1.id = T3.hero_id
INNER JOIN superpower AS T2
  ON T3.power_id = T2.id
INNER JOIN gender AS T4
  ON T1.gender_id = T4.id
WHERE
  T4.gender = 'Male'
LIMIT 5;
```
=====================
Question: Among the superheroes with height from 170 to 190, list the names of the superheroes with no eye color.
 db_id: superhero
Planner: 1. Filter the `superhero` table to select superheroes with `height_cm` between 170 and 190.
2. Find superheroes with no eye color by joining `superhero` and `colour` table on `eye_colour_id` and filter `colour` column with value "No Colour".
3. Return the `superhero_name` of the selected superheroes.

NL2SQL: ```sql
SELECT
  T1.superhero_name
FROM superhero AS T1
INNER JOIN colour AS T2
  ON T1.eye_colour_id = T2.id
WHERE
  T1.height_cm BETWEEN 170 AND 190 AND T2.colour = 'No Colour';
```
Critic: ```sql
SELECT
  superhero_name
FROM superhero
WHERE
  height_cm BETWEEN 170 AND 190 AND eye_colour_id IS NULL;
```
=====================
Question: Provide the hair colour of the human superhero who is 185 cm tall.
 db_id: superhero
Planner: 1. Filter the `superhero` table to find superheroes with `height_cm` equal to 185.
2. Filter the `race` table to find the id of the race 'Human'.
3. Filter the `superhero` table using the race id obtained in step 2.
4. Combine the filtered `superhero` table from steps 1 and 3 using the id to consider only human superheroes with a height of 185 cm.
5. Retrieve the `hair_colour_id` from the filtered `superhero` table.
6. Join the `colour` table with the `superhero` table using `hair_colour_id` and `id` to find the hair color corresponding to the `hair_colour_id`.
7. Select the `colour` from the `colour` table.

NL2SQL: ```sql
SELECT
  T2.colour
FROM superhero AS T1
INNER JOIN colour AS T2
  ON T1.hair_colour_id = T2.id
INNER JOIN race AS T3
  ON T1.race_id = T3.id
WHERE
  T3.race = 'Human' AND T1.height_cm = 185;
```
Critic: ```sql
SELECT
  T2.colour
FROM superhero AS T1
INNER JOIN colour AS T2
  ON T1.hair_colour_id = T2.id
INNER JOIN race AS T3
  ON T1.race_id = T3.id
WHERE
  T3.race = 'Human' AND T1.height_cm = 185;
```
=====================
Question: In superheroes with height between 150 to 180, what is the percentage of heroes published by Marvel Comics?
 db_id: superhero
Planner: Here's a plan to determine the percentage of superheroes with heights between 150cm and 180cm who are published by Marvel Comics:

1.  **Filter Superheroes by Height:** Select superheroes from the `superhero` table where `height_cm` is between 150 and 180.
2.  **Join with Publisher:** Join the filtered superheroes with the `publisher` table using `publisher_id` to determine the publisher of each hero.
3.  **Count Total Superheroes:** Count the total number of superheroes within the specified height range.
4.  **Count Marvel Superheroes:** Count the number of superheroes within the specified height range published by Marvel Comics (where `publisher_name` is 'Marvel Comics').
5.  **Calculate Percentage:** Divide the number of Marvel superheroes by the total number of superheroes and multiply by 100 to get the percentage.
6.  **Return the result.**

The tables involved are `superhero` and `publisher`.
The columns involved are `superhero.height_cm`, `superhero.publisher_id`, `publisher.id`, and `publisher.publisher_name`.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id)
FROM superhero AS T1
INNER JOIN publisher AS T2
  ON T1.publisher_id = T2.id
WHERE
  T1.height_cm BETWEEN 150 AND 180;
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id)
FROM superhero AS T1
INNER JOIN publisher AS T2
  ON T1.publisher_id = T2.id
WHERE
  T1.height_cm BETWEEN 150 AND 180;
```
=====================
Question: Among the male superheroes, list the super hero names of superheroes with weight greater than the 79% average weight of all superheroes.
 db_id: superhero
Planner: 1. Find the average weight of all superheroes.
2. Filter superheroes by gender = 'Male'.
3. Select the superhero names of male superheroes whose weight is greater than 79% of the average weight.

Tables:
- superhero: To get the superhero name, weight and gender id.
- gender: To filter superheroes by gender.

Columns:
- superhero.superhero_name: To display the superhero name.
- superhero.weight_kg: To filter by weight.
- superhero.gender_id: To join with the gender table.
- gender.gender: To filter by gender.

NL2SQL: ```sql
SELECT
  T1.superhero_name
FROM superhero AS T1
INNER JOIN gender AS T2
  ON T1.gender_id = T2.id
WHERE
  T2.gender = 'Male' AND T1.weight_kg > (
    SELECT
      AVG(weight_kg) * 0.79
    FROM superhero
  );
```
Critic: ```sql
SELECT
  superhero_name
FROM superhero
WHERE
  gender_id = (
    SELECT
      id
    FROM gender
    WHERE
      gender = 'Male'
  )
  AND weight_kg > (
    SELECT
      AVG(weight_kg) * 0.79
    FROM superhero
  );
```
=====================
Question: What are the superpowers of heroes with ID 1?
 db_id: superhero
Planner: 1.  We need to find the superpowers of heroes. The superpower information is in the `superpower` table and the hero information is in the `hero_power` table.
2.  We need to join the `hero_power` table with the `superpower` table using the `power_id` column.
3.  We need to filter the `hero_power` table by `hero_id = 1`.
4.  Finally, we need to select the `power_name` column from the `superpower` table.

```sql
SELECT
  T2.power_name
FROM hero_power AS T1
INNER JOIN superpower AS T2
  ON T1.power_id = T2.id
WHERE
  T1.hero_id = 1;
```
NL2SQL: ```sql
SELECT
  T2.power_name
FROM hero_power AS T1
INNER JOIN superpower AS T2
  ON T1.power_id = T2.id
WHERE
  T1.hero_id = 1;
```
Critic: ```sql
SELECT
  T2.power_name
FROM hero_power AS T1
INNER JOIN superpower AS T2
  ON T1.power_id = T2.id
WHERE
  T1.hero_id = 1;
```
=====================
Question: How many heroes have stealth power?
 db_id: superhero
Planner: 1. Find the `id` of the 'Stealth' power from the `superpower` table.
2. Use the `id` found in the previous step to find all `hero_id` values in the `hero_power` table where `power_id` matches the 'Stealth' power `id`.
3. Count the distinct `hero_id` values obtained in the previous step. This represents the number of heroes with the 'Stealth' power.

NL2SQL: ```sql
SELECT
  COUNT(DISTINCT hero_id)
FROM hero_power
WHERE
  power_id = (
    SELECT
      id
    FROM superpower
    WHERE
      power_name = 'Stealth'
  );
```
Critic: ```sql
SELECT COUNT(T1.hero_id) FROM hero_power AS T1 INNER JOIN superpower AS T2 ON T1.power_id = T2.id WHERE T2.power_name = 'Stealth'
```
=====================
Question: What is the hero's full name with the highest attribute in strength?
 db_id: superhero
Planner: 1. Find the `id` of the 'Strength' attribute from the `attribute` table.
2. Join `hero_attribute` table with `superhero` table using `hero_id` to get full name.
3. Filter the `hero_attribute` table with the `id` obtained in step 1 to consider only strength attributes.
4. Find the maximum `attribute_value` among the strength attributes.
5. Select the full name of the hero with maximum strength from the result in step 4.

NL2SQL: ```sql
SELECT
  T1.full_name
FROM superhero AS T1
INNER JOIN hero_attribute AS T2
  ON T1.id = T2.hero_id
INNER JOIN attribute AS T3
  ON T2.attribute_id = T3.id
WHERE
  T3.attribute_name = 'Strength'
ORDER BY
  T2.attribute_value DESC
LIMIT 1;
```
Critic: ```sql
SELECT
  T1.full_name
FROM superhero AS T1
INNER JOIN hero_attribute AS T2
  ON T1.id = T2.hero_id
INNER JOIN attribute AS T3
  ON T2.attribute_id = T3.id
WHERE
  T3.attribute_name = 'Strength'
ORDER BY
  T2.attribute_value DESC
LIMIT 1;
```
=====================
Question: Which superhero has the most durability published by Dark Horse Comics?
 db_id: superhero
Planner: 1. Find the publisher ID for 'Dark Horse Comics' in the `publisher` table.
2. Join `superhero` table with `hero_attribute` table on `hero_id`.
3. Join the `attribute` table with `hero_attribute` on `attribute_id`.
4. Filter the joined table to include only superheroes published by 'Dark Horse Comics' and durability.
5. Find the superhero with the maximum durability value.
6. Return the superhero's name.

NL2SQL: ```sql
SELECT
  T1.superhero_name
FROM superhero AS T1
INNER JOIN hero_attribute AS T2
  ON T1.id = T2.hero_id
INNER JOIN attribute AS T3
  ON T2.attribute_id = T3.id
INNER JOIN publisher AS T4
  ON T1.publisher_id = T4.id
WHERE
  T3.attribute_name = 'Durability' AND T4.publisher_name = 'Dark Horse Comics'
ORDER BY
  T2.attribute_value DESC
LIMIT 1;
```
Critic: ```sql
SELECT
  T1.superhero_name
FROM superhero AS T1
INNER JOIN hero_attribute AS T2
  ON T1.id = T2.hero_id
INNER JOIN attribute AS T3
  ON T2.attribute_id = T3.id
INNER JOIN publisher AS T4
  ON T1.publisher_id = T4.id
WHERE
  T3.attribute_name = 'durability' AND T4.publisher_name = 'Dark Horse Comics'
ORDER BY
  T2.attribute_value DESC
LIMIT 1;
```
=====================
Question: List the eyes, hair and skin colour of all female superheroes published by Dark Horse Comics.
 db_id: superhero
Planner: 1. Filter the `gender` table to find the `id` for 'Female'.
2. Filter the `publisher` table to find the `id` for 'Dark Horse Comics'.
3. In the `superhero` table, filter for `gender_id` from step 1 and `publisher_id` from step 2.
4. Retrieve `eye_colour_id`, `hair_colour_id`, and `skin_colour_id` from the filtered `superhero` table.
5. Join `colour` table three times, using aliases to differentiate between eye, hair and skin colours, on `eye_colour_id`, `hair_colour_id` and `skin_colour_id` respectively, to get the actual colours.
6. Select the eye, hair and skin colour from the joined table.

NL2SQL: ```sql
SELECT
  ec.colour,
  hc.colour,
  sc.colour
FROM superhero AS sh
JOIN gender AS g
  ON sh.gender_id = g.id
JOIN publisher AS p
  ON sh.publisher_id = p.id
JOIN colour AS ec
  ON sh.eye_colour_id = ec.id
JOIN colour AS hc
  ON sh.hair_colour_id = hc.id
JOIN colour AS sc
  ON sh.skin_colour_id = sc.id
WHERE
  g.gender = 'Female' AND p.publisher_name = 'Dark Horse Comics';
```
Critic: ```sql
SELECT
  T1.colour,
  T2.colour,
  T3.colour
FROM superhero AS T4
INNER JOIN colour AS T1
  ON T4.eye_colour_id = T1.id
INNER JOIN colour AS T2
  ON T4.hair_colour_id = T2.id
INNER JOIN colour AS T3
  ON T4.skin_colour_id = T3.id
INNER JOIN publisher AS T5
  ON T4.publisher_id = T5.id
INNER JOIN gender AS T6
  ON T4.gender_id = T6.id
WHERE
  T5.publisher_name = 'Dark Horse Comics' AND T6.gender = 'Female';
```
=====================
Question: Which superhero has the same eyes, hair and skin colour? Indicate the publisher of the superhero.
 db_id: superhero
Planner: 1. Select the superhero name and publisher name.
2. Join the `superhero` table with the `publisher` table on `publisher_id`.
3. Filter the results where `eye_colour_id`, `hair_colour_id`, and `skin_colour_id` are equal.

NL2SQL: ```sql
SELECT
  T1.superhero_name,
  T2.publisher_name
FROM superhero AS T1
INNER JOIN publisher AS T2
  ON T1.publisher_id = T2.id
WHERE
  T1.hair_colour_id = T1.skin_colour_id AND T1.hair_colour_id = T1.eye_colour_id;
```
Critic: ```sql
SELECT
  T1.superhero_name,
  T2.publisher_name
FROM superhero AS T1
INNER JOIN publisher AS T2
  ON T1.publisher_id = T2.id
WHERE
  T1.eye_colour_id = T1.hair_colour_id AND T1.hair_colour_id = T1.skin_colour_id;
```
=====================
Question: What is the percentage of blue female superheroes among all female superheroes?
 db_id: superhero
Planner: Plan:
1. Find the id of the 'Female' gender from the `gender` table.
2. Find the id of the 'Blue' color from the `colour` table.
3. Count the number of female superheroes whose eye color is blue. This involves joining `superhero` with `gender` on `gender_id` and with `colour` on `eye_colour_id`. Filter by gender='Female' and colour='Blue'.
4. Count the total number of female superheroes by joining `superhero` with `gender` on `gender_id` and filtering by gender='Female'.
5. Calculate the percentage by dividing the count from step 3 by the count from step 4 and multiplying by 100.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T3.colour = 'Blue' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id)
FROM superhero AS T1
INNER JOIN gender AS T2
  ON T1.gender_id = T2.id
INNER JOIN colour AS T3
  ON T1.eye_colour_id = T3.id
WHERE
  T2.gender = 'Female';
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T3.colour = 'Blue' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id)
FROM superhero AS T1
INNER JOIN gender AS T2
  ON T1.gender_id = T2.id
INNER JOIN colour AS T3
  ON T1.eye_colour_id = T3.id
WHERE
  T2.gender = 'Female';
```
=====================
Question: How many powers does Amazo hero have?
 db_id: superhero
Planner: 1. Find the superhero named 'Amazo' in the `superhero` table.
2. Use the `id` of 'Amazo' from the `superhero` table to filter the `hero_power` table.
3. Count the number of powers associated with 'Amazo' in the `hero_power` table.
4. Return the count.

NL2SQL: ```sql
SELECT
  COUNT(power_id)
FROM hero_power
WHERE
  hero_id = (
    SELECT
      id
    FROM superhero
    WHERE
      superhero_name = 'Amazo'
  );
```
Critic: ```sql
SELECT
  COUNT(*)
FROM hero_power
WHERE
  hero_id = (
    SELECT
      id
    FROM superhero
    WHERE
      superhero_name = 'Amazo'
  );
```
=====================
Question: Provide the heights of the heroes whose eye colours are amber.
 db_id: superhero
Planner: 1.  Join the `superhero` table with the `colour` table on the `eye_colour_id` column to filter superheroes with amber eyes.
2.  Filter the joined table to include only rows where `colour.colour` is 'Amber'.
3.  Select the `height_cm` column from the filtered table to output the heights of the selected superheroes.

NL2SQL: ```sql
SELECT
  T1.height_cm
FROM superhero AS T1
INNER JOIN colour AS T2
  ON T1.eye_colour_id = T2.id
WHERE
  T2.colour = 'Amber';
```
Critic: ```sql
SELECT
  height_cm
FROM superhero
WHERE
  eye_colour_id = (
    SELECT
      id
    FROM colour
    WHERE
      colour = 'Amber'
  );
```
=====================
Question: List the heroes' names whose eyes and hair colours are both black.
 db_id: superhero
Planner: 1.  Join the `superhero` table with the `colour` table twice, once for eye colour and once for hair colour.
2.  Filter the results where both eye colour and hair colour are 'Black'.
3.  Select the `superhero_name` from the `superhero` table.

NL2SQL: ```sql
SELECT
  T1.superhero_name
FROM superhero AS T1
INNER JOIN colour AS T2
  ON T1.eye_colour_id = T2.id
INNER JOIN colour AS T3
  ON T1.hair_colour_id = T3.id
WHERE
  T2.colour = 'Black' AND T3.colour = 'Black';
```
Critic: ```sql
SELECT
  T1.superhero_name
FROM superhero AS T1
INNER JOIN colour AS T2
  ON T1.eye_colour_id = T2.id
INNER JOIN colour AS T3
  ON T1.hair_colour_id = T3.id
WHERE
  T2.colour = 'Black' AND T3.colour = 'Black';
```
=====================
Question: Describe the names of neutral alignment superheroes.
 db_id: superhero
Planner: 1. Select the `superhero_name` from the `superhero` table.
2. Join the `superhero` table with the `alignment` table using the `alignment_id` column.
3. Filter the results to include only superheroes where the `alignment` is 'Neutral'.

NL2SQL: ```sql
SELECT
  T1.superhero_name
FROM superhero AS T1
INNER JOIN alignment AS T2
  ON T1.alignment_id = T2.id
WHERE
  T2.alignment = 'Neutral';
```
Critic: ```sql
SELECT
  superhero_name
FROM superhero
WHERE
  alignment_id = (
    SELECT
      id
    FROM alignment
    WHERE
      alignment = 'Neutral'
  );
```
=====================
Question: How many heroes have the highest attribute value in strength?
 db_id: superhero
Planner: Plan:
1. Find the id of the 'Strength' attribute from the 'attribute' table.
2. Find the maximum attribute value for 'Strength' from the 'hero_attribute' table, filtering by the 'Strength' attribute ID.
3. Count the number of heroes that have the maximum 'Strength' attribute value. Join 'hero_attribute' and 'attribute' tables. Filter by attribute name 'Strength' and also filter by the maximum strength value found in the previous step.
4. Output the count of such heroes.

NL2SQL: ```sql
SELECT
  COUNT(T1.hero_id)
FROM hero_attribute AS T1
INNER JOIN attribute AS T2
  ON T1.attribute_id = T2.id
WHERE
  T2.attribute_name = 'Strength' AND T1.attribute_value = (
    SELECT
      MAX(attribute_value)
    FROM hero_attribute
    WHERE
      attribute_id = (
        SELECT
          id
        FROM attribute
        WHERE
          attribute_name = 'Strength'
      )
  );
```
Critic: ```sql
SELECT
  COUNT(T1.hero_id)
FROM hero_attribute AS T1
INNER JOIN attribute AS T2
  ON T1.attribute_id = T2.id
WHERE
  T2.attribute_name = 'Strength' AND T1.attribute_value = (
    SELECT
      MAX(attribute_value)
    FROM hero_attribute AS T3
    INNER JOIN attribute AS T4
      ON T3.attribute_id = T4.id
    WHERE
      T4.attribute_name = 'Strength'
  );
```
=====================
Question: How many percent of female heroes were published by Marvel Comics?
 db_id: superhero
Planner: Here's the plan to calculate the percentage of female heroes published by Marvel Comics:

1.  **Identify female heroes:** Use the `gender` table to filter for gender 'Female'
2.  **Identify heroes published by Marvel Comics:** Use the `publisher` table to filter for 'Marvel Comics'.
3.  **Join tables:** Join `superhero` table with `gender` table on `gender.id` = `superhero.gender_id` and with `publisher` table on `publisher.id` = `superhero.publisher_id`.
4.  **Calculate the number of female heroes published by Marvel:** Count the number of heroes that satisfy both conditions.
5.  **Calculate the total number of female heroes:** Count the number of heroes that satisfy female gender condition
6.  **Calculate the percentage:** Divide the number of female heroes published by Marvel by the total number of female heroes, and multiply by 100.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id)
FROM superhero AS T1
INNER JOIN publisher AS T2
  ON T1.publisher_id = T2.id
INNER JOIN gender AS T3
  ON T1.gender_id = T3.id
WHERE
  T3.gender = 'Female';
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id)
FROM superhero AS T1
INNER JOIN publisher AS T2
  ON T1.publisher_id = T2.id
INNER JOIN gender AS T3
  ON T1.gender_id = T3.id
WHERE
  T3.gender = 'Female';
```
=====================
Question: Calculate the difference between Emil Blonsky's weight and Charles Chandler's weight.
 db_id: superhero
Planner: 1.  Find the weight of Emil Blonsky from the `superhero` table.
2.  Find the weight of Charles Chandler from the `superhero` table.
3.  Calculate the difference between Emil Blonsky's weight and Charles Chandler's weight.
4.  Return the calculated difference.

NL2SQL: ```sql
SELECT
  (
    SELECT
      weight_kg
    FROM superhero
    WHERE
      full_name = 'Emil Blonsky'
  ) - (
    SELECT
      weight_kg
    FROM superhero
    WHERE
      full_name = 'Charles Chandler'
  );
```
Critic: ```sql
SELECT (SELECT weight_kg FROM superhero WHERE full_name = 'Emil Blonsky') - (SELECT weight_kg FROM superhero WHERE full_name = 'Charles Chandler');
```
=====================
Question: Calculate the average height for all superhero.
 db_id: superhero
Planner: Plan:
The question asks for the average height of all superheroes.
1. Select the `height_cm` column from the `superhero` table.
2. Calculate the average of the `height_cm` column.
3. Return the calculated average.

NL2SQL: ```sql
SELECT avg(height_cm) FROM superhero
```
Critic: ```sql
SELECT avg(height_cm) FROM superhero
```
=====================
Question: What is Abomination's superpower?
 db_id: superhero
Planner: 1. Find the superhero id of 'Abomination' from the `superhero` table.
2. Use the hero id to find the corresponding power ids from the `hero_power` table.
3. Use the power ids to find the `power_name` from the `superpower` table.

NL2SQL: ```sql
SELECT
  T2.power_name
FROM superhero AS T1
INNER JOIN hero_power AS T3
  ON T1.id = T3.hero_id
INNER JOIN superpower AS T2
  ON T3.power_id = T2.id
WHERE
  T1.superhero_name = 'Abomination';
```
Critic: ```sql
SELECT
  T2.power_name
FROM superhero AS T1
INNER JOIN hero_power AS T3
  ON T1.id = T3.hero_id
INNER JOIN superpower AS T2
  ON T3.power_id = T2.id
WHERE
  T1.superhero_name = 'Abomination';
```
=====================
Question: Which hero was the fastest?
 db_id: superhero
Planner: Plan:
1. Find the `id` of the 'Speed' attribute from the `attribute` table.
2. Using the `hero_attribute` table, filter for rows where `attribute_id` matches the id found in the previous step.
3. Find the superhero name associated with the maximum `attribute_value` from the `superhero` table. Join `superhero` table with `hero_attribute` table on `hero_id`.
4. Select the superhero name that corresponds to the maximum speed attribute value.

NL2SQL: ```sql
SELECT
  T1.superhero_name
FROM superhero AS T1
INNER JOIN hero_attribute AS T2
  ON T1.id = T2.hero_id
INNER JOIN attribute AS T3
  ON T2.attribute_id = T3.id
WHERE
  T3.attribute_name = 'Speed'
ORDER BY
  T2.attribute_value DESC
LIMIT 1;
```
Critic: ```sql
SELECT
  T1.superhero_name
FROM superhero AS T1
INNER JOIN hero_attribute AS T2
  ON T1.id = T2.hero_id
INNER JOIN attribute AS T3
  ON T2.attribute_id = T3.id
WHERE
  T3.attribute_name = 'Speed'
ORDER BY
  T2.attribute_value DESC
LIMIT 1;
```
=====================
Question: State all of 3-D Man's attributes along with their values.
 db_id: superhero
Planner: 1. Find the `id` of the superhero named "3-D Man" from the `superhero` table.
2. Use the superhero's `id` to find all related entries in the `hero_attribute` table. This will give us the `attribute_id` and `attribute_value`.
3. Join the `attribute` table on `attribute_id` to retrieve the corresponding `attribute_name` for each `attribute_id` obtained in the previous step.
4. Display the `attribute_name` and `attribute_value` for each entry.

NL2SQL: ```sql
SELECT
  T2.attribute_name,
  T1.attribute_value
FROM hero_attribute AS T1
INNER JOIN attribute AS T2
  ON T1.attribute_id = T2.id
INNER JOIN superhero AS T3
  ON T1.hero_id = T3.id
WHERE
  T3.superhero_name = '3-D Man';
```
Critic: ```sql
SELECT
  T2.attribute_name,
  T1.attribute_value
FROM hero_attribute AS T1
INNER JOIN attribute AS T2
  ON T1.attribute_id = T2.id
INNER JOIN superhero AS T3
  ON T1.hero_id = T3.id
WHERE
  T3.superhero_name = '3-D Man';
```
=====================
Question: Which superheroes have blue eyes with brown hair?
 db_id: superhero
Planner: 1.  Join the `superhero` table with the `colour` table twice, once for eye color and once for hair color. Use aliases to distinguish between the two joins.
2.  Filter the results to include superheroes where the eye color is 'Blue' and the hair color is 'Brown'.
3.  Select the `superhero_name` from the `superhero` table.


NL2SQL: ```sql
SELECT
  T1.superhero_name
FROM superhero AS T1
INNER JOIN colour AS T2
  ON T1.eye_colour_id = T2.id
INNER JOIN colour AS T3
  ON T1.hair_colour_id = T3.id
WHERE
  T2.colour = 'Blue' AND T3.colour = 'Brown';
```
Critic: ```sql
SELECT
  superhero_name
FROM superhero
WHERE
  eye_colour_id = (
    SELECT
      id
    FROM colour
    WHERE
      colour = 'Blue'
  )
  AND hair_colour_id = (
    SELECT
      id
    FROM colour
    WHERE
      colour = 'Brown'
  );
```
=====================
Question: What is the publisher for Hawkman, Karate Kid and Speedy?
 db_id: superhero
Planner: 1. Find the `id` of the superheroes named 'Hawkman', 'Karate Kid', and 'Speedy' from the `superhero` table.
2. For each of these `id`s, find the corresponding `publisher_id` from the `superhero` table.
3. Find the `publisher_name` from the `publisher` table, using the `publisher_id` obtained in the previous step.
4. Return the `publisher_name`.

NL2SQL: ```sql
SELECT
  t1.publisher_name
FROM publisher AS t1
INNER JOIN superhero AS t2
  ON t1.id = t2.publisher_id
WHERE
  t2.superhero_name IN ('Hawkman', 'Karate Kid', 'Speedy');
```
Critic: ```sql
SELECT DISTINCT
  T1.publisher_name
FROM publisher AS T1
INNER JOIN superhero AS T2
  ON T1.id = T2.publisher_id
WHERE
  T2.superhero_name IN ('Hawkman', 'Karate Kid', 'Speedy');
```
=====================
Question: Calculate the percentage of superheroes with blue eyes.
 db_id: superhero
Planner: Here's the plan to calculate the percentage of superheroes with blue eyes:

1.  **Identify superheroes with blue eyes:** Join the `superhero` table with the `colour` table on `eye_colour_id = colour.id`. Filter the joined table where `colour.colour = 'Blue'`. Count the number of superheroes with blue eyes.
2.  **Calculate the total number of superheroes:** Count the total number of superheroes in the `superhero` table.
3.  **Calculate the percentage:** Divide the number of superheroes with blue eyes (step 1) by the total number of superheroes (step 2) and multiply by 100.

I need `superhero` table and `colour` table.
I need to count all superheroes.
I need to count the superheroes with blue eyes.
I need to calculate the percentage.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.colour = 'Blue' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T2.id)
FROM colour AS T1
INNER JOIN superhero AS T2
  ON T1.id = T2.eye_colour_id;
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.colour = 'Blue' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T2.id)
FROM colour AS T1
INNER JOIN superhero AS T2
  ON T1.id = T2.eye_colour_id;
```
=====================
Question: Find the ratio between male superheroes and female superheroes.
 db_id: superhero
Planner: Plan:
1. Count the number of male superheroes. This requires joining the `superhero` and `gender` tables on `gender_id = id`, filtering for `gender = 'Male'`, and counting the number of superheroes.
2. Count the number of female superheroes. This requires joining the `superhero` and `gender` tables on `gender_id = id`, filtering for `gender = 'Female'`, and counting the number of superheroes.
3. Calculate the ratio of male to female superheroes by dividing the count of male superheroes by the count of female superheroes.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.gender = 'Male' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN T1.gender = 'Female' THEN 1 ELSE 0 END)
FROM gender AS T1
INNER JOIN superhero AS T2
  ON T1.id = T2.gender_id;
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.gender = 'Male' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN T1.gender = 'Female' THEN 1 ELSE 0 END)
FROM gender AS T1
INNER JOIN superhero AS T2
  ON T1.id = T2.gender_id;
```
=====================
Question: Provide the eye colour of the superhero who has Karen Beecher-Duncan as their full name.
 db_id: superhero
Planner: 1. Find the superhero ID where the full_name is 'Karen Beecher-Duncan' from the 'superhero' table.
2. Get the eye_colour_id associated with that superhero ID.
3. Use the eye_colour_id to find the corresponding eye colour in the 'colour' table.
4. Return the eye colour.

Tables needed: superhero, colour
Columns: superhero.full_name, superhero.eye_colour_id, colour.id, colour.colour
Filters: superhero.full_name = 'Karen Beecher-Duncan'
Joins: superhero.eye_colour_id = colour.id

NL2SQL: ```sql
SELECT
  T2.colour
FROM superhero AS T1
INNER JOIN colour AS T2
  ON T1.eye_colour_id = T2.id
WHERE
  T1.full_name = 'Karen Beecher-Duncan';
```
Critic: ```sql
SELECT
  T2.colour
FROM superhero AS T1
INNER JOIN colour AS T2
  ON T1.eye_colour_id = T2.id
WHERE
  T1.full_name = 'Karen Beecher-Duncan';
```
=====================
Question: In superheroes with missing weight data, calculate the difference between the number of superheroes with blue eyes and no eye color.
 db_id: superhero
Planner: 1.  Filter superheroes with missing weight data (weight\_kg is NULL or 0).
2.  Find the count of superheroes with blue eyes (eye\_colour\_id corresponds to blue) from the filtered set.  Need to join `superhero` and `colour` on `eye_colour_id` and `id` where `colour` is 'Blue'.
3.  Find the count of superheroes with no eye color (eye\_colour\_id corresponds to no eye color) from the filtered set. Need to join `superhero` and `colour` on `eye_colour_id` and `id` where `colour` is 'No color'.
4.  Calculate the difference between the counts obtained in steps 2 and 3.
5.  Return the difference.

NL2SQL: ```sql
SELECT
  SUM(CASE WHEN T1.eye_colour_id = 7 THEN 1 ELSE 0 END) - SUM(CASE WHEN T1.eye_colour_id = 1 THEN 1 ELSE 0 END)
FROM superhero AS T1
WHERE
  T1.weight_kg IS NULL OR T1.weight_kg = 0;
```
Critic: ```sql
SELECT
  SUM(CASE WHEN T1.eye_colour_id = 7 THEN 1 ELSE 0 END) - SUM(CASE WHEN T1.eye_colour_id = 1 THEN 1 ELSE 0 END)
FROM superhero AS T1
WHERE
  T1.weight_kg IS NULL;
```
=====================
Question: How many green-skinned villains are there in the superhero universe?
 db_id: superhero
Planner: 1. Find the `id` of the color 'Green' from the `colour` table.
2. Find the `id` of the alignment 'Bad' from the `alignment` table.
3. In the `superhero` table, filter for superheroes with `skin_colour_id` equal to the `id` found in step 1 and `alignment_id` equal to the `id` found in step 2.
4. Count the number of superheroes that satisfy the conditions in step 3.

NL2SQL: ```sql
SELECT
  COUNT(T1.id)
FROM superhero AS T1
INNER JOIN colour AS T2
  ON T1.skin_colour_id = T2.id
INNER JOIN alignment AS T3
  ON T1.alignment_id = T3.id
WHERE
  T2.colour = 'Green' AND T3.alignment = 'Bad';
```
Critic: ```sql
SELECT
  COUNT(T1.id)
FROM superhero AS T1
INNER JOIN colour AS T2
  ON T1.skin_colour_id = T2.id
INNER JOIN alignment AS T3
  ON T1.alignment_id = T3.id
WHERE
  T2.colour = 'Green' AND T3.alignment = 'bad';
```
=====================
Question: Identify superheroes who can control wind and list their names in alphabetical order.
 db_id: superhero
Planner: 1. Find the `id` of the superpower 'Wind Control' from the `superpower` table.
2. Use the superpower `id` to find the corresponding `hero_id` from the `hero_power` table.
3. Use the `hero_id` to retrieve the `superhero_name` from the `superhero` table.
4. Order the `superhero_name` alphabetically.

NL2SQL: ```sql
SELECT
  T1.superhero_name
FROM superhero AS T1
INNER JOIN hero_power AS T2
  ON T1.id = T2.hero_id
INNER JOIN superpower AS T3
  ON T2.power_id = T3.id
WHERE
  T3.power_name = 'Wind Control'
ORDER BY
  T1.superhero_name;
```
Critic: ```sql
SELECT
  T1.superhero_name
FROM superhero AS T1
INNER JOIN hero_power AS T2
  ON T1.id = T2.hero_id
INNER JOIN superpower AS T3
  ON T2.power_id = T3.id
WHERE
  T3.power_name = 'Wind Control'
ORDER BY
  T1.superhero_name;
```
=====================
Question: Identify the gender of the superhero who has the ability of Phoenix Force.
 db_id: superhero
Planner: 1. Find the `id` of the superpower 'Phoenix Force' in the `superpower` table.
2. Use the superpower `id` to find the corresponding `hero_id` in the `hero_power` table.
3. Use the `hero_id` to find the `gender_id` in the `superhero` table.
4. Use the `gender_id` to find the `gender` in the `gender` table.
5. Return the `gender`.

NL2SQL: ```sql
SELECT
  T2.gender
FROM superpower AS T1
INNER JOIN gender AS T2
INNER JOIN superhero AS T3
INNER JOIN hero_power AS T4
  ON T1.id = T4.power_id
  AND T3.id = T4.hero_id
  AND T2.id = T3.gender_id
WHERE
  T1.power_name = 'Phoenix Force';
```
Critic: ```sql
SELECT
  T1.gender
FROM gender AS T1
INNER JOIN superhero AS T2
  ON T1.id = T2.gender_id
INNER JOIN hero_power AS T3
  ON T2.id = T3.hero_id
INNER JOIN superpower AS T4
  ON T3.power_id = T4.id
WHERE
  T4.power_name = 'Phoenix Force';
```
=====================
Question: Which publisher created more superheroes: DC or Marvel Comics? Find the difference in the number of superheroes.
 db_id: superhero
Planner: Here's a plan to determine the difference in the number of superheroes created by DC Comics and Marvel Comics:

1.  **Count Superheroes for DC Comics:** Count the number of superheroes associated with the publisher 'DC Comics'. This will involve joining the `superhero` table with the `publisher` table on `publisher_id`.

2.  **Count Superheroes for Marvel Comics:** Similarly, count the number of superheroes associated with the publisher 'Marvel Comics'. This will also involve joining the `superhero` table with the `publisher` table on `publisher_id`.

3.  **Calculate the Difference:** Subtract the count of Marvel superheroes from the count of DC superheroes. This will give the desired difference.

NL2SQL: ```sql
SELECT
  SUM(CASE WHEN T1.publisher_name = 'DC Comics' THEN 1 ELSE 0 END) - SUM(CASE WHEN T1.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END)
FROM publisher AS T1
INNER JOIN superhero AS T2
  ON T1.id = T2.publisher_id;
```
Critic: ```sql
SELECT
  SUM(CASE WHEN T1.publisher_name = 'DC Comics' THEN 1 ELSE 0 END) - SUM(CASE WHEN T1.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END)
FROM publisher AS T1
INNER JOIN superhero AS T2
  ON T1.id = T2.publisher_id;
```
=====================
Question: Which user has a higher reputation, Harlan or Jarrod Dixon?
 db_id: codebase_community
Planner: Plan:
1. Find the reputation of the user named 'Harlan' from the `users` table.
2. Find the reputation of the user named 'Jarrod Dixon' from the `users` table.
3. Compare the reputations and return the user with the higher reputation. Since the question only asks "which user", we only need the DisplayName of the user with the higher reputation.
4. The `users` table is sufficient for this task.
5. Use a CASE statement to compare reputations of the two users.

NL2SQL: ```sql
SELECT
  CASE
    WHEN (
      SELECT
        Reputation
      FROM users
      WHERE
        DisplayName = 'Harlan'
    ) > (
      SELECT
        Reputation
      FROM users
      WHERE
        DisplayName = 'Jarrod Dixon'
    )
    THEN 'Harlan'
    ELSE 'Jarrod Dixon'
  END;
```
Critic: ```sql
SELECT
  CASE
    WHEN (
      SELECT
        Reputation
      FROM users
      WHERE
        DisplayName = 'Harlan'
    ) > (
      SELECT
        Reputation
      FROM users
      WHERE
        DisplayName = 'Jarrod Dixon'
    )
    THEN 'Harlan'
    ELSE 'Jarrod Dixon'
  END;
```
=====================
Question: Please list the display names of all the users whose accounts were created in the year 2011.
 db_id: codebase_community
Planner: 1.  **Table**: `users`
2.  **Columns**:
    *   `DisplayName`: To get the display names of the users.
    *   `CreationDate`: To filter the users created in 2011.
3.  **Filter**:
    *   `WHERE YEAR(CreationDate) = 2011`

NL2SQL: ```sql
SELECT
  DisplayName
FROM users
WHERE
  STRFTIME('%Y', CreationDate) = '2011';
```
Critic: ```sql
SELECT
  DisplayName
FROM users
WHERE
  CAST(strftime('%Y', CreationDate) AS INTEGER) = 2011;
```
=====================
Question: How many users last accessed the website after 2014/9/1?
 db_id: codebase_community
Planner: 1.  Select the `users` table.
2.  Filter the `users` table where `LastAccessDate` is greater than '2014-09-01'.
3.  Count the number of users satisfying the condition.
NL2SQL: ```sql
SELECT
  COUNT(Id)
FROM users
WHERE
  LastAccessDate > '2014-09-01';
```
Critic: ```sql
SELECT
  COUNT(Id)
FROM users
WHERE
  LastAccessDate > '2014-09-01';
```
=====================
Question: Who is the owner of the post "Eliciting priors from experts"?
 db_id: codebase_community
Planner: 1. Find the post with the title "Eliciting priors from experts" from the `posts` table.
2. Get the `OwnerUserId` from the matched post.
3. Find the user with the `OwnerUserId` from the `users` table.
4. Return the `DisplayName` of the user.

Required Tables: `posts`, `users`
Required Columns:
- `posts`: `Title`, `OwnerUserId`
- `users`: `Id`, `DisplayName`
Joins: `posts` JOIN `users` ON `posts`.`OwnerUserId` = `users`.`Id`
Filters: `posts`.`Title` = "Eliciting priors from experts"
Output: `users`.`DisplayName`

NL2SQL: ```sql
SELECT
  T2.DisplayName
FROM posts AS T1
INNER JOIN users AS T2
  ON T1.OwnerUserId = T2.Id
WHERE
  T1.Title = 'Eliciting priors from experts';
```
Critic: ```sql
SELECT
  T2.DisplayName
FROM posts AS T1
INNER JOIN users AS T2
  ON T1.OwnerUserId = T2.Id
WHERE
  T1.Title = "Eliciting priors from experts";
```
=====================
Question: How many posts does the user csgillespie own?
 db_id: codebase_community
Planner: 1. Find the `Id` of the user with `DisplayName` equal to "csgillespie" in the `users` table.
2. Count the number of posts in the `posts` table where `OwnerUserId` is equal to the `Id` obtained in step 1.
3. Return the count.
Tables: `users`, `posts`
Columns: `users.Id`, `users.DisplayName`, `posts.OwnerUserId`
Filters: `users.DisplayName` = "csgillespie"
Joins: None
Aggregations: `COUNT(*)`

NL2SQL: ```sql
SELECT COUNT(*) FROM posts WHERE OwnerUserId = (SELECT Id FROM users WHERE DisplayName = 'csgillespie');
```
Critic: ```sql
SELECT COUNT(*) FROM posts WHERE OwnerUserId = (SELECT Id FROM Users WHERE DisplayName = 'csgillespie');
```
=====================
Question: What is the display name of the user who last edited the post "Examples for teaching: Correlation does not mean causation"?
 db_id: codebase_community
Planner: The question asks for the display name of the last editor of a specific post.
1.  **Find the post ID:** Filter the `posts` table by `Title` to find the `Id` of the post titled "Examples for teaching: Correlation does not mean causation".
2.  **Find the last editor ID:** From the row found in step 1, retrieve the `LastEditorUserId`.
3.  **Find the display name:** Use the `LastEditorUserId` to find the corresponding `DisplayName` in the `users` table.
4.  **Return the display name.**

NL2SQL: ```sql
SELECT
  T2.DisplayName
FROM posts AS T1
INNER JOIN users AS T2
  ON T1.LastEditorUserId = T2.Id
WHERE
  T1.Title = 'Examples for teaching: Correlation does not mean causation';
```
Critic: ```sql
SELECT
  LastEditorDisplayName
FROM posts
WHERE
  Title = 'Examples for teaching: Correlation does not mean causation';
```
=====================
Question: Among the posts owned by an elder user, how many of them have a score of over 19?
 db_id: codebase_community
Planner: Plan:
1. Filter users table for users with Age > 65.
2. Join the filtered users table with the posts table on users.Id = posts.OwnerUserId.
3. Filter the joined table for posts with Score >= 20.
4. Count the number of posts that satisfy the conditions.
Tables:
- users: to identify elder users based on age.
- posts: to access post scores and owner user IDs.
Columns:
- users.Id: to join with posts table
- users.Age: to filter elder users (Age > 65).
- posts.OwnerUserId: to join with users table
- posts.Score: to filter posts with a score greater than or equal to 20.
Filters:
- users.Age > 65
- posts.Score >= 20
Joins:
- Join users and posts on users.Id = posts.OwnerUserId
Aggregations:
- Count the number of posts that satisfy the join and filter conditions.

NL2SQL: ```sql
SELECT
  COUNT(T2.Id)
FROM users AS T1
INNER JOIN posts AS T2
  ON T1.Id = T2.OwnerUserId
WHERE
  T1.Age > 65 AND T2.Score >= 20;
```
Critic: ```sql
SELECT
  COUNT(T1.Id)
FROM posts AS T1
INNER JOIN users AS T2
  ON T1.OwnerUserId = T2.Id
WHERE
  T2.Age > 65 AND T1.Score > 19;
```
=====================
Question: From which post is the tag "bayesian" excerpted from? Please give the body of the post.
 db_id: codebase_community
Planner: Here's the plan to retrieve the requested information:

1.  **Identify the `ExcerptPostId` associated with the tag "bayesian"**:
    *   We need to query the `tags` table.
    *   Filter the `tags` table where `TagName` is 'bayesian'.
    *   Retrieve the `ExcerptPostId` from the filtered row.

2.  **Retrieve the `Body` of the post identified by the `ExcerptPostId`**:
    *   We need to query the `posts` table.
    *   Filter the `posts` table where `Id` is equal to the `ExcerptPostId` obtained in the previous step.
    *   Retrieve the `Body` column from the filtered row.

NL2SQL: ```sql
SELECT
  T2.Body
FROM tags AS T1
INNER JOIN posts AS T2
  ON T1.ExcerptPostId = T2.Id
WHERE
  T1.TagName = 'bayesian';
```
Critic: ```sql
SELECT
  T2.Body
FROM Tags AS T1
JOIN Posts AS T2
  ON T1.ExcerptPostId = T2.Id
WHERE
  T1.TagName = 'bayesian';
```
=====================
Question: What is the average score of the posts owned by the user csgillespie?
 db_id: codebase_community
Planner: 1. Find the `Id` of the user with `DisplayName` equal to 'csgillespie' from the `users` table.
2. Use the `Id` obtained in the previous step to filter posts in the `posts` table where `OwnerUserId` matches the user's `Id`.
3. Calculate the average `Score` of the selected posts.
4. Return the average score.

NL2SQL: ```sql
SELECT AVG(Score) FROM posts WHERE OwnerUserId = (SELECT Id FROM users WHERE DisplayName = 'csgillespie');
```
Critic: ```sql
SELECT AVG(Score) FROM Posts WHERE OwnerUserId = (SELECT Id FROM Users WHERE DisplayName = 'csgillespie');
```
=====================
Question: Among the posts with a score of over 5, what is the percentage of them being owned by an elder user?
 db_id: codebase_community
Planner: Plan:
1. Find the posts with `Score` > 5 from the `posts` table.
2. Join the `posts` table with the `users` table on `posts.OwnerUserId` = `users.Id` to get the age of the owner of each post.
3. Filter the joined table where `users.Age` > 65 to find the number of posts with score > 5 owned by elder users.
4. Calculate the total number of posts where `posts.Score` > 5.
5. Calculate the percentage by dividing the number of posts owned by elder users by the total number of posts with score > 5 and multiplying by 100.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T2.Age > 65 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.Id)
FROM posts AS T1
INNER JOIN users AS T2
  ON T1.OwnerUserId = T2.Id
WHERE
  T1.Score > 5;
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T2.Age > 65 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.Id)
FROM Posts AS T1
INNER JOIN Users AS T2
  ON T1.OwnerUserId = T2.Id
WHERE
  T1.Score > 5;
```
=====================
Question: User No.3025 gave a comment at 20:29:39 on 2014/4/23 to a post, how many favorite counts did that post get?
 db_id: codebase_community
Planner: Plan:
1. Find the `PostId` from the `comments` table where `UserId` is 3025 and `CreationDate` is '2014-04-23 20:29:39'.
2. Retrieve the `FavoriteCount` from the `posts` table using the `PostId` obtained in the previous step.
3. Return the `FavoriteCount`.

NL2SQL: ```sql
SELECT
  T1.FavoriteCount
FROM posts AS T1
INNER JOIN comments AS T2
  ON T1.Id = T2.PostId
WHERE
  T2.UserId = 3025 AND T2.CreationDate = '2014-04-23 20:29:39';
```
Critic: ```sql
SELECT
  T1.FavoriteCount
FROM posts AS T1
INNER JOIN comments AS T2
  ON T1.Id = T2.PostId
WHERE
  T2.UserId = 3025 AND T2.CreationDate = '2014-04-23 20:29:39';
```
=====================
Question: User No.23853 gave a comment to a post at 9:08:18 on 2013/7/12, was that post well-finished?
 db_id: codebase_community
Planner: 1. Find the `PostId` from the `comments` table where `UserId` is 23853 and `CreationDate` is '2013-07-12 09:08:18.0'.
2. Use the `PostId` found in step 1 to query the `posts` table.
3. Check the `ClosedDate` column in the `posts` table for the `PostId`. If it's `NULL`, the post is well-finished; otherwise, it's not.
4. Return whether the post is well-finished or not.
   Since the question asks whether the post was well-finished, let's return a boolean result: 1 if `ClosedDate` is `NULL`, and 0 otherwise.

NL2SQL: ```sql
SELECT
  CASE WHEN T1.ClosedDate IS NULL THEN 1 ELSE 0 END
FROM posts AS T1
INNER JOIN comments AS T2
  ON T1.Id = T2.PostId
WHERE
  T2.UserId = 23853 AND T2.CreationDate = '2013-07-12 09:08:18.0';
```
Critic: ```sql
SELECT
  CASE
    WHEN ClosedDate IS NULL
    THEN 'No'
    ELSE 'Yes'
  END
FROM Posts
WHERE
  Id IN (
    SELECT
      PostId
    FROM Comments
    WHERE
      UserId = 23853 AND CreationDate = '2013-07-12 09:08:18'
  );
```
=====================
Question: For the user with the display name of "Tiago Pasqualini", how many posts did he/she own?
 db_id: codebase_community
Planner: Plan:
1. Find the `Id` of the user with `DisplayName` = "Tiago Pasqualini" from the `users` table.
2. Count the number of posts with `OwnerUserId` equal to the user `Id` found in step 1 from the `posts` table.
3. Return the count.

NL2SQL: ```sql
SELECT
  COUNT(p.Id)
FROM users AS u
JOIN posts AS p
  ON u.Id = p.OwnerUserId
WHERE
  u.DisplayName = 'Tiago Pasqualini';
```
Critic: ```sql
SELECT
  COUNT(Id)
FROM posts
WHERE
  OwnerUserId = (
    SELECT
      Id
    FROM users
    WHERE
      DisplayName = 'Tiago Pasqualini'
  );
```
=====================
Question: Provide the display name of the user who made the vote No.6347.
 db_id: codebase_community
Planner: 1. Find the `UserId` from the `Votes` table where `Id` is 6347.
2. Use the obtained `UserId` to find the corresponding `DisplayName` in the `Users` table.
3. Return the `DisplayName`.

NL2SQL: ```sql
SELECT
  T2.DisplayName
FROM Votes AS T1
INNER JOIN Users AS T2
  ON T1.UserId = T2.Id
WHERE
  T1.Id = 6347;
```
Critic: ```sql
SELECT
  T2.DisplayName
FROM Votes AS T1
INNER JOIN Users AS T2
  ON T1.UserId = T2.Id
WHERE
  T1.Id = 6347;
```
=====================
Question: For the user No.24, how many times is the number of his/her posts compared to his/her votes?
 db_id: codebase_community
Planner: Plan:
1. Count the number of posts for user ID 24 from the `posts` table. Filter by `OwnerUserId = 24`.
2. Count the number of votes where the user ID is 24 from the `votes` table. Filter by `UserId = 24`.
3. Divide the post count by the vote count to get the ratio.
4. Return the ratio.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.OwnerUserId = 24 THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN T2.UserId = 24 THEN 1 ELSE 0 END)
FROM posts AS T1
INNER JOIN votes AS T2;
```
Critic: ```sql
SELECT
  CAST(COUNT(CASE WHEN OwnerUserId = 24 THEN Id ELSE NULL END) AS REAL) / COUNT(CASE WHEN UserId = 24 THEN PostId ELSE NULL END)
FROM posts AS T1
LEFT JOIN votes AS T2
  ON T1.Id = T2.PostId;
```
=====================
Question: How many views did the post titled 'Integration of Weka and/or RapidMiner into Informatica PowerCenter/Developer' get?
 db_id: codebase_community
Planner: 1. Select the `ViewCount` from the `posts` table.
2. Filter the `posts` table by `Title` = 'Integration of Weka and/or RapidMiner into Informatica PowerCenter/Developer'.

NL2SQL: ```sql
SELECT
  ViewCount
FROM posts
WHERE
  Title = 'Integration of Weka and/or RapidMiner into Informatica PowerCenter/Developer';
```
Critic: ```sql
SELECT
  ViewCount
FROM posts
WHERE
  Title = 'Integration of Weka and/or RapidMiner into Informatica PowerCenter/Developer';
```
=====================
Question: Write the contents of comments with a score of 17.
 db_id: codebase_community
Planner: 1. Select the `Text` column from the `comments` table.
2. Filter the results based on the `Score` column being equal to 17.

NL2SQL: ```sql
SELECT
  Text
FROM comments
WHERE
  Score = 17;
```
Critic: ```sql
SELECT
  Text
FROM comments
WHERE
  Score = 17;
```
=====================
Question: Name the user that commented 'thank you user93!'
 db_id: codebase_community
Planner: 1. Filter the `comments` table to find comments where the `Text` column is equal to 'thank you user93!'.
2. From the filtered comments, retrieve the `UserId`.
3. Use the `UserId` to find the corresponding user's `DisplayName` from the `users` table.
4. Output the `DisplayName`.

NL2SQL: ```sql
SELECT
  T1.DisplayName
FROM users AS T1
INNER JOIN comments AS T2
  ON T1.Id = T2.UserId
WHERE
  T2.Text = 'thank you user93!';
```
Critic: ```sql
SELECT
  T1.DisplayName
FROM users AS T1
INNER JOIN comments AS T2
  ON T1.Id = T2.UserId
WHERE
  T2.Text = 'thank you user93!';
```
=====================
Question: Which user made a post titled 'Understanding what Dassault iSight is doing?' and how much is the reputation of the user?
 db_id: codebase_community
Planner: Plan:
1. Find the `Id` of the post with the title 'Understanding what Dassault iSight is doing?' from the `posts` table.
2. Using the `OwnerUserId` from the posts table, find the corresponding user's `Reputation` and `DisplayName` from the `users` table.
3. Return the `DisplayName` and `Reputation` of the user.

NL2SQL: ```sql
SELECT
  u.DisplayName,
  u.Reputation
FROM posts AS p
JOIN users AS u
  ON p.OwnerUserId = u.Id
WHERE
  p.Title = 'Understanding what Dassault iSight is doing?';
```
Critic: ```sql
SELECT
  T1.DisplayName,
  T1.Reputation
FROM users AS T1
INNER JOIN posts AS T2
  ON T1.Id = T2.OwnerUserId
WHERE
  T2.Title = 'Understanding what Dassault iSight is doing?';
```
=====================
Question: Who is the owner of the post titled 'Open source tools for visualizing multi-dimensional data?'
 db_id: codebase_community
Planner: 1. Find the `Id` of the post titled 'Open source tools for visualizing multi-dimensional data' from the `posts` table.
2. Use the `OwnerUserId` from the `posts` table to find the corresponding user in the `users` table.
3. Retrieve the `DisplayName` of the user from the `users` table.

NL2SQL: ```sql
SELECT
  T2.DisplayName
FROM posts AS T1
INNER JOIN users AS T2
  ON T1.OwnerUserId = T2.Id
WHERE
  T1.Title = 'Open source tools for visualizing multi-dimensional data?';
```
Critic: ```sql
SELECT
  T2.DisplayName
FROM posts AS T1
INNER JOIN users AS T2
  ON T1.OwnerUserId = T2.Id
WHERE
  T1.Title = 'Open source tools for visualizing multi-dimensional data?';
```
=====================
Question: Write all the comments left by users who edited the post titled 'Why square the difference instead of taking the absolute value in standard deviation?'
 db_id: codebase_community
Planner: 1. Find the `Id` of the post titled 'Why square the difference instead of taking the absolute value in standard deviation?' from the `posts` table.
2. Retrieve all `Text` (comment content) from the `comments` table where the `PostId` matches the `Id` found in step 1.

Return the `Text` column from the `comments` table.

NL2SQL: ```sql
SELECT
  T1.Text
FROM comments AS T1
INNER JOIN posts AS T2
  ON T1.PostId = T2.Id
WHERE
  T2.Title = 'Why square the difference instead of taking the absolute value in standard deviation?';
```
Critic: ```sql
SELECT
  Comment
FROM PostHistory
WHERE
  PostId = (
    SELECT
      Id
    FROM Posts
    WHERE
      Title = 'Why square the difference instead of taking the absolute value in standard deviation?'
  )
  AND Comment IS NOT NULL;
```
=====================
Question: Which user added a bounty amount of 50 to the post title mentioning variance?
 db_id: codebase_community
Planner: 1. Filter the `Votes` table to find records where `BountyAmount` is 50.
2. Filter the `Posts` table to find records where `Title` contains 'variance'.
3. Join the filtered `Votes` and `Posts` tables on `PostId` to link the bounty information to the posts.
4. Join the result with the `Users` table on `Users.Id = Votes.UserId` to retrieve the display name of the user who added the bounty.
5. Select the `DisplayName` from the `Users` table.

NL2SQL: ```sql
SELECT
  T1.DisplayName
FROM Users AS T1
INNER JOIN Votes AS T2
  ON T1.Id = T2.UserId
INNER JOIN Posts AS T3
  ON T2.PostId = T3.Id
WHERE
  T2.BountyAmount = 50 AND T3.Title LIKE '%variance%';
```
Critic: ```sql
SELECT DISTINCT
  U.DisplayName
FROM Users AS U
JOIN Votes AS V
  ON U.Id = V.UserId
JOIN Posts AS P
  ON V.PostId = P.Id
WHERE
  V.BountyAmount = 50 AND P.Title LIKE '%variance%';
```
=====================
Question: Calculate the average view count of each post tagged as 'humor' and list the title and the comment of each post.
 db_id: codebase_community
Planner: Plan:
1. Filter posts table for posts tagged with 'humor' using the `Tags` column and the `LIKE` operator.
2. Calculate the average view count of the filtered posts using `AVG(ViewCount)`.
3. Retrieve the 'Title' from the `posts` table and the 'Text' from the `comments` table to display the title and comment for each post.
4. Join `posts` and `comments` table by `posts.Id` = `comments.PostId`.
5. Group by post title and comments.

NL2SQL: ```sql
SELECT
  p.Title,
  AVG(p.ViewCount),
  c.Text
FROM Posts AS p
JOIN Comments AS c
  ON p.Id = c.PostId
WHERE
  p.Tags LIKE '%<humor>%'
GROUP BY
  p.Title,
  c.Text;
```
Critic: ```sql
SELECT
  p.Title,
  AVG(p.ViewCount),
  ph.Comment
FROM Posts AS p
JOIN PostHistory AS ph
  ON p.Id = ph.PostId
WHERE
  p.Tags LIKE '%<humor>%'
GROUP BY
  p.Title,
  ph.Comment;
```
=====================
Question: How many users are awarded with more than 5 badges?
 db_id: codebase_community
Planner: Plan:
1. Count the number of badges for each user using the `badges` table. Group by `UserId` and count the number of badges.
2. Filter the results to include only users with more than 5 badges.
3. Count the number of users that satisfy the above condition.
4. Return the count of users.
Tables: `badges`
Columns: `UserId`, `Name`
Filters: count(`Name`) > 5
Joins: None
Aggregations: count(Name) group by UserId
Final Aggregation: count distinct UserId

NL2SQL: ```sql
SELECT
  COUNT(DISTINCT UserId)
FROM (
  SELECT
    UserId
  FROM badges
  GROUP BY
    UserId
  HAVING
    COUNT(Name) > 5
) AS UserBadgeCounts;
```
Critic: ```sql
SELECT
  COUNT(DISTINCT UserId)
FROM badges
GROUP BY
  UserId
HAVING
  COUNT(*) > 5;
```
=====================
Question: Which user have only one post history per post and having at least 1000 views?
 db_id: codebase_community
Planner: Plan:
1. Find users who have at least 1000 views from the `Users` table.
2. Find users who have only one post history per post from the `PostHistory` table.
3. Join the results to find the common users.
4. Return the `DisplayName` of these users.

NL2SQL: ```sql
SELECT
  T1.DisplayName
FROM Users AS T1
INNER JOIN (
  SELECT
    UserId
  FROM PostHistory
  GROUP BY
    UserId,
    PostId
  HAVING
    COUNT(*) = 1
) AS T2
  ON T1.Id = T2.UserId
WHERE
  T1.Views >= 1000;
```
Critic: ```sql
SELECT
  U.DisplayName
FROM Users AS U
JOIN PostHistory AS PH
  ON U.Id = PH.UserId
JOIN Posts AS P
  ON PH.PostId = P.Id
WHERE
  U.Views >= 1000
GROUP BY
  U.Id
HAVING
  COUNT(DISTINCT PH.PostId) = COUNT(PH.PostId)
  AND COUNT(PH.PostId) > 0;
```
=====================
Question: What is the percentage difference of student badges given during 2010 and 2011?
 db_id: codebase_community
Planner: 1.  Filter the `badges` table to include only records where the `Name` is 'Student'.
2.  Count the number of 'Student' badges awarded in 2010.
3.  Count the number of 'Student' badges awarded in 2011.
4.  Calculate the percentage difference between the counts of 'Student' badges in 2010 and 2011 using the formula: `((count_2011 - count_2010) / count_2010) * 100`.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN STRFTIME('%Y', Date) = '2011' THEN 1 ELSE 0 END) - SUM(CASE WHEN STRFTIME('%Y', Date) = '2010' THEN 1 ELSE 0 END) AS REAL) * 100 / SUM(CASE WHEN STRFTIME('%Y', Date) = '2010' THEN 1 ELSE 0 END)
FROM badges
WHERE
  Name = 'Student';
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN STRFTIME('%Y', Date) = '2011' THEN 1 ELSE 0 END) - SUM(CASE WHEN STRFTIME('%Y', Date) = '2010' THEN 1 ELSE 0 END) AS REAL) * 100 / SUM(CASE WHEN STRFTIME('%Y', Date) = '2010' THEN 1 ELSE 0 END)
FROM badges
WHERE
  Name = 'Student';
```
=====================
Question: What is the average of the up votes and the average user age for users creating more than 10 posts?
 db_id: codebase_community
Planner: 1.  Find the users who created more than 10 posts. This can be done by counting the number of posts per user using the `posts` table and grouping by `OwnerUserId`.
2.  Join the result with the `users` table on `users.Id = posts.OwnerUserId`.
3.  Calculate the average of the `UpVotes` and the average of the `Age` for the users satisfying the condition from step 1.
4.  Return the average upvotes and average age.

NL2SQL: ```sql
SELECT
  AVG(T1.UpVotes),
  AVG(T1.Age)
FROM users AS T1
INNER JOIN posts AS T2
  ON T1.Id = T2.OwnerUserId
GROUP BY
  T2.OwnerUserId
HAVING
  COUNT(T2.OwnerUserId) > 10;
```
Critic: ```sql
SELECT
  AVG(UpVotes),
  AVG(Age)
FROM users
WHERE
  Id IN (
    SELECT
      OwnerUserId
    FROM posts
    GROUP BY
      OwnerUserId
    HAVING
      COUNT(*) > 10
  );
```
=====================
Question: Calculate the ratio of votes in 2010 and 2011.
 db_id: codebase_community
Planner: Plan:
1. Count the number of votes in 2010 from the `votes` table.
2. Count the number of votes in 2011 from the `votes` table.
3. Calculate the ratio of votes in 2010 to votes in 2011.
Use the `votes` table. Filter by `CreationDate` to get the votes in 2010 and 2011. Use `COUNT(Id)` to count the number of votes.
Columns: Id, CreationDate
Tables: votes
Filters: Year of CreationDate is 2010, Year of CreationDate is 2011
Joins: None
Final Calculation: COUNT(Id where YEAR(CreationDate) = 2010) / COUNT(Id where YEAR(CreationDate) = 2011)

NL2SQL: ```sql
SELECT CAST(SUM(CASE WHEN STRFTIME('%Y', CreationDate) = '2010' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN STRFTIME('%Y', CreationDate) = '2011' THEN 1 ELSE 0 END) FROM votes
```
Critic: ```sql
SELECT CAST(SUM(CASE WHEN STRFTIME('%Y', CreationDate) = '2010' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN STRFTIME('%Y', CreationDate) = '2011' THEN 1 ELSE 0 END) FROM votes
```
=====================
Question: Which post by slashnick has the most answers count? State the post ID.
 db_id: codebase_community
Planner: Plan:
1. Find the `Id` of the user with `DisplayName` equal to 'slashnick' from the `users` table.
2. Filter the `posts` table for posts where `OwnerUserId` matches the user ID found in the previous step.
3. Find the maximum `AnswerCount` among those posts.
4. Retrieve the `Id` of the post with the maximum `AnswerCount` found.

NL2SQL: ```sql
SELECT
  Id
FROM posts
WHERE
  OwnerUserId = (
    SELECT
      Id
    FROM users
    WHERE
      DisplayName = 'slashnick'
  )
ORDER BY
  AnswerCount DESC
LIMIT 1;
```
Critic: ```sql
SELECT
  p.Id
FROM posts AS p
JOIN users AS u
  ON p.OwnerUserId = u.Id
WHERE
  u.DisplayName = 'slashnick'
ORDER BY
  p.AnswerCount DESC
LIMIT 1;
```
=====================
Question: Among posts by Harvey Motulsky and Noah Snyder, which one has higher popularity?
 db_id: codebase_community
Planner: Here's my plan to determine which post by Harvey Motulsky or Noah Snyder has higher popularity (view count):

1.  **Join `posts` and `users` tables:**  I'll need to join these tables on `posts.OwnerUserId = users.Id` to link posts to their respective owners.
2.  **Filter by User:**  I'll filter the joined table to include only posts where `users.DisplayName` is either 'Harvey Motulsky' or 'Noah Snyder'.
3.  **Order and Limit:** Order the results by `posts.ViewCount` in descending order to find the post with the highest view count. Limit the result to 1 row.
4.  **Select and Return:** Select the `posts.Title` and `posts.ViewCount` to show which user's post has the highest popularity.

NL2SQL: ```sql
SELECT
  p.Title,
  p.ViewCount
FROM posts AS p
JOIN users AS u
  ON p.OwnerUserId = u.Id
WHERE
  u.DisplayName = 'Harvey Motulsky' OR u.DisplayName = 'Noah Snyder'
ORDER BY
  p.ViewCount DESC
LIMIT 1;
```
Critic: ```sql
SELECT
  p.Title,
  p.ViewCount
FROM posts AS p
JOIN users AS u
  ON p.OwnerUserId = u.Id
WHERE
  u.DisplayName IN ('Harvey Motulsky', 'Noah Snyder')
ORDER BY
  p.ViewCount DESC
LIMIT 1;
```
=====================
Question: State all the tags used by Mark Meckes in his posts that doesn't have comments.
 db_id: codebase_community
Planner: 1. Find the `Id` of the user whose `DisplayName` is 'Mark Meckes' from the `Users` table.
2. Find the `Id` of the posts from the `Posts` table where `OwnerUserId` matches the `Id` found in step 1 and `CommentCount` is 0.
3. Extract the `Tags` from those posts and split the tags string into individual tags.
4. Return the distinct tags.

NL2SQL: ```sql
SELECT DISTINCT
  SUBSTR(value, 2, LENGTH(value) - 2)
FROM Posts
JOIN Users
  ON Posts.OwnerUserId = Users.Id
WHERE
  Users.DisplayName = 'Mark Meckes' AND Posts.CommentCount = 0
  AND length(Tags) > 0
  AND Tags != ''
  and value != ''
  AND value != '<>'
  AND value != '><'
  AND value != NULL
  AND value != '<'
  AND value != '>'
  AND value != '<<>>'
  AND value != '<<>'
  AND value != '<>>'
  AND value != '<<'
  AND value != '>>'
  AND value NOT LIKE '%><%'
  AND value NOT LIKE '%<<%'
  AND value NOT LIKE '%>>%'
  AND value NOT LIKE '%<%>%'
  AND value NOT LIKE '%<<>%'
  AND value NOT LIKE '%<>>%'
  AND value NOT LIKE '%<%'
  AND value NOT LIKE '%>%'
  AND LENGTH(Tags) - LENGTH(REPLACE(Tags, '>', '')) = LENGTH(Tags) - LENGTH(REPLACE(Tags, '<', ''))
  AND Tags LIKE '%><%'
  AND Tags LIKE '%<%'
  AND Tags LIKE '%>%'
  AND Tags LIKE '%><%'
  AND Posts.Tags IS NOT NULL
  AND Posts.Tags != ''
  AND value IS NOT NULL
  AND value != '';
```
Critic: ```sql
SELECT DISTINCT
  T2.TagName
FROM Posts AS T1
INNER JOIN Tags AS T2
  ON T1.Tags LIKE '%' || T2.TagName || '%'
INNER JOIN Users AS T3
  ON T1.OwnerUserId = T3.Id
WHERE
  T3.DisplayName = 'Mark Meckes' AND T1.CommentCount = 0;
```
=====================
Question: Based on posts posted by Community, calculate the percentage of posts that use the R language.
 db_id: codebase_community
Planner: Plan:
1. Count the total number of posts. The problem states that the calculation should be based on posts posted by 'Community'. This suggests that we need to filter the posts table based on the posts posted by "Community". This can be done by filtering the 'posts' table using OwnerDisplayName = 'Community'.
2. Count the number of posts that have the tag 'r'. This can be done by looking at the 'posts' table and using the 'Tags' column to identify posts tagged with 'r'. We can use a LIKE operator with '%<r>%' to find these posts.
3. Calculate the percentage of posts tagged with 'r' out of the total number of posts posted by 'Community'.
4. Calculate the final percentage as (Posts with tag 'r') / (Total Posts by Community) * 100

NL2SQL: ```sql
SELECT CAST(SUM(CASE WHEN Tags LIKE '%<r>%' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*)
FROM posts
WHERE OwnerDisplayName = 'Community';
```
Critic: ```sql
SELECT CAST(SUM(CASE WHEN Tags LIKE '%<r>%' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM posts WHERE CommunityOwnedDate IS NOT NULL
```
=====================
Question: Calculate the difference in view count from post posted by Mornington and view count from posts posted by Amos.
 db_id: codebase_community
Planner: Plan:
1. Find the user ID for 'Mornington' and 'Amos' from the `users` table using the `DisplayName` column.
2. Get the view count of posts made by 'Mornington' and 'Amos' from the `posts` table. Join `posts` and `users` table on `OwnerUserId` = `Id` where `DisplayName` is 'Mornington' or 'Amos'.
3. Calculate the sum of view counts for posts by 'Mornington' and 'Amos' separately.
4. Subtract the total view count of Amos's posts from the total view count of Mornington's posts.
5. Return the calculated difference.
Columns needed:
- users.Id
- users.DisplayName
- posts.ViewCount
- posts.OwnerUserId
Tables needed:
- users
- posts
Filters:
- users.DisplayName = 'Mornington'
- users.DisplayName = 'Amos'
Joins:
- posts.OwnerUserId = users.Id
NL2SQL: ```sql
SELECT
  SUM(CASE WHEN T2.DisplayName = 'Mornington' THEN T1.ViewCount ELSE 0 END) - SUM(CASE WHEN T2.DisplayName = 'Amos' THEN T1.ViewCount ELSE 0 END)
FROM posts AS T1
INNER JOIN users AS T2
  ON T1.OwnerUserId = T2.Id
WHERE
  T2.DisplayName = 'Mornington' OR T2.DisplayName = 'Amos';
```
Critic: ```sql
SELECT
  SUM(CASE WHEN T2.DisplayName = 'Mornington' THEN T1.ViewCount ELSE 0 END) - SUM(CASE WHEN T2.DisplayName = 'Amos' THEN T1.ViewCount ELSE 0 END)
FROM posts AS T1
INNER JOIN users AS T2
  ON T1.OwnerUserId = T2.Id
WHERE
  T2.DisplayName IN ('Mornington', 'Amos');
```
=====================
Question: What is the average monthly number of links created in 2010 for posts that have no more than 2 answers?
 db_id: codebase_community
Planner: Plan:
1. Filter the 'posts' table to include only posts with 'AnswerCount' less than or equal to 2.
2. Filter the 'postLinks' table to include only links created in the year 2010.
3. Join the filtered 'posts' table with the filtered 'postLinks' table using the 'Id' column from 'posts' and the 'PostId' column from 'postLinks'.
4. Calculate the count of links created in 2010 for posts that have no more than 2 answers.
5. Calculate the average monthly number of links by dividing the count by 12.
6. Return the average monthly number of links.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN STRFTIME('%Y', T1.CreationDate) = '2010' THEN 1 ELSE 0 END) AS REAL) / 12
FROM postLinks AS T1
INNER JOIN posts AS T2
  ON T1.PostId = T2.Id
WHERE
  T2.AnswerCount <= 2;
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN STRFTIME('%Y', T1.CreationDate) = '2010' THEN 1 ELSE 0 END) AS REAL) / 12
FROM postLinks AS T1
INNER JOIN posts AS T2
  ON T1.PostId = T2.Id
WHERE
  T2.AnswerCount <= 2;
```
=====================
Question: When did 'chl' cast its first vote in a post?
 db_id: codebase_community
Planner: 1. Find the `UserId` for the user with `DisplayName` equal to 'chl' from the `Users` table.
2. Use the `UserId` obtained in the previous step to filter the `Votes` table.
3. Find the minimum `CreationDate` from the filtered `Votes` table.

Required tables: `Users`, `Votes`
Columns: `Users.Id`, `Users.DisplayName`, `Votes.UserId`, `Votes.CreationDate`
Filters: `Users.DisplayName = 'chl'`
Aggregations: `MIN(Votes.CreationDate)`
Joins: None

NL2SQL: ```sql
SELECT min(T2.CreationDate) FROM Users AS T1 INNER JOIN Votes AS T2 ON T1.Id = T2.UserId WHERE T1.DisplayName = 'chl'
```
Critic: ```sql
SELECT min(CreationDate) FROM Votes WHERE UserId = (SELECT Id FROM Users WHERE DisplayName = 'chl')
```
=====================
Question: What is the display name of the user who acquired the first Autobiographer badge?
 db_id: codebase_community
Planner: 1. Find the `UserId` of the user who acquired the "Autobiographer" badge earliest.
2. Use the `UserId` to find the `DisplayName` from the `Users` table.
3. Return the `DisplayName`.

Tables needed: `Badges`, `Users`
Columns needed: `Badges.Name`, `Badges.UserId`, `Badges.Date`, `Users.Id`, `Users.DisplayName`
Filters: `Badges.Name` = "Autobiographer"
Joins: `Badges.UserId` = `Users.Id`
Order by: `Badges.Date` ASC
Limit: 1

NL2SQL: ```sql
SELECT
  T2.DisplayName
FROM Badges AS T1
INNER JOIN Users AS T2
  ON T1.UserId = T2.Id
WHERE
  T1.Name = 'Autobiographer'
ORDER BY
  T1.Date
LIMIT 1;
```
Critic: ```sql
SELECT
  T2.DisplayName
FROM Badges AS T1
INNER JOIN Users AS T2
  ON T1.UserId = T2.Id
WHERE
  T1.Name = 'Autobiographer'
ORDER BY
  T1.Date
LIMIT 1;
```
=====================
Question: Among the users located in United Kingdom, how many users whose post have a total favorite amount of 4 or more?
 db_id: codebase_community
Planner: 1.  Filter the `users` table to find users located in the United Kingdom (Location = 'United Kingdom').
2.  Join the filtered `users` table with the `posts` table using the `Id` column in `users` and the `OwnerUserId` in `posts`.
3.  Filter the joined table to include only posts where the `FavoriteCount` is greater than or equal to 4.
4.  Count the number of distinct `UserId` values from the resulting table. This represents the number of users who meet the specified criteria.

NL2SQL: ```sql
SELECT
  COUNT(DISTINCT T1.Id)
FROM users AS T1
INNER JOIN posts AS T2
  ON T1.Id = T2.OwnerUserId
WHERE
  T1.Location = 'United Kingdom' AND T2.FavoriteCount >= 4;
```
Critic: ```sql
SELECT
  COUNT(DISTINCT T1.Id)
FROM users AS T1
INNER JOIN posts AS T2
  ON T1.Id = T2.OwnerUserId
WHERE
  T1.Location = 'United Kingdom' AND T2.FavoriteCount >= 4;
```
=====================
Question: Which post by Harvey Motulsky has the most views? Please give the id and title of this post.
 db_id: codebase_community
Planner: Plan:
1. Find the `UserId` of the user named 'Harvey Motulsky' from the `users` table.
2. Find all posts by that `UserId` from the `posts` table.
3. Find the post with the maximum `ViewCount` among these posts.
4. Return the `Id` and `Title` of the post with the maximum `ViewCount`.

NL2SQL: ```sql
SELECT
  Id,
  Title
FROM posts
WHERE
  OwnerUserId = (
    SELECT
      Id
    FROM users
    WHERE
      DisplayName = 'Harvey Motulsky'
  )
ORDER BY
  ViewCount DESC
LIMIT 1;
```
Critic: ```sql
SELECT
  p.Id,
  p.Title
FROM posts AS p
JOIN users AS u
  ON p.OwnerUserId = u.Id
WHERE
  u.DisplayName = 'Harvey Motulsky'
ORDER BY
  p.ViewCount DESC
LIMIT 1;
```
=====================
Question: Which is the most valuable post in 2010? Please give its id and the owner's display name.
 db_id: codebase_community
Planner: Plan:
1. Filter the `posts` table for posts created in the year 2010.
2. Find the post with the maximum `FavoriteCount` among the filtered posts.
3. Retrieve the `Id` and `OwnerUserId` of the most valuable post.
4. Join the `posts` table with the `users` table on `OwnerUserId` to get the `DisplayName` of the owner.
5. Select the `Id` of the post and the `DisplayName` of the owner.

NL2SQL: ```sql
SELECT
  p.Id,
  u.DisplayName
FROM posts AS p
JOIN users AS u
  ON p.OwnerUserId = u.Id
WHERE
  STRFTIME('%Y', p.CreaionDate) = '2010'
ORDER BY
  p.FavoriteCount DESC
LIMIT 1;
```
Critic: ```sql
SELECT
  p.Id,
  u.DisplayName
FROM posts AS p
JOIN users AS u
  ON p.OwnerUserId = u.Id
WHERE
  STRFTIME('%Y', p.CreaionDate) = '2010'
ORDER BY
  p.FavoriteCount DESC
LIMIT 1;
```
=====================
Question: What is the percentage of posts whose owners had a reputation of over 1000 in 2011?
 db_id: codebase_community
Planner: Plan:
1. Get all posts created in 2011 using the `posts` table.
2. Join `posts` table with `users` table on `OwnerUserId` to get the reputation of the post owner.
3. Filter the posts created in 2011 where the owner's reputation was greater than 1000.
4. Calculate the percentage of such posts by dividing the count of posts where the owner's reputation was greater than 1000 with the total count of posts created in 2011.
5. Multiply result by 100 to get percentage.
Columns needed:
- posts.Id
- posts.CreationDate
- posts.OwnerUserId
- users.Id
- users.Reputation
Tables needed:
- posts
- users
Filters:
- YEAR(posts.CreationDate) = 2011
- users.Reputation > 1000
Joins:
- posts.OwnerUserId = users.Id
Aggregations:
- COUNT(posts.Id)
Final Calculation:
- (COUNT of posts created in 2011 with owner's reputation > 1000) / (COUNT of all posts created in 2011) * 100

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T2.Reputation > 1000 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.Id)
FROM Posts AS T1
INNER JOIN Users AS T2
  ON T1.OwnerUserId = T2.Id
WHERE
  STRFTIME('%Y', T1.CreaionDate) = '2011';
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T2.Reputation > 1000 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.Id)
FROM posts AS T1
INNER JOIN users AS T2
  ON T1.OwnerUserId = T2.Id
WHERE
  STRFTIME('%Y', T1.CreaionDate) = '2011';
```
=====================
Question: Identify the total views on the post 'Computer Game Datasets'. Name the user who posted it last time.
 db_id: codebase_community
Planner: Plan:
1. Find the post with the title 'Computer Game Datasets' from the `posts` table.
2. Extract the `ViewCount` from the identified post.
3. Find the last editor of the post by using `LastEditorUserId` in `posts` table and joining with `users` table to extract `DisplayName`.
4. If the `LastEditorUserId` is null, use `OwnerUserId` to find the user.
5. Return the `ViewCount` and the `DisplayName` of the last editor or the owner.

NL2SQL: ```sql
SELECT
  p.ViewCount,
  COALESCE(u.DisplayName, u2.DisplayName) AS LastEditorDisplayName
FROM posts AS p
LEFT JOIN users AS u
  ON p.LastEditorUserId = u.Id
LEFT JOIN users AS u2
  ON p.OwnerUserId = u2.Id
WHERE
  p.Title = 'Computer Game Datasets';
```
Critic: ```sql
SELECT
  p.ViewCount,
  u.DisplayName
FROM Posts AS p
JOIN Users AS u
  ON p.LastEditorUserId = u.Id
WHERE
  p.Title = 'Computer Game Datasets';
```
=====================
Question: How many comments were added to the post with the highest score?
 db_id: codebase_community
Planner: Plan:
1. Find the post ID with the highest score from the `posts` table.
2. Count the number of comments associated with that post ID in the `comments` table.
3. Return the count of comments.
Tables:
- posts: To find the post ID with the highest score.
- comments: To count the number of comments for the post with the highest score.
Columns:
- posts.Id: Post ID
- posts.Score: Post score
- comments.PostId: Post ID in comments table
Aggregations:
- MAX(posts.Score): To find the highest score.
- COUNT(comments.Id): To count the number of comments.
Joins:
- None.
Filters:
- None.
- comments.PostId = the PostId from the posts table with the highest score.

NL2SQL: ```sql
SELECT
  COUNT(comments.Id)
FROM posts
JOIN comments
  ON posts.Id = comments.PostId
WHERE
  posts.Id = (
    SELECT
      Id
    FROM posts
    ORDER BY
      Score DESC
    LIMIT 1
  );
```
Critic: ```sql
SELECT
  CommentCount
FROM posts
ORDER BY
  Score DESC
LIMIT 1;
```
=====================
Question: Provide the text of the latest 10 comments to the post with the title 'Analysing wind data with R' and the display name of the user who left it.
 db_id: codebase_community
Planner: Plan:
1. Find the `PostId` of the post with the title 'Analysing wind data with R' from the `Posts` table.
2. Retrieve the latest 10 comments for that `PostId` from the `Comments` table, along with the `UserDisplayName` of the user who posted the comment and the `Text` of the comment.
3. Order the comments by `CreationDate` in descending order and limit the result to 10.
4. Return the `Text` and `UserDisplayName`.

NL2SQL: ```sql
SELECT
  T1.Text,
  T1.UserDisplayName
FROM comments AS T1
INNER JOIN posts AS T2
  ON T1.PostId = T2.Id
WHERE
  T2.Title = 'Analysing wind data with R'
ORDER BY
  T1.CreationDate DESC
LIMIT 10;
```
Critic: ```sql
SELECT
  T1.Text,
  U.DisplayName
FROM Comments AS T1
JOIN Posts AS T2
  ON T1.PostId = T2.Id
JOIN Users AS U
  ON T1.UserId = U.Id
WHERE
  T2.Title = 'Analysing wind data with R'
ORDER BY
  T1.CreationDate DESC
LIMIT 10;
```
=====================
Question: Among all the posts posted by the most influential user, identify the percentage with a score above 50.
 db_id: codebase_community
Planner: Here's my plan to determine the percentage of posts with a score above 50 among all posts by the most influential user:

1.  **Identify the most influential user:** Find the user with the highest reputation from the `users` table.
2.  **Find all posts by the most influential user:** Retrieve all posts from the `posts` table where `OwnerUserId` matches the ID of the most influential user.
3.  **Filter posts with a score above 50:** From the posts identified in the previous step, select those with a `Score` greater than 50.
4.  **Calculate the percentage:** Divide the number of posts with a score above 50 (from step 3) by the total number of posts by the most influential user (from step 2).  Multiply by 100 to express the result as a percentage.
5. Ensure that only valid numbers will be divided.
Tables:
*   `users`: To find the most influential user (highest reputation).
*   `posts`: To find posts by that user and filter by score.

Columns:
*   `users.Id`: User ID (to link to posts).
*   `users.Reputation`: User's reputation (to identify the most influential).
*   `posts.OwnerUserId`: User ID of the post owner.
*   `posts.Score`: Score of the post.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.Score > 50 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.Id)
FROM posts AS T1
JOIN users AS T2
  ON T1.OwnerUserId = T2.Id
WHERE
  T2.Id = (
    SELECT
      Id
    FROM users
    ORDER BY
      Reputation DESC
    LIMIT 1
  );
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.Score > 50 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.Id)
FROM posts AS T1
WHERE
  T1.OwnerUserId = (
    SELECT
      Id
    FROM users
    ORDER BY
      Reputation DESC
    LIMIT 1
  );
```
=====================
Question: What is the excerpt post ID and wiki post ID of the tag named sample?
 db_id: codebase_community
Planner: Plan:
1. Select the `ExcerptPostId` and `WikiPostId` from the `tags` table.
2. Filter the `tags` table where `TagName` is 'sample'.

NL2SQL: ```sql
SELECT
  ExcerptPostId,
  WikiPostId
FROM tags
WHERE
  TagName = 'sample';
```
Critic: ```sql
SELECT
  ExcerptPostId,
  WikiPostId
FROM Tags
WHERE
  TagName = 'sample';
```
=====================
Question: Give the user's reputation and up vote number of the user that commented "fine, you win :)".
 db_id: codebase_community
Planner: We need to find the user who commented "fine, you win :)", and then retrieve their reputation and upvotes.
1.  Filter the `comments` table for comments where the `Text` column is equal to "fine, you win :)".
2.  Join the filtered `comments` table with the `users` table using the `UserId` to get the reputation and upvotes of the user.
3.  Select the `Reputation` and `UpVotes` columns from the `users` table.

NL2SQL: ```sql
SELECT
  T1.Reputation,
  T1.UpVotes
FROM users AS T1
INNER JOIN comments AS T2
  ON T1.Id = T2.UserId
WHERE
  T2.Text = 'fine, you win :)';
```
Critic: ```sql
SELECT
  T1.Reputation,
  T1.UpVotes
FROM users AS T1
INNER JOIN comments AS T2
  ON T1.Id = T2.UserId
WHERE
  T2.Text = 'fine, you win :)';
```
=====================
Question: Among the posts with views ranging from 100 to 150, what is the comment with the highest score?
 db_id: codebase_community
Planner: 1. Find the posts with `ViewCount` between 100 and 150 from the `posts` table.
2. Retrieve the `Id` (post ID) of these posts.
3. Find comments associated with these post IDs from the `comments` table.
4. Order the comments by `Score` in descending order and select the top 1 comment's `Text`.
SQL should select `Text` column from `comments` table, use where condition `PostId` from `posts` table and `ViewCount` between 100 and 150. Finally, find the `MAX(Score)`.
SQL generation.
```sql
SELECT Text FROM comments WHERE PostId IN (SELECT Id FROM posts WHERE ViewCount BETWEEN 100 AND 150) ORDER BY Score DESC LIMIT 1
```
NL2SQL: ```sql
SELECT Text FROM comments WHERE PostId IN (SELECT Id FROM posts WHERE ViewCount BETWEEN 100 AND 150) ORDER BY Score DESC LIMIT 1
```
Critic: ```sql
SELECT Text FROM Comments WHERE PostId IN (SELECT Id FROM Posts WHERE ViewCount BETWEEN 100 AND 150) ORDER BY Score DESC LIMIT 1
```
=====================
Question: In posts with 1 comment, how many of the comments have 0 score?
 db_id: codebase_community
Planner: Plan:
1. Find posts with `CommentCount` = 1 from the `posts` table.
2. Join the `comments` table with the `posts` table on `posts.Id` = `comments.PostId`.
3. Filter the joined table where `comments.Score` = 0.
4. Count the number of comments that satisfy the conditions.
5. Return the count.

NL2SQL: ```sql
SELECT
  COUNT(T1.Id)
FROM comments AS T1
INNER JOIN posts AS T2
  ON T1.PostId = T2.Id
WHERE
  T2.CommentCount = 1 AND T1.Score = 0;
```
Critic: ```sql
SELECT
  COUNT(T1.Id)
FROM Comments AS T1
JOIN Posts AS T2
  ON T1.PostId = T2.Id
WHERE
  T2.CommentCount = 1 AND T1.Score = 0;
```
=====================
Question: Among the comments with scores between 5 to 10, what is the percentage of the users with 0 up votes?
 db_id: codebase_community
Planner: Plan:
1. Filter comments table by score between 5 and 10.
2. Join the filtered comments with the users table on UserId.
3. Count the number of users with 0 upvotes.
4. Count the total number of users.
5. Calculate the percentage.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T2.UpVotes = 0 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.UserId)
FROM comments AS T1
INNER JOIN users AS T2
  ON T1.UserId = T2.Id
WHERE
  T1.Score BETWEEN 5 AND 10;
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T2.UpVotes = 0 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.UserId)
FROM comments AS T1
INNER JOIN Users AS T2
  ON T1.UserId = T2.Id
WHERE
  T1.Score BETWEEN 5 AND 10;
```
=====================
Question: Which are the cards that have incredibly powerful foils.
 db_id: card_games
Planner: 1. Filter cards table for cards that have both `cardKingdomFoilId` and `cardKingdomId` not null.
2. Select the `name` column from the filtered cards.

NL2SQL: ```sql
SELECT
  name
FROM cards
WHERE
  cardKingdomFoilId IS NOT NULL
  AND cardKingdomId IS NOT NULL;
```
Critic: ```sql
SELECT
  name
FROM cards
WHERE
  cardKingdomFoilId IS NOT NULL
  AND cardKingdomId IS NOT NULL;
```
=====================
Question: What are the borderless cards available without powerful foils?
 db_id: card_games
Planner: Plan:
1. Filter the `cards` table for cards where `borderColor` is 'borderless'.
2. Filter the `cards` table where `cardKingdomFoilId` is NULL and `cardKingdomId` is not NULL. Since cardKingdomId represents non-foil, but also exists without cardKingdomFoilId.
3. Combine the above conditions with an AND operation to find cards that are borderless and do not have powerful foils.
4. Select the `name` column from the filtered `cards` table.

NL2SQL: ```sql
SELECT
  name
FROM cards
WHERE
  borderColor = 'borderless' AND cardKingdomFoilId IS NULL;
```
Critic: ```sql
SELECT
  name
FROM cards
WHERE
  borderColor = 'borderless' AND cardKingdomFoilId IS NULL AND cardKingdomId IS NULL;
```
=====================
Question: List all the mythic rarity print cards banned in gladiator format.
 db_id: card_games
Planner: Plan:
1. Join the `cards` and `legalities` tables on the `uuid` column to link card information with legality status.
2. Filter the results based on the following conditions:
    - `rarity` is 'mythic' in the `cards` table.
    - `format` is 'gladiator' in the `legalities` table.
    - `status` is 'Banned' in the `legalities` table.
3. Select the `name` column from the `cards` table to list the names of the cards that satisfy the conditions.

NL2SQL: ```sql
SELECT
  c.name
FROM cards AS c
JOIN legalities AS l
  ON c.uuid = l.uuid
WHERE
  c.rarity = 'mythic' AND l.format = 'gladiator' AND l.status = 'Banned';
```
Critic: ```sql
SELECT
  name
FROM cards
WHERE
  rarity = 'mythic'
  AND uuid IN (
    SELECT
      uuid
    FROM legalities
    WHERE
      format = 'gladiator' AND status = 'Banned'
  );
```
=====================
Question: For artifact type of cards that do not have multiple faces on the same card, state its legalities status for vintage play format.
 db_id: card_games
Planner: Here's a plan to retrieve the legality status for artifact cards without multiple faces in the vintage format:

1.  **Filter cards table:** Filter for `types` containing 'Artifact' and `side` being NULL.
2.  **Join with legalities table:** Join the filtered cards table with the `legalities` table using the `uuid` column.
3.  **Filter legalities table:** Filter for `format` equal to 'vintage'.
4.  **Select the status:** Select the `status` column from the `legalities` table.

NL2SQL: ```sql
SELECT
  T2.status
FROM cards AS T1
INNER JOIN legalities AS T2
  ON T1.uuid = T2.uuid
WHERE
  T1.types = 'Artifact' AND T1.side IS NULL AND T2.format = 'vintage';
```
Critic: ```sql
SELECT
  T2.status
FROM cards AS T1
INNER JOIN legalities AS T2
  ON T1.uuid = T2.uuid
WHERE
  T1.types LIKE '%Artifact%' AND T1.side IS NULL AND T2.format = 'vintage';
```
=====================
Question: List all the card id and artist with unknown power which are legal for commander play format.
 db_id: card_games
Planner: 1.  Join the `cards` table and the `legalities` table on the `uuid` column.
2.  Filter the results to include only cards where `power` is '*' or `power` is NULL.
3.  Filter the results to include only cards where `format` is 'Commander' and `status` is 'Legal'.
4.  Select the `uuid` (card id) and `artist` columns from the `cards` table.

NL2SQL: ```sql
SELECT
  c.uuid,
  c.artist
FROM cards AS c
JOIN legalities AS l
  ON c.uuid = l.uuid
WHERE
  (
    c.power = '*' OR c.power IS NULL
  )
  AND l.format = 'Commander'
  AND l.status = 'Legal';
```
Critic: ```sql
SELECT
  uuid,
  artist
FROM cards
WHERE
  power IS NULL
INTERSECT
SELECT
  uuid,
  artist
FROM cards AS T1
INNER JOIN legalities AS T2
  ON T1.uuid = T2.uuid
WHERE
  format = 'Commander' AND status = 'Legal';
```
=====================
Question: Find all cards illustrated by Stephen Daniel and describe the text of the ruling of these cards. State if these cards have missing or degraded properties and values.
 db_id: card_games
Planner: Plan:
1. Find cards illustrated by 'Stephen Daniele' from the `cards` table.
2. Retrieve the ruling text for the identified cards from the `rulings` table, joining on the `uuid`.
3. Check `cards` table for `hasContentWarning` = 1 to identify potentially missing or degraded content.
4. Output the card `name`, `text`, ruling `text`, and `hasContentWarning` column.

NL2SQL: ```sql
SELECT
  c.name,
  c.text,
  r.text,
  c.hasContentWarning
FROM cards AS c
JOIN rulings AS r
  ON c.uuid = r.uuid
WHERE
  c.artist = 'Stephen Daniele';
```
Critic: ```sql
SELECT
  c.name,
  c.text,
  r.text,
  CASE WHEN c.hasContentWarning = 1 THEN 'Yes' ELSE 'No' END AS hasContentWarning
FROM cards AS c
JOIN rulings AS r
  ON c.uuid = r.uuid
WHERE
  c.artist = 'Stephen Daniele';
```
=====================
Question: Name the card and artist with the most ruling information. Also state if the card is a promotional printing.
 db_id: card_games
Planner: Here's the plan to answer the question:

1.  **Join `cards` and `rulings` tables:** Join `cards` and `rulings` using the `uuid` column to link cards to their rulings.
2.  **Count rulings per card:** Group the joined table by card name (`cards.name`) and artist (`cards.artist`) and count the number of rulings for each card.
3.  **Find the maximum ruling count:** Determine the maximum number of rulings among all cards.
4.  **Filter for cards with the maximum ruling count:** Filter the grouped results to include only the card(s) having the maximum number of rulings.
5.  **Check if the card is promotional:** Check if `isPromo` column is equal to 1.
6.  **Select the required information:** Select the card name, artist, and promotional status (`isPromo`).

NL2SQL: ```sql
SELECT
  c.name,
  c.artist,
  c.isPromo
FROM cards AS c
JOIN rulings AS r
  ON c.uuid = r.uuid
GROUP BY
  c.name,
  c.artist,
  c.isPromo
ORDER BY
  COUNT(r.uuid) DESC
LIMIT 1;
```
Critic: ```sql
SELECT
  T1.name,
  T1.artist,
  T1.isPromo
FROM cards AS T1
INNER JOIN rulings AS T2
  ON T1.uuid = T2.uuid
GROUP BY
  T1.uuid
ORDER BY
  COUNT(T2.uuid) DESC
LIMIT 1;
```
=====================
Question: Calculate the percentage of the cards availabe in Chinese Simplified.
 db_id: card_games
Planner: Here's a plan to calculate the percentage of cards available in Chinese Simplified:

1.  **Count all cards:** Count the total number of cards using the `cards` table.
2.  **Count cards in Chinese Simplified:** Count the number of cards available in Chinese Simplified. This requires joining `cards` with `foreign_data` where `foreign_data.language` is 'Chinese Simplified' and then count distinct `cards.uuid`.
3.  **Calculate the percentage:** Divide the number of cards in Chinese Simplified by the total number of cards and multiply by 100 to get the percentage.

NL2SQL:
```sql
SELECT
  CAST(SUM(CASE WHEN T2.language = 'Chinese Simplified' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.uuid)
FROM cards AS T1
INNER JOIN foreign_data AS T2
  ON T1.uuid = T2.uuid;
```
NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T2.language = 'Chinese Simplified' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.uuid)
FROM cards AS T1
INNER JOIN foreign_data AS T2
  ON T1.uuid = T2.uuid
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN language = 'Chinese Simplified' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*)
FROM foreign_data
```
=====================
Question: How many cards have infinite power?
 db_id: card_games
Planner: Plan:
1. Filter the `cards` table to find cards where the `power` column is equal to '*'.
2. Count the number of cards that satisfy the condition in step 1.
3. Return the count.

Required Tables:
- cards

Required Columns:
- cards.power

Required Filters:
- cards.power = '*'

No joins are needed.
Aggregate function: COUNT(*)

NL2SQL: ```sql
SELECT
  COUNT(*)
FROM cards
WHERE
  power = '*';
```
Critic: ```sql
SELECT
  COUNT(*)
FROM cards
WHERE
  power = '*';
```
=====================
Question: What is the border color of card "Ancestor's Chosen"?
 db_id: card_games
Planner: 1.  Find the `borderColor` from the `cards` table.
2.  Filter the `cards` table by `name` = "Ancestor's Chosen".

NL2SQL: ```sql
SELECT
  borderColor
FROM cards
WHERE
  name = 'Ancestor\'s Chosen';
```
Critic: ```sql
SELECT
  borderColor
FROM cards
WHERE
  name = "Ancestor's Chosen";
```
=====================
Question: What is the rule of playing card "Benalish Knight"?
 db_id: card_games
Planner: 1. Find the `uuid` of the card named "Benalish Knight" from the `cards` table.
2. Use the `uuid` to find the rules text of the card from the `rulings` table.
3. Return the `text` column from the `rulings` table.

NL2SQL: ```sql
SELECT
  T1.text
FROM rulings AS T1
INNER JOIN cards AS T2
  ON T1.uuid = T2.uuid
WHERE
  T2.name = 'Benalish Knight';
```
Critic: ```sql
SELECT
  text
FROM cards
WHERE
  name = 'Benalish Knight';
```
=====================
Question: What is the percentage of borderless cards?
 db_id: card_games
Planner: Plan:
1. Calculate the total number of cards.
2. Calculate the number of borderless cards (borderColor = 'borderless').
3. Calculate the percentage of borderless cards by dividing the number of borderless cards by the total number of cards and multiplying by 100.
4. Output percentage.
Columns: id, borderColor from cards table.
Filters: borderColor = 'borderless'
Joins: no joins are required.
Tables: cards
NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN borderColor = 'borderless' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id)
FROM cards;
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN borderColor = 'borderless' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id)
FROM cards;
```
=====================
Question: What is the percentage of cards whose language is French among the Story Spotlight cards?
 db_id: card_games
Planner: 1.  Find the total number of Story Spotlight cards. This requires filtering the `cards` table for `isStorySpotlight = 1`.
2.  Find the number of Story Spotlight cards that are in French. This requires joining `cards` and `foreign_data` on `uuid` and filtering the result for `isStorySpotlight = 1` and `language = 'French'`.
3.  Calculate the percentage of French Story Spotlight cards by dividing the count from step 2 by the count from step 1 and multiplying by 100.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T2.language = 'French' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.uuid)
FROM cards AS T1
INNER JOIN foreign_data AS T2
  ON T1.uuid = T2.uuid
WHERE
  T1.isStorySpotlight = 1;
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T2.language = 'French' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id)
FROM cards AS T1
INNER JOIN foreign_data AS T2
  ON T1.uuid = T2.uuid
WHERE
  T1.isStorySpotlight = 1;
```
=====================
Question: How many cards with original type of "Summon - Angel" have subtype other than "Angel"?
 db_id: card_games
Planner: Plan:
1. Filter the `cards` table for cards with `originalType` equal to "Summon - Angel".
2. Filter the results further to include only cards where the `subtypes` column does not contain "Angel".
3. Count the number of cards that satisfy both conditions.
4. Return the count.

NL2SQL: ```sql
SELECT
  COUNT(*)
FROM cards
WHERE
  originalType = 'Summon - Angel' AND subtypes NOT LIKE '%Angel%';
```
Critic: ```sql
SELECT
  COUNT(*)
FROM cards
WHERE
  originalType = 'Summon - Angel' AND subtypes IS NOT NULL AND subtypes != 'Angel';
```
=====================
Question: What are the cards belong to duel deck a? List the ID.
 db_id: card_games
Planner: Plan:
1. Filter the `cards` table where `duelDeck` is equal to 'a'.
2. Select the `id` column from the filtered table.

NL2SQL: ```sql
SELECT
  id
FROM cards
WHERE
  duelDeck = 'a';
```
Critic: ```sql
SELECT
  uuid
FROM cards
WHERE
  duelDeck = 'a';
```
=====================
Question: How many of the banned cards are white border?
 db_id: card_games
Planner: 1.  Filter the `legalities` table to find cards with a "Banned" status.
2.  Join the filtered `legalities` table with the `cards` table on the `uuid` column to link legalities information to card details.
3.  Filter the joined table to include only cards with a "white" border color.
4.  Count the number of distinct cards that meet both criteria.
   Columns needed: `borderColor` from the `cards` table and `status` from the `legalities` table.
   Tables needed: `cards` and `legalities`.
   Join condition: `cards.uuid` = `legalities.uuid`.
   Filter conditions: `legalities.status` = 'Banned' and `cards.borderColor` = 'white'.
NL2SQL: ```sql
SELECT
  COUNT(DISTINCT T1.uuid)
FROM cards AS T1
INNER JOIN legalities AS T2
  ON T1.uuid = T2.uuid
WHERE
  T2.status = 'Banned' AND T1.borderColor = 'white';
```
Critic: ```sql
SELECT
  COUNT(T1.id)
FROM cards AS T1
INNER JOIN legalities AS T2
  ON T1.uuid = T2.uuid
WHERE
  T2.status = 'Banned' AND T1.borderColor = 'white';
```
=====================
Question: Among the Artifact cards, which are black color and comes with foreign languague translation?
 db_id: card_games
Planner: Plan:
1. Filter the `cards` table to get cards with `originalType` equal to 'Artifact' and `colors` equal to 'B'.
2. Join the `cards` table with the `foreign_data` table on the `uuid` column to find cards with foreign language translations.
3. Select the `name` column from the `cards` table.

NL2SQL: ```sql
SELECT
  c.name
FROM cards AS c
JOIN foreign_data AS fd
  ON c.uuid = fd.uuid
WHERE
  c.originalType = 'Artifact' AND c.colors = 'B';
```
Critic: ```sql
SELECT
  c.name
FROM cards AS c
JOIN foreign_data AS fd
  ON c.uuid = fd.uuid
WHERE
  c.types LIKE '%Artifact%' AND c.colors LIKE '%B%';
```
=====================
Question: What is the mana cost of cards with a normal layout, a 2003 frame version, with a black border color, and available in paper and mtgo?
 db_id: card_games
Planner: Here's my plan to answer the question:

1.  **Select the `manaCost` column** from the `cards` table.
2.  **Filter** the `cards` table based on the following criteria:
    *   `layout` = 'normal'
    *   `frameVersion` = '2003'
    *   `borderColor` = 'black'
    *   `availability` contains both 'paper' and 'mtgo'.

NL2SQL: ```sql
SELECT
  manaCost
FROM cards
WHERE
  layout = 'normal'
  AND frameVersion = '2003'
  AND borderColor = 'black'
  AND availability LIKE '%paper%'
  AND availability LIKE '%mtgo%';
```
Critic: ```sql
SELECT
  manaCost
FROM cards
WHERE
  layout = 'normal' AND frameVersion = '2003' AND borderColor = 'black' AND availability LIKE '%paper%' AND availability LIKE '%mtgo%';
```
=====================
Question: What is the percentage of Story Spotlight cards that do not have a text box? List them by their ID.
 db_id: card_games
Planner: 1.  Filter the `cards` table to identify Story Spotlight cards where `isStorySpotlight` is 1.
2.  From the filtered set of Story Spotlight cards, count the number of cards that do not have a text box (`text` column is NULL or empty string). Also retrieve their IDs for listing.
3.  Calculate the total number of Story Spotlight cards where `isStorySpotlight` is 1.
4.  Calculate the percentage of Story Spotlight cards without a text box by dividing the count from step 2 by the count from step 3 and multiplying by 100.
5.  Present the percentage and list the IDs of the cards identified in step 2.

Columns:
*   `cards.id`
*   `cards.isStorySpotlight`
*   `cards.text`

Tables:
*   `cards`

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.text IS NULL OR T1.text = '' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id),
  GROUP_CONCAT(CASE WHEN T1.text IS NULL OR T1.text = '' THEN T1.id ELSE NULL END)
FROM cards AS T1
WHERE
  T1.isStorySpotlight = 1;
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.text IS NULL OR T1.text = '' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id),
  GROUP_CONCAT(T1.id)
FROM cards AS T1
WHERE
  T1.isStorySpotlight = 1
  AND T1.isTextless = 1;
```
=====================
Question: How many Brazilian Portuguese translated sets are inside the Commander block?
 db_id: card_games
Planner: 1.  Filter the `sets` table to find sets where the `block` is 'Commander'.
2.  Filter the `set_translations` table to find set translations where the `language` is 'Portuguese (Brasil)'.
3.  Join the filtered `sets` table with the filtered `set_translations` table on `code` = `setCode`.
4.  Count the number of rows in the joined table.

NL2SQL: ```sql
SELECT
  COUNT(T1.code)
FROM sets AS T1
INNER JOIN set_translations AS T2
  ON T1.code = T2.setCode
WHERE
  T1.block = 'Commander' AND T2.language = 'Portuguese (Brasil)';
```
Critic: ```sql
SELECT
  COUNT(DISTINCT T1.code)
FROM sets AS T1
INNER JOIN set_translations AS T2
  ON T1.code = T2.setCode
WHERE
  T1.block = 'Commander' AND T2.language = 'Portuguese (Brasil)';
```
=====================
Question: Lists all types of cards in German.
 db_id: card_games
Planner: Plan:
1. Find the German language entries in the `foreign_data` table.
2. Filter for the rows where language is German
3. Select type from foreign_data.
4. Return the `type` column, which represents the card types in German.

```sql
SELECT DISTINCT
  type
FROM foreign_data
WHERE
  language = 'German';
```
NL2SQL: ```sql
SELECT DISTINCT
  T1.types
FROM cards AS T1
INNER JOIN foreign_data AS T2
  ON T1.uuid = T2.uuid
WHERE
  T2.language = 'German';
```
Critic: ```sql
SELECT DISTINCT
  type
FROM foreign_data
WHERE
  language = 'German';
```
=====================
Question: How many unknown power cards contain info about the triggered ability
 db_id: card_games
Planner: Plan:
1. Filter the `cards` table to find cards where `power` is NULL or '*'.
2. Filter the `cards` table to find cards where `text` contains 'triggered ability'.
3. Join the two conditions with AND.
4. Count the number of cards.
5. Return the count.

NL2SQL: ```sql
SELECT
  COUNT(*)
FROM cards
WHERE
  (
    power IS NULL
    OR power = '*'
  )
  AND text LIKE '%triggered ability%';
```
Critic: ```sql
SELECT
  COUNT(*)
FROM cards
WHERE
  power IS NULL
  AND text LIKE '%triggered ability%';
```
=====================
Question: Indicates the number of cards with pre-modern format, ruling text "This is a triggered mana ability." that do not have multiple faces.
 db_id: card_games
Planner: Here's my plan to determine the number of cards meeting the specified criteria:

1.  **Join `cards` and `legalities`:** Use `uuid` to link cards to their legalities to filter for cards with the "premodern" format.
2.  **Filter for "premodern" format:** In the `legalities` table, filter for `format = 'premodern'`.
3.  **Filter for ruling text:** Filter the cards table for cards where the text column contains "This is a triggered mana ability.".
4.  **Filter out multiple faces:** Filter the cards table for cards where the `side` column is NULL.
5.  **Count the cards:** Count the distinct `uuid` values to get the number of cards that meet all conditions.

Now, let's proceed with generating the SQL query.

NL2SQL: ```sql
SELECT
  COUNT(DISTINCT T1.uuid)
FROM cards AS T1
INNER JOIN legalities AS T2
  ON T1.uuid = T2.uuid
WHERE
  T2.format = 'premodern' AND T1.text = 'This is a triggered mana ability.' AND T1.side IS NULL;
```
Critic: ```sql
SELECT
  COUNT(DISTINCT T1.uuid)
FROM cards AS T1
INNER JOIN legalities AS T2
  ON T1.uuid = T2.uuid
INNER JOIN rulings AS T3
  ON T1.uuid = T3.uuid
WHERE
  T2.format = 'premodern' AND T3.text = 'This is a triggered mana ability.' AND T1.side IS NULL;
```
=====================
Question: What is the foreign name of the card in French of type Creature, normal layout and black border color, by artist Matthew D. Wilson?
 db_id: card_games
Planner: Plan:
1. Select the `name` column from the `foreign_data` table, aliased as `foreign_name`.
2. Filter `cards` table where `type` is 'Creature', `layout` is 'normal', `borderColor` is 'black' and `artist` is 'Matthew D. Wilson'.
3. Filter `foreign_data` table where `language` is 'French'.
4. Join `cards` and `foreign_data` table on `uuid`.

NL2SQL: ```sql
SELECT
  T2.name
FROM cards AS T1
INNER JOIN foreign_data AS T2
  ON T1.uuid = T2.uuid
WHERE
  T1.type = 'Creature' AND T1.layout = 'normal' AND T1.borderColor = 'black' AND T1.artist = 'Matthew D. Wilson' AND T2.language = 'French';
```
Critic: ```sql
SELECT
  T2.name
FROM cards AS T1
INNER JOIN foreign_data AS T2
  ON T1.uuid = T2.uuid
WHERE
  T1.types LIKE '%Creature%' AND T1.layout = 'normal' AND T1.borderColor = 'black' AND T1.artist = 'Matthew D. Wilson' AND T2.language = 'French';
```
=====================
Question: What language is the set of 180 cards that belongs to the Ravnica block translated into?
 db_id: card_games
Planner: 1. Find the set code for the Ravnica block using the `sets` table and the `block` column.
2. Use the set code to filter the `sets` table and get the set id where baseSetSize is 180.
3. Using the set id from `sets` table, find the language from the `set_translations` table.
4. Return the language.

NL2SQL: ```sql
SELECT DISTINCT
  T2.language
FROM sets AS T1
INNER JOIN set_translations AS T2
  ON T1.code = T2.setCode
WHERE
  T1.block = 'Ravnica' AND T1.baseSetSize = 180;
```
Critic: ```sql
SELECT DISTINCT
  T2.language
FROM sets AS T1
INNER JOIN set_translations AS T2
  ON T1.code = T2.setCode
WHERE
  T1.block = 'Ravnica';
```
=====================
Question: What percentage of cards with format commander and legal status do not have a content warning?
 db_id: card_games
Planner: 1.  Join the `cards` and `legalities` tables on the `uuid` column to link card information with legality information.
2.  Filter the results to include only cards where the `format` is 'commander' and the `status` is 'legal'.
3.  Count the number of cards that satisfy the above conditions and also have `hasContentWarning` equal to 0.
4.  Count the total number of cards satisfying the condition in step 2.
5.  Calculate the percentage by dividing the result of step 3 by the result of step 4 and multiplying by 100.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.hasContentWarning = 0 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id)
FROM cards AS T1
INNER JOIN legalities AS T2
  ON T1.uuid = T2.uuid
WHERE
  T2.format = 'Commander' AND T2.status = 'Legal';
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.hasContentWarning = 0 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id)
FROM cards AS T1
INNER JOIN legalities AS T2
  ON T1.uuid = T2.uuid
WHERE
  T2.format = 'commander' AND T2.status = 'legal';
```
=====================
Question: What percentage of cards without power are in French?
 db_id: card_games
Planner: Plan:
1. Find all cards that have power IS NULL or power = '*' using the `cards` table.
2. Find all cards that have power IS NULL or power = '*' and are in French using the `cards` and `foreign_data` tables.
3. Calculate the percentage of cards without power that are in French.

Tables:
- `cards`: To identify cards without power.
- `foreign_data`: To identify cards that are in French.

Columns:
- `cards.uuid`: To join `cards` and `foreign_data`.
- `cards.power`: To filter cards without power.
- `foreign_data.language`: To filter cards in French.

Joins:
- Join `cards` and `foreign_data` on `cards.uuid` = `foreign_data.uuid`.

Filters:
- `cards.power` IS NULL or `cards.power` = '*' to select cards without power.
- `foreign_data.language` = 'French' to select cards in French.

Calculations:
- `COUNT(CASE WHEN foreign_data.language = 'French' THEN 1 END)` to count cards without power that are in French.
- `COUNT(*)` to count total cards without power.
- Divide the count of French cards without power by the count of total cards without power and multiply by 100 to get the percentage.

NL2SQL: ```sql
SELECT CAST(SUM(CASE WHEN T2.language = 'French' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.uuid) FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.power IS NULL OR T1.power = '*'
```
Critic: ```sql
SELECT CAST(SUM(CASE WHEN T2.language = 'French' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.uuid) FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.power IS NULL
```
=====================
Question: What is the language of the card with the multiverse number 149934?
 db_id: card_games
Planner: 1.  Find the language of the card with multiverseid = 149934 from the `foreign_data` table.
2.  Select the `language` column from the `foreign_data` table.
3.  Filter by `multiverseid` = 149934.
NL2SQL: ```sql
SELECT
  language
FROM foreign_data
WHERE
  multiverseid = 149934;
```
Critic: ```sql
SELECT
  T1.language
FROM foreign_data AS T1
INNER JOIN cards AS T2
  ON T1.uuid = T2.uuid
WHERE
  T2.multiverseId = '149934';
```
=====================
Question: What proportion of cards do not have a text box with a normal layout?
 db_id: card_games
Planner: Plan:
1. Calculate the number of cards that do not have a text box and do not have a normal layout. This can be done using `cards` table and filtering `isTextless = 1` and `layout <> 'normal'`.
2. Calculate the total number of cards that do not have a text box. This can be done using `cards` table and filtering `isTextless = 1`.
3. Divide the result of step 1 by the result of step 2 to get the proportion.
4. Multiply the result by 100 to get the percentage.
5. Return the percentage.
Columns needed: `isTextless`, `layout`
Tables needed: `cards`
Filters: `isTextless = 1` and `layout <> 'normal'` in the first query. `isTextless = 1` in the second query.
No joins are needed.
NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN isTextless = 1 AND layout <> 'normal' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(CASE WHEN isTextless = 1 THEN uuid ELSE NULL END)
FROM cards
WHERE
  isTextless = 1;
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN isTextless = 1 AND layout = 'normal' THEN 0 ELSE 1 END) AS REAL) * 100 / COUNT(*)
FROM cards;
```
=====================
Question: What languages are available in the set known as Archenemy on the magic card market and having the code ARC?
 db_id: card_games
Planner: 1.  Filter the `sets` table to find the set with `mcmName` equal to 'Archenemy' and `code` equal to 'ARC'.
2.  Join `sets` table with `set_translations` table on `setCode`
3.  Select the distinct `language` from `set_translations` table.


NL2SQL: ```sql
SELECT DISTINCT
  T2.language
FROM sets AS T1
INNER JOIN set_translations AS T2
  ON T1.code = T2.setCode
WHERE
  T1.mcmName = 'Archenemy' AND T1.code = 'ARC';
```
Critic: ```sql
SELECT DISTINCT
  language
FROM set_translations
WHERE
  setCode = 'ARC';
```
=====================
Question: Which foreign language used by "A Pedra Fellwar"?
 db_id: card_games
Planner: 1. Find the `uuid` of the card named "A Pedra Fellwar" from the `cards` table.
2. Using the `uuid`, find the corresponding entries in the `foreign_data` table.
3. Retrieve the `language` from the `foreign_data` table for the corresponding entries.
4. Return the list of distinct languages.

NL2SQL: ```sql
SELECT DISTINCT language FROM foreign_data WHERE uuid IN (SELECT uuid FROM cards WHERE name = 'A Pedra Fellwar')
```
Critic: ```sql
SELECT DISTINCT language FROM foreign_data WHERE uuid IN (SELECT uuid FROM cards WHERE name = 'A Pedra Fellwar')
```
=====================
Question: Which card costs more converted mana, "Serra Angel" or "Shrine Keeper"?
 db_id: card_games
Planner: 1.  Find the converted mana cost for "Serra Angel" from the `cards` table.
2.  Find the converted mana cost for "Shrine Keeper" from the `cards` table.
3.  Compare the two converted mana costs and determine which is greater.
4.  Return the name of the card with the higher converted mana cost.

Tables:
*   `cards`

Columns:
*   `name`
*   `convertedManaCost`

Filters:
*   `name` = "Serra Angel"
*   `name` = "Shrine Keeper"

NL2SQL: ```sql
SELECT
  CASE
    WHEN (
      SELECT
        convertedManaCost
      FROM cards
      WHERE
        name = 'Serra Angel'
    ) > (
      SELECT
        convertedManaCost
      FROM cards
      WHERE
        name = 'Shrine Keeper'
    )
    THEN 'Serra Angel'
    ELSE 'Shrine Keeper'
  END;
```
Critic: ```sql
SELECT
  CASE
    WHEN (
      SELECT
        convertedManaCost
      FROM cards
      WHERE
        name = 'Serra Angel'
    ) > (
      SELECT
        convertedManaCost
      FROM cards
      WHERE
        name = 'Shrine Keeper'
    )
    THEN 'Serra Angel'
    ELSE 'Shrine Keeper'
  END;
```
=====================
Question: What's the Italian name of the set of cards with "Ancestor's Chosen" is in?
 db_id: card_games
Planner: 1. Find the set code for the card "Ancestor's Chosen" from the `cards` table.
2. Find the Italian translation of the set name using the `set_translations` table, filtering by the set code and language ('Italian').
3. Return the Italian translation of the set name.
The columns needed are `setCode` from the `cards` table, `translation` from `set_translations` table, `name` from `cards` table and `language` from `set_translations` table.
The tables needed are `cards` and `set_translations`.
The join condition is `cards.setCode = set_translations.setCode`.
The filters are `cards.name = 'Ancestor''s Chosen'` and `set_translations.language = 'Italian'`.

NL2SQL: ```sql
SELECT
  st.translation
FROM cards AS c
JOIN set_translations AS st
  ON c.setCode = st.setCode
WHERE
  c.name = 'Ancestor''s Chosen' AND st.language = 'Italian';
```
Critic: ```sql
SELECT
  ST.translation
FROM cards AS C
JOIN sets AS S
  ON C.setCode = S.code
JOIN set_translations AS ST
  ON S.code = ST.setCode
WHERE
  C.name = 'Ancestor''s Chosen' AND ST.language = 'Italian';
```
=====================
Question: For the set of cards with "Ancestor's Chosen" in it, is there a Korean version of it?
 db_id: card_games
Planner: 1. Find the UUID of the card named "Ancestor's Chosen" in the `cards` table.
2. Use the UUID found in step 1 to query the `foreign_data` table.
3. Filter the results from `foreign_data` to find entries where the language is 'Korean'.
4. If there are any results, it indicates that a Korean version exists. Otherwise, it doesn't.
   The columns to be selected are language, name
   The tables to be used are cards and foreign_data
   Join condition is cards.uuid = foreign_data.uuid
   The where clause for cards table is name = 'Ancestor''s Chosen'
   The where clause for foreign_data table is language = 'Korean'
NL2SQL: ```sql
SELECT
  fd.language
FROM cards AS c
JOIN foreign_data AS fd
  ON c.uuid = fd.uuid
WHERE
  c.name = 'Ancestor''s Chosen' AND fd.language = 'Korean';
```
Critic: ```sql
SELECT
  CASE WHEN EXISTS(SELECT 1 FROM foreign_data AS fd JOIN cards AS c ON c.uuid = fd.uuid WHERE c.name = "Ancestor's Chosen" AND fd.language = 'Korean') THEN 'Yes' ELSE 'No' END;
```
=====================
Question: Among the cards in the set "Hauptset Zehnte Edition", how many of them are designed by Adam Rex?
 db_id: card_games
Planner: 1.  Find the set code for the set "Hauptset Zehnte Edition" from the `sets` table using `name = 'Hauptset Zehnte Edition'`.
2.  Filter the `cards` table using the `setCode` obtained from the previous step to select the cards that belong to the set "Hauptset Zehnte Edition".
3.  Filter the cards from the previous step by `artist = 'Adam Rex'`.
4.  Count the number of cards that satisfy the condition.

NL2SQL: ```sql
SELECT
  COUNT(id)
FROM cards
WHERE
  setCode = (
    SELECT
      code
    FROM sets
    WHERE
      name = 'Hauptset Zehnte Edition'
  )
  AND artist = 'Adam Rex';
```
Critic: ```sql
SELECT
  COUNT(T1.id)
FROM cards AS T1
INNER JOIN sets AS T2
  ON T1.setCode = T2.code
WHERE
  T2.name = 'Hauptset Zehnte Edition' AND T1.artist = 'Adam Rex';
```
=====================
Question: What is the Simplified Chinese translation of the name of the set "Eighth Edition"?
 db_id: card_games
Planner: 1. Find the set code for the set named "Eighth Edition" from the `sets` table.
2. Use the set code to find the Simplified Chinese translation from the `set_translations` table where the language is "Chinese Simplified".
3. Return the translation.

Columns:
* sets: code, name
* set_translations: setCode, language, translation

Filters:
* sets: name = "Eighth Edition"
* set_translations: language = "Chinese Simplified"

Joins:
* Join `sets` table with `set_translations` table on `sets.code` = `set_translations.setCode`

Return:
* set_translations.translation

NL2SQL: ```sql
SELECT
  st.translation
FROM sets AS s
JOIN set_translations AS st
  ON s.code = st.setCode
WHERE
  s.name = 'Eighth Edition' AND st.language = 'Chinese Simplified';
```
Critic: ```sql
SELECT
  T2.translation
FROM sets AS T1
INNER JOIN set_translations AS T2
  ON T1.code = T2.setCode
WHERE
  T1.name = 'Eighth Edition' AND T2.language = 'Chinese Simplified';
```
=====================
Question: Did the set of cards with "Angel of Mercy" appear on Magic: The Gathering Online?
 db_id: card_games
Planner: Plan:
1. Find the card uuid of the card named "Angel of Mercy" from the `cards` table.
2. Check if the card with the found `uuid` appeared on Magic: The Gathering Online. This can be done by checking the `sets` table. Join `cards` with `sets` table on `setCode` column, where `sets.mtgoCode` is not NULL.
3. Return true if the card exists on Magic: The Gathering Online, and false otherwise.
4. Use `DISTINCT` so each combination is only accounted for once.
5. Select `sets.name` so we can view which set the card is in.

NL2SQL: ```sql
SELECT DISTINCT
  T1.name
FROM sets AS T1
INNER JOIN cards AS T2
  ON T1.code = T2.setCode
WHERE
  T2.name = 'Angel of Mercy' AND T1.mtgoCode IS NOT NULL;
```
Critic: ```sql
SELECT
  CASE WHEN COUNT(T1.isOnlineOnly) > 0 THEN 'true' ELSE 'false' END
FROM sets AS T1
INNER JOIN cards AS T2
  ON T1.code = T2.setCode
WHERE
  T2.name = 'Angel of Mercy' AND T1.isOnlineOnly = 1;
```
=====================
Question: Among the sets in the block "Ice Age", how many of them have an Italian translation?
 db_id: card_games
Planner: 1.  Find the sets that belong to the "Ice Age" block from the `sets` table.
2.  Join `sets` table with the `set_translations` table on `setCode = code`.
3.  Filter the joined table for Italian translations (`language = 'Italian'`).
4.  Count the distinct set codes.
NL2SQL: ```sql
SELECT
  COUNT(DISTINCT T1.code)
FROM sets AS T1
INNER JOIN set_translations AS T2
  ON T1.code = T2.setCode
WHERE
  T1.block = 'Ice Age' AND T2.language = 'Italian';
```
Critic: ```sql
SELECT
  COUNT(DISTINCT T1.code)
FROM sets AS T1
INNER JOIN set_translations AS T2
  ON T1.code = T2.setCode
WHERE
  T1.block = 'Ice Age' AND T2.language = 'Italian';
```
=====================
Question: Is the set of cards with Adarkar Valkyrie only available outside the United States?
 db_id: card_games
Planner: 1.  Find the `uuid` of the card named 'Adarkar Valkyrie' from the `cards` table.
2.  Find the `setCode` from the `cards` table using the `uuid` found in the previous step.
3.  Check in the `sets` table if there is any set where `code` matches the `setCode` and `isForeignOnly` is 1.
4.  Return True if the condition in step 3 is met, and False otherwise.

SQL Generation Steps:

*   Join `cards` and `sets` table where `cards.setCode` = `sets.code`.
*   Filter `cards` by `name` = 'Adarkar Valkyrie'.
*   Check `sets.isForeignOnly` = 1.

NL2SQL: ```sql
SELECT
  CASE
    WHEN COUNT(T1.code) > 0
    THEN 'True'
    ELSE 'False'
  END
FROM sets AS T1
INNER JOIN cards AS T2
  ON T1.code = T2.setCode
WHERE
  T2.name = 'Adarkar Valkyrie' AND T1.isForeignOnly = 1;
```
Critic: ```sql
SELECT
  CASE
    WHEN EXISTS(
      SELECT
        1
      FROM cards AS T1
      INNER JOIN sets AS T2
        ON T1.setCode = T2.code
      WHERE
        T1.name = 'Adarkar Valkyrie' AND T2.isForeignOnly = 1
    )
    THEN 'True'
    ELSE 'False'
  END;
```
=====================
Question: Among the sets of cards that have an Italian translation, how many of them have a base set number of under 100?
 db_id: card_games
Planner: Plan:
1. Find sets that have an Italian translation. This requires joining `sets` and `set_translations` on `setCode` and filtering `set_translations` by `language = 'Italian'` and `translation is not null`.
2. Filter the sets from the previous step to include only sets where `baseSetSize < 100`.
3. Count the number of sets that satisfy both conditions.
4. Return the count.

NL2SQL: ```sql
SELECT
  COUNT(DISTINCT T1.code)
FROM sets AS T1
INNER JOIN set_translations AS T2
  ON T1.code = T2.setCode
WHERE
  T2.language = 'Italian' AND T1.baseSetSize < 100
```
Critic: ```sql
SELECT
  COUNT(DISTINCT T1.code)
FROM sets AS T1
INNER JOIN set_translations AS T2
  ON T1.code = T2.setCode
WHERE
  T2.language = 'Italian' AND T1.baseSetSize < 100
```
=====================
Question: Which of these artists have designed a card in the set Coldsnap, Jeremy Jarvis, Aaron Miller or Chippy?
 db_id: card_games
Planner: Plan:
1. Find the set code for the set 'Coldsnap' from the `sets` table.
2. Filter the `cards` table by set code and artist names ('Jeremy Jarvis', 'Aaron Miller', 'Chippy').
3. Select the distinct artist names from the filtered results.

NL2SQL: ```sql
SELECT DISTINCT artist FROM cards WHERE setCode = (SELECT code FROM sets WHERE name = 'Coldsnap') AND artist IN ('Jeremy Jarvis', 'Aaron Miller', 'Chippy')
```
Critic: ```sql
SELECT DISTINCT artist FROM cards WHERE setCode = (SELECT code FROM sets WHERE name = 'Coldsnap') AND artist IN ('Jeremy Jarvis', 'Aaron Miller', 'Chippy')
```
=====================
Question: Among the cards with converted mana cost higher than 5 in the set Coldsnap, how many of them have unknown power?
 db_id: card_games
Planner: 1.  Find the cards from the set "Coldsnap".
2.  Filter these cards to include only those with a converted mana cost greater than 5.
3.  Filter these cards further to include only those with an unknown power (power = '*' or power is null).
4.  Count the remaining cards.

Tables:
*   `cards`: To access card information like name, converted mana cost, power, and set code.
*   `sets`: To retrieve the set ID using the set name.

Columns:
*   `cards.convertedManaCost`: To filter cards based on converted mana cost.
*   `cards.power`: To filter cards based on their power.
*   `cards.setCode`: To join with the `sets` table.
*   `sets.code`: To filter by set name.
*   `sets.name`: To specify the set name "Coldsnap".

NL2SQL: ```sql
SELECT
  COUNT(T1.uuid)
FROM cards AS T1
INNER JOIN sets AS T2
  ON T1.setCode = T2.code
WHERE
  T2.name = 'Coldsnap' AND T1.convertedManaCost > 5 AND T1.power = '*';
```
Critic: ```sql
SELECT
  COUNT(uuid)
FROM cards
WHERE
  setCode = 'CSP' AND convertedManaCost > 5 AND power = '*';
```
=====================
Question: What is the Italian flavor text of the card "Ancestor's Chosen"?
 db_id: card_games
Planner: 1. Filter the `cards` table to find the card with the name "Ancestor's Chosen". Get the `uuid` of this card.
2. Filter the `foreign_data` table using the `uuid` obtained in step 1 and the `language` as 'Italian'.
3. Retrieve the `flavorText` from the filtered `foreign_data` table.

NL2SQL: ```sql
SELECT
  T1.flavorText
FROM foreign_data AS T1
INNER JOIN cards AS T2
  ON T1.uuid = T2.uuid
WHERE
  T2.name = 'Ancestor''s Chosen' AND T1.language = 'Italian';
```
Critic: ```sql
SELECT
  T1.flavorText
FROM foreign_data AS T1
INNER JOIN cards AS T2
  ON T1.uuid = T2.uuid
WHERE
  T2.name = "Ancestor's Chosen" AND T1.language = 'Italian';
```
=====================
Question: Please list the Italian text ruling of all the cards in the set Coldsnap.
 db_id: card_games
Planner: 1.  Find the set code for the 'Coldsnap' set from the `sets` table.
2.  Join `cards` table with `foreign_data` table on the UUID.
3.  Filter the results to include only cards where the set code matches the one found in step 1, and the language in `foreign_data` is 'Italian'.
4.  Retrieve the `text` column from `foreign_data` to get the Italian text ruling.
NL2SQL: ```sql
SELECT
  T1.text
FROM foreign_data AS T1
INNER JOIN cards AS T2
  ON T1.uuid = T2.uuid
INNER JOIN sets AS T3
  ON T2.setCode = T3.code
WHERE
  T3.name = 'Coldsnap' AND T1.language = 'Italian';
```
Critic: ```sql
SELECT
  T1.text
FROM foreign_data AS T1
INNER JOIN cards AS T2
  ON T1.uuid = T2.uuid
WHERE
  T2.setCode = 'CSP' AND T1.language = 'Italian';
```
=====================
Question: Please list the Italian names of the cards in the set Coldsnap with the highest converted mana cost.
 db_id: card_games
Planner: Here's a plan to retrieve the Italian card names from the Coldsnap set with the highest converted mana cost:

1.  **Identify Coldsnap cards:**
    *   Join the `cards` table with the `sets` table on `setCode` = `code` to filter cards belonging to the Coldsnap set. Use `sets.name` = 'Coldsnap' as a filter.
2.  **Find Italian Translations:**
    *   Join the `cards` table with the `foreign_data` table on `uuid` = `uuid` and use the filter `foreign_data.language` = 'Italian'.
3.  **Determine the Maximum Converted Mana Cost:**
    *   Find the maximum `convertedManaCost` from the `cards` table for cards in the Coldsnap set.
4.  **Combine and Filter:**
    *   Combine the above information to select the Italian card names (`foreign_data.name`) from the Coldsnap set where the `convertedManaCost` from the `cards` table matches the maximum `convertedManaCost` calculated earlier.
5.  **Final Result:**
    *   Select the Italian card names (`foreign_data.name`)

NL2SQL:
```sql
SELECT
  T2.name
FROM cards AS T1
INNER JOIN foreign_data AS T2
  ON T1.uuid = T2.uuid
INNER JOIN sets AS T3
  ON T1.setCode = T3.code
WHERE
  T3.name = 'Coldsnap' AND T2.language = 'Italian' AND T1.convertedManaCost = (
    SELECT
      MAX(convertedManaCost)
    FROM cards AS T4
    WHERE
      T4.setCode = 'CSP'
  );
```
NL2SQL: ```sql
SELECT
  T1.name
FROM foreign_data AS T1
INNER JOIN cards AS T2
  ON T1.uuid = T2.uuid
WHERE
  T1.language = 'Italian' AND T2.setCode = 'CSP' AND T2.convertedManaCost = (
    SELECT
      MAX(T2.convertedManaCost)
    FROM cards AS T2
    WHERE
      T2.setCode = 'CSP'
  );
```
Critic: ```sql
SELECT
  T1.name
FROM foreign_data AS T1
INNER JOIN cards AS T2
  ON T1.uuid = T2.uuid
WHERE
  T1.language = 'Italian' AND T2.setCode = 'CSP'
ORDER BY
  T2.convertedManaCost DESC
LIMIT 1;
```
=====================
Question: What is the percentage of the cards with a converted mana cost of 7 in the set Coldsnap?
 db_id: card_games
Planner: 1.  Find the set code for the set 'Coldsnap' from the `sets` table.
2.  Find all cards from the `cards` table that belong to the set 'Coldsnap' using the set code.
3.  Count the total number of cards in the 'Coldsnap' set.
4.  Count the number of cards with a converted mana cost of 7 in the 'Coldsnap' set.
5.  Calculate the percentage of cards with a converted mana cost of 7 by dividing the count of cards with converted mana cost 7 by the total count of cards and multiplying by 100.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.convertedManaCost = 7 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.uuid)
FROM cards AS T1
INNER JOIN sets AS T2
  ON T1.setCode = T2.code
WHERE
  T2.name = 'Coldsnap';
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.convertedManaCost = 7 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.uuid)
FROM cards AS T1
WHERE
  T1.setCode = 'CSP';
```
=====================
Question: What is the percentage of incredibly powerful cards in the set Coldsnap?
 db_id: card_games
Planner: Plan:
1. Find the set code for the set 'Coldsnap' from the `sets` table.
2. Find all cards from the `cards` table that belong to the set 'Coldsnap'.
3. Count the total number of cards in the 'Coldsnap' set.
4. Filter these cards where `cardKingdomFoilId` is not NULL and `cardKingdomId` is not NULL.
5. Count the number of incredibly powerful cards in 'Coldsnap'.
6. Calculate the percentage of incredibly powerful cards by dividing the count of incredibly powerful cards by the total number of cards in 'Coldsnap' and multiplying by 100.
7. Display the percentage.
Tables: sets, cards
Columns: sets.code, cards.setCode, cards.cardKingdomFoilId, cards.cardKingdomId, sets.name
NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.cardKingdomFoilId IS NOT NULL AND T1.cardKingdomId IS NOT NULL THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.uuid)
FROM cards AS T1
INNER JOIN sets AS T2
  ON T1.setCode = T2.code
WHERE
  T2.name = 'Coldsnap';
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.cardKingdomFoilId IS NOT NULL AND T1.cardKingdomId IS NOT NULL THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.uuid)
FROM cards AS T1
WHERE
  T1.setCode = 'CSP';
```
=====================
Question: Which of the play format has the highest number of banned status? Indicate the play format and the names of all the card meet the condition.
 db_id: card_games
Planner: Plan:
1. Join the `legalities` and `cards` tables on the `uuid` column.
2. Filter the `legalities` table for rows where `status` is 'Banned'.
3. Group the results by `format` and count the number of banned cards in each format.
4. Find the format with the maximum count of banned cards.
5. Retrieve the `format` and the names of all cards with 'Banned' status in that format.

NL2SQL: ```sql
SELECT
  T1.format,
  T2.name
FROM legalities AS T1
INNER JOIN cards AS T2
  ON T1.uuid = T2.uuid
WHERE
  T1.status = 'Banned'
GROUP BY
  T1.format
ORDER BY
  COUNT(T1.status) DESC
LIMIT 1;
```
Critic: ```sql
SELECT
  format,
  GROUP_CONCAT(card_name)
FROM (
  SELECT
    T1.format,
    T2.name AS card_name,
    COUNT(T1.status) AS banned_count,
    RANK() OVER (ORDER BY COUNT(T1.status) DESC) AS rank_num
  FROM legalities AS T1
  INNER JOIN cards AS T2
    ON T1.uuid = T2.uuid
  WHERE
    T1.status = 'Banned'
  GROUP BY
    T1.format,
    T2.name
)
WHERE
  rank_num = 1
GROUP BY
  format;
```
=====================
Question: Which cards are ranked 1st on EDHRec? List all of the cards name and its banned play format.
 db_id: card_games
Planner: Plan:
1. Find cards that are ranked 1st on EDHRec using the `cards` table and filter by `edhrecRank = 1`.
2. Find the banned format for each card using the `legalities` table. Join `cards` and `legalities` on `uuid`. Filter the `legalities` table by `status = 'Banned'`.
3. Select the card name from the `cards` table and the format from the `legalities` table.

NL2SQL: ```sql
SELECT
  c.name,
  l.format
FROM cards AS c
JOIN legalities AS l
  ON c.uuid = l.uuid
WHERE
  c.edhrecRank = 1 AND l.status = 'Banned';
```
Critic: ```sql
SELECT
  name,
  format
FROM cards AS T1
INNER JOIN legalities AS T2
  ON T1.uuid = T2.uuid
WHERE
  T1.edhrecRank = 1 AND T2.status = 'Banned';
```
=====================
Question: List the names of all the cards in the set Hour of Devastation and find the formats in which these cards are legal.
 db_id: card_games
Planner: Plan:
1. Find the set code for 'Hour of Devastation' from the `sets` table.
2. Select card names from the `cards` table where the `setCode` matches the set code found in step 1.
3. Find the legal formats for each card from the `legalities` table using `uuid` to connect to `cards` table
4. Display the card name and the format for each legal card.
Tables:
- `sets`: To get the `code` for the set "Hour of Devastation".
- `cards`: To get the `name` of the cards from the set.
- `legalities`: To get the `format` in which the cards are legal.

Columns:
- `sets.code`: To filter for "Hour of Devastation".
- `cards.name`: To display the card names.
- `cards.uuid`: To join with `legalities`.
- `legalities.format`: To display the legal formats.
- `legalities.status`: To filter for legal formats.

Filters:
- `sets.name` = 'Hour of Devastation'
- `legalities.status` = 'Legal'

Joins:
- Join `cards` and `legalities` on `cards.uuid` = `legalities.uuid`.
- Join `sets` and `cards` on `sets.code` = `cards.setCode`.

NL2SQL: ```sql
SELECT
  c.name,
  l.format
FROM cards AS c
JOIN sets AS s
  ON c.setCode = s.code
JOIN legalities AS l
  ON c.uuid = l.uuid
WHERE
  s.name = 'Hour of Devastation' AND l.status = 'Legal';
```
Critic: ```sql
SELECT
  T1.name,
  T2.format
FROM cards AS T1
INNER JOIN legalities AS T2
  ON T1.uuid = T2.uuid
WHERE
  T1.setCode = 'HOU';
```
=====================
Question: Find and list the names of sets which doesn't have Japanese translation but have Korean translation.
 db_id: card_games
Planner: Plan:
1. Find sets that have Korean translations in the `set_translations` table.
2. Find sets that do not have Japanese translations in the `set_translations` table.
3. Join the two results on `setCode` to find the sets that satisfy both conditions.
4. Retrieve the names of the sets from the `sets` table using the `code` column.
5. Return the names of the sets.
Tables:
sets, set_translations

Columns:
sets.name, sets.code, set_translations.setCode, set_translations.language

NL2SQL: ```sql
SELECT
  s.name
FROM sets AS s
WHERE
  s.code IN (
    SELECT DISTINCT
      st.setCode
    FROM set_translations AS st
    WHERE
      st.language = 'Korean'
  )
  AND s.code NOT IN (
    SELECT DISTINCT
      st.setCode
    FROM set_translations AS st
    WHERE
      st.language = 'Japanese'
  );
```
Critic: ```sql
SELECT
  name
FROM sets
WHERE
  code IN (
    SELECT
      setCode
    FROM set_translations
    WHERE
      language = 'Korean'
  )
  AND code NOT IN (
    SELECT
      setCode
    FROM set_translations
    WHERE
      language = 'Japanese'
  );
```
=====================
Question: List all the frame styles and cards Allen Williams worked on and find any banned cards if there are any.
 db_id: card_games
Planner: Plan:
1. Filter the `cards` table for cards where `artist` is 'Allen Williams'.
2. Select the `frameVersion` column from the filtered cards.
3. Join `cards` and `legalities` on `uuid` to identify banned cards.
4. Filter where `artist` is 'Allen Williams' and where `status` is 'Banned'.
5. Select the `name` column to show the name of banned cards.
6. Combine the results to get both the frame styles and names of banned cards.

NL2SQL: ```sql
SELECT
  c.frameVersion,
  c.name
FROM cards AS c
LEFT JOIN legalities AS l
  ON c.uuid = l.uuid
WHERE
  c.artist = 'Allen Williams' AND l.status = 'Banned';
```
Critic: ```sql
SELECT
  c.frameVersion,
  c.name
FROM cards AS c
LEFT JOIN legalities AS l
  ON c.uuid = l.uuid
WHERE
  c.artist = 'Allen Williams'
UNION
SELECT
  c.frameVersion,
  c.name
FROM cards AS c
LEFT JOIN legalities AS l
  ON c.uuid = l.uuid
WHERE
  l.status = 'Banned';
```
=====================
Question: What is the most common bond type?
 db_id: toxicology
Planner: Plan:
1. Count the occurrences of each bond type in the `bond` table.
2. Find the maximum count of bond types.
3. Select the bond type(s) that have the maximum count.
Tables: bond
Columns: bond_type
Aggregations: COUNT
Ordering: DESC
Limiting: 1
NL2SQL: ```sql
SELECT bond_type FROM bond GROUP BY bond_type ORDER BY COUNT(*) DESC LIMIT 1
```
Critic: ```sql
SELECT bond_type FROM bond GROUP BY bond_type ORDER BY COUNT(*) DESC LIMIT 1
```
=====================
Question: Calculate the average number of oxygen atoms in single-bonded molecules.
 db_id: toxicology
Planner: Here's my plan to calculate the average number of oxygen atoms in single-bonded molecules:

1.  **Identify single-bonded molecules:** Filter the `bond` table to find `molecule_id` values where `bond_type` is '-'.
2.  **Find oxygen atoms in those molecules:** Join the filtered `bond` table with the `atom` table using `molecule_id`. Filter the joined table to select only rows where the `element` is 'O'.
3.  **Calculate the count of oxygen atoms for each single-bonded molecule:** Group by `molecule_id` and count the number of oxygen atoms.
4.  **Calculate the average:** Calculate the average number of oxygen atoms across all single-bonded molecules using AVG().
5.  **Final columns:** molecule\_id, average\_oxygen\_atoms

NL2SQL: ```sql
SELECT
  AVG(oxygen_count)
FROM (
  SELECT
    a.molecule_id,
    COUNT(a.atom_id) AS oxygen_count
  FROM atom AS a
  JOIN bond AS b
    ON a.molecule_id = b.molecule_id
  WHERE
    a.element = 'O' AND b.bond_type = '-'
  GROUP BY
    a.molecule_id
) AS subquery;
```
Critic: ```sql
SELECT AVG(CASE WHEN T1.element = 'O' THEN 1 ELSE 0 END) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T3.bond_type = '-';
```
=====================
Question: On average how many carcinogenic molecules are single bonded?
 db_id: toxicology
Planner: Plan:
1. Join the `molecule` table with the `bond` table on `molecule_id` to filter for carcinogenic molecules and their bonds.
2. Filter the results to include only bonds where `bond_type` is '-'.
3. Calculate the average number of single bonds by dividing the number of single bonds in carcinogenic molecules by the total number of carcinogenic molecules.
4. Count the molecule ids.
5. Divide the number of single bonds by the number of carcinogenic molecules.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.bond_type = '-' THEN 1 ELSE 0 END) AS REAL) / COUNT(T1.molecule_id)
FROM bond AS T1
INNER JOIN molecule AS T2
  ON T1.molecule_id = T2.molecule_id
WHERE
  T2.label = '+';
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.bond_type = '-' THEN 1 ELSE 0 END) AS REAL) / COUNT(T2.molecule_id)
FROM bond AS T1
INNER JOIN molecule AS T2
  ON T1.molecule_id = T2.molecule_id
WHERE
  T2.label = '+';
```
=====================
Question: Find the triple-bonded molecules which are carcinogenic.
 db_id: toxicology
Planner: Plan:
1. Filter `bond` table to find `bond_id` where `bond_type` is '#'.
2. Filter `molecule` table to find `molecule_id` where `label` is '+'.
3. Join the filtered `bond` and `molecule` tables on `molecule_id`.
4. Select the `molecule_id` from the joined table.

NL2SQL: ```sql
SELECT
  T1.molecule_id
FROM bond AS T1
INNER JOIN molecule AS T2
  ON T1.molecule_id = T2.molecule_id
WHERE
  T1.bond_type = '#' AND T2.label = '+';
```
Critic: ```sql
SELECT DISTINCT
  T1.molecule_id
FROM bond AS T1
INNER JOIN molecule AS T2
  ON T1.molecule_id = T2.molecule_id
WHERE
  T1.bond_type = '#' AND T2.label = '+';
```
=====================
Question: What is the percentage of carbon in double-bond molecules?
 db_id: toxicology
Planner: Plan:
1. Filter the `bond` table to get the `molecule_id` of double-bond molecules (`bond_type` = '=').
2. Filter the `atom` table to only include carbon atoms (`element` = 'C').
3. Join the result from step 1 and step 2 on `molecule_id` to only include the molecules with double bonds.
4. Count the total number of carbon atoms in molecules with double bonds.
5. Count the total number of atoms in molecules with double bonds.
6. Divide the number of carbon atoms in molecules with double bonds (step 4) by the total number of atoms in molecules with double bonds (step 5) to get the percentage.
7. Multiply the result from step 6 by 100 to get the percentage.
Tables: `bond`, `atom`
Columns:
*   `bond`: `molecule_id`, `bond_type`
*   `atom`: `molecule_id`, `element`
Filters:
*   `bond`: `bond_type` = '='
*   `atom`: `element` = 'C'
Joins: `bond.molecule_id` = `atom.molecule_id`
Aggregate functions: `COUNT`, `SUM`
Other operations: division, multiplication
NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.element = 'C' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.atom_id)
FROM atom AS T1
INNER JOIN bond AS T2
  ON T1.molecule_id = T2.molecule_id
WHERE
  T2.bond_type = '=';
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.element = 'C' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.atom_id)
FROM atom AS T1
INNER JOIN molecule AS T3
  ON T1.molecule_id = T3.molecule_id
INNER JOIN bond AS T2
  ON T3.molecule_id = T2.molecule_id
WHERE
  T2.bond_type = '=';
```
=====================
Question: What elements are in the TR004_8_9 bond atoms?
 db_id: toxicology
Planner: Plan:
1. Filter the `connected` table by `bond_id` = 'TR004_8_9'.
2. From the filtered table, get the `atom_id` and `atom_id2` columns, which represent the atom IDs connected by the specified bond.
3. Join the `atom` table with the results from the previous step using the `atom_id` column to retrieve the `element` for each atom ID.
4. Return the distinct `element` values.

NL2SQL: ```sql
SELECT DISTINCT T1.element FROM atom AS T1 JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T2.bond_id = 'TR004_8_9'
UNION
SELECT DISTINCT T1.element FROM atom AS T1 JOIN connected AS T2 ON T1.atom_id = T2.atom_id2 WHERE T2.bond_id = 'TR004_8_9'
```
Critic: ```sql
SELECT DISTINCT T1.element FROM atom AS T1 JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T2.bond_id = "TR004_8_9" UNION SELECT DISTINCT T1.element FROM atom AS T1 JOIN connected AS T2 ON T1.atom_id = T2.atom_id2 WHERE T2.bond_id = "TR004_8_9"
```
=====================
Question: What elements are in a double type bond?
 db_id: toxicology
Planner: Plan:
1. Filter the `bond` table to find bonds where `bond_type` is '=' (double bond).
2. Retrieve the `molecule_id` from the filtered `bond` table.
3. Join the `atom` table with the `molecule` table using `molecule_id`.
4. Filter the `atom` table based on `molecule_id` to select atoms that belongs to double bond molecules.
5. Extract the `element` from `atom` table to know which elements are in the molecules having double bonds.
6. Return the distinct elements.

Tables: `bond`, `molecule`, `atom`
Columns: `bond`.`bond_type`, `bond`.`molecule_id`, `atom`.`molecule_id`, `atom`.`element`
Filters: `bond`.`bond_type` = '=',
Joins: `bond`.`molecule_id` = `atom`.`molecule_id`
Return: `atom`.`element`
Distinct: yes

NL2SQL: ```sql
SELECT DISTINCT T1.element FROM atom AS T1 JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.bond_type = "="
```
Critic: ```sql
SELECT DISTINCT T1.element FROM atom AS T1 JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.bond_type = "="
```
=====================
Question: Which type of label is the most numerous in atoms with hydrogen?
 db_id: toxicology
Planner: Plan:
1. Find the atoms that have element 'h'.
2. Find the molecule_id of these atoms.
3. Count the number of molecules for each label.
4. Find the label with the highest count.
Tables: atom, molecule
Columns: atom.element, atom.molecule_id, molecule.label
Filters: atom.element = 'h'
Group by: molecule.label
Order by: count DESC
Limit: 1
Joins: atom.molecule_id = molecule.molecule_id

NL2SQL: ```sql
SELECT
  T2.label
FROM atom AS T1
INNER JOIN molecule AS T2
  ON T1.molecule_id = T2.molecule_id
WHERE
  T1.element = 'h'
GROUP BY
  T2.label
ORDER BY
  COUNT(T2.label) DESC
LIMIT 1;
```
Critic: ```sql
SELECT T2.label FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'H' GROUP BY T2.label ORDER BY count(*) DESC LIMIT 1
```
=====================
Question: Which element is the least numerous in non-carcinogenic molecules?
 db_id: toxicology
Planner: Plan:
1. Filter the `molecule` table to select only non-carcinogenic molecules (label = '-').
2. Join the filtered `molecule` table with the `atom` table using `molecule_id` to associate molecules with their constituent atoms.
3. Group the resulting table by `element` and count the number of occurrences of each element.
4. Find the minimum count of elements, i.e., the least numerous element, in the non-carcinogenic molecules.
5. Select the element with the minimum count.

NL2SQL: ```sql
SELECT element FROM atom WHERE molecule_id IN (SELECT molecule_id FROM molecule WHERE label = '-') GROUP BY element ORDER BY count(*) ASC LIMIT 1
```
Critic: ```sql
SELECT element FROM atom WHERE molecule_id IN (SELECT molecule_id FROM molecule WHERE label = '-') GROUP BY element ORDER BY COUNT(*) ASC LIMIT 1
```
=====================
Question: What type of bond is there between the atoms TR004_8 and TR004_20?
 db_id: toxicology
Planner: Plan:
1. Find the bond ID connecting the two atoms 'TR004_8' and 'TR004_20' in the `connected` table. Consider that the order of `atom_id` and `atom_id2` might be reversed.
2. Use the obtained bond ID to find the corresponding `bond_type` from the `bond` table.
3. Return the `bond_type`.

NL2SQL: ```sql
SELECT
  T1.bond_type
FROM bond AS T1
INNER JOIN connected AS T2
  ON T1.bond_id = T2.bond_id
WHERE
  (
    T2.atom_id = 'TR004_8' AND T2.atom_id2 = 'TR004_20'
  )
  OR (
    T2.atom_id = 'TR004_20' AND T2.atom_id2 = 'TR004_8'
  );
```
Critic: ```sql
SELECT
  T1.bond_type
FROM bond AS T1
INNER JOIN connected AS T2
  ON T1.bond_id = T2.bond_id
WHERE
  (
    T2.atom_id = 'TR004_8' AND T2.atom_id2 = 'TR004_20'
  )
  OR (
    T2.atom_id = 'TR004_20' AND T2.atom_id2 = 'TR004_8'
  );
```
=====================
Question: How many atoms with iodine and with sulfur type elements are there in single bond molecules?
 db_id: toxicology
Planner: Plan:
1. Find all atoms that are iodine or sulfur using the `atom` table.
2. Find all single bonds using the `bond` table.
3. Join the `connected` table with the results from step 1 and step 2 to link the atoms and bonds.
4. Filter the joined table to include only the atoms that are iodine or sulfur and connected by single bonds.
5. Count the distinct atoms.

NL2SQL:
```sql
SELECT
  COUNT(DISTINCT T1.atom_id)
FROM atom AS T1
INNER JOIN connected AS T2
  ON T1.atom_id = T2.atom_id
INNER JOIN bond AS T3
  ON T2.bond_id = T3.bond_id
WHERE
  T1.element IN ('i', 's') AND T3.bond_type = '-';
```
NL2SQL: ```sql
SELECT
  COUNT(DISTINCT T1.atom_id)
FROM atom AS T1
INNER JOIN connected AS T2
  ON T1.atom_id = T2.atom_id
INNER JOIN bond AS T3
  ON T2.bond_id = T3.bond_id
WHERE
  T1.element IN ('i', 's') AND T3.bond_type = '-';
```
Critic: ```sql
SELECT
  SUM(CASE WHEN T1.element = 'i' THEN 1 ELSE 0 END) AS iodine_count,
  SUM(CASE WHEN T1.element = 's' THEN 1 ELSE 0 END) AS sulfur_count
FROM atom AS T1
INNER JOIN connected AS T2
  ON T1.atom_id = T2.atom_id
INNER JOIN bond AS T3
  ON T2.bond_id = T3.bond_id
WHERE
  T3.bond_type = '-' AND T1.element IN ('i', 's');
```
=====================
Question: What percentage of carcinogenic-type molecules does not contain fluorine?
 db_id: toxicology
Planner: Plan:
1. Filter the `molecule` table for molecules with `label` = '+', representing carcinogenic molecules.
2. Join the filtered `molecule` table with the `atom` table on `molecule_id` to identify atoms within the carcinogenic molecules.
3. Count the number of distinct carcinogenic molecules that contain fluorine (element = 'f') and the number of all distinct carcinogenic molecules.
4. Calculate the percentage of molecules that do not contain fluorine by subtracting the count of molecules containing fluorine from the total count and dividing by the total number of molecules, then multiplying by 100.
5. Rename columns appropriately to reflect the desired output.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.element = 'f' THEN 0 ELSE 1 END) AS REAL) * 100 / COUNT(T1.molecule_id)
FROM atom AS T1
INNER JOIN molecule AS T2
  ON T1.molecule_id = T2.molecule_id
WHERE
  T2.label = '+';
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.element = 'f' THEN 0 ELSE 1 END) AS REAL) * 100 / COUNT(DISTINCT T1.molecule_id)
FROM atom AS T1
INNER JOIN molecule AS T2
  ON T1.molecule_id = T2.molecule_id
WHERE
  T2.label = '+';
```
=====================
Question: What is the percentage of carcinogenic molecules in triple type bonds?
 db_id: toxicology
Planner: Plan:
1. Find carcinogenic molecules using the `molecule` table where `label` is '+'.
2. Join the `bond` table with the `molecule` table on `molecule_id` to find the bonds associated with carcinogenic molecules.
3. Filter for triple bonds (`bond_type` is '#').
4. Calculate the percentage of triple bonds among all bonds of carcinogenic molecules. This involves counting the number of triple bonds and dividing by the total number of bonds in carcinogenic molecules, then multiplying by 100.
5. The columns needed are: from the `molecule` table, `label`; from the `bond` table, `bond_type` and `molecule_id`.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.bond_type = '#' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.bond_id)
FROM bond AS T1
INNER JOIN molecule AS T2
  ON T1.molecule_id = T2.molecule_id
WHERE
  T2.label = '+';
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.bond_type = '#' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.bond_id)
FROM bond AS T1
INNER JOIN molecule AS T2
  ON T1.molecule_id = T2.molecule_id
WHERE
  T2.label = '+';
```
=====================
Question: Please list top three elements of the toxicology of the molecule TR000 in alphabetical order.
 db_id: toxicology
Planner: Plan:
1. Filter the `atom` table by `molecule_id = "TR000"` to get all atoms belonging to the molecule "TR000".
2. Select the `element` column from the filtered `atom` table.
3. Get the top 3 elements.
4. Order the elements in alphabetical order.

NL2SQL: ```sql
SELECT element FROM atom WHERE molecule_id = "TR000" ORDER BY element ASC LIMIT 3
```
Critic: ```sql
SELECT element FROM atom WHERE molecule_id = "TR000" ORDER BY element ASC LIMIT 3
```
=====================
Question: What is the percentage of double bonds in the molecule TR008? Please provide your answer as a percentage with five decimal places.
 db_id: toxicology
Planner: Plan:
1. Filter the `bond` table to get all bonds associated with the molecule 'TR008'.
2. Count the total number of bonds for molecule 'TR008'.
3. Count the number of double bonds (bond_type = '=') for molecule 'TR008'.
4. Calculate the percentage of double bonds by dividing the number of double bonds by the total number of bonds and multiplying by 100.
5. Format the percentage to five decimal places.
Tables: bond
Columns: molecule_id, bond_type
Filters: molecule_id = 'TR008', bond_type = '='
Aggregations: COUNT, SUM, DIVIDE
Output: Percentage of double bonds in 'TR008' formatted to five decimal places.

NL2SQL: ```sql
SELECT CAST(SUM(CASE WHEN bond_type = '=' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(bond_id) FROM bond WHERE molecule_id = 'TR008'
```
Critic: ```sql
SELECT CAST(SUM(CASE WHEN bond_type = '=' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(bond_id) FROM bond WHERE molecule_id = 'TR008'
```
=====================
Question: What is the percentage of molecules that are carcinogenic? Please provide your answer as a percentage with three decimal places.
 db_id: toxicology
Planner: Plan:
1. Count the total number of molecules.
2. Count the number of carcinogenic molecules (where label = '+').
3. Calculate the percentage of carcinogenic molecules by dividing the count of carcinogenic molecules by the total number of molecules.
4. Format the result as a percentage with three decimal places.
Tables:
- molecule

Columns:
- molecule_id
- label

Filters:
- label = '+' to identify carcinogenic molecules

Aggregations:
- COUNT(molecule_id) to count the total number of molecules
- SUM(CASE WHEN label = '+' THEN 1 ELSE 0 END) to count the number of carcinogenic molecules

NL2SQL: ```sql
SELECT CAST(SUM(CASE WHEN label = '+' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(molecule_id) FROM molecule
```
Critic: ```sql
SELECT CAST(SUM(CASE WHEN label = '+' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(molecule_id) FROM molecule
```
=====================
Question: How much of the hydrogen in molecule TR206 is accounted for? Please provide your answer as a percentage with four decimal places.
 db_id: toxicology
Planner: Plan:
1. Filter the `atom` table for atoms belonging to molecule 'TR206'.
2. Count the total number of atoms in molecule 'TR206'.
3. Count the number of hydrogen atoms (element = 'H') in molecule 'TR206'.
4. Calculate the percentage of hydrogen atoms by dividing the number of hydrogen atoms by the total number of atoms, multiplying by 100, and rounding to four decimal places.
5. Output the calculated percentage.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN element = 'H' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(atom_id)
FROM atom
WHERE
  molecule_id = 'TR206';
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN element = 'H' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(atom_id)
FROM atom
WHERE
  molecule_id = 'TR206';
```
=====================
Question: What are the elements of the toxicology and label of molecule TR060?
 db_id: toxicology
Planner: Plan:
1. Filter the `molecule` table to find the row where `molecule_id` is 'TR060'.
2. Extract the `label` column from the filtered row.
3. Filter the `atom` table to find all rows where `molecule_id` is 'TR060'.
4. Extract the `element` column from the filtered rows.
5. Return the label and elements.
Tables:
- molecule
- atom

Columns:
- molecule.molecule_id
- molecule.label
- atom.molecule_id
- atom.element

Filters:
- molecule.molecule_id = 'TR060'
- atom.molecule_id = 'TR060'

NL2SQL: ```sql
SELECT
  t1.label,
  t2.element
FROM molecule AS t1
INNER JOIN atom AS t2
  ON t1.molecule_id = t2.molecule_id
WHERE
  t1.molecule_id = 'TR060';
```
Critic: ```sql
SELECT
  T1.label,
  T2.element
FROM molecule AS T1
INNER JOIN atom AS T2
  ON T1.molecule_id = T2.molecule_id
WHERE
  T1.molecule_id = "TR060";
```
=====================
Question: Which bond type accounted for the majority of the bonds found in molecule TR010 and state whether or not this molecule is carcinogenic?
 db_id: toxicology
Planner: Plan:
1. Find the count of each bond type for molecule TR010 from the `bond` table.
2. Determine the bond type with the maximum count.
3. Retrieve the carcinogenicity label for molecule TR010 from the `molecule` table.
4. Combine the most frequent bond type and the carcinogenicity information to answer the question.
Tables: `bond`, `molecule`
Columns: `bond.molecule_id`, `bond.bond_type`, `molecule.molecule_id`, `molecule.label`
Filters: `bond.molecule_id` = 'TR010', `molecule.molecule_id` = 'TR010'
Joins: None
Aggregations: COUNT(`bond.bond_type`)
Ordering: Order by count descending to find most frequent.
Limits: Limit 1 to find top bond type.

NL2SQL: ```sql
SELECT
  b.bond_type,
  m.label
FROM bond AS b
JOIN molecule AS m
  ON b.molecule_id = m.molecule_id
WHERE
  b.molecule_id = 'TR010'
GROUP BY
  b.bond_type,
  m.label
ORDER BY
  COUNT(b.bond_type) DESC
LIMIT 1;
```
Critic: ```sql
SELECT T1.bond_type, T2.label FROM bond AS T1 JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.molecule_id = "TR010" GROUP BY T1.bond_type ORDER BY count(*) DESC LIMIT 1
```
=====================
Question: Please list top three molecules that have single bonds between two atoms and are not carcinogenic in alphabetical order.
 db_id: toxicology
Planner: Plan:
1. Filter bonds table to get `bond_id`s of single bonds where `bond_type` is '-'.
2. Join the `connected` table with the filtered bonds table on `bond_id` to find atom pairs connected by single bonds.
3. Retrieve `molecule_id` from the `atom` table using `atom_id` in the `connected` table.
4. Filter the `molecule` table to select molecules where `label` is '-'.
5. Find the intersection of molecules with single bonds and molecules that are not carcinogenic.
6. Group the result by `molecule_id`, order by `molecule_id` in ascending order, and limit to the top 3.
7. Return the `molecule_id`.

NL2SQL: ```sql
SELECT T1.molecule_id FROM molecule AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.bond_type = '-' AND T1.label = '-' GROUP BY T1.molecule_id ORDER BY T1.molecule_id ASC LIMIT 3
```
Critic: ```sql
SELECT T1.molecule_id FROM molecule AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.bond_type = '-' AND T1.label = '-' GROUP BY T1.molecule_id ORDER BY T1.molecule_id ASC LIMIT 3
```
=====================
Question: How many bonds which involved atom 12 does molecule TR009 have?
 db_id: toxicology
Planner: Plan:
1. Filter the 'atom' table to find the molecule_id of the molecule labeled 'TR009'.
2. Filter the 'connected' table to find the bond_id that contains atom TR009_12 in atom_id or atom_id2.
3. Count the number of the 'bond_id' which involved atom 12 ('TR009_12') in molecule 'TR009'.
4. Return the count of such 'bond_id'.

NL2SQL: ```sql
SELECT
  COUNT(T1.bond_id)
FROM connected AS T1
INNER JOIN atom AS T2
  ON T1.atom_id = T2.atom_id
WHERE
  T2.molecule_id = 'TR009' AND (
    T1.atom_id = 'TR009_12' OR T1.atom_id2 = 'TR009_12'
  );
```
Critic: ```sql
SELECT
  COUNT(DISTINCT T1.bond_id)
FROM connected AS T1
WHERE
  T1.atom_id = 'TR009_12' OR T1.atom_id2 = 'TR009_12';
```
=====================
Question: What are the bond type and the atoms of the bond ID of TR001_6_9?
 db_id: toxicology
Planner: Plan:
1. Find the bond type from the `bond` table using the given bond ID.
2. Find the `atom_id` and `atom_id2` from the `connected` table using the given `bond_id`.
3. Retrieve the element for the `atom_id` and `atom_id2` from the `atom` table.
4. Return the bond type and the elements for `atom_id` and `atom_id2`.

Tables: `bond`, `connected`, `atom`
Columns:
- `bond`: `bond_id`, `bond_type`
- `connected`: `bond_id`, `atom_id`, `atom_id2`
- `atom`: `atom_id`, `element`

Joins:
- `bond` and `connected` on `bond.bond_id` = `connected.bond_id`
- `connected` and `atom` on `connected.atom_id` = `atom.atom_id`
- `connected` and `atom` on `connected.atom_id2` = `atom.atom_id`

Filters:
- `bond.bond_id` = 'TR001_6_9'

NL2SQL: ```sql
SELECT
  b.bond_type,
  a1.element,
  a2.element
FROM bond AS b
JOIN connected AS c
  ON b.bond_id = c.bond_id
JOIN atom AS a1
  ON c.atom_id = a1.atom_id
JOIN atom AS a2
  ON c.atom_id2 = a2.atom_id
WHERE
  b.bond_id = 'TR001_6_9';
```
Critic: ```sql
SELECT
  b.bond_type,
  a1.element,
  a2.element
FROM bond AS b
JOIN connected AS c
  ON b.bond_id = c.bond_id
JOIN atom AS a1
  ON c.atom_id = a1.atom_id
JOIN atom AS a2
  ON c.atom_id2 = a2.atom_id
WHERE
  b.bond_id = "TR001_6_9";
```
=====================
Question: How many connections does the atom 19 have?
 db_id: toxicology
Planner: Plan:
1. Find the `atom_id` corresponding to the atom 19. The `atom_id` is likely to be like 'TR%_19'.
2. Use the `connected` table to find all connections where `atom_id` or `atom_id2` equals to the `atom_id` found in step 1.
3. Count the number of connections.

Tables:
- connected

Columns:
- connected.atom_id
- connected.atom_id2

Filters:
- atom_id like '%_19' or atom_id2 like '%_19'

Aggregations:
- COUNT

NL2SQL: ```sql
SELECT count(*) FROM connected WHERE atom_id LIKE '%_19' OR atom_id2 LIKE '%_19'
```
Critic: ```sql
SELECT count(*) FROM connected WHERE atom_id = '19' OR atom_id2 = '19'
```
=====================
Question: List all the elements of the toxicology of the molecule "TR004".
 db_id: toxicology
Planner: Plan:
1. Filter the `molecule` table to find the `molecule_id` equal to "TR004".
2. Use the `molecule_id` to filter the `atom` table.
3. Select the `element` from the `atom` table.

NL2SQL: ```sql
SELECT
  element
FROM atom
WHERE
  molecule_id = 'TR004';
```
Critic: ```sql
SELECT
  T1.element
FROM atom AS T1
INNER JOIN molecule AS T2
  ON T1.molecule_id = T2.molecule_id
WHERE
  T2.molecule_id = "TR004";
```
=====================
Question: Among all the atoms from 21 to 25, list all the molecules that are carcinogenic.
 db_id: toxicology
Planner: Plan:
1. Filter the `atom` table to select atoms with `atom_id` in the range '21' to '25' (using `SUBSTR(atom_id, 7, 2)`).
2. Join the filtered `atom` table with the `molecule` table on `molecule_id`.
3. Filter the joined table to select molecules where `label` is '+'.
4. Select the `molecule_id` from the filtered table.
5. Return the `molecule_id`.

NL2SQL: ```sql
SELECT DISTINCT T1.molecule_id FROM atom AS T1 JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE SUBSTR(T1.atom_id, 7, 2) >= '21' AND SUBSTR(T1.atom_id, 7, 2) <= '25' AND T2.label = '+';
```
Critic: ```sql
SELECT DISTINCT T1.molecule_id FROM atom AS T1 JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE CAST(SUBSTR(T1.atom_id, 7, 2) AS INTEGER) BETWEEN 21 AND 25 AND T2.label = '+';
```
=====================
Question: What are the bonds that have phosphorus and nitrogen as their atom elements?
 db_id: toxicology
Planner: Plan:
1. Find the `bond_id` values where one atom is phosphorus ('P') and the other atom is nitrogen ('N'). This requires joining the `atom` and `connected` tables twice, once for each atom in the bond.
2. From the `atom` table, select `atom_id` where `element` = 'p'. From the `atom` table, select `atom_id` where `element` = 'n'.
3. Join the first selection to the `connected` table on `atom_id`. Join the second selection to the `connected` table on `atom_id2`. The `bond_id` is selected from the `connected` table.
4. Return the `bond_id` values found in the previous step.

NL2SQL: ```sql
SELECT
  T1.bond_id
FROM connected AS T1
INNER JOIN atom AS T2
  ON T1.atom_id = T2.atom_id
INNER JOIN atom AS T3
  ON T1.atom_id2 = T3.atom_id
WHERE
  T2.element = 'p' AND T3.element = 'n';
```
Critic: ```sql
SELECT
  T1.bond_id
FROM connected AS T1
INNER JOIN atom AS T2
  ON T1.atom_id = T2.atom_id
INNER JOIN atom AS T3
  ON T1.atom_id2 = T3.atom_id
WHERE
  T2.element = 'p' AND T3.element = 'n'
UNION
SELECT
  T1.bond_id
FROM connected AS T1
INNER JOIN atom AS T2
  ON T1.atom_id = T2.atom_id
INNER JOIN atom AS T3
  ON T1.atom_id2 = T3.atom_id
WHERE
  T2.element = 'n' AND T3.element = 'p';
```
=====================
Question: Is the molecule with the most double bonds carcinogenic?
 db_id: toxicology
Planner: Plan:
1. Count the number of double bonds for each molecule from the `bond` table, filtering for `bond_type` equal to '='.
2. Find the molecule with the maximum number of double bonds.
3. Check if the molecule with the maximum double bonds is carcinogenic using the `molecule` table, where `label` equals '+'.
4. Return true if the molecule with the most double bonds is carcinogenic, otherwise return false.
Tables: bond, molecule
Columns:
- bond: molecule_id, bond_type
- molecule: molecule_id, label
Joins: None
Filters:
- bond: bond_type = '='
- molecule: label = '+'
Aggregations: COUNT, MAX

NL2SQL: ```sql
SELECT
  CASE
    WHEN EXISTS(
      SELECT
        1
      FROM molecule
      WHERE
        molecule_id = (
          SELECT
            molecule_id
          FROM bond
          WHERE
            bond_type = '='
          GROUP BY
            molecule_id
          ORDER BY
            COUNT(*) DESC
          LIMIT 1
        )
        AND label = '+'
    )
    THEN TRUE
    ELSE FALSE
  END;
```
Critic: ```sql
SELECT
  CASE
    WHEN EXISTS(
      SELECT
        1
      FROM molecule AS T1
      INNER JOIN bond AS T2
        ON T1.molecule_id = T2.molecule_id
      WHERE
        T2.bond_type = '='
      GROUP BY
        T1.molecule_id
      ORDER BY
        COUNT(T2.bond_id) DESC
      LIMIT 1
    )
    THEN 'yes'
    ELSE 'no'
  END;
```
=====================
Question: What is the average number of bonds the atoms with the element iodine have?
 db_id: toxicology
Planner: Plan:
1. Filter the `atom` table to get the `atom_id` of atoms with `element` equal to 'i'.
2. Join the `connected` table with the filtered `atom` table on `atom_id` to find all bonds associated with iodine atoms.
3. Count the number of distinct `bond_id` associated with iodine atoms from the `connected` table. This represents the total number of bonds involving iodine atoms.
4. Count the number of iodine atoms.
5. Divide the total number of bonds involving iodine by the number of iodine atoms to get the average number of bonds per iodine atom.
6. Return the average number of bonds.

NL2SQL: ```sql
SELECT
  CAST(COUNT(DISTINCT T1.bond_id) AS REAL) / COUNT(DISTINCT T2.atom_id)
FROM connected AS T1
INNER JOIN atom AS T2
  ON T1.atom_id = T2.atom_id
WHERE
  T2.element = 'i';
```
Critic: ```sql
SELECT
  CAST(COUNT(T1.bond_id) AS REAL) / COUNT(T2.atom_id)
FROM connected AS T1
INNER JOIN atom AS T2
  ON T1.atom_id = T2.atom_id
WHERE
  T2.element = 'I';
```
=====================
Question: List all the elements of atoms that can not bond with any other atoms.
 db_id: toxicology
Planner: Plan:
1. Find all `atom_id`s in the `connected` table.
2. Find all `atom_id`s in the `atom` table.
3. Find the `atom_id`s present in the `atom` table but not in the `connected` table.
4. Retrieve the `element` for these `atom_id`s.
Tables: `atom`, `connected`
Columns: `atom`.`atom_id`, `atom`.`element`, `connected`.`atom_id`
Filters: `atom`.`atom_id` NOT IN (SELECT `atom_id` FROM `connected`)
Joins: None
Final select columns: `atom`.`element`

NL2SQL: ```sql
SELECT element FROM atom WHERE atom_id NOT IN (SELECT atom_id FROM connected)
```
Critic: ```sql
SELECT DISTINCT T1.element FROM atom AS T1 LEFT JOIN connected AS T2 ON T1.atom_id  =  T2.atom_id WHERE T2.atom_id IS NULL
```
=====================
Question: What are the atoms of the triple bond with the molecule "TR041"?
 db_id: toxicology
Planner: Plan:
1. Filter the `bond` table to find the `bond_id` where `molecule_id` is "TR041" and `bond_type` is "#" (triple bond).
2. Join the `connected` table with the filtered `bond` table on `bond_id` to find the `atom_id`s associated with the triple bonds.
3. Retrieve the `atom_id` from `connected` table.
4. Return the `atom_id` of the triple bonded atoms.

NL2SQL: ```sql
SELECT
  T1.atom_id
FROM connected AS T1
INNER JOIN bond AS T2
  ON T1.bond_id = T2.bond_id
WHERE
  T2.molecule_id = 'TR041' AND T2.bond_type = '#';
```
Critic: ```sql
SELECT
  T1.atom_id
FROM connected AS T1
INNER JOIN bond AS T2
  ON T1.bond_id = T2.bond_id
WHERE
  T2.molecule_id = 'TR041' AND T2.bond_type = '#';
```
=====================
Question: What are the elements of the atoms of TR144_8_19?
 db_id: toxicology
Planner: Plan:
1. Filter the `atom` table to find atoms with `molecule_id` equal to "TR144_8_19".
2. Select the `element` column from the filtered table.

NL2SQL: ```sql
SELECT element FROM atom WHERE molecule_id = "TR144_8_19"
```
Critic: ```sql
SELECT element FROM atom WHERE molecule_id = (SELECT molecule_id FROM bond WHERE bond_id = "TR144_8_19")
```
=====================
Question: List the elements of all the triple bonds.
 db_id: toxicology
Planner: Plan:
1. Filter the `bond` table to select only the bonds where `bond_type` is '#'.
2. Retrieve the `element` information from the `atom` table. Since the `bond` table does not contain atom or element information, we must connect it to the atom table by `molecule_id` through the `connected` table.
3. Join `bond` with `connected` table on `bond_id`.
4. Join `connected` table with `atom` table on `atom_id` and `molecule_id`.
5. Select the `element` column from the `atom` table and return the results.
6. Eliminate redundant results.

NL2SQL: ```sql
SELECT DISTINCT T1.element FROM atom AS T1 JOIN connected AS T2 ON T1.atom_id  =  T2.atom_id JOIN bond AS T3 ON T2.bond_id  =  T3.bond_id WHERE T3.bond_type  =  '#'
```
Critic: ```sql
SELECT DISTINCT T1.element FROM atom AS T1 JOIN connected AS T2 ON T1.atom_id = T2.atom_id JOIN bond AS T3 ON T2.bond_id = T3.bond_id WHERE T3.bond_type = '#'
```
=====================
Question: What proportion of single bonds are carcinogenic? Please provide your answer as a percentage with five decimal places.
 db_id: toxicology
Planner: Plan:
1. Filter the `bond` table to select only single bonds (bond_type = '-').
2. Join the filtered `bond` table with the `molecule` table using `molecule_id` to determine which single bonds belong to carcinogenic molecules (label = '+').
3. Count the total number of single bonds.
4. Count the number of carcinogenic single bonds.
5. Calculate the proportion of carcinogenic single bonds by dividing the number of carcinogenic single bonds by the total number of single bonds and multiplying by 100.
6. Format the proportion as a percentage with five decimal places.

Tables: bond, molecule
Columns: bond.bond_type, bond.molecule_id, molecule.molecule_id, molecule.label
Filters: bond.bond_type = '-', molecule.label = '+'
Joins: bond.molecule_id = molecule.molecule_id
Aggregations: COUNT, SUM
Calculations: proportion = (SUM(carcinogenic single bonds) / COUNT(single bonds)) * 100
Output: percentage with five decimal places

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T2.label = '+' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.bond_id)
FROM bond AS T1
INNER JOIN molecule AS T2
  ON T1.molecule_id = T2.molecule_id
WHERE
  T1.bond_type = '-';
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T2.label = '+' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.bond_id)
FROM bond AS T1
INNER JOIN molecule AS T2
  ON T1.molecule_id = T2.molecule_id
WHERE
  T1.bond_type = '-';
```
=====================
Question: Calculate the total atoms with triple-bond molecules containing the element phosphorus or bromine.
 db_id: toxicology
Planner: Plan:
1. Filter the `bond` table to select only triple bonds (bond_type = '#').
2. Join the filtered `bond` table with the `molecule` table using `molecule_id` to associate bonds with molecules.
3. Filter the `atom` table to select atoms containing phosphorus ('p') or bromine ('br').
4. Join the filtered `atom` table with the `molecule` table using `molecule_id` to associate atoms with molecules.
5. Find the intersection of the molecule ids obtained from the bond query and the atom query to get the molecules which have triple bonds and contain phosphorus or bromine atoms.
6. Count the total number of atoms in those molecules.
7. Return the total count of atoms.

NL2SQL: ```sql
SELECT
  SUM(CASE WHEN T1.element IN ('p', 'br') THEN 1 ELSE 0 END)
FROM atom AS T1
INNER JOIN molecule AS T2
  ON T1.molecule_id = T2.molecule_id
WHERE
  T2.molecule_id IN (
    SELECT
      T1.molecule_id
    FROM molecule AS T1
    INNER JOIN bond AS T2
      ON T1.molecule_id = T2.molecule_id
    WHERE
      T2.bond_type = '#'
  );
```
Critic: ```sql
SELECT
  SUM(CASE WHEN T1.element IN ('p', 'br') THEN 1 ELSE 0 END)
FROM atom AS T1
INNER JOIN molecule AS T2
  ON T1.molecule_id = T2.molecule_id
WHERE
  T2.molecule_id IN (
    SELECT
      molecule_id
    FROM bond
    WHERE
      bond_type = '#'
  );
```
=====================
Question: What is the composition of element chlorine in percentage among the single bond molecules?
 db_id: toxicology
Planner: Plan:
1. Filter the `bond` table to only include single bonds (`bond_type` = '-').
2. Get the `molecule_id` from the filtered `bond` table.
3. Filter the `atom` table to only include atoms that belong to the molecules identified in step 2.
4. Calculate the percentage of chlorine atoms among these molecules. This can be done by counting the number of chlorine atoms (`element` = 'Cl') and dividing it by the total number of atoms.
Tables:
- bond
- atom
Columns:
- bond.molecule_id
- bond.bond_type
- atom.molecule_id
- atom.element
Aggregations:
- COUNT(atom.atom_id)
- SUM(CASE WHEN atom.element = 'Cl' THEN 1 ELSE 0 END)
Filters:
- bond.bond_type = '-'
- atom.element = 'Cl'
Joins: Implicit join via molecule_id between bond and atom tables.
Calculations:
- SUM(CASE WHEN atom.element = 'Cl' THEN 1 ELSE 0 END) * 100.0 / COUNT(atom.atom_id)

NL2SQL: ```sql
SELECT CAST(SUM(CASE WHEN T1.element = 'Cl' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.atom_id) FROM atom AS T1 JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.bond_type = '-'
```
Critic: ```sql
SELECT CAST(SUM(CASE WHEN T1.element = 'Cl' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.atom_id) FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.bond_type = '-'
```
=====================
Question: What are the elements for bond id TR001_10_11?
 db_id: toxicology
Planner: Plan:
1. Find the atom_ids connected by bond TR001_10_11 from the `connected` table.
2. Using the atom_ids from step 1, retrieve the element for each atom from the `atom` table.

Tables: `connected`, `atom`
Columns:
*   `connected`: `atom_id`, `atom_id2`, `bond_id`
*   `atom`: `atom_id`, `element`

Join condition: `connected.atom_id` = `atom.atom_id` OR `connected.atom_id2` = `atom.atom_id`
Filter: `connected.bond_id` = 'TR001_10_11'
Output columns: `atom.element`

NL2SQL: ```sql
SELECT
  T1.element
FROM atom AS T1
INNER JOIN connected AS T2
  ON T1.atom_id = T2.atom_id
WHERE
  T2.bond_id = 'TR001_10_11'
UNION
SELECT
  T1.element
FROM atom AS T1
INNER JOIN connected AS T2
  ON T1.atom_id = T2.atom_id2
WHERE
  T2.bond_id = 'TR001_10_11';
```
Critic: ```sql
SELECT
  T1.element
FROM atom AS T1
INNER JOIN connected AS T2
  ON T1.atom_id = T2.atom_id
WHERE
  T2.bond_id = 'TR001_10_11'
UNION
SELECT
  T1.element
FROM atom AS T1
INNER JOIN connected AS T2
  ON T1.atom_id = T2.atom_id2
WHERE
  T2.bond_id = 'TR001_10_11';
```
=====================
Question: What is the percentage of element chlorine in carcinogenic molecules?
 db_id: toxicology
Planner: Plan:

1.  Find the molecule IDs of carcinogenic molecules from the `molecule` table where `label` is '+'.
2.  Find the total number of carcinogenic molecules.
3.  Find the number of chlorine atoms present in carcinogenic molecules using the `atom` table, joining with the carcinogenic molecule IDs obtained in step 1.
4.  Calculate the percentage of chlorine atoms in carcinogenic molecules by dividing the count of chlorine atoms by the total number of carcinogenic molecules found in step 2, and multiplying by 100.
5.  Return the calculated percentage.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.element = 'cl' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.molecule_id)
FROM atom AS T1
INNER JOIN molecule AS T2
  ON T1.molecule_id = T2.molecule_id
WHERE
  T2.label = '+';
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.element = 'Cl' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.molecule_id)
FROM atom AS T1
INNER JOIN molecule AS T2
  ON T1.molecule_id = T2.molecule_id
WHERE
  T2.label = '+';
```
=====================
Question: Tally the toxicology element of the 4th atom of each molecule that was carcinogenic.
 db_id: toxicology
Planner: Plan:
1. Filter the `molecule` table to only include carcinogenic molecules (where `label` is '+').
2. Filter the `atom` table to only include atoms that are the 4th atom in each molecule (where `substr(atom_id, 7, 1)` is '4').
3. Join the filtered `molecule` table with the filtered `atom` table on `molecule_id`.
4. Group the results by `element` and count the occurrences of each element.
5. Order the results by the count in descending order.
6. Return the `element` and its count.

Tables:
- molecule
- atom

Columns:
- molecule.molecule_id
- molecule.label
- atom.atom_id
- atom.molecule_id
- atom.element

Filters:
- molecule.label = '+'
- substr(atom.atom_id, 7, 1) = '4'

Joins:
- molecule.molecule_id = atom.molecule_id

Aggregate:
- COUNT(*) grouped by atom.element

NL2SQL: ```sql
SELECT element, COUNT(*) FROM molecule AS m JOIN atom AS a ON m.molecule_id = a.molecule_id WHERE m.label = '+' AND SUBSTR(a.atom_id, 7, 1) = '4' GROUP BY element
```
Critic: ```sql
SELECT element, COUNT(*) FROM molecule AS m JOIN atom AS a ON m.molecule_id = a.molecule_id WHERE m.label = '+' AND SUBSTR(a.atom_id, 7, 1) = '4' GROUP BY element
```
=====================
Question: What is the ratio of Hydrogen elements in molecule ID TR006? List the ratio with its label.
 db_id: toxicology
Planner: Plan:
1. Filter the `atom` table to get the atoms belonging to molecule ID 'TR006'.
2. Count the total number of atoms in molecule 'TR006'.
3. Count the number of Hydrogen atoms (element = 'H') in molecule 'TR006'.
4. Calculate the ratio of Hydrogen atoms to the total number of atoms.
5. Select the calculated ratio with the label 'ratio'.
Tables: atom
Columns: atom.molecule_id, atom.element
Filters: atom.molecule_id = 'TR006', atom.element = 'H'
Aggregations: COUNT(atom.element WHERE atom.element = 'H'), COUNT(atom.element)
Calculations: ratio = COUNT(atom.element WHERE atom.element = 'H') / COUNT(atom.element)
Final SELECT columns: ratio

NL2SQL: ```sql
SELECT CAST(SUM(CASE WHEN element = 'H' THEN 1 ELSE 0 END) AS REAL) / COUNT(element) AS ratio FROM atom WHERE molecule_id = 'TR006'
```
Critic: ```sql
SELECT CAST(SUM(CASE WHEN element = 'H' THEN 1 ELSE 0 END) AS REAL) / COUNT(*) AS ratio FROM atom WHERE molecule_id = 'TR006'
```
=====================
Question: Which non-carcinogenic molecules consisted more than 5 atoms?
 db_id: toxicology
Planner: Plan:
1. Filter the `molecule` table to find non-carcinogenic molecules (label = '-').
2. Join the filtered `molecule` table with the `atom` table on `molecule_id`.
3. Group the results by `molecule_id` and count the number of atoms for each molecule.
4. Filter the grouped results to include only molecules with more than 5 atoms.
5. Select the `molecule_id` of the molecules that satisfy the condition.

NL2SQL: ```sql
SELECT
  T1.molecule_id
FROM atom AS T1
INNER JOIN molecule AS T2
  ON T1.molecule_id = T2.molecule_id
WHERE
  T2.label = '-'
GROUP BY
  T1.molecule_id
HAVING
  COUNT(T1.molecule_id) > 5;
```
Critic: ```sql
SELECT
  T1.molecule_id
FROM atom AS T1
INNER JOIN molecule AS T2
  ON T1.molecule_id = T2.molecule_id
WHERE
  T2.label = '-'
GROUP BY
  T1.molecule_id
HAVING
  COUNT(T1.atom_id) > 5;
```
=====================
Question: How many schools with an average score in Math greater than 400 in the SAT test are exclusively virtual?
 db_id: california_schools
Planner: Here's a plan to determine the number of exclusively virtual schools with an average Math SAT score greater than 400:

1.  **Join `schools` and `satscores`:** Join the `schools` and `satscores` tables on a common key to combine school information with SAT scores. The `cds` column in `satscores` seems to correspond to `CDSCode` in `schools`. However, `CDSCode` in schools is text, and `cds` in satscores is text as well.
2.  **Filter for exclusively virtual schools:** Filter the joined table for schools where the `Virtual` column in the `schools` table is equal to 'Y'.
3.  **Filter for average Math score > 400:** Filter the joined table for schools where `AvgScrMath` in the `satscores` table is greater than 400.
4.  **Count the schools:** Count the number of distinct schools that satisfy both conditions.

The necessary tables are `schools` and `satscores`.
The columns needed are:
*   `schools.CDSCode`
*   `schools.Virtual`
*   `satscores.cds`
*   `satscores.AvgScrMath`

NL2SQL: ```sql
SELECT
  COUNT(T1.CDSCode)
FROM schools AS T1
INNER JOIN satscores AS T2
  ON T1.CDSCode = T2.cds
WHERE
  T1.Virtual = 'Y' AND T2.AvgScrMath > 400;
```
Critic: ```sql
SELECT
  COUNT(*)
FROM schools
WHERE
  Virtual = 'Y';
```
=====================
Question: Please list the codes of the schools with a total enrollment of over 500.
 db_id: california_schools
Planner: Plan:
1. Calculate the total enrollment for each school by summing 'Enrollment (K-12)' and 'Enrollment (Ages 5-17)' from the 'frpm' table.
2. Group the results by 'CDSCode' and calculate the sum of the total enrollment for each school.
3. Filter the results to include only schools where the total enrollment is greater than 500.
4. Select the 'CDSCode' for the schools that meet the criteria.

NL2SQL: ```sql
SELECT
  CDSCode
FROM frpm
GROUP BY
  CDSCode
HAVING
  SUM(`Enrollment (K-12)`) + SUM(`Enrollment (Ages 5-17)`) > 500;
```
Critic: ```sql
SELECT
  CDSCode
FROM frpm
GROUP BY
  CDSCode
HAVING
  SUM(`Enrollment (K-12)`) > 500;
```
=====================
Question: Among the schools with an SAT excellence rate of over 0.3, what is the highest eligible free rate for students aged 5-17?
 db_id: california_schools
Planner: 1.  **Calculate the SAT excellence rate:**
    *   Join the `satscores` and `schools` tables on the common column `CDS` (from `satscores`) and `CDSCode` (from `schools`). Since `CDSCode` in `schools` is text and `CDS` in `satscores` is also text, no conversion needed.
    *   Calculate the excellence rate as `NumGE1500` / `NumTstTakr`.

2.  **Filter schools based on the excellence rate:**
    *   Filter the results from step 1 to include only schools where the calculated excellence rate is greater than 0.3.

3.  **Find the corresponding eligible free rate for students aged 5-17:**
    *   Join the filtered table from step 2 with the `frpm` table using the `CDSCode` from `schools` and `CDSCode` from `frpm`.

4.  **Find the maximum eligible free rate:**
    *   Select the maximum value of the `Percent (%) Eligible Free (Ages 5-17)` column from the joined and filtered table.

NL2SQL: ```sql
SELECT
  MAX(T2."Percent (%) Eligible Free (Ages 5-17)")
FROM schools AS T1
INNER JOIN frpm AS T2
  ON T1.CDSCode = T2.CDSCode
INNER JOIN satscores AS T3
  ON T1.CDSCode = T3.cds
WHERE
  CAST(T3.NumGE1500 AS REAL) / T3.NumTstTakr > 0.3;
```
Critic: ```sql
SELECT
  MAX("Percent (%) Eligible Free (Ages 5-17)")
FROM frpm AS T1
INNER JOIN satscores AS T2
  ON T1.CDSCode = T2.cds
WHERE
  CAST(T2.NumGE1500 AS REAL) / T2.NumTstTakr > 0.3;
```
=====================
Question: Rank schools by their average score in Writing where the score is greater than 499, showing their charter numbers.
 db_id: california_schools
Planner: Plan:
1. Join the `satscores` and `schools` tables using a common key. The `satscores` table uses `sname` (school name) and `dname` (district name) while `schools` table uses `School` and `District`.

2.  Filter the results to include only schools where the average writing score (`AvgScrWrite`) is greater than 499.

3.  Select the school's `CharterNum` and calculate the average writing score.

4.  Rank the schools based on their average writing score in descending order.

NL2SQL: ```sql
SELECT
  s.CharterNum,
  AVG(sa.AvgScrWrite) AS average_writing_score
FROM schools AS s
JOIN satscores AS sa
  ON s.School = sa.sname AND s.District = sa.dname
WHERE
  sa.AvgScrWrite > 499
GROUP BY
  s.CharterNum
ORDER BY
  average_writing_score DESC;
```
Critic: ```sql
SELECT
  T1.CharterNum,
  AVG(T2.AvgScrWrite)
FROM schools AS T1
INNER JOIN satscores AS T2
  ON T1.School = T2.sname
WHERE
  T2.AvgScrWrite > 499
  AND T1.CharterNum IS NOT NULL
GROUP BY
  T1.CharterNum
ORDER BY
  AVG(T2.AvgScrWrite) DESC;
```
=====================
Question: List the names of schools with more than 30 difference in enrollements between K-12 and ages 5-17? Please also give the full street adress of the schools.
 db_id: california_schools
Planner: Plan:
1. Select the school name and full street address from the `schools` table.
2. Join the `schools` table with the `frpm` table using the `CDSCode` column. Since the `CDSCode` column is TEXT in schools table and INTEGER in the frpm table, we must convert them to same data type before joining.
3. Filter the results where the absolute difference between `Enrollment (K-12)` and `Enrollment (Ages 5-17)` in the `frpm` table is greater than 30.
4. Return the School and Street columns

NL2SQL: ```sql
SELECT
  s.School,
  s.Street
FROM schools AS s
JOIN frpm AS f
  ON CAST(s.CDSCode AS INTEGER) = f.CDSCode
WHERE
  ABS(f."Enrollment (K-12)" - f."Enrollment (Ages 5-17)") > 30;
```
Critic: ```sql
SELECT
  School,
  Street
FROM schools
WHERE
  CDSCode IN (
    SELECT
      CAST(CDSCode AS TEXT)
    FROM frpm
    WHERE
      ABS("Enrollment (K-12)" - "Enrollment (Ages 5-17)") > 30
  );
```
=====================
Question: Give the names of the schools with the percent eligible for free meals in K-12 is more than 0.1 and test takers whose test score is greater than or equal to 1500?
 db_id: california_schools
Planner: Plan:
1. Join the `schools` table with `frpm` table on `CDSCode` = `CDSCode`.
2. Join the result with the `satscores` table on `schools`.`School` = `satscores`.`sname`.
3. Filter results where `frpm`.`Percent (%) Eligible Free (K-12)` > 0.1.
4. Filter results where `satscores`.`NumGE1500` is greater than or equal to 1500.
5. Select the `School` column from the `schools` table.

NL2SQL: ```sql
SELECT
  T1.School
FROM schools AS T1
INNER JOIN frpm AS T2
  ON T1.CDSCode = T2.CDSCode
INNER JOIN satscores AS T3
  ON T1.School = T3.sname
WHERE
  T2."Percent (%) Eligible Free (K-12)" > 0.1 AND T3.NumGE1500 >= 1500;
```
Critic: ```sql
SELECT
  T1.School
FROM schools AS T1
INNER JOIN frpm AS T2
  ON T1.CDSCode = T2.CDSCode
INNER JOIN satscores AS T3
  ON T1.School = T3.sname
WHERE
  T2."Percent (%) Eligible Free (K-12)" > 0.1 AND T3.NumGE1500 >= 1;
```
=====================
Question: Name schools in Riverside which the average of average math score for SAT is grater than 400, what is the funding type of these schools?
 db_id: california_schools
Planner: 1.  Join `schools` and `satscores` tables on the condition that school name is the same.
2.  Filter schools by `City = "Riverside"` from `schools` table.
3.  Calculate the average of `AvgScrMath` and filter the schools where this average is greater than 400.
4.  Select the `School` and `FundingType` columns from the joined table.

NL2SQL: ```sql
SELECT
  T1.School,
  T1.FundingType
FROM schools AS T1
INNER JOIN satscores AS T2
  ON T1.School = T2.sname
WHERE
  T1.City = 'Riverside'
GROUP BY
  T1.School
HAVING
  AVG(T2.AvgScrMath) > 400;
```
Critic: ```sql
SELECT
  T1.School,
  T1.FundingType
FROM schools AS T1
INNER JOIN satscores AS T2
  ON T1.CDSCode = T2.cds
WHERE
  T1.City = 'Riverside'
GROUP BY
  T1.School,
  T1.FundingType
HAVING
  AVG(T2.AvgScrMath) > 400;
```
=====================
Question: State the names and full communication address of high schools in Monterey which has more than 800 free or reduced price meals for ages 15-17?
 db_id: california_schools
Planner: Plan:
1. Filter the `schools` table for schools located in Monterey County and the `SOCType` is high school.
2. Filter the `frpm` table to select the rows where the 'FRPM Count (Ages 5-17)' is greater than 800.
3. Join `schools` and `frpm` tables on `CDSCode` column.
4. Select the school name, street, city, state, and zip columns from the joined table.

NL2SQL: ```sql
SELECT
  s.School,
  s.Street,
  s.City,
  s.State,
  s.Zip
FROM schools AS s
JOIN frpm AS f
  ON s.CDSCode = f.CDSCode
WHERE
  s.County = 'Monterey'
  AND s.SOCType = 'High School'
  AND f."FRPM Count (Ages 5-17)" > 800;
```
Critic: ```sql
SELECT
  School,
  Street,
  City,
  State,
  Zip
FROM Schools
WHERE
  County = 'Monterey'
  AND SOCType = 'High School'
  AND CDSCode IN (
    SELECT
      CAST(CDSCode AS TEXT)
    FROM frpm
    WHERE
      "FRPM Count (Ages 5-17)" > 800
  );
```
=====================
Question: What is the average score in writing for the schools that were opened after 1991 or closed before 2000? List the school names along with the score. Also, list the communication number of the schools if there is any.
 db_id: california_schools
Planner: Here's my plan to answer the question:

1.  **Filter schools:** Select schools that were opened after 1991 OR closed before 2000 from the `schools` table.
2.  **Join tables:** Join the filtered `schools` table with the `satscores` table using a common column. Since `schools` does not have the exact same school identifier, we will use `School` column from `schools` and `sname` from `satscores`.
3.  **Select and aggregate:** Select the school names (`School`) from `schools`, the average writing scores (`AvgScrWrite`) from `satscores`, and the phone number (`Phone`) from `schools`. Calculate the average of the `AvgScrWrite` column.
4.  **Output:** Display the school name, average writing score, and the phone number.

NL2SQL: ```sql
SELECT
  s.School,
  AVG(sat.AvgScrWrite),
  s.Phone
FROM schools AS s
JOIN satscores AS sat
  ON s.School = sat.sname
WHERE
  s.OpenDate > '1991-12-31' OR s.ClosedDate < '2000-01-01'
GROUP BY
  s.School,
  s.Phone;
```
Critic: ```sql
SELECT
  T1.School,
  AVG(T2.AvgScrWrite),
  T1.Phone
FROM schools AS T1
INNER JOIN satscores AS T2
  ON T1.School = T2.sname
WHERE
  T1.OpenDate > '1991-12-31' OR T1.ClosedDate < '2000-01-01'
GROUP BY
  T1.School,
  T1.Phone;
```
=====================
Question: Consider the average difference between K-12 enrollment and 15-17 enrollment of schools that are locally funded, list the names and DOC type of schools which has a difference above this average.
 db_id: california_schools
Planner: Plan:
1. Calculate the average difference between 'Enrollment (K-12)' and 'Enrollment (Ages 5-17)' for schools that are locally funded using the 'frpm' table and 'schools' table. Join these tables on the condition `schools.CDScode = frpm.CDScode` and filter by `FundingType = 'Locally Funded'`.
2. Filter schools based on the average difference calculated in step 1.
3. Select the school name and District Ownership Code type ('DOCType') from the schools table for schools that meet the filter criteria.

SQL Generation:
```sql
SELECT
  T1.School,
  T1.DOCType
FROM schools AS T1
INNER JOIN frpm AS T2
  ON T1.CDSCode = T2.CDSCode
WHERE
  T2."Enrollment (K-12)" - T2."Enrollment (Ages 5-17)" > (
    SELECT
      AVG(T2."Enrollment (K-12)" - T2."Enrollment (Ages 5-17)")
    FROM schools AS T1
    INNER JOIN frpm AS T2
      ON T1.CDSCode = T2.CDSCode
    WHERE
      T1.FundingType = 'Locally Funded'
  );
```
NL2SQL: ```sql
SELECT
  T1.School,
  T1.DOCType
FROM schools AS T1
INNER JOIN frpm AS T2
  ON T1.CDSCode = T2.CDSCode
WHERE
  T1.FundingType = 'Locally Funded'
  AND T2."Enrollment (K-12)" - T2."Enrollment (Ages 5-17)" > (
    SELECT
      AVG(T2."Enrollment (K-12)" - T2."Enrollment (Ages 5-17)")
    FROM schools AS T1
    INNER JOIN frpm AS T2
      ON T1.CDSCode = T2.CDSCode
    WHERE
      T1.FundingType = 'Locally Funded'
  );
```
Critic: ```sql
SELECT
  T1.School,
  T1.DOCType
FROM schools AS T1
INNER JOIN frpm AS T2
  ON T1.CDSCode = T2.CDSCode
WHERE
  T1.FundingType = 'Locally Funded'
  AND T2."Enrollment (K-12)" - T2."Enrollment (Ages 5-17)" > (
    SELECT
      AVG("Enrollment (K-12)" - "Enrollment (Ages 5-17)")
    FROM frpm AS T2
    INNER JOIN schools AS T1
      ON T1.CDSCode = T2.CDSCode
    WHERE
      T1.FundingType = 'Locally Funded'
  );
```
=====================
Question: What is the eligible free rate of the 10th and 11th schools with the highest enrolment for students in grades 1 through 12?
 db_id: california_schools
Planner: Plan:
1. Join the `frpm` and `schools` tables using `CDSCode` from `frpm` and `CDSCode` from `schools` (after converting it to integer).
2. Filter the joined table to include only rows where `Low Grade` is 1 and `High Grade` is 12 (or `GSserved` contains '1-12' from the `schools` table).
3. Order the filtered table by `Enrollment (K-12)` in descending order.
4. Select `Percent (%) Eligible Free (K-12)`
5. Return the  `Percent (%) Eligible Free (K-12)` for the 10th and 11th schools. Since SQL doesn't directly support selecting nth row, use a subquery to achieve this.

NL2SQL: ```sql
SELECT `Percent (%) Eligible Free (K-12)` FROM (
SELECT `Percent (%) Eligible Free (K-12)`, `Enrollment (K-12)`, ROW_NUMBER() OVER (ORDER BY `Enrollment (K-12)` DESC) as rn
FROM frpm
WHERE `Low Grade` = '1' AND `High Grade` = '12') AS subquery
WHERE rn IN (10, 11);
```
Critic: ```sql
SELECT `Percent (%) Eligible Free (K-12)` FROM (SELECT `Percent (%) Eligible Free (K-12)`, `Enrollment (K-12)`, ROW_NUMBER() OVER (ORDER BY `Enrollment (K-12)` DESC) AS rn FROM frpm WHERE `Low Grade` <= '1' AND `High Grade` >= '12') AS t WHERE rn IN (10, 11)
```
=====================
Question: What is the eligible free or reduced price meal rate for the top 5 schools in grades 1-12 with the highest free or reduced price meal count of the schools with the ownership code 66?
 db_id: california_schools
Planner: 1.  Filter the `schools` table to select schools with `SOC` = 66.
2.  Join the filtered `schools` table with the `frpm` table using the `CDSCode`.
3.  Filter the joined table where `Low Grade` is 1 and `High Grade` is 12.
4.  Calculate the eligible free or reduced price meal rate (`FRPM Rate`) by dividing `FRPM Count (K-12)` by `Enrollment (K-12)`.
5.  Order the result by `FRPM Count (K-12)` in descending order.
6.  Select the top 5 schools based on `FRPM Count (K-12)`.
7.  Retrieve the `FRPM Rate` for the selected schools.

NL2SQL: ```sql
SELECT
  T1.`Percent (%) Eligible FRPM (K-12)`
FROM frpm AS T1
INNER JOIN schools AS T2
  ON T1.CDSCode = T2.CDSCode
WHERE
  T2.SOC = '66' AND T1.LowGrade = '1' AND T1.HighGrade = '12'
ORDER BY
  T1.`FRPM Count (K-12)` DESC
LIMIT 5;
```
Critic: ```sql
SELECT
  `Percent (%) Eligible FRPM (K-12)`
FROM frpm AS T1
INNER JOIN schools AS T2
  ON T1.CDSCode = T2.CDSCode
WHERE
  T2.SOC = '66'
ORDER BY
  T1.`FRPM Count (K-12)` DESC
LIMIT 5;
```
=====================
Question: What is the complete address of the school with the lowest excellence rate? Indicate the Street, City, Zip and State.
 db_id: california_schools
Planner: 1. Calculate the excellence rate for each school using the `satscores` table: `NumGE1500 / NumTstTakr`.
2. Find the minimum excellence rate across all schools.
3. Retrieve the school information (Street, City, Zip, State) from the `schools` table that matches the school having the minimum excellence rate from the `satscores` table.
4. Join `schools` and `satscores` table on school name.
5. Select the Street, City, Zip, and State columns from the `schools` table.

NL2SQL: ```sql
SELECT
  T1.Street,
  T1.City,
  T1.Zip,
  T1.State
FROM schools AS T1
INNER JOIN satscores AS T2
  ON T1.School = T2.sname
ORDER BY
  CAST(T2.NumGE1500 AS REAL) / T2.NumTstTakr
LIMIT 1;
```
Critic: ```sql
SELECT
  Street,
  City,
  Zip,
  State
FROM Schools
ORDER BY
  (
    SELECT
      CAST(NumGE1500 AS REAL) / NumTstTakr
    FROM satscores
    WHERE
      sname = School
  )
LIMIT 1;
```
=====================
Question: Under whose administration is the school with the highest number of students scoring 1500 or more on the SAT? Indicate their full names.
 db_id: california_schools
Planner: Plan:
1. Find the school with the highest `NumGE1500` from the `satscores` table.
2. Get the CDSCode of this school from the `satscores` table.
3. Join the `schools` table with the `satscores` table on the `CDSCode` to retrieve administrator names (`AdmfName1`, `AdmLname1`, `AdmfName2`, `AdmLname2`, `AdmfName3`, `AdmLname3`).
4. Concatenate the first and last names of administrators to get their full names.
5. Return the concatenated full names of the administrators.
6. Filter the returned results to not be null.

Final Answer:
```sql
SELECT DISTINCT
  CASE
    WHEN T1.AdmFName1 IS NOT NULL AND T1.AdmLName1 IS NOT NULL
    THEN T1.AdmFName1 || ' ' || T1.AdmLName1
    ELSE NULL
  END,
  CASE
    WHEN T1.AdmFName2 IS NOT NULL AND T1.AdmLName2 IS NOT NULL
    THEN T1.AdmFName2 || ' ' || T1.AdmLName2
    ELSE NULL
  END,
  CASE
    WHEN T1.AdmFName3 IS NOT NULL AND T1.AdmLName3 IS NOT NULL
    THEN T1.AdmFName3 || ' ' || T1.AdmLName3
    ELSE NULL
  END
FROM schools AS T1
INNER JOIN satscores AS T2
  ON T1.CDSCode = T2.cds
WHERE
  T2.NumGE1500 = (
    SELECT
      MAX(NumGE1500)
    FROM satscores
  );
```
NL2SQL: ```sql
SELECT DISTINCT
  T1.AdmFName1,
  T1.AdmLName1,
  T1.AdmFName2,
  T1.AdmLName2,
  T1.AdmFName3,
  T1.AdmLName3
FROM schools AS T1
INNER JOIN satscores AS T2
  ON T1.CDSCode = T2.cds
WHERE
  T2.NumGE1500 = (
    SELECT
      MAX(NumGE1500)
    FROM satscores
  );
```
Critic: ```sql
SELECT DISTINCT
  T1.AdmFName1,
  T1.AdmLName1
FROM schools AS T1
INNER JOIN satscores AS T2
  ON T1.CDSCode = T2.cds
WHERE
  T2.NumGE1500 = (
    SELECT
      MAX(NumGE1500)
    FROM satscores
  );
```
=====================
Question: What is the average number of test takers from Fresno schools that opened between 1/1/1980 and 12/31/1980?
 db_id: california_schools
Planner: 1. Filter the `schools` table to include only schools located in "Fresno" county and opened in 1980.
2. Join the filtered `schools` table with the `satscores` table using a join on `schools.School = satscores.sname`.
3. Calculate the average `NumTstTakr` from the joined table.
4. Return the calculated average.

NL2SQL: ```sql
SELECT
  AVG(T2.NumTstTakr)
FROM schools AS T1
INNER JOIN satscores AS T2
  ON T1.School = T2.sname
WHERE
  T1.County = 'Fresno'
  AND T1.OpenDate BETWEEN '1980-01-01' AND '1980-12-31';
```
Critic: ```sql
SELECT
  AVG(T1.NumTstTakr)
FROM satscores AS T1
INNER JOIN schools AS T2
  ON T1.sname = T2.School
WHERE
  T2.County = 'Fresno'
  AND T2.OpenDate BETWEEN '1980-01-01' AND '1980-12-31';
```
=====================
Question: What is the telephone number for the school with the lowest average score in reading in Fresno Unified?
 db_id: california_schools
Planner: 1. Filter `schools` table to find schools in the "Fresno Unified" district and store the `School` name and `Phone` number.
2. Filter `satscores` table for school average reading scores (`AvgScrRead`), and district name (`dname`) in "Fresno Unified" and store the school name(`sname`) and `AvgScrRead`.
3. Join the filtered `satscores` table with the filtered `schools` table on matching school name (`sname` = `School`).
4. Find the minimum `AvgScrRead` among the joined results.
5. Select the `Phone` number corresponding to the school with the minimum `AvgScrRead`.

NL2SQL: ```sql
SELECT
  T1.Phone
FROM schools AS T1
INNER JOIN satscores AS T2
  ON T1.School = T2.sname
WHERE
  T1.District = 'Fresno Unified'
ORDER BY
  T2.AvgScrRead
LIMIT 1;
```
Critic: ```sql
SELECT
  T1.Phone
FROM schools AS T1
INNER JOIN satscores AS T2
  ON T1.School = T2.sname
WHERE
  T1.District = 'Fresno Unified'
ORDER BY
  T2.AvgScrRead
LIMIT 1;
```
=====================
Question: List the names of virtual schools that are among the top 5 in their respective counties based on average reading scores.
 db_id: california_schools
Planner: Plan:
1. Join the `schools` and `satscores` tables on the appropriate school identifier (school name and county).
2. Filter for virtual schools (`schools.Virtual = 'Yes'`).
3. Calculate the rank of each school within its county based on `satscores.AvgScrRead` using a window function (PARTITION BY County ORDER BY AvgScrRead DESC).
4. Filter the results to include only schools with a rank less than or equal to 5.
5. Select the names of the schools that meet the criteria.

NL2SQL: ```sql
SELECT
  T1.School
FROM schools AS T1
INNER JOIN satscores AS T2
  ON T1.School = T2.sname AND T1.County = T2.cname
WHERE
  T1.Virtual = 'Yes'
  AND T1.County IN (
    SELECT
      T1.County
    FROM schools AS T1
    INNER JOIN satscores AS T2
      ON T1.School = T2.sname AND T1.County = T2.cname
    WHERE
      T1.Virtual = 'Yes'
    GROUP BY
      T1.County
    ORDER BY
      AVG(T2.AvgScrRead) DESC
    LIMIT 5
  )
GROUP BY
  T1.School
ORDER BY
  AVG(T2.AvgScrRead) DESC;
```
Critic: ```sql
SELECT
  s.School
FROM schools AS s
JOIN satscores AS sat
  ON s.School = sat.sname AND s.County = sat.cname
WHERE
  s.Virtual = 'Yes'
  AND s.School IN (
    SELECT
      s2.School
    FROM schools AS s2
    JOIN satscores AS sat2
      ON s2.School = sat2.sname AND s2.County = sat2.cname
    WHERE
      s2.Virtual = 'Yes'
    GROUP BY
      s2.County,
      s2.School
    HAVING
      RANK() OVER (PARTITION BY s2.County ORDER BY AVG(sat2.AvgScrRead) DESC) <= 5
  );
```
=====================
Question: What is the average writing score of each of the schools managed by Ricci Ulrich? List the schools and the corresponding average writing scores.
 db_id: california_schools
Planner: Plan:
1. Find the schools managed by Ricci Ulrich using the `schools` table. Filter the `schools` table where `AdmLName1` is 'Ulrich' and `AdmFName1` is 'Ricci'.
2. Join the filtered `schools` table with the `satscores` table using the school name to get the writing scores for those schools.
3. Calculate the average writing score for each school.
4. Select the school name and the average writing score.

NL2SQL: ```sql
SELECT
  T1.School,
  AVG(T2.AvgScrWrite)
FROM schools AS T1
INNER JOIN satscores AS T2
  ON T1.School = T2.sname
WHERE
  T1.AdmLName1 = 'Ulrich' AND T1.AdMFName1 = 'Ricci'
GROUP BY
  T1.School;
```
Critic: ```sql
SELECT
  T1.School,
  AVG(T2.AvgScrWrite)
FROM schools AS T1
INNER JOIN satscores AS T2
  ON T1.School = T2.SName
WHERE
  T1.AdmLName1 = 'Ulrich' AND T1.AdMFName1 = 'Ricci'
GROUP BY
  T1.School;
```
=====================
Question: Which state special schools have the highest number of enrollees from grades 1 through 12?
 db_id: california_schools
Planner: 1.  Find state special schools from the `schools` table based on the `DOC` (District Ownership Code). The description for State Special Schools is 31.
2.  Filter schools offering grades 1-12. Grades are found in the column `GSoffered` and `GSserved`.
3.  Join `schools` and `frpm` using `CDSCode` to get enrollment numbers (`Enrollment (K-12)`).
4.  Filter `frpm` table to consider only rows where `Low Grade` is 1 and `High Grade` is 12.
5.  Select the school name and sum of enrollment for each school.
6.  Group the results by school name and order by total enrollment in descending order.
7.  Limit the result to the school with the highest enrollment.

NL2SQL: ```sql
SELECT
  s.School,
  SUM(f."Enrollment (K-12)") AS total_enrollment
FROM schools AS s
JOIN frpm AS f
  ON s.CDSCode = f.CDSCode
WHERE
  s.DOC = '31' AND f."Low Grade" = '1' AND f."High Grade" = '12'
GROUP BY
  s.School
ORDER BY
  total_enrollment DESC
LIMIT 1;
```
Critic: ```sql
SELECT
  s.State,
  SUM(f."Enrollment (K-12)") AS total_enrollment
FROM schools AS s
JOIN frpm AS f
  ON s.CDSCode = f.CDSCode
WHERE
  s.SOCType = 'State Special Schools'
GROUP BY
  s.State
ORDER BY
  total_enrollment DESC
LIMIT 1;
```
=====================
Question: What is the monthly average number of schools that opened in Alameda County under the jurisdiction of the Elementary School District in 1980?
 db_id: california_schools
Planner: 1.  **Filter by County:** Filter the schools table for schools located in "Alameda County".
2.  **Filter by Open Date:** Filter the schools table to include only schools that opened in the year 1980.
3.  **Filter by District Type:** Filter the schools table for schools with 'Elementary School District' in their 'DOCType'.
4.  **Count Schools:** Count the number of schools that satisfy all the above conditions.
5.  **Calculate Monthly Average:** Divide the total count by 12 to get the monthly average.
6.  **Return Result:** Return the calculated monthly average.

Tables: `schools`

Columns:

*   `schools.County`
*   `schools.OpenDate`
*   `schools.DOCType`
NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN STRFTIME('%Y', OpenDate) = '1980' THEN 1 ELSE 0 END) AS REAL) / 12
FROM schools
WHERE
  County = 'Alameda County' AND DOCType = 'Elementary School District';
```
Critic: ```sql
SELECT
  CAST(COUNT(CASE WHEN STRFTIME('%Y', OpenDate) = '1980' THEN CDSCode ELSE NULL END) AS REAL) / 12
FROM schools
WHERE
  County = 'Alameda County' AND DOCType = 'Elementary School District';
```
=====================
Question: What is the ratio of merged Unified School District schools in Orange County to merged Elementary School District schools?
 db_id: california_schools
Planner: Plan:
1. Filter the `schools` table for schools in Orange County.
2. Count the number of schools where `StatusType` is "Merged" and `DOCType` is 'Unified School District'.
3. Count the number of schools where `StatusType` is "Merged" and `DOCType` is 'Elementary School District'.
4. Calculate the ratio of the two counts.
5. Return the ratio.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.DOCType = 'Unified School District' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN T1.DOCType = 'Elementary School District' THEN 1 ELSE 0 END)
FROM schools AS T1
WHERE
  T1.County = 'Orange' AND T1.StatusType = 'Merged';
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.DOCType = 'Unified School District' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN T1.DOCType = 'Elementary School District' THEN 1 ELSE 0 END)
FROM schools AS T1
WHERE
  T1.County = 'Orange'
  AND T1.StatusType = 'Active';
```
=====================
Question: What is the postal street address for the school with the 7th highest Math average? Indicate the school's name.
 db_id: california_schools
Planner: Plan:
1. Find the school with the 7th highest average Math score using the `satscores` table. Need to use a subquery to rank the schools by `AvgScrMath` and then filter for the 7th highest. Select the school name `sname` from this subquery.
2. Join the result of the subquery with the `schools` table using the school name `sname` from `satscores` and `School` from `schools`.
3. Select the `Street` (postal street address) and `School` (school name) from the `schools` table.

NL2SQL: ```sql
SELECT
  T1.Street,
  T1.School
FROM schools AS T1
INNER JOIN (
  SELECT
    sname
  FROM satscores
  ORDER BY
    AvgScrMath DESC
  LIMIT 1 OFFSET 6
) AS T2
  ON T1.School = T2.sname;
```
Critic: ```sql
SELECT
  Street,
  School
FROM schools
WHERE
  School IN (
    SELECT
      sname
    FROM satscores
    ORDER BY
      AvgScrMath DESC
    LIMIT 1 OFFSET 6
  );
```
=====================
Question: What is the total number of non-chartered schools in the county of Los Angeles with a percent (%) of eligible free meals for grades 1 through 12 that is less than 0.18%?
 db_id: california_schools
Planner: 1. Filter the `schools` table for schools located in the county of 'Los Angeles' and that are non-charter schools (Charter = 0).
2. Filter the `frpm` table for schools with a low grade of '1' and high grade of '12'. Also filter for percent eligible free less than 0.18.
3. Join the filtered `schools` table with the filtered `frpm` table on `schools`.`CDSCode` = `frpm`.`CDSCode`.
4. Count the number of schools after the join.
5. Return the count.

NL2SQL: ```sql
SELECT
  COUNT(T1.CDSCode)
FROM schools AS T1
INNER JOIN frpm AS T2
  ON T1.CDSCode = T2.CDSCode
WHERE
  T1.County = 'Los Angeles'
  AND T1.Charter = 0
  AND T2."Low Grade" = '1'
  AND T2."High Grade" = '12'
  AND T2."Percent (%) Eligible Free (K-12)" < 0.18;
```
Critic: ```sql
SELECT
  COUNT(T1.CDSCode)
FROM schools AS T1
INNER JOIN frpm AS T2
  ON T1.CDSCode = T2.CDSCode
WHERE
  T1.County = 'Los Angeles'
  AND T1.Charter = 0
  AND T2."Percent (%) Eligible Free (K-12)" < 0.18;
```
=====================
Question: How many students from the ages of 5 to 17 are enrolled at the State Special School school in Fremont for the 2014-2015 academic year?
 db_id: california_schools
Planner: 1. Filter the `schools` table to find schools where the `EdOpsName` is 'State Special School' and the `City` is 'Fremont'.
2. Filter the `frpm` table where `Academic Year` is 2014-2015 (2015).
3. Join the filtered `schools` table with the filtered `frpm` table on `CDSCode` from `schools` and `CDSCode` from `frpm`.
4. Select the sum of `Enrollment (Ages 5-17)` from the joined table to get the number of students from the ages of 5 to 17.

NL2SQL: ```sql
SELECT
  SUM(T1."Enrollment (Ages 5-17)")
FROM frpm AS T1
INNER JOIN schools AS T2
  ON T1.CDSCode = T2.CDSCode
WHERE
  T2.EdOpsCode = 'SSS' AND T2.City = 'Fremont' AND T1."Academic Year" = 2015;
```
Critic: ```sql
SELECT
  SUM(T1."Enrollment (Ages 5-17)")
FROM frpm AS T1
INNER JOIN schools AS T2
  ON T1.CDSCode = T2.CDSCode
WHERE
  T2.School = 'State Special School' AND T2.City = 'Fremont' AND T1."Academic Year" = 2015;
```
=====================
Question: Which schools served a grade span of Kindergarten to 9th grade in the county of Los Angeles and what is its Percent (%) Eligible FRPM (Ages 5-17)?
 db_id: california_schools
Planner: Plan:
1. Filter the `schools` table for schools in Los Angeles County.
2. Filter the `schools` table for schools with a grade span of Kindergarten to 9th grade (GSserved = 'K-9').
3. Join the filtered `schools` table with the `frpm` table on the `CDSCode`. Since CDSCode in schools table is text, but integer in frpm table. Use CAST.
4. Select the `Percent (%) Eligible FRPM (Ages 5-17)` from the `frpm` table.
5. Select the School from schools table.

NL2SQL: ```sql
SELECT
  t1.School,
  t2."Percent (%) Eligible FRPM (Ages 5-17)"
FROM schools AS t1
INNER JOIN frpm AS t2
  ON CAST(t1.CDSCode AS INTEGER) = t2.CDSCode
WHERE
  t1.County = 'Los Angeles' AND t1.GSserved = 'K-9';
```
Critic: ```sql
SELECT
  s.School,
  f."Percent (%) Eligible FRPM (Ages 5-17)"
FROM schools AS s
JOIN frpm AS f
  ON s.CDSCode = CAST(f.CDSCode AS TEXT)
WHERE
  s.County = 'Los Angeles' AND s.GSserved = 'K-9';
```
=====================
Question: Between San Diego and Santa Barbara, which county offers the most number of schools that does not offer physical building? Indicate the amount.
 db_id: california_schools
Planner: Plan:
1. Filter the `schools` table to include only schools where `Virtual` is 'Yes'.
2. Filter the schools to only include schools where County is either 'San Diego' or 'Santa Barbara'.
3. Group the filtered schools by `County` and count the number of schools in each county.
4. Order the results in descending order based on the count of schools.
5. Limit the result to the top 1 row to get the county with the most schools and its count.
6. Return the County and the count of the schools.

NL2SQL: ```sql
SELECT
  County,
  COUNT(*) AS num_schools
FROM schools
WHERE
  Virtual = 'Yes' AND County IN ('San Diego', 'Santa Barbara')
GROUP BY
  County
ORDER BY
  num_schools DESC
LIMIT 1;
```
Critic: ```sql
SELECT
  County,
  COUNT(*)
FROM schools
WHERE
  Virtual = 'Yes' AND County IN ('San Diego', 'Santa Barbara')
GROUP BY
  County
ORDER BY
  COUNT(*) DESC
LIMIT 1;
```
=====================
Question: What is the grade span offered in the school with the highest longitude?
 db_id: california_schools
Planner: 1. Find the school with the highest longitude from the `schools` table using `MAX(Longitude)`.
2. Retrieve the `GSoffered` (grade span offered) for that school.
3. Display the `GSoffered` value.

Tables: `schools`
Columns: `Longitude`, `GSoffered`
Filters: None
Joins: None
NL2SQL: ```sql
SELECT GSoffered FROM schools ORDER BY Longitude DESC LIMIT 1
```
Critic: ```sql
SELECT GSoffered FROM schools ORDER BY Longitude DESC LIMIT 1;
```
=====================
Question: Of the schools that offers a magnet program serving a grade span of Kindergarten to 8th grade, how many offers Multiple Provision Types? List the number of cities that offers a Kindergarten to 8th grade span and indicate how many schools are there serving such grade span for each city.
 db_id: california_schools
Planner: Here's the plan to answer the question:

**Part 1: Schools with Magnet Programs Serving Grades K-8 and Offering Multiple Provision Types**

1.  **Table:** `schools` and `frpm`
2.  **Filters:**
    *   `schools.Magnet = 1` (Magnet program)
    *   `frpm.Low Grade = 'KG'` and `frpm.High Grade = '8'` (Grade span K-8)
    *   `frpm.NSLP Provision Status = 'Multiple Provision Types'`
3.  **Joins:**
    *   Join `schools` and `frpm` on `schools.CDSCode = frpm.CDSCode`
4.  **Aggregation:**
    *   Count the number of schools that satisfy all the conditions.

**Part 2: Number of Cities with K-8 Grade Span and School Count per City**

1.  **Table:** `schools` and `frpm`
2.  **Filters:**
    *   `frpm.Low Grade = 'KG'` and `frpm.High Grade = '8'` (Grade span K-8)
3.  **Joins:**
    *   Join `schools` and `frpm` on `schools.CDSCode = frpm.CDSCode`
4.  **Aggregation:**
    *   Group by `schools.City` and count the number of schools in each city.
    *   Also, count the number of cities.

NL2SQL: ```sql
SELECT
  SUM(CASE WHEN T1.Magnet = 1 AND T2."NSLP Provision Status" = 'Multiple Provision Types' THEN 1 ELSE 0 END),
  T1.City,
  COUNT(T1.School)
FROM schools AS T1
INNER JOIN frpm AS T2
  ON T1.CDSCode = T2.CDSCode
WHERE
  T2."Low Grade" = 'KG' AND T2."High Grade" = '8'
GROUP BY
  T1.City;
```
Critic: ```sql
SELECT
  SUM(CASE WHEN T1.Magnet = 1 THEN 1 ELSE 0 END) AS num_magnet_schools_with_multiple_provision_types,
  T1.City,
  COUNT(T1.School) AS num_schools
FROM schools AS T1
INNER JOIN frpm AS T2
  ON T1.CDSCode = T2.CDSCode
WHERE
  T1.Magnet = 1 AND T2."NSLP Provision Status" = 'Multiple Provision Types' AND T2."Low Grade" = 'KG' AND T2."High Grade" = '8'
GROUP BY
  T1.City;
```
=====================
Question: What is the Percent (%) Eligible Free (K-12) in the school administered by an administrator whose first name is Alusine. List the district code of the school.
 db_id: california_schools
Planner: Here's the plan to get the required information:

1.  **Identify relevant tables:**
    *   `schools`: To filter by administrator's first name (`AdmFName1`) and retrieve the district code.
    *   `frpm`: To get the Percent (%) Eligible Free (K-12).

2.  **Join the tables:**
    *   Join `schools` and `frpm` tables using the `CDSCode` to connect schools with their free meal program data. Note that `CDSCode` is text in `schools` and integer in `frpm`, cast to correct the type.

3.  **Filter the data:**
    *   Filter `schools` table where `AdmFName1` is 'Alusine'.

4.  **Select the required columns:**
    *   Select the `District Code` from the `frpm` table.
    *   Select the `Percent (%) Eligible Free (K-12)` from the `frpm` table.

5. **Handle potential data issues**:
    * Cast CDSCode in schools to integer.
    * CDSCode in frpm is integer.

NL2SQL:
```sql
SELECT
  T2.`District Code`,
  T2.`Percent (%) Eligible Free (K-12)`
FROM schools AS T1
INNER JOIN frpm AS T2
  ON CAST(T1.CDSCode AS INTEGER) = T2.CDSCode
WHERE
  T1.AdmFName1 = 'Alusine';
```
NL2SQL: ```sql
SELECT
  T2.`District Code`,
  T2.`Percent (%) Eligible Free (K-12)`
FROM schools AS T1
INNER JOIN frpm AS T2
  ON CAST(T1.CDSCode AS INTEGER) = T2.CDSCode
WHERE
  T1.AdmFName1 = 'Alusine';
```
Critic: ```sql
SELECT
  T2.`District Code`,
  T2.`Percent (%) Eligible Free (K-12)`
FROM schools AS T1
INNER JOIN frpm AS T2
  ON T1.CDSCode = CAST(T2.CDSCode AS TEXT)
WHERE
  T1.AdmFName1 = 'Alusine';
```
=====================
Question: What are the valid e-mail addresses of the administrator of the school located in the San Bernardino county, City of San Bernardino City Unified that opened between 1/1/2009 to 12/31/2010 whose school types are public Intermediate/Middle Schools and Unified Schools?
 db_id: california_schools
Planner: Plan:
1. Filter the `schools` table by `County` = "San Bernardino", `City` = "San Bernardino City Unified", `OpenDate` between '2009-01-01' and '2010-12-31'.
2. Filter the `schools` table by `SOCType` = "Public Intermediate/Middle School" or `SOCType` = "Unified School".
3. Select the `AdmEmail1` column from the filtered table.

NL2SQL: ```sql
SELECT AdmEmail1
FROM schools
WHERE County = 'San Bernardino'
AND City = 'San Bernardino'
AND OpenDate BETWEEN '2009-01-01' AND '2010-12-31'
AND SOCType = 'Public Intermediate/Middle School'
UNION
SELECT AdmEmail1
FROM schools
WHERE County = 'San Bernardino'
AND City = 'San Bernardino'
AND OpenDate BETWEEN '2009-01-01' AND '2010-12-31'
AND DOCType = 'Unified School'
```
Critic: ```sql
SELECT AdmEmail1
FROM schools
WHERE County = 'San Bernardino'
AND District = 'San Bernardino City Unified'
AND OpenDate BETWEEN '2009-01-01' AND '2010-12-31'
AND (SOCType = 'Public Intermediate/Middle School' OR DOCType = 'Unified School')
```
=====================
Question: How many accounts who choose issuance after transaction are staying in East Bohemia region?
 db_id: financial
Planner: Here's my plan to figure out the number of accounts with 'issuance after transaction' staying in the 'East Bohemia' region:

1.  **Identify accounts with 'issuance after transaction':**
    *   Use the `trans` table.
    *   Filter by `operation` = 'POPLATEK PO OBRATU'.
    *   Get the `account_id` from these records.

2.  **Find the district of these accounts:**
    *   Use the `account` table.
    *   Join with the `trans` table on `account.account_id` = `trans.account_id`.
    *   Select the `district_id` from the `account` table.

3.  **Find the region of those districts:**
    *   Use the `district` table.
    *   Join with the `account` table on `district.district_id` = `account.district_id`.
    *   Filter by `district.A3` = 'East Bohemia'.

4.  **Count the accounts:**
    *   Count the distinct `account_id` after applying the above filters and joins.

I will use the tables `trans`, `account` and `district` to answer this question.
```nl2sql
SELECT count(DISTINCT T1.account_id) FROM account AS T1 JOIN district AS T2 ON T1.district_id = T2.district_id JOIN trans AS T3 ON T1.account_id = T3.account_id WHERE T2.A3 = "East Bohemia" AND T3.operation = "POPLATEK PO OBRATU"
```
NL2SQL: ```sql
SELECT count(DISTINCT T1.account_id) FROM account AS T1 JOIN district AS T2 ON T1.district_id = T2.district_id JOIN trans AS T3 ON T1.account_id = T3.account_id WHERE T2.A3 = "East Bohemia" AND T3.operation = "POPLATEK PO OBRATU"
```
Critic: ```sql
SELECT count(DISTINCT T1.account_id) FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN trans AS T3 ON T1.account_id = T3.account_id WHERE T2.A3 = "East Bohemia" AND T3.operation = "VKLAD"
```
=====================
Question: List out the no. of districts that have female average salary is more than 6000 but less than 10000?
 db_id: financial
Planner: Plan:
1. Join the `district` and `client` tables on `district_id`.
2. Filter the joined table for female clients (`gender` = 'F').
3. Filter the result further where average salary (A11) is between 6000 and 10000.
4. Count the distinct `district_id` values that satisfy the above conditions.

NL2SQL: ```sql
SELECT
  COUNT(DISTINCT T1.district_id)
FROM district AS T1
INNER JOIN client AS T2
  ON T1.district_id = T2.district_id
WHERE
  T2.gender = 'F' AND T1.A11 > 6000 AND T1.A11 < 10000;
```
Critic: ```sql
SELECT
  COUNT(DISTINCT T1.district_id)
FROM district AS T1
INNER JOIN client AS T2
  ON T1.district_id = T2.district_id
WHERE
  T2.gender = 'F' AND T1.A11 > 6000 AND T1.A11 < 10000;
```
=====================
Question: How many male customers who are living in North Bohemia have average salary greater than 8000?
 db_id: financial
Planner: Plan:
1. Filter the `client` table to select male customers (`gender` = 'M').
2. Join the filtered `client` table with the `district` table using `district_id`.
3. Filter the joined table to select districts located in North Bohemia (`A3` = 'North Bohemia').
4. Filter the resulting table to select customers with an average salary (`A11`) greater than 8000.
5. Count the number of customers that satisfy the conditions.
```sql
SELECT
  COUNT(T1.client_id)
FROM client AS T1
INNER JOIN district AS T2
  ON T1.district_id = T2.district_id
WHERE
  T1.gender = 'M' AND T2.A3 = 'North Bohemia' AND T2.A11 > 8000;
```
NL2SQL: ```sql
SELECT
  COUNT(T1.client_id)
FROM client AS T1
INNER JOIN district AS T2
  ON T1.district_id = T2.district_id
WHERE
  T1.gender = 'M' AND T2.A3 = 'North Bohemia' AND T2.A11 > 8000;
```
Critic: ```sql
SELECT
  COUNT(T1.client_id)
FROM client AS T1
INNER JOIN district AS T2
  ON T1.district_id = T2.district_id
WHERE
  T1.gender = 'M' AND T2.A3 = 'North Bohemia' AND T2.A11 > 8000;
```
=====================
Question: List out the account numbers of female clients who are oldest and has lowest average salary, calculate the gap between this lowest average salary with the highest average salary?
 db_id: financial
Planner: Here's the plan to address the question:

1.  **Identify Female Clients:** Use the `client` table and filter by `gender = 'F'`.
2.  **Determine the Oldest Female Client:** Find the maximum `birth_date` from the filtered female clients.
3.  **Find the Account IDs of the oldest female clients:** Find account_id where client id is the oldest female client.
4.  **Calculate Average Salary for Each District:** Use the `district` table to get `A11` (average salary) for each district.
5.  **Find the District ID for each account:** Use the `account` table to find the district id for each account.
6.  **Find the lowest average salary for oldest female clients:** combine the `client`, `account`, and `district` tables, filtering for female clients, oldest clients based on birth date and find the minimum `A11`.
7.  **Find the highest average salary for the districts:** Use the `district` table to determine the maximum average salary.
8.  **Calculate the Gap:** Subtract the lowest average salary from the highest average salary.
9.  **Output Account Numbers:** Output `account_id` found in step 3.

SQL query:
```sql
SELECT
  T3.account_id
FROM client AS T1
INNER JOIN disp AS T2
  ON T1.client_id = T2.client_id
INNER JOIN account AS T3
  ON T2.account_id = T3.account_id
INNER JOIN district AS T4
  ON T3.district_id = T4.district_id
WHERE
  T1.gender = 'F' AND T1.birth_date = (
    SELECT
      MIN(birth_date)
    FROM client
    WHERE
      gender = 'F'
  )
ORDER BY
  T4.A11
LIMIT 1;
```
NL2SQL: ```sql
SELECT
  MAX(T4.A11) - MIN(T4.A11)
FROM client AS T1
INNER JOIN disp AS T2
  ON T1.client_id = T2.client_id
INNER JOIN account AS T3
  ON T2.account_id = T3.account_id
INNER JOIN district AS T4
  ON T3.district_id = T4.district_id
WHERE
  T1.gender = 'F' AND T1.birth_date = (
    SELECT
      MIN(birth_date)
    FROM client
    WHERE
      gender = 'F'
  );
```
Critic: ```sql
SELECT
  T1.account_id
FROM account AS T1
INNER JOIN disp AS T2
  ON T1.account_id = T2.account_id
INNER JOIN client AS T3
  ON T2.client_id = T3.client_id
INNER JOIN district AS T4
  ON T1.district_id = T4.district_id
WHERE
  T3.gender = 'F'
ORDER BY
  T3.birth_date
LIMIT 1;
```
=====================
Question: List out the account numbers of clients who are youngest and have highest average salary?
 db_id: financial
Planner: Plan:
1. Find the youngest client's birthdate. We can do this by selecting the maximum birthdate from the `client` table.
2. Find the highest average salary from the `district` table.
3. Join `client` and `disp` tables on `client_id` to get the `account_id` for the youngest clients.
4. Join `account` and `district` on `district_id` to get the average salary for each account.
5. Filter the clients based on the youngest birthdate and the highest average salary.
6. Select the distinct `account_id`s.

```sql
SELECT DISTINCT T1.account_id FROM disp AS T1 JOIN client AS T2 ON T1.client_id = T2.client_id JOIN account AS T3 ON T1.account_id = T3.account_id JOIN district AS T4 ON T3.district_id = T4.district_id WHERE T2.birth_date = ( SELECT max(birth_date) FROM client ) AND T4.A11 = ( SELECT max(A11) FROM district )
```
NL2SQL: ```sql
SELECT DISTINCT T1.account_id FROM disp AS T1 JOIN client AS T2 ON T1.client_id = T2.client_id JOIN account AS T3 ON T1.account_id = T3.account_id JOIN district AS T4 ON T3.district_id = T4.district_id WHERE T2.birth_date = ( SELECT max(birth_date) FROM client ) AND T4.A11 = ( SELECT max(A11) FROM district )
```
Critic: ```sql
SELECT t1.account_id FROM disp AS t1 JOIN client AS t2 ON t1.client_id = t2.client_id JOIN account AS t3 ON t1.account_id = t3.account_id JOIN district AS t4 ON t3.district_id = t4.district_id WHERE t2.birth_date = (SELECT max(birth_date) FROM client) AND t4.A11 = (SELECT max(A11) FROM district)
```
=====================
Question: Among the accounts who have approved loan date in 1997, list out the accounts that have the lowest approved amount and choose weekly issuance statement.
 db_id: financial
Planner: Plan:
1. Filter `loan` table for loans approved in 1997. Extract `account_id` and `amount`.
2. Find the minimum `amount` from the filtered results.
3. Filter the `loan` table again to select `account_id` with the minimum `amount` from step 2 and approved in 1997.
4. From table `account` select `account_id` that has frequency equal to 'POPLATEK TYDNE'.
5. Finally, select the `account_id` that exists in both result set 3 and 4.

Tables:
- loan
- account

Columns:
- loan.account_id
- loan.date
- loan.amount
- account.account_id
- account.frequency

NL2SQL: ```sql
SELECT DISTINCT T1.account_id FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE T2.frequency = 'POPLATEK TYDNE' AND T1.date LIKE '1997%' AND T1.amount = (SELECT min(amount) FROM loan WHERE date LIKE '1997%');
```
Critic: ```sql
SELECT T1.account_id FROM account AS T1 INNER JOIN loan AS T2 ON T1.account_id = T2.account_id WHERE T2.date LIKE '1997%' AND T1.frequency = 'POPLATEK TYDNE' ORDER BY T2.amount ASC LIMIT 1
```
=====================
Question: Among the accounts who have loan validity more than 12 months, list out the accounts that have the highest approved amount and have account opening date in 1993.
 db_id: financial
Planner: 1. Join `loan` and `account` tables on `account_id`.
2. Filter the joined table to include only records where `duration` > 12 and the year of `account.date` is 1993.
3. Order the filtered table by `amount` in descending order.
4. Select the `account_id` from the ordered table.

NL2SQL: ```sql
SELECT
  T1.account_id
FROM account AS T1
INNER JOIN loan AS T2
  ON T1.account_id = T2.account_id
WHERE
  T2.duration > 12 AND STRFTIME('%Y', T1.date) = '1993'
ORDER BY
  T2.amount DESC;
```
Critic: ```sql
SELECT
  T1.account_id
FROM account AS T1
INNER JOIN loan AS T2
  ON T1.account_id = T2.account_id
WHERE
  T2.duration > 12 AND STRFTIME('%Y', T1.date) = '1993'
ORDER BY
  T2.amount DESC
LIMIT 1;
```
=====================
Question: Among the account opened, how many female customers who were born before 1950 and stayed in Sokolov?
 db_id: financial
Planner: Plan:
1. Join the `client` table with the `district` table on `district_id` to filter for clients from Sokolov.
2. Filter the clients to include only those with gender 'F' and birth dates before 1950.
3. Join the filtered `client` table with the `disp` table on `client_id`.
4. Join the `disp` table with the `account` table on `account_id`.
5. Count the distinct `account_id` values to find the number of accounts that satisfy the conditions.

NL2SQL: ```sql
SELECT
  COUNT(DISTINCT T1.account_id)
FROM account AS T1
INNER JOIN disp AS T2
  ON T1.account_id = T2.account_id
INNER JOIN client AS T3
  ON T2.client_id = T3.client_id
INNER JOIN district AS T4
  ON T3.district_id = T4.district_id
WHERE
  T3.gender = 'F' AND T4.A2 = 'Sokolov' AND T3.birth_date < '1950-01-01';
```
Critic: ```sql
SELECT
  COUNT(DISTINCT T1.account_id)
FROM account AS T1
INNER JOIN disp AS T2
  ON T1.account_id = T2.account_id
INNER JOIN client AS T3
  ON T2.client_id = T3.client_id
INNER JOIN district AS T4
  ON T1.district_id = T4.district_id
WHERE
  T3.gender = 'F' AND T4.A2 = 'Sokolov' AND T3.birth_date < '1950-01-01';
```
=====================
Question: For the female client who was born in 1976/1/29, which district did she opened her account?
 db_id: financial
Planner: 1.  Find the `client_id` of the female client who was born on '1976-01-29' from the `client` table. Filter by `gender` = 'F' and `birth_date` = '1976-01-29'.
2.  Find the `account_id` associated with this `client_id` from the `disp` table. Filter by `type` = 'OWNER'.
3.  Find the `district_id` associated with these `account_id` from the `account` table.
4.  Find the district name (A2) from the `district` table using the `district_id`.

SQL plan:

1.  Join `client` and `disp` on `client.client_id` = `disp.client_id`.
2.  Join `disp` and `account` on `disp.account_id` = `account.account_id`.
3.  Join `account` and `district` on `account.district_id` = `district.district_id`.
4.  Filter by `client.gender` = 'F', `client.birth_date` = '1976-01-29' and `disp.type` = 'OWNER'.
5.  Select `district.A2`.

NL2SQL: ```sql
SELECT
  T1.A2
FROM district AS T1
INNER JOIN account AS T2
  ON T1.district_id = T2.district_id
INNER JOIN disp AS T3
  ON T2.account_id = T3.account_id
INNER JOIN client AS T4
  ON T3.client_id = T4.client_id
WHERE
  T4.gender = 'F' AND T4.birth_date = '1976-01-29';
```
Critic: ```sql
SELECT
  T1.A2
FROM district AS T1
INNER JOIN account AS T2
  ON T1.district_id = T2.district_id
INNER JOIN disp AS T3
  ON T2.account_id = T3.account_id
INNER JOIN client AS T4
  ON T3.client_id = T4.client_id
WHERE
  T4.gender = 'F' AND T4.birth_date = '1976-01-29';
```
=====================
Question: For the branch which located in the south Bohemia with biggest number of inhabitants, what is the percentage of the male clients?
 db_id: financial
Planner: Here's my plan to determine the percentage of male clients in the South Bohemia branch with the most inhabitants:

1. **Identify the district in South Bohemia with the most inhabitants:**
   - Filter the `district` table to find districts located in South Bohemia (`A3 = 'south Bohemia'`).
   - Order the filtered districts by the number of inhabitants (`A4`) in descending order.
   - Select the `district_id` of the district with the highest number of inhabitants.

2. **Find all clients in that district:**
   - Filter the `client` table by the `district_id` obtained in step 1.

3. **Calculate the total number of clients in that district:**
   - Count the number of clients from step 2.

4. **Calculate the number of male clients in that district:**
   - Filter the clients from step 2 where `gender = 'M'`.
   - Count the number of male clients.

5. **Calculate the percentage of male clients:**
   - Divide the number of male clients (step 4) by the total number of clients (step 3) and multiply by 100.
   - Round the result to a reasonable number of decimal places.

Now, let's convert this plan into SQL.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.gender = 'M' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.client_id)
FROM client AS T1
JOIN district AS T2
  ON T1.district_id = T2.district_id
WHERE
  T2.A3 = 'south Bohemia'
ORDER BY
  T2.A4 DESC
LIMIT 1;
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.gender = 'M' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.client_id)
FROM client AS T1
JOIN district AS T2
  ON T1.district_id = T2.district_id
WHERE
  T2.A3 = 'south Bohemia'
ORDER BY
  T2.A4 DESC
LIMIT 1;
```
=====================
Question: For the client whose loan was approved first in 1993/7/5, what is the increase rate of his/her account balance from 1993/3/22 to 1998/12/27?
 db_id: financial
Planner: Here's the plan to calculate the account balance increase rate:

1.  **Find the client with the first loan approval in 1993/7/5:**
    *   Use the `loan` table.
    *   Filter for `date` = '1993-07-05'.
    *   Get the `account_id` associated with this loan.
    *   Join with `disp` table using `account_id` to find `client_id`. Since there could be multiple clients associate with the account, we should pick one (e.g., `type` = 'OWNER').

2.  **Find the account balance for the identified client on 1993/3/22:**
    *   Use the `trans` table.
    *   Filter by `account_id` from step 1.
    *   Filter by `date` = '1993-03-22'.
    *   Select the `balance`. Since we are looking for balance on a specific date, we need to find the transaction on that date, and select the `balance` column from that transaction.

3.  **Find the account balance for the identified client on 1998/12/27:**
    *   Use the `trans` table.
    *   Filter by `account_id` from step 1.
    *   Filter by `date` = '1998-12-27'.
    *   Select the `balance`. Since we are looking for balance on a specific date, we need to find the transaction on that date, and select the `balance` column from that transaction.

4.  **Calculate the increase rate:**
    *   `Increase Rate = ((Balance on 1998/12/27 - Balance on 1993/3/22) / Balance on 1993/3/22) * 100`

**Tables needed:** `loan`, `trans`, `disp`

**Columns needed:**
*   `loan`: `date`, `account_id`
*   `trans`: `account_id`, `date`, `balance`
*   `disp`: `account_id`, `client_id`, `type`

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T2.date = '1998-12-27' THEN T2.balance ELSE 0 END) - SUM(CASE WHEN T2.date = '1993-03-22' THEN T2.balance ELSE 0 END) AS REAL) * 100 / SUM(CASE WHEN T2.date = '1993-03-22' THEN T2.balance ELSE 1 END)
FROM loan AS T1
INNER JOIN trans AS T2
  ON T1.account_id = T2.account_id
INNER JOIN disp AS T3
  ON T2.account_id = T3.account_id
WHERE
  T1.date = '1993-07-05'
  AND T3.type = 'OWNER';
```
Critic: ```sql
SELECT
  CAST(
    (
      SUM(CASE WHEN T2.date = '1998-12-27' THEN T2.balance ELSE 0 END) - SUM(CASE WHEN T2.date = '1993-03-22' THEN T2.balance ELSE 0 END)
    ) AS REAL
  ) * 100 / SUM(CASE WHEN T2.date = '1993-03-22' THEN T2.balance ELSE 1 END)
FROM loan AS T1
INNER JOIN trans AS T2
  ON T1.account_id = T2.account_id
WHERE
  T1.loan_id = (
    SELECT
      loan_id
    FROM loan
    ORDER BY
      date
    LIMIT 1
  );
```
=====================
Question: What is the percentage of loan amount that has been fully paid with no issue.
 db_id: financial
Planner: Plan:
1. Calculate the total loan amount.
2. Calculate the total loan amount where the loan status is 'A' (contract finished, no problems).
3. Calculate the percentage of the loan amount that has been fully paid with no issue by dividing the result of step 2 by the result of step 1 and multiplying by 100.
4. Rename the result column to "percentage".
Tables needed: loan
Columns needed: amount, status
Filters: status = 'A'
Aggregations: SUM, COUNT
Calculations: percentage = (SUM(amount where status = 'A') / SUM(amount)) * 100
NL2SQL: ```sql
SELECT CAST(SUM(CASE WHEN status = 'A' THEN amount ELSE 0 END) AS REAL) * 100 / SUM(amount) AS percentage FROM loan
```
Critic: ```sql
SELECT CAST(SUM(CASE WHEN status = 'A' THEN amount ELSE 0 END) AS REAL) * 100 / SUM(amount) FROM loan
```
=====================
Question: For loan amount less than USD100,000, what is the percentage of accounts that is still running with no issue.
 db_id: financial
Planner: Plan:
1. Filter the `loan` table to include only loans with an amount less than 100000.
2. Count the total number of loans that meet the condition in step 1.
3. Filter the `loan` table to include loans with amount less than 100000 AND status equal to 'C'.
4. Count the number of loans that meet both conditions (amount < 100000 and status = 'C').
5. Calculate the percentage by dividing the count from step 4 by the count from step 2 and multiplying by 100.
6. Select the calculated percentage.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN status = 'C' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*)
FROM loan
WHERE
  amount < 100000;
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN status = 'C' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*)
FROM loan
WHERE
  amount < 100000;
```
=====================
Question: For loans contracts which are still running where client are in debt, list the district of the and the state the percentage unemployment rate increment from year 1995 to 1996.
 db_id: financial
Planner: 1.  **Filter loans:** Filter the `loan` table to select loans with `status` equal to 'D'.
2.  **Join loan and account:** Join the filtered `loan` table with the `account` table on `account_id`.
3.  **Join account and district:** Join the result with the `district` table on `district_id`.
4.  **Select and calculate:** Select the `A2` column (district name), and calculate the percentage increase in unemployment rate from 1995 to 1996 using the formula: `((A13 - A12) / A12) * 100`.
5. **Display results:** Show the district name and the calculated percentage unemployment rate increment.

NL2SQL: ```sql
SELECT
  T1.A2,
  ((
    T1.A13 - T1.A12
  ) / T1.A12) * 100
FROM district AS T1
INNER JOIN account AS T2
  ON T1.district_id = T2.district_id
INNER JOIN loan AS T3
  ON T2.account_id = T3.account_id
WHERE
  T3.status = 'D';
```
Critic: ```sql
SELECT
  d.A2,
  d.A3,
  (
    (
      d.A13 - d.A12
    ) / d.A12
  ) * 100 AS unemployment_rate_increment
FROM district AS d
INNER JOIN client AS c
  ON d.district_id = c.district_id
INNER JOIN loan AS l
  ON c.client_id = l.account_id
WHERE
  l.status = 'D';
```
=====================
Question: List the top nine districts, by descending order, from the highest to the lowest, the number of female account holders.
 db_id: financial
Planner: Plan:
1. Join `client` and `district` tables on `district_id` to link client information with district information.
2. Filter `client` table to include only female clients (gender = 'F').
3. Group the results by district name (A2) and count the number of female clients in each district.
4. Order the results in descending order based on the count of female clients.
5. Limit the results to the top nine districts.
6. Return the district name and the count of female clients in that district.

NL2SQL: ```sql
SELECT
  d.A2,
  COUNT(c.client_id) AS female_count
FROM client AS c
JOIN district AS d
  ON c.district_id = d.district_id
WHERE
  c.gender = 'F'
GROUP BY
  d.A2
ORDER BY
  female_count DESC
LIMIT 9;
```
Critic: ```sql
SELECT
  d.A2,
  COUNT(c.client_id) AS num_female_clients
FROM client AS c
JOIN district AS d
  ON c.district_id = d.district_id
WHERE
  c.gender = 'F'
GROUP BY
  d.A2
ORDER BY
  num_female_clients DESC
LIMIT 9;
```
=====================
Question: Between 1/1/1995 and 12/31/1997, how many loans in the amount of at least 250,000 per account that chose monthly statement issuance were approved?
 db_id: financial
Planner: 1.  **Filter loans by date:** Select loans approved between '1995-01-01' and '1997-12-31'.
2.  **Filter loans by amount:** Select loans with an amount of at least 250,000.
3.  **Join loan and account tables:** Join the `loan` and `account` tables on `account_id`.
4.  **Filter accounts by statement issuance frequency:** Filter the joined table to include only accounts with `frequency = 'POPLATEK MESICNE'` (monthly statement issuance).
5.  **Count the loans:** Count the number of loans that satisfy all the conditions.

NL2SQL: ```sql
SELECT
  COUNT(T1.loan_id)
FROM loan AS T1
INNER JOIN account AS T2
  ON T1.account_id = T2.account_id
WHERE
  T1.date BETWEEN '1995-01-01' AND '1997-12-31'
  AND T1.amount >= 250000
  AND T2.frequency = 'POPLATEK MESICNE';
```
Critic: ```sql
SELECT
  COUNT(loan_id)
FROM loan AS T1
INNER JOIN account AS T2
  ON T1.account_id = T2.account_id
WHERE
  T1.date BETWEEN '1995-01-01' AND '1997-12-31'
  AND T1.amount >= 250000
  AND T2.frequency = 'POPLATEK MESICNE';
```
=====================
Question: How many accounts have running contracts in Branch location 1?
 db_id: financial
Planner: 1. Find the `district_id` that corresponds to "Branch location 1". This is because the question specifies location by branch ID. In the provided table information, location is represented by district_id. It isn't clear how to infer which `district_id` corresponds to "Branch location 1" without a table mapping branch location names to their district id. Let us assume it corresponds to `district_id = 1`.
2. Filter `account` table by `district_id = 1`.
3. Join `account` and `loan` tables on `account_id`.
4. Filter `loan` table by `status = 'C'` (running contracts).
5. Count the distinct `account_id` from the joined and filtered table.

NL2SQL: ```sql
SELECT
  COUNT(DISTINCT T1.account_id)
FROM account AS T1
INNER JOIN loan AS T2
  ON T1.account_id = T2.account_id
WHERE
  T1.district_id = 1 AND T2.status = 'C';
```
Critic: ```sql
SELECT
  COUNT(DISTINCT T1.account_id)
FROM account AS T1
INNER JOIN loan AS T2
  ON T1.account_id = T2.account_id
WHERE
  T1.district_id = 1 AND T2.status = 'C' OR T2.status = 'D';
```
=====================
Question: In the branch where the second-highest number of crimes were committed in 1995 occurred, how many male clients are there?
 db_id: financial
Planner: Here's a plan to answer the question using SQL:

1.  **Find the second-highest number of crimes in 1995:**
    *   Use the `district` table.
    *   Find the distinct values of `A15` (number of committed crimes in 1995).
    *   Order these values in descending order and limit to the second value.

2.  **Find the district(s) with the second-highest number of crimes in 1995:**
    *   Use the `district` table.
    *   Filter the table where `A15` equals the second-highest number of crimes found in step 1.
    *   Get the `district_id` for these districts.

3.  **Find male clients in the district(s) identified in step 2:**
    *   Use the `client` table.
    *   Filter the table where `gender` is 'M' and `district_id` is in the list of `district_id`s found in step 2.
    *   Count the number of clients that satisfy the filter.

NL2SQL:
```sql
SELECT
  COUNT(CASE WHEN T1.gender = 'M' THEN T1.client_id ELSE NULL END)
FROM client AS T1
INNER JOIN district AS T2
  ON T1.district_id = T2.district_id
WHERE
  T2.A15 = (
    SELECT
      MAX(A15)
    FROM district
    WHERE
      A15 < (
        SELECT
          MAX(A15)
        FROM district
      )
  );
```
NL2SQL: ```sql
SELECT
  COUNT(T1.client_id)
FROM client AS T1
INNER JOIN district AS T2
  ON T1.district_id = T2.district_id
WHERE
  T2.A15 = (
    SELECT
      A15
    FROM district
    ORDER BY
      A15 DESC
    LIMIT 1 OFFSET 1
  )
  AND T1.gender = 'M';
```
Critic: ```sql
SELECT
  COUNT(T1.client_id)
FROM client AS T1
INNER JOIN district AS T2
  ON T1.district_id = T2.district_id
WHERE
  T2.district_id = (
    SELECT
      district_id
    FROM district
    ORDER BY
      A15 DESC
    LIMIT 1 OFFSET 1
  )
  AND T1.gender = 'M';
```
=====================
Question: Which are the top ten withdrawals (non-credit card) by district names for the month of January 1996?
 db_id: financial
Planner: 1.  **Filter Transactions:** Select transaction records that represent withdrawals ('VYDAJ') and occurred in January 1996 (date LIKE '1996-01%').
2.  **Join with Account and District:** Join the filtered transaction records with the `account` table using `account_id` to get the `district_id`. Then, join the `district` table using `district_id` to get the `district_name` (A2).
3.  **Group by District Name:** Group the results by `district_name`.
4.  **Calculate Total Withdrawal Amount:** Calculate the sum of withdrawal amounts for each district.
5.  **Order and Limit:** Order the results in descending order of total withdrawal amount and select the top 10 districts.
6.  **Output:** Display the `district_name` and the total withdrawal amount.

NL2SQL: ```sql
SELECT
  d.A2,
  SUM(t.amount) AS total_withdrawal_amount
FROM trans AS t
JOIN account AS a
  ON t.account_id = a.account_id
JOIN district AS d
  ON a.district_id = d.district_id
WHERE
  t.type = 'VYDAJ' AND t.date LIKE '1996-01%'
GROUP BY
  d.A2
ORDER BY
  total_withdrawal_amount DESC
LIMIT 10;
```
Critic: ```sql
SELECT
  D.A2,
  SUM(T.amount) AS total_withdrawal_amount
FROM trans AS T
JOIN account AS A
  ON T.account_id = A.account_id
JOIN district AS D
  ON A.district_id = D.district_id
WHERE
  T.type = 'VYDAJ' AND STRFTIME('%Y-%m', T.date) = '1996-01'
GROUP BY
  D.A2
ORDER BY
  total_withdrawal_amount DESC
LIMIT 10;
```
=====================
Question: How many accounts have running contracts in Branch location 1?
 db_id: financial
Planner: 1. Filter the `loan` table for loans with `status` equal to 'C' or 'D' (running contracts).
2. Join the filtered `loan` table with the `account` table using `account_id`.
3. Filter the joined table for accounts where the `district_id` is 1.
4. Count the distinct `account_id` from the resulting table. This gives the number of accounts with running contracts in branch location 1.

NL2SQL: ```sql
SELECT
  COUNT(DISTINCT T1.account_id)
FROM account AS T1
INNER JOIN loan AS T2
  ON T1.account_id = T2.account_id
WHERE
  T1.district_id = 1 AND (
    T2.status = 'C' OR T2.status = 'D'
  );
```
Critic: ```sql
SELECT
  COUNT(DISTINCT T1.account_id)
FROM account AS T1
INNER JOIN loan AS T2
  ON T1.account_id = T2.account_id
WHERE
  T1.district_id = 1 AND T2.status = 'C';
```
=====================
Question: In the branch where the second-highest number of crimes were committed in 1995 occurred, how many male clients are there?
 db_id: financial
Planner: 1. Find the district with the second highest number of crimes in 1995 using the `district` table.
2. Get the `district_id` of that district.
3. Join the `client` table with the `district` table using `district_id`.
4. Filter for clients where gender is male ('M').
5. Count the number of such male clients.

NL2SQL: ```sql
SELECT
  COUNT(T1.client_id)
FROM client AS T1
INNER JOIN district AS T2
  ON T1.district_id = T2.district_id
WHERE
  T1.gender = 'M' AND T2.district_id = (
    SELECT
      district_id
    FROM district
    ORDER BY
      A15 DESC
    LIMIT 1 OFFSET 1
  );
```
Critic: ```sql
SELECT
  COUNT(T1.client_id)
FROM client AS T1
INNER JOIN district AS T2
  ON T1.district_id = T2.district_id
WHERE
  T1.gender = 'M' AND T2.district_id = (
    SELECT
      district_id
    FROM district
    ORDER BY
      A15 DESC
    LIMIT 1 OFFSET 1
  );
```
=====================
Question: Who are the account holder identification numbers whose who have transactions on the credit card with the amount is less than the average, in 1998?
 db_id: financial
Planner: Here's the plan to determine the account holder identification numbers with credit card transactions below the average amount in 1998:

1.  **Calculate the average transaction amount for credit card transactions in 1998:**
    *   Use the `trans` table.
    *   Filter for transactions where the `operation` column indicates a credit card withdrawal ('VYBER KARTOU').
    *   Filter for transactions in the year 1998 (using the `date` column).
    *   Calculate the average `amount` for these transactions.

2.  **Find the account IDs with credit card transactions below the calculated average in 1998:**
    *   Use the `trans` table again.
    *   Filter for credit card transactions in 1998 as before.
    *   Filter for transactions where the `amount` is less than the average calculated in step 1.
    *   Select the distinct `account_id` values.

3.  **Find the client IDs (account holder identification numbers) associated with the selected account IDs:**
    *   Use the `disp` table to link `account_id` with `client_id`.
    *   Filter for rows where the `account_id` matches the `account_id` values obtained in step 2.
    *   Select the distinct `client_id` values.

Tables needed: `trans`, `disp`
Columns needed: `trans.date`, `trans.amount`, `trans.operation`, `disp.account_id`, `disp.client_id`
Filters: Credit card transactions in 1998, transaction amount less than average.
Joins: `trans` and `disp` on `account_id`.
Aggregations: Average transaction amount.
Final SELECT: Distinct `client_id`.

NL2SQL: ```sql
SELECT DISTINCT T2.client_id FROM trans AS T1 JOIN disp AS T2 ON T1.account_id = T2.account_id WHERE T1.operation = 'VYBER KARTOU' AND CAST(strftime('%Y', T1.date) AS INTEGER) = 1998 AND T1.amount < (SELECT avg(amount) FROM trans WHERE operation = 'VYBER KARTOU' AND CAST(strftime('%Y', date) AS INTEGER) = 1998)
```
Critic: ```sql
SELECT DISTINCT T2.client_id FROM trans AS T1 JOIN disp AS T2 ON T1.account_id = T2.account_id WHERE strftime('%Y', T1.date) = '1998' AND T1.amount < (SELECT avg(amount) FROM trans WHERE strftime('%Y', date) = '1998')
```
=====================
Question: Please list the account types that are not eligible for loans, and the average income of residents in the district where the account is located exceeds $8000 but is no more than $9000.
 db_id: financial
Planner: Here's my plan to answer the question:

1.  **Identify loan-ineligible account types:** Determine the account types which are NOT 'OWNER' from the `disp` table.
2.  **Filter districts by average income:** Filter the `district` table to find districts where `A11` (average salary) is greater than 8000 and less than or equal to 9000.
3.  **Join tables:** Join the `disp` table and `account` table on `account_id` to connect account types to accounts. Then join with `district` table on `district_id` to associate the account to districts matching income criteria.
4.  **Select distinct account types:**  Retrieve the distinct account types that meet both criteria.
I will select the `type` column from the `disp` table to get the type of account.
I will use `account`, `disp` and `district` tables.
```nl2sql
SELECT DISTINCT T1.type FROM disp AS T1 JOIN account AS T2 ON T1.account_id = T2.account_id JOIN district AS T3 ON T2.district_id = T3.district_id WHERE T3.A11 > 8000 AND T3.A11 <= 9000 AND T1.type != "OWNER"
```
NL2SQL: ```sql
SELECT DISTINCT T1.frequency FROM account AS T1 JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T2.A11 > 8000 AND T2.A11 <= 9000
```
Critic: ```sql
SELECT DISTINCT frequency FROM account AS T1 JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T2.A11 > 8000 AND T2.A11 <= 9000 AND T1.account_id NOT IN (SELECT T3.account_id FROM disp AS T3 WHERE T3.type = 'OWNER')
```
=====================
Question: What is the average number of crimes committed in 1995 in regions where the number exceeds 4000 and the region has accounts that are opened starting from the year 1997?
 db_id: financial
Planner: Here's a plan to answer the question:

1.  **Identify relevant tables:** `district` and `account`.
2.  **Filter `district` table:** Filter the `district` table for records where `A15` (no. of committed crimes 1995) is greater than 4000.
3.  **Filter `account` table:** Filter the `account` table for records where the account opening year (from the `date` column) is greater than or equal to 1997.
4.  **Join `district` and `account` tables:** Join the filtered `district` and `account` tables using the `district_id` column.
5.  **Calculate the average:** Calculate the average of `A15` (no. of committed crimes 1995) for the joined results.

NL2SQL: ```sql
SELECT avg(T1.A15)
FROM district AS T1
JOIN account AS T2 ON T1.district_id = T2.district_id
WHERE
  T1.A15 > 4000 AND strftime('%Y', T2.date) >= '1997';
```
Critic: ```sql
SELECT
  AVG(A15)
FROM district
WHERE
  A15 > 4000
  AND district_id IN (
    SELECT
      district_id
    FROM account
    WHERE
      CAST(strftime('%Y', date) AS INTEGER) >= 1997
  );
```
=====================
Question: List all the withdrawals in cash transactions that the client with the id 3356 makes.
 db_id: financial
Planner: Plan:
1. Filter the `trans` table to include only withdrawal in cash transactions (`operation` = 'VYBER').
2. Filter the `disp` table to include only records where `client_id` is 3356.
3. Join `trans` table with `disp` table on `account_id` to find the transactions associated with the client with id 3356.
4. Select `trans_id` from the joined table.

NL2SQL: ```sql
SELECT
  T.trans_id
FROM trans AS T
JOIN disp AS D
  ON T.account_id = D.account_id
WHERE
  D.client_id = 3356 AND T.operation = 'VYBER';
```
Critic: ```sql
SELECT
  T.trans_id
FROM trans AS T
JOIN disp AS D
  ON T.account_id = D.account_id
WHERE
  D.client_id = 3356 AND T.operation = 'VYBER' AND T.type = 'withdrawal';
```
=====================
Question: What percentage of clients who opened their accounts in the district with an average salary of over 10000 are women?
 db_id: financial
Planner: Here's the plan to determine the percentage of female clients who opened their accounts in districts with an average salary over 10000:

1.  **Identify districts with average salary over 10000:** Filter the `district` table for `A11` (average salary) > 10000.
2.  **Find accounts in those districts:** Join the filtered `district` table with the `account` table on `district_id`.
3.  **Identify clients associated with those accounts:** Join the `account` table with the `disp` table on `account_id`, and then join the `disp` table with the `client` table on `client_id`.
4.  **Filter for female clients:** Filter the resulting table for `gender` = 'F' in the `client` table.
5.  **Calculate the total number of clients in those districts:** Count the number of distinct client IDs from step 3, before filtering on gender.
6.  **Calculate the number of female clients:** Count the number of distinct client IDs from step 4.
7.  **Calculate the percentage:** Divide the number of female clients (step 6) by the total number of clients (step 5) and multiply by 100.
NL2SQL:
```sql
SELECT
  CAST(SUM(CASE WHEN T1.gender = 'F' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.client_id)
FROM client AS T1
INNER JOIN disp AS T2
  ON T1.client_id = T2.client_id
INNER JOIN account AS T3
  ON T2.account_id = T3.account_id
INNER JOIN district AS T4
  ON T3.district_id = T4.district_id
WHERE
  T4.A11 > 10000;
```
NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.gender = 'F' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.client_id)
FROM client AS T1
INNER JOIN disp AS T2
  ON T1.client_id = T2.client_id
INNER JOIN account AS T3
  ON T2.account_id = T3.account_id
INNER JOIN district AS T4
  ON T3.district_id = T4.district_id
WHERE
  T4.A11 > 10000;
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.gender = 'F' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.client_id)
FROM client AS T1
INNER JOIN account AS T2
  ON T1.client_id = T2.district_id
INNER JOIN district AS T3
  ON T2.district_id = T3.district_id
WHERE
  T3.A11 > 10000;
```
=====================
Question: What was the growth rate of the total amount of loans across all accounts for a male client between 1996 and 1997?
 db_id: financial
Planner: Here's a plan to calculate the loan growth rate:

1. **Identify male clients:** Filter the `client` table for `gender = 'M'`.
2. **Find loans associated with those clients:** Join the `loan` table with the `account` and `disp` tables to connect loans to clients. Use `account.account_id = loan.account_id` and `disp.account_id = account.account_id` and `disp.client_id = client.client_id`.
3. **Filter loans by year:**  Extract the year from the `date` column in the `loan` table. Separate the loans taken in 1996 and 1997.
4. **Calculate total loan amount for each year:** Calculate the sum of the `amount` column in the `loan` table for both 1996 and 1997.
5. **Calculate the growth rate:** Apply the formula: `((total_loan_amount_1997 - total_loan_amount_1996) / total_loan_amount_1996) * 100`.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN STRFTIME('%Y', T1.date) = '1997' THEN T1.amount ELSE 0 END) - SUM(CASE WHEN STRFTIME('%Y', T1.date) = '1996' THEN T1.amount ELSE 0 END) AS REAL) * 100 / SUM(CASE WHEN STRFTIME('%Y', T1.date) = '1996' THEN T1.amount ELSE 0 END)
FROM loan AS T1
INNER JOIN account AS T2
  ON T1.account_id = T2.account_id
INNER JOIN disp AS T3
  ON T2.account_id = T3.account_id
INNER JOIN client AS T4
  ON T3.client_id = T4.client_id
WHERE
  T4.gender = 'M';
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN STRFTIME('%Y', T1.date) = '1997' THEN T1.amount ELSE 0 END) - SUM(CASE WHEN STRFTIME('%Y', T1.date) = '1996' THEN T1.amount ELSE 0 END) AS REAL) * 100 / SUM(CASE WHEN STRFTIME('%Y', T1.date) = '1996' THEN T1.amount ELSE 0 END)
FROM loan AS T1
INNER JOIN disp AS T2
  ON T1.account_id = T2.account_id
INNER JOIN client AS T3
  ON T2.client_id = T3.client_id
WHERE
  T3.gender = 'M';
```
=====================
Question: How often does account number 3 request an account statement to be released? What was the aim of debiting 3539 in total?
 db_id: financial
Planner: Here's a plan to answer the question using SQL:

1.  **Find the number of account statement requests:**
    *   Table: `trans`
    *   Filter: `account_id` = 3 and `operation` = 'VYDAJ' and `k_symbol` = 'POPLATEK'

2.  **Find the purpose of debiting 3539 in total:**
    *   Table: `trans`
    *   Filter: `amount` = 3539 and `type`='VYDAJ' and `account_id` = 3
    *   Column: `k_symbol`

NL2SQL:
```sql
SELECT
  COUNT(CASE WHEN T1.operation = 'VYDAJ' AND T1.k_symbol = 'POPLATEK' THEN T1.trans_id ELSE NULL END),
  T1.k_symbol
FROM trans AS T1
WHERE
  T1.account_id = 3 AND T1.amount = 3539
GROUP BY
  T1.k_symbol;
```
NL2SQL: ```sql
SELECT
  SUM(CASE WHEN operation = 'VYDAJ' AND k_symbol = 'POPLATEK' THEN 1 ELSE 0 END),
  k_symbol
FROM trans
WHERE
  account_id = 3 AND amount = 3539;
```
Critic: ```sql
SELECT
  COUNT(CASE WHEN operation = 'VYDAJ' AND k_symbol = 'SIPO' THEN 1 ELSE NULL END),
  k_symbol
FROM trans
WHERE
  account_id = 3 AND amount = 3539;
```
=====================
Question: What percentage of male clients request for weekly statements to be issued?
 db_id: financial
Planner: Plan:
1. Find the total number of male clients. This involves selecting from the `client` table where `gender` is 'M'.
2. Find the number of clients who requested weekly statements. This involves identifying clients whose accounts have the 'POPLATEK TYDNE' frequency in the `account` table. To link clients and accounts, we join `client` and `disp` using `client_id`, then join `disp` and `account` using `account_id`.
3. Find the number of male clients who requested weekly statements.  This is the intersection of the sets from steps 1 and 2.
4. Calculate the percentage: (number of male clients requesting weekly statements / total number of male clients) * 100.
Columns needed:
- `client.client_id`, `client.gender`
- `account.account_id`, `account.frequency`
- `disp.client_id`, `disp.account_id`

Tables needed:
- `client`
- `account`
- `disp`

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.gender = 'M' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.client_id)
FROM client AS T1
INNER JOIN disp AS T2
  ON T1.client_id = T2.client_id
INNER JOIN account AS T3
  ON T2.account_id = T3.account_id
WHERE
  T3.frequency = 'POPLATEK TYDNE'
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.gender = 'M' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.client_id)
FROM client AS T1
INNER JOIN disp AS T2
  ON T1.client_id = T2.client_id
INNER JOIN account AS T3
  ON T2.account_id = T3.account_id
WHERE
  T3.frequency = 'POPLATEK TYDENNE'
```
=====================
Question: Name the account numbers of female clients who are oldest and have lowest average salary?
 db_id: financial
Planner: Plan:
1. Find the oldest female clients. This requires filtering `client` table by `gender = 'F'` and finding the maximum `birth_date`.
2. Calculate the average salary for each client using the `trans` table. Group by `account_id` and calculate the average amount.
3. Join the `client` table with the aggregated transaction data on `client_id` via `disp` and `account` to link clients to their accounts and average salaries.
4. Filter the joined table for female clients.
5. Order the result by birth date descending and average salary ascending, and select the account numbers of the oldest with the lowest average salary.
6. Return the `account_id`.

NL2SQL: ```sql
SELECT t1.account_id FROM account AS t1 JOIN disp AS t2 ON t1.account_id = t2.account_id JOIN client AS t3 ON t2.client_id = t3.client_id JOIN district AS t4 ON t1.district_id = t4.district_id WHERE t3.gender = 'F' ORDER BY t3.birth_date ASC, t4.A11 ASC
```
Critic: ```sql
SELECT t1.account_id FROM account AS t1 JOIN disp AS t2 ON t1.account_id = t2.account_id JOIN client AS t3 ON t2.client_id = t3.client_id JOIN district AS t4 ON t1.district_id = t4.district_id WHERE t3.gender = 'F' ORDER BY t3.birth_date ASC, t4.A11 ASC LIMIT 1
```
=====================
Question: What is the average amount of loan which are still on running contract with statement issuance after each transaction?
 db_id: financial
Planner: Plan:
1. Filter `loan` table for loans with `status` equal to 'C' (running contract).
2. Filter `trans` table for transactions with `operation` equal to 'POPLATEK PO OBRATU' (issuance after transaction).
3. Calculate the average amount of these loans from step 1.

Tables:
- loan
- trans

Columns:
- loan.amount
- loan.status
- trans.operation

NL2SQL: ```sql
SELECT avg(amount) FROM loan WHERE status = 'C';
```
Critic: ```sql
SELECT AVG(amount) FROM loan WHERE status = 'C';
```
=====================
Question: Provide the IDs and age of the client with high level credit card, which is eligible for loans.
 db_id: financial
Planner: 1. Join `client` and `disp` on `client_id` to link clients to their account dispositions.
2. Join the result with `card` on `disp_id` to filter for high-level credit cards ('gold').
3. Filter `disp` table for `type = 'OWNER'` to identify clients eligible for loans.
4. Select the `client_id` and calculate the age using `birth_date`.

NL2SQL: ```sql
SELECT
  T1.client_id,
  SUBSTR(T1.birth_date, 1, 4)
FROM client AS T1
JOIN disp AS T2
  ON T1.client_id = T2.client_id
JOIN card AS T3
  ON T2.disp_id = T3.disp_id
WHERE
  T3.type = 'gold' AND T2.type = 'OWNER';
```
Critic: ```sql
SELECT
  T1.client_id,
  CAST(SUBSTR(T1.birth_date, 1, 4) AS INTEGER)
FROM client AS T1
INNER JOIN disp AS T2
  ON T1.client_id = T2.client_id
INNER JOIN card AS T3
  ON T2.disp_id = T3.disp_id
WHERE
  T3.type = 'gold' AND T2.type = 'OWNER';
```
=====================
Question: What is the ratio of customers who pay in EUR against customers who pay in CZK?
 db_id: debit_card_specializing
Planner: Plan:
1.  Count the number of customers who pay in EUR.
2.  Count the number of customers who pay in CZK.
3.  Calculate the ratio of EUR customers to CZK customers.

Tables: customers
Columns: Currency
Filters: Currency = 'EUR', Currency = 'CZK'
Aggregations: COUNT
Calculations: Ratio

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN Currency = 'EUR' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN Currency = 'CZK' THEN 1 ELSE 0 END)
FROM Customers;
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN Currency = 'EUR' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN Currency = 'CZK' THEN 1 ELSE 0 END)
FROM customers;
```
=====================
Question: In 2012, who had the least consumption in LAM?
 db_id: debit_card_specializing
Planner: Plan:
1. Filter the `yearmonth` table for the year 2012.  We can achieve this by filtering the `Date` column in `yearmonth` table
2. Filter `gasstations` table by country = LAM.
3. Join the filtered `yearmonth` table with the `gasstations` table using `CustomerID` from `yearmonth` and `GasStationID` from `transactions_1k`.
4. Find the minimum consumption among the results.
5. Find the `CustomerID` with the minimum consumption.
6. Retrieve the information of the customer with the `CustomerID` that we found.

The tables involved are `yearmonth`, `transactions_1k`, and `gasstations`.
The columns needed are `CustomerID` and `Consumption` from `yearmonth`, `GasStationID` from `transactions_1k`, and `Country` from `gasstations`.

NL2SQL: ```sql
SELECT
  T1.CustomerID
FROM yearmonth AS T1
INNER JOIN transactions_1k AS T2
  ON T1.CustomerID = T2.CustomerID
INNER JOIN gasstations AS T3
  ON T2.GasStationID = T3.GasStationID
WHERE
  SUBSTR(T1.Date, 1, 4) = '2012' AND T3.Country = 'LAM'
ORDER BY
  T1.Consumption
LIMIT 1;
```
Critic: ```sql
SELECT
  CustomerID
FROM yearmonth
WHERE
  SUBSTR(Date, 1, 4) = '2012'
ORDER BY
  Consumption
LIMIT 1;
```
=====================
Question: What was the average monthly consumption of customers in SME for the year 2013?
 db_id: debit_card_specializing
Planner: Plan:
1. Filter the `customers` table to select customers in the 'SME' segment.
2. Filter the `yearmonth` table for the year 2013. We can extract the year from the 'Date' column.
3. Join the filtered `customers` table with the filtered `yearmonth` table on `CustomerID`.
4. Calculate the average monthly consumption by averaging the 'Consumption' values from the joined table and dividing by 12.
5. Output the calculated average monthly consumption.

Tables: `customers`, `yearmonth`
Filters:
* `customers`: `Segment` = 'SME'
* `yearmonth`: year of `Date` = 2013
Joins: `customers.CustomerID` = `yearmonth.CustomerID`
Columns: `yearmonth.Consumption`
Aggregate Function: AVG(Consumption) / 12

NL2SQL: ```sql
SELECT AVG(T2.Consumption) / 12 FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'SME' AND substr(T2.Date, 1, 4) = '2013'
```
Critic: ```sql
SELECT avg(Consumption) FROM yearmonth WHERE substr(Date, 1, 4) = '2013'
```
=====================
Question: What was the difference in gas consumption between CZK-paying customers and EUR-paying customers in 2012?
 db_id: debit_card_specializing
Planner: Plan:

1.  **Find CZK gas consumption in 2012**:
    *   Join `customers` and `yearmonth` tables on `CustomerID`.
    *   Filter `customers` for `Currency` = 'CZK'.
    *   Filter `yearmonth` for dates in 2012 (e.g., using `LIKE '2012%'`).
    *   Sum the `Consumption` for CZK customers in 2012.
2.  **Find EUR gas consumption in 2012**:
    *   Join `customers` and `yearmonth` tables on `CustomerID`.
    *   Filter `customers` for `Currency` = 'EUR'.
    *   Filter `yearmonth` for dates in 2012 (e.g., using `LIKE '2012%'`).
    *   Sum the `Consumption` for EUR customers in 2012.
3.  **Calculate the difference**: Subtract the total EUR consumption from the total CZK consumption.

NL2SQL: ```sql
SELECT
  SUM(CASE WHEN T1.Currency = 'CZK' THEN T2.Consumption ELSE 0 END) - SUM(CASE WHEN T1.Currency = 'EUR' THEN T2.Consumption ELSE 0 END)
FROM customers AS T1
INNER JOIN yearmonth AS T2
  ON T1.CustomerID = T2.CustomerID
WHERE
  T2.Date LIKE '2012%';
```
Critic: ```sql
SELECT
  SUM(CASE WHEN T1.Currency = 'CZK' THEN T2.Consumption ELSE 0 END) - SUM(CASE WHEN T1.Currency = 'EUR' THEN T2.Consumption ELSE 0 END)
FROM customers AS T1
INNER JOIN yearmonth AS T2
  ON T1.CustomerID = T2.CustomerID
WHERE
  SUBSTR(T2.Date, 1, 4) = '2012';
```
=====================
Question: Which year recorded the most consumption of gas paid in CZK?
 db_id: debit_card_specializing
Planner: Plan:
1. Filter `customers` table to find customers who paid in CZK.
2. Join `yearmonth` and `customers` table on `CustomerID`.
3. Extract the year from the `Date` column in `yearmonth` table.
4. Group the result by year and calculate the sum of `Consumption` for each year.
5. Order the result by the sum of `Consumption` in descending order.
6. Limit the result to the top 1 year to find the year with the most consumption.

NL2SQL: ```sql
SELECT
  SUBSTR(T1.Date, 1, 4)
FROM yearmonth AS T1
INNER JOIN customers AS T2
  ON T1.CustomerID = T2.CustomerID
WHERE
  T2.Currency = 'CZK'
GROUP BY
  SUBSTR(T1.Date, 1, 4)
ORDER BY
  SUM(T1.Consumption) DESC
LIMIT 1;
```
Critic: ```sql
SELECT
  SUBSTR(T1.Date, 1, 4)
FROM yearmonth AS T1
INNER JOIN transactions_1k AS T2
  ON T1.CustomerID = T2.CustomerID
INNER JOIN customers AS T3
  ON T2.CustomerID = T3.CustomerID
WHERE
  T3.Currency = 'CZK'
GROUP BY
  SUBSTR(T1.Date, 1, 4)
ORDER BY
  SUM(T1.Consumption) DESC
LIMIT 1;
```
=====================
Question: What was the gas consumption peak month for SME customers in 2013?
 db_id: debit_card_specializing
Planner: Plan:
1. Filter the `customers` table to select only SME customers (Segment = 'SME').
2. Filter the `yearmonth` table to select data for the year 2013 (Date between '201301' and '201312').
3. Join the filtered `customers` and `yearmonth` tables on `CustomerID`.
4. Group the result by month (extracted from the 'Date' column) and calculate the sum of 'Consumption' for each month.
5. Find the month with the maximum consumption.
6. Return the month with the highest consumption.

NL2SQL: ```sql
SELECT
  SUBSTR(Date, 5, 2)
FROM yearmonth
WHERE
  CustomerID IN (
    SELECT
      CustomerID
    FROM customers
    WHERE
      Segment = 'SME'
  )
  AND Date BETWEEN '201301' AND '201312'
GROUP BY
  SUBSTR(Date, 5, 2)
ORDER BY
  SUM(Consumption) DESC
LIMIT 1;
```
Critic: ```sql
SELECT
  SUBSTR(Date, 5, 2)
FROM yearmonth
WHERE
  CAST(SUBSTR(Date, 1, 4) AS INTEGER) = 2013
  AND CustomerID IN (
    SELECT
      CustomerID
    FROM customers
    WHERE
      Segment = 'SME'
  )
GROUP BY
  SUBSTR(Date, 5, 2)
ORDER BY
  SUM(Consumption) DESC
LIMIT 1;
```
=====================
Question: What is the difference in the annual average consumption of the customers with the least amount of consumption paid in CZK for 2013 between SME and LAM, LAM and KAM, and KAM and SME?
 db_id: debit_card_specializing
Planner: Here's my plan to determine the difference in annual average consumption for 2013:

1.  **Filter for 2013 data:** Use the `yearmonth` table and filter the `Date` column to include only records from 2013 (e.g., `Date LIKE '2013%'`).
2.  **Join `yearmonth` and `customers` tables:** Join `yearmonth` table with the `customers` table using `CustomerID` to associate consumption with customer segments and currency.
3.  **Filter for CZK transactions:** Filter the results based on the `Currency` column in the `customers` table to include only transactions in 'CZK'.
4.  **Calculate the total consumption per customer segment:** Group the joined table by the `Segment` column from the `customers` table and calculate the sum of `Consumption` for each segment.
5.  **Determine the minimum consumption for each segment:** Using a subquery or window function, find the minimum `Consumption` value for each `Segment`.
6.  **Filter for customers with the minimum consumption:** Filter the initial results to only include `CustomerID`s whose `Consumption` value equals the minimum consumption for that segment.
7.  **Calculate the number of customers with the minimum consumption in each segment:** Count the number of customers with minimum consumption within each segment.
8.  **Calculate annual consumption per segment:** Calculate the sum of `Consumption` for the filtered data per segment.
9.  **Calculate the average annual consumption:** Divide the total annual consumption per segment by the count of customers with minimum consumption in that segment.
10. **Calculate the differences:** Calculate the differences between the average annual consumption of SME and LAM, LAM and KAM, and KAM and SME.
11. **Present the results:** Display the differences as requested.

Tables: `customers`, `yearmonth`
Columns:
*   `customers`: `CustomerID`, `Segment`, `Currency`
*   `yearmonth`: `CustomerID`, `Date`, `Consumption`

Joins:
*   `customers` JOIN `yearmonth` ON `customers.CustomerID` = `yearmonth.CustomerID`

Filters:
*   `yearmonth.Date` LIKE '2013%'
*   `customers.Currency` = 'CZK'

Aggregations:
*   `SUM(yearmonth.Consumption)` (grouped by `customers.Segment`)
*   `COUNT(customers.CustomerID)` (grouped by `customers.Segment`)
*   `MIN(yearmonth.Consumption)` (partitioned by `customers.Segment`)

NL2SQL: ```sql
WITH YearlyData AS (
  SELECT
    c.CustomerID,
    c.Segment,
    ym.Consumption
  FROM customers AS c
  JOIN yearmonth AS ym
    ON c.CustomerID = ym.CustomerID
  WHERE
    SUBSTR(ym.Date, 1, 4) = '2013' AND c.Currency = 'CZK'
), MinConsumption AS (
  SELECT
    Segment,
    MIN(Consumption) AS MinConsumptionValue
  FROM YearlyData
  GROUP BY
    Segment
), SegmentCounts AS (
  SELECT
    yd.Segment,
    SUM(yd.Consumption) AS TotalConsumption,
    COUNT(DISTINCT yd.CustomerID) AS CustomerCount
  FROM YearlyData AS yd
  JOIN MinConsumption AS mc
    ON yd.Segment = mc.Segment AND yd.Consumption = mc.MinConsumptionValue
  GROUP BY
    yd.Segment
), SegmentAvg AS (
  SELECT
    Segment,
    TotalConsumption / CustomerCount AS AvgConsumption
  FROM SegmentCounts
)
SELECT
  (
    SELECT
      AvgConsumption
    FROM SegmentAvg
    WHERE
      Segment = 'SME'
  ) - (
    SELECT
      AvgConsumption
    FROM SegmentAvg
    WHERE
      Segment = 'LAM'
  ) AS SME_minus_LAM,
  (
    SELECT
      AvgConsumption
    FROM SegmentAvg
    WHERE
      Segment = 'LAM'
  ) - (
    SELECT
      AvgConsumption
    FROM SegmentAvg
    WHERE
      Segment = 'KAM'
  ) AS LAM_minus_KAM,
  (
    SELECT
      AvgConsumption
    FROM SegmentAvg
    WHERE
      Segment = 'KAM'
  ) - (
    SELECT
      AvgConsumption
    FROM SegmentAvg
    WHERE
      Segment = 'SME'
  ) AS KAM_minus_SME;
```
Critic: ```sql
WITH YearlyData AS (
  SELECT
    c.CustomerID,
    c.Segment,
    ym.Consumption
  FROM customers AS c
  JOIN yearmonth AS ym
    ON c.CustomerID = ym.CustomerID
  WHERE
    SUBSTR(ym.Date, 1, 4) = '2013' AND c.Currency = 'CZK'
), AvgConsumption AS (
  SELECT
    Segment,
    AVG(Consumption) AS AvgConsumption
  FROM YearlyData
  GROUP BY
    Segment
)
SELECT
  (
    SELECT
      AvgConsumption
    FROM AvgConsumption
    WHERE
      Segment = 'SME'
  ) - (
    SELECT
      AvgConsumption
    FROM AvgConsumption
    WHERE
      Segment = 'LAM'
  ) AS SME_minus_LAM,
  (
    SELECT
      AvgConsumption
    FROM AvgConsumption
    WHERE
      Segment = 'LAM'
  ) - (
    SELECT
      AvgConsumption
    FROM AvgConsumption
    WHERE
      Segment = 'KAM'
  ) AS LAM_minus_KAM,
  (
    SELECT
      AvgConsumption
    FROM AvgConsumption
    WHERE
      Segment = 'KAM'
  ) - (
    SELECT
      AvgConsumption
    FROM AvgConsumption
    WHERE
      Segment = 'SME'
  ) AS KAM_minus_SME;
```
=====================
Question: Which of the three segments—SME, LAM and KAM—has the biggest and lowest percentage increases in consumption paid in EUR between 2012 and 2013?
 db_id: debit_card_specializing
Planner: Plan:
1. Filter the `customers` table to include only customers with EUR currency.
2. Create a CTE called `Consumption2012` to calculate the total consumption for each segment in 2012.  Join `yearmonth` and `customers` tables on `CustomerID`. Filter `yearmonth` table where the year extracted from the Date column is 2012.  Group by `Segment` and sum the `Consumption`.
3. Create a CTE called `Consumption2013` to calculate the total consumption for each segment in 2013. Join `yearmonth` and `customers` tables on `CustomerID`. Filter `yearmonth` table where the year extracted from the Date column is 2013. Group by `Segment` and sum the `Consumption`.
4. Join `Consumption2012` and `Consumption2013` CTEs on `Segment`.
5. Calculate the percentage increase in consumption between 2012 and 2013 for each segment: `((Consumption2013 - Consumption2012) / Consumption2012) * 100`.
6. Order the result by percentage increase in descending order to find the segment with the biggest increase.
7. Order the result by percentage increase in ascending order to find the segment with the lowest increase.
8. Return the segment names with the biggest and lowest percentage increases.

NL2SQL: ```sql
WITH Consumption2012 AS (
  SELECT
    c.Segment,
    SUM(ym.Consumption) AS Consumption2012
  FROM yearmonth AS ym
  JOIN customers AS c
    ON ym.CustomerID = c.CustomerID
  WHERE
    SUBSTR(ym.Date, 1, 4) = '2012' AND c.Currency = 'EUR'
  GROUP BY
    c.Segment
), Consumption2013 AS (
  SELECT
    c.Segment,
    SUM(ym.Consumption) AS Consumption2013
  FROM yearmonth AS ym
  JOIN customers AS c
    ON ym.CustomerID = c.CustomerID
  WHERE
    SUBSTR(ym.Date, 1, 4) = '2013' AND c.Currency = 'EUR'
  GROUP BY
    c.Segment
), ConsumptionChanges AS (
  SELECT
    c2012.Segment,
    (
      (
        c2013.Consumption2013 - c2012.Consumption2012
      ) / c2012.Consumption2012
    ) * 100 AS PercentageIncrease
  FROM Consumption2012 AS c2012
  JOIN Consumption2013 AS c2013
    ON c2012.Segment = c2013.Segment
)
SELECT
  (
    SELECT
      Segment
    FROM ConsumptionChanges
    ORDER BY
      PercentageIncrease DESC
    LIMIT 1
  ) AS BiggestIncreaseSegment,
  (
    SELECT
      Segment
    FROM ConsumptionChanges
    ORDER BY
      PercentageIncrease
    LIMIT 1
  ) AS LowestIncreaseSegment;
```
Critic: ```sql
WITH Consumption2012 AS (
  SELECT
    c.Segment,
    SUM(ym.Consumption) AS Consumption2012
  FROM yearmonth AS ym
  JOIN customers AS c
    ON ym.CustomerID = c.CustomerID
  WHERE
    SUBSTR(ym.Date, 1, 4) = '2012' AND c.Currency = 'EUR'
  GROUP BY
    c.Segment
), Consumption2013 AS (
  SELECT
    c.Segment,
    SUM(ym.Consumption) AS Consumption2013
  FROM yearmonth AS ym
  JOIN customers AS c
    ON ym.CustomerID = c.CustomerID
  WHERE
    SUBSTR(ym.Date, 1, 4) = '2013' AND c.Currency = 'EUR'
  GROUP BY
    c.Segment
), ConsumptionChanges AS (
  SELECT
    c2012.Segment,
    (
      (
        c2013.Consumption2013 - c2012.Consumption2012
      ) / c2012.Consumption2012
    ) * 100 AS PercentageIncrease
  FROM Consumption2012 AS c2012
  JOIN Consumption2013 AS c2013
    ON c2012.Segment = c2013.Segment
)
SELECT
  (
    SELECT
      Segment
    FROM ConsumptionChanges
    ORDER BY
      PercentageIncrease DESC
    LIMIT 1
  ) AS BiggestIncreaseSegment,
  (
    SELECT
      Segment
    FROM ConsumptionChanges
    ORDER BY
      PercentageIncrease
    LIMIT 1
  ) AS LowestIncreaseSegment;
```
=====================
Question: How much did customer 6 consume in total between August and November 2013?
 db_id: debit_card_specializing
Planner: Plan:
1. Filter the `yearmonth` table to include only records where `CustomerID` is 6 and the `Date` falls between '201308' and '201311' (inclusive).
2. Calculate the sum of the `Consumption` for the filtered records.
3. Return the calculated sum.

NL2SQL: ```sql
SELECT sum(Consumption) FROM yearmonth WHERE CustomerID = 6 AND Date BETWEEN '201308' AND '201311'
```
Critic: ```sql
SELECT sum(Consumption) FROM yearmonth WHERE CustomerID = 6 AND Date LIKE '201308%' OR Date LIKE '201309%' OR Date LIKE '201310%' OR Date LIKE '201311%'
```
=====================
Question: How many more "discount" gas stations does the Czech Republic have compared to Slovakia?
 db_id: debit_card_specializing
Planner: Plan:
1. Filter the `gasstations` table for gas stations in the Czech Republic ('CZE') that are "discount" segment.
2. Count the number of such gas stations.
3. Filter the `gasstations` table for gas stations in Slovakia ('SVK') that are "discount" segment.
4. Count the number of such gas stations.
5. Subtract the count for Slovakia from the count for the Czech Republic.
6. Return the difference.

NL2SQL: ```sql
SELECT
  (
    SELECT
      COUNT(*)
    FROM gasstations
    WHERE
      Country = 'CZE' AND Segment = 'Discount'
  ) - (
    SELECT
      COUNT(*)
    FROM gasstations
    WHERE
      Country = 'SVK' AND Segment = 'Discount'
  );
```
Critic: ```sql
SELECT
  (
    SELECT
      COUNT(*)
    FROM gasstations
    WHERE
      Country = 'CZE' AND Segment = 'Discount'
  ) - (
    SELECT
      COUNT(*)
    FROM gasstations
    WHERE
      Country = 'SVK' AND Segment = 'Discount'
  );
```
=====================
Question: Is it true that more SMEs pay in Czech koruna than in euros? If so, how many more?
 db_id: debit_card_specializing
Planner: Plan:
1. Count the number of SMEs that pay in CZK. This involves filtering the `customers` table by `Segment = 'SME'` and `Currency = 'CZK'` and counting the distinct `CustomerID`.
2. Count the number of SMEs that pay in EUR. This involves filtering the `customers` table by `Segment = 'SME'` and `Currency = 'EUR'` and counting the distinct `CustomerID`.
3. Calculate the difference between the two counts.
4. Return true if the difference is positive, and false otherwise. Also return the difference itself.

Tables:
*   `customers`

Columns:
*   `CustomerID`
*   `Segment`
*   `Currency`

Filters:
*   `Segment = 'SME'`
*   `Currency = 'CZK'`
*   `Currency = 'EUR'`

Joins:
*   None needed

NL2SQL: ```sql
SELECT
  CASE
    WHEN (
      SELECT
        COUNT(DISTINCT CustomerID)
      FROM customers
      WHERE
        Segment = 'SME' AND Currency = 'CZK'
    ) > (
      SELECT
        COUNT(DISTINCT CustomerID)
      FROM customers
      WHERE
        Segment = 'SME' AND Currency = 'EUR'
    )
    THEN 'TRUE'
    ELSE 'FALSE'
  END,
  (
    SELECT
      COUNT(DISTINCT CustomerID)
    FROM customers
    WHERE
      Segment = 'SME' AND Currency = 'CZK'
  ) - (
    SELECT
      COUNT(DISTINCT CustomerID)
    FROM customers
    WHERE
      Segment = 'SME' AND Currency = 'EUR'
  );
```
Critic: ```sql
SELECT
  CASE
    WHEN SUM(CASE WHEN Currency = 'CZK' THEN 1 ELSE 0 END) > SUM(CASE WHEN Currency = 'EUR' THEN 1 ELSE 0 END)
    THEN 'TRUE'
    ELSE 'FALSE'
  END,
  SUM(CASE WHEN Currency = 'CZK' THEN 1 ELSE 0 END) - SUM(CASE WHEN Currency = 'EUR' THEN 1 ELSE 0 END)
FROM customers
WHERE
  Segment = 'SME';
```
=====================
Question: How many percent of LAM customer consumed more than 46.73?
 db_id: debit_card_specializing
Planner: Plan:
1. Find the total number of LAM customers using the `customers` table, filtering by `Segment = 'LAM'`.
2. Find the number of LAM customers whose consumption is greater than 46.73. This requires joining `customers` and `yearmonth` tables on `CustomerID`, filtering by `Segment = 'LAM'` and `Consumption > 46.73`.
3. Calculate the percentage by dividing the result of step 2 by the result of step 1 and multiplying by 100.
NL2SQL:
```sql
SELECT
  CAST(SUM(CASE WHEN T2.Consumption > 46.73 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.CustomerID)
FROM Customers AS T1
INNER JOIN YearMonth AS T2
  ON T1.CustomerID = T2.CustomerID
WHERE
  T1.Segment = 'LAM';
```
NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T2.Consumption > 46.73 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.CustomerID)
FROM Customers AS T1
INNER JOIN YearMonth AS T2
  ON T1.CustomerID = T2.CustomerID
WHERE
  T1.Segment = 'LAM';
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T2.Consumption > 46.73 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.CustomerID)
FROM customers AS T1
INNER JOIN yearmonth AS T2
  ON T1.CustomerID = T2.CustomerID
WHERE
  T1.Segment = 'LAM';
```
=====================
Question: In February 2012, what percentage of customers consumed more than 528.3?
 db_id: debit_card_specializing
Planner: Plan:
1. Filter the `yearmonth` table to only include records from February 2012 (where `Date` = '201202').
2. Filter the result further to only include customers where `Consumption` is greater than 528.3.
3. Count the number of customers meeting the criteria in step 2.
4. Count the total number of customers in February 2012.
5. Calculate the percentage by dividing the count from step 3 by the count from step 4 and multiplying by 100.
6. Return the calculated percentage.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN Consumption > 528.3 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(CustomerID)
FROM yearmonth
WHERE
  Date = '201202';
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN Consumption > 528.3 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(CustomerID)
FROM yearmonth
WHERE
  substr(Date, 1, 6) = '201202';
```
=====================
Question: What is the highest monthly consumption in the year 2012?
 db_id: debit_card_specializing
Planner: Plan:
1. Filter the `yearmonth` table to include only records where the year is 2012. This can be done by extracting the year from the `Date` column.
2. Group the filtered data by month (extract the month from the `Date` column).
3. Calculate the sum of `Consumption` for each month.
4. Find the maximum monthly consumption from the calculated monthly consumptions.
5. Return the maximum monthly consumption.

Tables: `yearmonth`
Columns: `Date`, `Consumption`
Filters: Year from `Date` = 2012
Aggregate Function: `SUM(Consumption)` grouped by month from `Date`
Final Operation: `MAX(monthly consumption)`

NL2SQL: ```sql
SELECT MAX(monthly_consumption)
FROM (
    SELECT SUM(Consumption) AS monthly_consumption
    FROM yearmonth
    WHERE SUBSTR(Date, 1, 4) = '2012'
    GROUP BY SUBSTR(Date, 5, 2)
) AS monthly_consumptions;
```
Critic: ```sql
SELECT MAX(Consumption) FROM yearmonth WHERE substr(Date,1,4)='2012'
```
=====================
Question: Please list the product description of the products consumed in September, 2013.
 db_id: debit_card_specializing
Planner: Plan:
1. Filter `yearmonth` table for records where the date starts with '201309'.
2. Extract the `CustomerID` from the filtered `yearmonth` table.
3. Filter the `transactions_1k` table using the extracted `CustomerID` and also filter the `transactions_1k` table for records where the `Date` falls in September 2013.
4. Extract the `ProductID` from the filtered `transactions_1k` table.
5. Retrieve the `Description` from the `products` table using the extracted `ProductID`.

NL2SQL: ```sql
SELECT DISTINCT
  T2.Description
FROM yearmonth AS T1
INNER JOIN transactions_1k AS T3
  ON T1.CustomerID = T3.CustomerID
INNER JOIN products AS T2
  ON T3.ProductID = T2.ProductID
WHERE
  substr(T1.Date, 1, 6) = '201309'
  AND T3.Date LIKE '2013-09%';
```
Critic: ```sql
SELECT DISTINCT
  T1.Description
FROM products AS T1
INNER JOIN transactions_1k AS T2
  ON T1.ProductID = T2.ProductID
WHERE
  STRFTIME('%Y-%m', T2.Date) = '2013-09';
```
=====================
Question: Please list the countries of the gas stations with transactions taken place in June, 2013.
 db_id: debit_card_specializing
Planner: Plan:
1. Filter the `transactions_1k` table to include only transactions that occurred in June 2013. This can be achieved by filtering the `Date` column.
2. Join the filtered `transactions_1k` table with the `gasstations` table using the `GasStationID` column.
3. Select the `Country` column from the joined table.
4. Remove duplicate country names using DISTINCT.

NL2SQL: ```sql
SELECT DISTINCT
  g.Country
FROM transactions_1k AS t
JOIN gasstations AS g
  ON t.GasStationID = g.GasStationID
WHERE
  STRFTIME('%Y-%m', t.Date) = '2013-06';
```
Critic: ```sql
SELECT DISTINCT
  g.Country
FROM transactions_1k AS t
JOIN gasstations AS g
  ON t.GasStationID = g.GasStationID
WHERE
  STRFTIME('%Y%m', t.Date) = '201306';
```
=====================
Question: Among the customers who paid in euro, how many of them have a monthly consumption of over 1000?
 db_id: debit_card_specializing
Planner: Plan:
1. Filter customers table for customers who paid in euro (Currency = 'EUR').
2. Join the filtered customers table with the yearmonth table on CustomerID.
3. Filter the joined table for monthly consumption greater than 1000 (Consumption > 1000).
4. Count the distinct CustomerIDs in the filtered table.

NL2SQL: ```sql
SELECT
  COUNT(DISTINCT T1.CustomerID)
FROM customers AS T1
INNER JOIN yearmonth AS T2
  ON T1.CustomerID = T2.CustomerID
WHERE
  T1.Currency = 'EUR' AND T2.Consumption > 1000;
```
Critic: ```sql
SELECT
  COUNT(DISTINCT T1.CustomerID)
FROM customers AS T1
INNER JOIN yearmonth AS T2
  ON T1.CustomerID = T2.CustomerID
WHERE
  T1.Currency = 'EUR' AND T2.Consumption > 1000;
```
=====================
Question: Please list the product descriptions of the transactions taken place in the gas stations in the Czech Republic.
 db_id: debit_card_specializing
Planner: Plan:
1. Filter `gasstations` table to select gas stations located in the Czech Republic (Country = 'CZE').
2. Join `transactions_1k` table with the filtered `gasstations` table using `GasStationID` to get transactions that occurred at gas stations in the Czech Republic.
3. Join the result with the `products` table using `ProductID` to get the descriptions of the products involved in those transactions.
4. Select the `Description` column from the `products` table.

NL2SQL: ```sql
SELECT
  T1.Description
FROM products AS T1
JOIN transactions_1k AS T2
  ON T1.ProductID = T2.ProductID
JOIN gasstations AS T3
  ON T2.GasStationID = T3.GasStationID
WHERE
  T3.Country = 'CZE';
```
Critic: ```sql
SELECT DISTINCT
  T1.Description
FROM products AS T1
JOIN transactions_1k AS T2
  ON T1.ProductID = T2.ProductID
JOIN gasstations AS T3
  ON T2.GasStationID = T3.GasStationID
WHERE
  T3.Country = 'CZE';
```
=====================
Question: Please list the disparate time of the transactions taken place in the gas stations from chain no. 11.
 db_id: debit_card_specializing
Planner: Plan:
1. Filter the `gasstations` table to get the `GasStationID` for chain no. 11.
2. Filter the `transactions_1k` table using the `GasStationID` obtained in the previous step.
3. Select the `Time` column from the filtered `transactions_1k` table.
4. Find the distinct times.

NL2SQL: ```sql
SELECT DISTINCT Time FROM transactions_1k WHERE GasStationID IN (SELECT GasStationID FROM gasstations WHERE ChainID = 11)
```
Critic: ```sql
SELECT DISTINCT Time FROM transactions_1k WHERE GasStationID IN (SELECT GasStationID FROM gasstations WHERE ChainID = 11)
```
=====================
Question: Among the transactions made in the gas stations in the Czech Republic, how many of them are taken place after 2012/1/1?
 db_id: debit_card_specializing
Planner: Plan:
1. Filter the `gasstations` table to find gas stations located in the Czech Republic (Country = 'CZE').
2. Join the `transactions_1k` table with the filtered `gasstations` table using the `GasStationID` to link transactions to gas stations.
3. Filter the joined table to include only transactions that occurred after January 1, 2012 ('2012-01-01').
4. Count the number of transactions that satisfy these conditions.
5. Return the count of these transactions.
Needed Tables: `gasstations`, `transactions_1k`
Needed Columns: `gasstations`.`GasStationID`, `gasstations`.`Country`, `transactions_1k`.`GasStationID`, `transactions_1k`.`Date`
Filters: `gasstations`.`Country` = 'CZE', `transactions_1k`.`Date` > '2012-01-01'
Joins: `transactions_1k` JOIN `gasstations` ON `transactions_1k`.`GasStationID` = `gasstations`.`GasStationID`
Aggregate Function: COUNT(*)

NL2SQL: ```sql
SELECT
  COUNT(*)
FROM transactions_1k
JOIN gasstations
  ON transactions_1k.GasStationID = gasstations.GasStationID
WHERE
  gasstations.Country = 'CZE' AND transactions_1k.Date > '2012-01-01'
```
Critic: ```sql
SELECT
  COUNT(*)
FROM transactions_1k AS T
INNER JOIN gasstations AS G
  ON T.GasStationID = G.GasStationID
WHERE
  G.Country = 'CZE' AND T.Date > '2012-01-01'
```
=====================
Question: What kind of currency did the customer paid at 16:25:00 in 2012/8/24?
 db_id: debit_card_specializing
Planner: Plan:
1. Filter the `transactions_1k` table to find the `CustomerID` where `Date` is '2012-08-24' and `Time` is '16:25:00'.
2. Join the filtered table with the `customers` table using `CustomerID`.
3. Retrieve the `Currency` from the `customers` table.

NL2SQL: ```sql
SELECT
  T2.Currency
FROM transactions_1k AS T1
INNER JOIN customers AS T2
  ON T1.CustomerID = T2.CustomerID
WHERE
  T1.Date = '2012-08-24' AND T1.Time = '16:25:00';
```
Critic: ```sql
SELECT
  T2.Currency
FROM transactions_1k AS T1
INNER JOIN customers AS T2
  ON T1.CustomerID = T2.CustomerID
WHERE
  T1.Date = '2012-08-24' AND T1.Time = '16:25:00';
```
=====================
Question: What segment did the customer have at 2012/8/23 21:20:00?
 db_id: debit_card_specializing
Planner: Plan:
1. Filter `transactions_1k` table for the specific date '2012-08-23' and time '21:20:00'.
2. Retrieve the `CustomerID` from the filtered `transactions_1k` table.
3. Join `customers` table with the `CustomerID` obtained in the previous step.
4. Retrieve the `Segment` of that `CustomerID` from the `customers` table.

NL2SQL: ```sql
SELECT
  T1.Segment
FROM customers AS T1
INNER JOIN transactions_1k AS T2
  ON T1.CustomerID = T2.CustomerID
WHERE
  T2.Date = '2012-08-23' AND T2.Time = '21:20:00';
```
Critic: ```sql
SELECT
  T1.Segment
FROM customers AS T1
INNER JOIN transactions_1k AS T2
  ON T1.CustomerID = T2.CustomerID
WHERE
  T2.Date = '2012-08-23' AND T2.Time = '21:20:00';
```
=====================
Question: For all the transactions happened during 8:00-9:00 in 2012/8/26, how many happened in CZE?
 db_id: debit_card_specializing
Planner: Plan:
1. Filter `transactions_1k` table to include only transactions that occurred on '2012-08-26' between 08:00:00 and 09:00:00 using the `Date` and `Time` columns.
2. Join the filtered `transactions_1k` table with the `gasstations` table using the `GasStationID` to link transactions to gas stations.
3. Filter the joined table to include only transactions that occurred at gas stations in 'CZE' using the `Country` column in the `gasstations` table.
4. Count the number of transactions that satisfy all the above conditions.

NL2SQL: ```sql
SELECT
  COUNT(T1.TransactionID)
FROM transactions_1k AS T1
JOIN gasstations AS T2
  ON T1.GasStationID = T2.GasStationID
WHERE
  T1.Date = '2012-08-26' AND T1.Time BETWEEN '08:00:00' AND '09:00:00' AND T2.Country = 'CZE';
```
Critic: ```sql
SELECT
  COUNT(T1.TransactionID)
FROM transactions_1k AS T1
INNER JOIN gasstations AS T2
  ON T1.GasStationID = T2.GasStationID
WHERE
  T1.Date = '2012-08-26' AND T1.Time BETWEEN '08:00:00' AND '09:00:00' AND T2.Country = 'CZE';
```
=====================
Question: What's the nationality of the customer who spent 548.4 in 2012/8/24?
 db_id: debit_card_specializing
Planner: Plan:
1. Filter the `transactions_1k` table by date '2012-08-24' and amount 548.
2. Get the `CustomerID` from the filtered table.
3. Join the `customers` table with the `transactions_1k` table using the `CustomerID`.
4. Retrieve the `Segment` from the `customers` table.

NL2SQL: ```sql
SELECT
  T1.Segment
FROM customers AS T1
INNER JOIN transactions_1k AS T2
  ON T1.CustomerID = T2.CustomerID
WHERE
  T2.Date = '2012-08-24' AND T2.Amount = 548;
```
Critic: ```sql
SELECT
  T1.Segment
FROM customers AS T1
INNER JOIN transactions_1k AS T2
  ON T1.CustomerID = T2.CustomerID
WHERE
  T2.Date = '2012-08-24' AND T2.Price = 548.4;
```
=====================
Question: What is the percentage of the customers who used EUR in 2012/8/25?
 db_id: debit_card_specializing
Planner: Plan:
1. Find the total number of customers in the `customers` table.
2. Find the number of customers who used EUR in the `customers` table.
3. Filter the `transactions_1k` table by date '2012-08-25'.
4. Join `transactions_1k` with `customers` using `CustomerID`.
5. Filter the joined table to include only customers who used EUR on '2012-08-25'.
6. Calculate the percentage of customers who used EUR on '2012-08-25' by dividing the count of customers who used EUR on that date by the total number of customers and multiplying by 100.
7. If the total number of customers is 0, return 0.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.Currency = 'EUR' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.CustomerID)
FROM customers AS T1
INNER JOIN transactions_1k AS T2
  ON T1.CustomerID = T2.CustomerID
WHERE
  T2.Date = '2012-08-25';
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.Currency = 'EUR' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.CustomerID)
FROM Customers AS T1
INNER JOIN Transactions_1k AS T2
  ON T1.CustomerID = T2.CustomerID
WHERE
  T2.Date = '2012-08-25';
```
=====================
Question: For the customer who paid 634.8 in 2012/8/25, what was the consumption decrease rate from Year 2012 to 2013?
 db_id: debit_card_specializing
Planner: Plan:
1. Find the CustomerID based on the transaction details (Date, Amount) in the `transactions_1k` table.
2. Calculate the total consumption for the found CustomerID in the year 2012 using the `yearmonth` table.
3. Calculate the total consumption for the same CustomerID in the year 2013 using the `yearmonth` table.
4. Calculate the consumption decrease rate using the formula: (consumption_2012 - consumption_2013) / consumption_2012.
5. Return the calculated decrease rate.

NL2SQL: ```sql
SELECT
  (
    (
      SUM(CASE WHEN STRFTIME('%Y', Date) = '2012' THEN Consumption ELSE 0 END) - SUM(CASE WHEN STRFTIME('%Y', Date) = '2013' THEN Consumption ELSE 0 END)
    ) / SUM(CASE WHEN STRFTIME('%Y', Date) = '2012' THEN Consumption ELSE 0 END)
  )
FROM yearmonth
WHERE
  CustomerID = (
    SELECT
      CustomerID
    FROM transactions_1k
    WHERE
      Date = '2012-08-25' AND Amount = 634
  );
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN STRFTIME('%Y', T1.Date) = '2012' THEN T1.Consumption ELSE 0 END) - SUM(CASE WHEN STRFTIME('%Y', T1.Date) = '2013' THEN T1.Consumption ELSE 0 END) AS REAL) * 100 / SUM(CASE WHEN STRFTIME('%Y', T1.Date) = '2012' THEN T1.Consumption ELSE 0 END)
FROM yearmonth AS T1
INNER JOIN transactions_1k AS T2
  ON T1.CustomerID = T2.CustomerID
WHERE
  T2.Date = '2012-08-25' AND T2.Amount = 634;
```
=====================
Question: What is the percentage of "premium" against the overall segment in Country = "SVK"?
 db_id: debit_card_specializing
Planner: Plan:
1. Filter `gasstations` table by `Country = "SVK"` to focus on gas stations in Slovakia.
2. Count the total number of gas stations in Slovakia.
3. Filter the `gasstations` table again by `Country = "SVK"` and `Segment = "premium"` to find the number of premium gas stations in Slovakia.
4. Calculate the percentage of premium gas stations by dividing the number of premium gas stations by the total number of gas stations and multiplying by 100.
5. Return the calculated percentage.
Tables: gasstations
Columns: Country, Segment
Filters: Country = "SVK", Segment = "premium"
Aggregations: COUNT(*)
Calculations: percentage = (COUNT(premium gas stations) / COUNT(all gas stations)) * 100

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN Segment = 'premium' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*)
FROM gasstations
WHERE
  Country = 'SVK';
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN Segment = 'Premium' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*)
FROM gasstations
WHERE
  Country = 'SVK';
```
=====================
Question: What is the amount spent by customer "38508" at the gas stations? How much had the customer spent in January 2012?
 db_id: debit_card_specializing
Planner: Plan:

1.  Find the total amount spent by customer "38508" at gas stations.
    *   Use the `transactions_1k` table.
    *   Filter by `CustomerID = 38508`.
    *   Join with `products` table to filter based on `Description` contains the word `Gas`.
    *   Sum the `Amount` column.
2.  Find the total amount spent by customer "38508" in January 2012.
    *   Use the `transactions_1k` table.
    *   Filter by `CustomerID = 38508` and `Date` like '2012-01%'.
    *   Sum the `Amount` column.

NL2SQL: ```sql
SELECT
  SUM(CASE WHEN T1.ProductID IN (
    SELECT
      ProductID
    FROM products
    WHERE
      Description LIKE '%Gas%'
  ) THEN T1.Amount ELSE 0 END),
  SUM(CASE WHEN STRFTIME('%Y%m', T1.Date) = '201201' THEN T1.Amount ELSE 0 END)
FROM transactions_1k AS T1
WHERE
  T1.CustomerID = 38508;
```
Critic: ```sql
SELECT
  SUM(CASE WHEN T1.ProductID IN (SELECT ProductID FROM products WHERE Description LIKE '%Gas%') THEN T1.Amount ELSE 0 END),
  SUM(CASE WHEN STRFTIME('%Y%m', T1.Date) = '201201' THEN T1.Amount ELSE 0 END)
FROM transactions_1k AS T1
WHERE
  T1.CustomerID = 38508;
```
=====================
Question: Who is the top spending customer and how much is the average price per single item purchased by this customer? What currency was being used?
 db_id: debit_card_specializing
Planner: Here's how we can approach this problem using SQL:

**Plan:**

1.  **Find the top spending customer:**
    *   Join `transactions_1k` with `customers` on `CustomerID`.
    *   Calculate the total spending for each customer using `SUM(Price)`.
    *   Find the maximum spending using `MAX()`.
    *   Filter to get the customer ID corresponding to the maximum spending.
2.  **Calculate the average price per item for the top customer:**
    *   Filter `transactions_1k` by the `CustomerID` found in step 1.
    *   Calculate the total price using `SUM(Price)`.
    *   Calculate the total amount using `SUM(Amount)`.
    *   Calculate the average price per item by dividing the total price by the total amount.
3.  **Find the currency used by the top customer:**
    *   Select the `Currency` from the `customers` table where `CustomerID` matches the top customer found in step 1.
4.  **Combine the results:**
    *   Present the top customer's ID, average price per item, and currency in the final output.

**Tables:**

*   `transactions_1k`: To calculate total spending and average price per item.
*   `customers`: To identify the customer segment and their currency.

**Columns:**

*   `transactions_1k.CustomerID`: To link transactions to customers.
*   `transactions_1k.Price`: To calculate total spending.
*   `transactions_1k.Amount`: To calculate average price per item.
*   `customers.CustomerID`: To identify the customer.
*   `customers.Currency`: To identify the currency.

**Filters:**

*   Filter `transactions_1k` by the `CustomerID` of the top spending customer.

**Joins:**

*   Join `transactions_1k` with `customers` on `CustomerID`.

NL2SQL: ```sql
SELECT
  t1.CustomerID,
  SUM(t1.Price) / SUM(t1.Amount),
  t2.Currency
FROM transactions_1k AS t1
JOIN customers AS t2
  ON t1.CustomerID = t2.CustomerID
WHERE
  t1.CustomerID = (
    SELECT
      CustomerID
    FROM transactions_1k
    GROUP BY
      CustomerID
    ORDER BY
      SUM(Price) DESC
    LIMIT 1
  )
GROUP BY
  t1.CustomerID,
  t2.Currency;
```
Critic: ```sql
SELECT
  t1.CustomerID,
  SUM(t1.Price) / SUM(t1.Amount),
  t2.Currency
FROM transactions_1k AS t1
JOIN customers AS t2
  ON t1.CustomerID = t2.CustomerID
WHERE
  t1.CustomerID = (
    SELECT
      CustomerID
    FROM transactions_1k
    GROUP BY
      CustomerID
    ORDER BY
      SUM(Price) DESC
    LIMIT 1
  )
GROUP BY
  t1.CustomerID,
  t2.Currency;
```
=====================
Question: For all the people who paid more than 29.00 per unit of product id No.5. Give their consumption status in the August of 2012.
 db_id: debit_card_specializing
Planner: Plan:
1. Find the CustomerIDs from `transactions_1k` where `ProductID` is 5 and `Price` / `Amount` is greater than 29.00.
2. Find the `Consumption` from the `yearmonth` table where the `CustomerID` matches and the `Date` is '201208'.
3. Return the `Consumption` values.
Tables: `transactions_1k`, `yearmonth`
Columns: `transactions_1k.CustomerID`, `transactions_1k.ProductID`, `transactions_1k.Price`, `transactions_1k.Amount`, `yearmonth.CustomerID`, `yearmonth.Date`, `yearmonth.Consumption`
Filters: `transactions_1k.ProductID = 5`, `transactions_1k.Price / transactions_1k.Amount > 29.00`, `yearmonth.Date = '201208'`
Join: Join `transactions_1k` and `yearmonth` on `CustomerID`.
Aggregations: None
Output: `yearmonth.Consumption`

NL2SQL: ```sql
SELECT DISTINCT T2.Consumption FROM transactions_1k AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.ProductID = 5 AND T1.Price / T1.Amount > 29.00 AND T2.Date = '201208'
```
Critic: ```sql
SELECT DISTINCT T2.Consumption FROM transactions_1k AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.ProductID = 5 AND T1.Price / T1.Amount > 29.00 AND T2.Date LIKE '201208%'
```
=====================
Question: What's Angela Sanders's major?
 db_id: student_club
Planner: 1. Find the `member_id` of the member whose first name is "Angela" and last name is "Sanders" from the `Member` table.
2. Retrieve the `link_to_major` from the `Member` table using the `member_id` found in the previous step.
3. Find the `major_name` from the `Major` table where `major_id` matches the `link_to_major` obtained in the previous step.

NL2SQL: ```sql
SELECT
  T2.major_name
FROM Member AS T1
INNER JOIN Major AS T2
  ON T1.link_to_major = T2.major_id
WHERE
  T1.first_name = 'Angela' AND T1.last_name = 'Sanders';
```
Critic: ```sql
SELECT
  T2.major_name
FROM Member AS T1
INNER JOIN Major AS T2
  ON T1.link_to_major = T2.major_id
WHERE
  T1.first_name = 'Angela' AND T1.last_name = 'Sanders';
```
=====================
Question: Among the students from the Student_Club who attended the event "Women's Soccer", how many of them want a T-shirt that's in medium size?
 db_id: student_club
Planner: Plan:
1. Filter the Event table to find the event_id of the event named "Women's Soccer".
2. Use the event_id found in step 1 to filter the Attendance table to find the link_to_member of all the members who attended "Women's Soccer".
3. Use the link_to_member found in step 2 to filter the Member table.
4. Filter the Member table with t_shirt_size = 'Medium' and count the number of members after filtering.
5. Return the count.

NL2SQL: ```sql
SELECT
  COUNT(T1.member_id)
FROM Member AS T1
INNER JOIN Attendance AS T2
  ON T1.member_id = T2.link_to_member
INNER JOIN Event AS T3
  ON T2.link_to_event = T3.event_id
WHERE
  T3.event_name = 'Women''s Soccer' AND T1.t_shirt_size = 'Medium';
```
Critic: ```sql
SELECT
  COUNT(T1.member_id)
FROM Member AS T1
INNER JOIN Attendance AS T2
  ON T1.member_id = T2.link_to_member
INNER JOIN Event AS T3
  ON T2.link_to_event = T3.event_id
WHERE
  T3.event_name = 'Women''s Soccer' AND T1.t_shirt_size = 'M';
```
=====================
Question: Among the events attended by more than 10 members of the Student_Club, how many of them are meetings?
 db_id: student_club
Planner: Here's my plan to answer the question:

1.  **Join** the `Attendance` table with the `Event` table on `link_to_event` and `event_id` respectively.
2.  **Filter** for events where the `type` is 'Meeting'.
3.  **Group** the result by `event_id` and count the number of attendees for each event using `COUNT(link_to_member)`.
4.  **Filter** the grouped results where the count of attendees is greater than 10.
5.  **Count** the number of distinct events that meet the criteria.

NL2SQL: ```sql
SELECT
  COUNT(DISTINCT T1.event_id)
FROM Event AS T1
INNER JOIN Attendance AS T2
  ON T1.event_id = T2.link_to_event
WHERE
  T1.type = 'Meeting'
GROUP BY
  T1.event_id
HAVING
  COUNT(T2.link_to_member) > 10;
```
Critic: ```sql
SELECT
  COUNT(T1.event_id)
FROM Event AS T1
JOIN Attendance AS T2
  ON T1.event_id = T2.link_to_event
WHERE
  T1.type = 'Meeting'
GROUP BY
  T1.event_id
HAVING
  COUNT(T2.link_to_member) > 10;
```
=====================
Question: List all the names of events that had an attendance of over 20 students but were not fundraisers.
 db_id: student_club
Planner: Here's a plan to retrieve the event names based on the given criteria:

1.  **Join Tables:** Join the `Event` table and `Attendance` table on their common column `event_id` and `link_to_event` respectively.
2.  **Filter by Attendance:** Filter the results of the join to include only events where the count of attendees is greater than 20.  This will involve a `GROUP BY` clause on `event_id` and a `HAVING` clause to filter the groups.
3.  **Filter out Fundraisers:** Further filter these results to exclude events where the `type` column in the `Event` table is 'fundraiser'.
4.  **Select Event Names:** Finally, select the `event_name` column from the `Event` table for the events that meet all the criteria.

NL2SQL: ```sql
SELECT
  T1.event_name
FROM Event AS T1
INNER JOIN Attendance AS T2
  ON T1.event_id = T2.link_to_event
WHERE
  T1.type <> 'fundraiser'
GROUP BY
  T1.event_id
HAVING
  COUNT(T1.event_id) > 20;
```
Critic: ```sql
SELECT
  event_name
FROM Event AS T1
INNER JOIN Attendance AS T2
  ON T1.event_id = T2.link_to_event
WHERE
  T1.type != 'Fundraiser'
GROUP BY
  T1.event_name
HAVING
  COUNT(T2.link_to_member) > 20;
```
=====================
Question: What is the amount of the funds that the Vice President received?
 db_id: student_club
Planner: 1. Find the `member_id` of the member whose `position` is 'Vice President' from the `Member` table.
2. Using the `member_id` found in step 1, look for the `amount` from the `Income` table where `link_to_member` matches the `member_id`.
3. Sum the amounts to get the total amount of funds the Vice President received.
4. Return the sum of amount.

Tables:
- Member
- Income

Columns:
- Member.member_id
- Member.position
- Income.link_to_member
- Income.amount

Filters:
- Member.position = 'Vice President'

Joins:
- None (filtering Income table based on link_to_member)

NL2SQL: ```sql
SELECT
  SUM(T1.amount)
FROM Income AS T1
INNER JOIN Member AS T2
  ON T1.link_to_member = T2.member_id
WHERE
  T2.position = 'Vice President';
```
Critic: ```sql
SELECT
  SUM(T1.amount)
FROM Income AS T1
INNER JOIN Member AS T2
  ON T1.link_to_member = T2.member_id
WHERE
  T2.position = 'Vice President';
```
=====================
Question: List the full name of the Student_Club members that grew up in Illinois state.
 db_id: student_club
Planner: Plan:
1. Select the first name and last name from the `Member` table.
2. Join `Member` table with `Zip_Code` table on `zip` column.
3. Filter the result where the `state` column in `Zip_Code` table is 'Illinois'.
4. Concatenate first name and last name to create full name.

NL2SQL: ```sql
SELECT
  T1.first_name,
  T1.last_name
FROM Member AS T1
INNER JOIN Zip_Code AS T2
  ON T1.zip = T2.zip_code
WHERE
  T2.state = 'Illinois';
```
Critic: ```sql
SELECT
  first_name,
  last_name
FROM Member AS T1
INNER JOIN Zip_Code AS T2
  ON T1.zip = T2.zip_code
WHERE
  T2.state = 'Illinois';
```
=====================
Question: Was each expense in October Meeting on October 8, 2019 approved?
 db_id: student_club
Planner: 1. Find the `event_id` of the event named 'October Meeting' that occurred on '2019-10-08' from the `Event` table.
2. Find the `link_to_budget` from the `Budget` table with `link_to_event` equal to the `event_id` obtained in step 1.
3. From the `Expense` table, filter the expenses that have `link_to_budget` obtained in step 2 and extract the `approved` status for each expense.
4. Check if all of the `approved` statuses are 'TRUE'.
Tables:
- Event: To get the event_id for 'October Meeting' on '2019-10-08'.
- Budget: To get the link_to_budget corresponding to event_id.
- Expense: To check whether each expense was approved for the corresponding link_to_budget.
Columns:
- Event: event_id, event_name, event_date
- Budget: link_to_event
- Expense: link_to_budget, approved

Plan:
1. Select `event_id` from `Event` where `event_name` = 'October Meeting' and `event_date` = '2019-10-08'.
2. Select `link_to_budget` from `Budget` where `link_to_event` = event_id.
3. Select `approved` from `Expense` where `link_to_budget` in link_to_budget from budget.
4. Check if all values in `approved` column are 'TRUE'.

NL2SQL: ```sql
SELECT
  CASE
    WHEN SUM(CASE WHEN approved = 'TRUE' THEN 1 ELSE 0 END) = COUNT(*)
    THEN 'Yes'
    ELSE 'No'
  END
FROM Expense
WHERE
  link_to_budget IN (
    SELECT
      budget_id
    FROM Budget
    WHERE
      link_to_event = (
        SELECT
          event_id
        FROM Event
        WHERE
          event_name = 'October Meeting' AND event_date = '2019-10-08'
      )
  );
```
Critic: ```sql
SELECT
  CASE
    WHEN SUM(CASE WHEN T1.approved = 'TRUE' THEN 1 ELSE 0 END) = COUNT(T1.approved)
    THEN 'Yes'
    ELSE 'No'
  END
FROM Expense AS T1
INNER JOIN Budget AS T2
  ON T1.link_to_budget = T2.budget_id
INNER JOIN Event AS T3
  ON T2.link_to_event = T3.event_id
WHERE
  T3.event_name = 'October Meeting' AND T3.event_date = '2019-10-08';
```
=====================
Question: Calculate the total average cost that Elijah Allen spent in the events on September and October.
 db_id: student_club
Planner: Here's a plan to calculate the total average cost Elijah Allen spent in events during September and October:

1. **Identify Elijah Allen:**
   - Use the `Member` table to find the `member_id` of the member with `first_name` = 'Elijah' and `last_name` = 'Allen'.

2. **Filter Expenses for Elijah Allen and Specific Months:**
   - Use the `Expense` table.
   - Filter expenses based on the `link_to_member` matching the `member_id` found in step 1.
   - Filter expenses based on the `expense_date` to include only September and October.  We will use a function to extract the month from the date (month = 9 or month = 10).

3. **Calculate the Average Cost:**
   - Calculate the average of the `cost` from the filtered expenses in the `Expense` table.

Tables: `Member`, `Expense`
Columns: `Member.member_id`, `Member.first_name`, `Member.last_name`, `Expense.link_to_member`, `Expense.expense_date`, `Expense.cost`
Filters: `Member.first_name` = 'Elijah', `Member.last_name` = 'Allen', `Expense.link_to_member` = (Elijah Allen's member_id), month(`Expense.expense_date`) in (9, 10)
Joins: None
Aggregations: AVG(`Expense.cost`)

NL2SQL: ```sql
SELECT avg(T1.cost) FROM Expense AS T1 JOIN Member AS T2 ON T1.link_to_member = T2.member_id WHERE T2.first_name = 'Elijah' AND T2.last_name = 'Allen' AND STRFTIME('%m', T1.expense_date) IN ('09', '10')
```
Critic: ```sql
SELECT avg(T1.cost) FROM expense AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id WHERE T2.first_name = 'Elijah' AND T2.last_name = 'Allen' AND CAST(strftime('%m', T1.expense_date) AS INTEGER) IN (9, 10)
```
=====================
Question: Calculate the difference of the total amount spent in all events by the Student_Club in year 2019 and 2020.
 db_id: student_club
Planner: 1.  **Calculate total amount spent in 2019:**
    *   Join `Budget` and `Event` tables on `link_to_event`.
    *   Filter the results for events where the year of `event_date` in the `Event` table is 2019.
    *   Sum the `spent` column from the `Budget` table for these events.
2.  **Calculate total amount spent in 2020:**
    *   Join `Budget` and `Event` tables on `link_to_event`.
    *   Filter the results for events where the year of `event_date` in the `Event` table is 2020.
    *   Sum the `spent` column from the `Budget` table for these events.
3.  **Calculate the difference:**
    *   Subtract the total amount spent in 2020 from the total amount spent in 2019.
    *   Return the difference.

Return single column named "difference".

NL2SQL: ```sql
SELECT
  SUM(CASE WHEN STRFTIME('%Y', T2.event_date) = '2019' THEN T1.spent ELSE 0 END) - SUM(CASE WHEN STRFTIME('%Y', T2.event_date) = '2020' THEN T1.spent ELSE 0 END) AS difference
FROM Budget AS T1
INNER JOIN Event AS T2
  ON T1.link_to_event = T2.event_id;
```
Critic: ```sql
SELECT
  SUM(CASE WHEN STRFTIME('%Y', T2.event_date) = '2019' THEN T1.spent ELSE 0 END) - SUM(CASE WHEN STRFTIME('%Y', T2.event_date) = '2020' THEN T1.spent ELSE 0 END)
FROM Budget AS T1
INNER JOIN Event AS T2
  ON T1.link_to_event = T2.event_id;
```
=====================
Question: What was the notes of the fundraising on 2019/9/14?
 db_id: student_club
Planner: 1. Filter the Income table by `date_received` = '2019-09-14' and `source` = 'Fundraising'.
2. Retrieve the `notes` column from the filtered table.

NL2SQL: ```sql
SELECT
  notes
FROM Income
WHERE
  date_received = '2019-09-14' AND source = 'Fundraising';
```
Critic: ```sql
SELECT
  notes
FROM Income
WHERE
  date_received = '2019-09-14' AND source = 'Fundraising';
```
=====================
Question: Tell the phone number of "Carlo Jacobs".
 db_id: student_club
Planner: The question asks for the phone number of a member whose first name is "Carlo" and last name is "Jacobs".
We should use the `Member` table, filter the table to find the member with the specified first and last name, and then select the `phone` number for that member.
Plan:
1. SELECT phone FROM Member
2. WHERE first_name = "Carlo" AND last_name = "Jacobs"

NL2SQL: ```sql
SELECT phone FROM Member WHERE first_name = "Carlo" AND last_name = "Jacobs"
```
Critic: ```sql
SELECT phone FROM Member WHERE first_name = "Carlo" AND last_name = "Jacobs"
```
=====================
Question: What is the status of the event which bought "Post Cards, Posters" on 2019/8/20?
 db_id: student_club
Planner: 1.  Find the `expense_id` from the `Expense` table where `expense_description` is 'Post Cards, Posters' and `expense_date` is '2019-08-20'.
2.  Find the `link_to_budget` from the `Expense` table with the `expense_id`.
3.  Find the `link_to_event` from the `Budget` table with the `budget_id`.
4.  Find the `event_status` from the `Budget` table with the `budget_id`.

NL2SQL: ```sql
SELECT
  T1.event_status
FROM Budget AS T1
INNER JOIN Expense AS T2
  ON T1.budget_id = T2.link_to_budget
WHERE
  T2.expense_description = 'Post Cards, Posters' AND T2.expense_date = '2019-08-20';
```
Critic: ```sql
SELECT
  T1.status
FROM Event AS T1
INNER JOIN Budget AS T2
  ON T1.event_id = T2.link_to_event
INNER JOIN Expense AS T3
  ON T2.budget_id = T3.link_to_budget
WHERE
  T3.expense_description = 'Post Cards, Posters' AND T3.expense_date = '2019-08-20';
```
=====================
Question: What was Brent Thomason's major?
 db_id: student_club
Planner: 1. Find the `member_id` of the member whose `first_name` is 'Brent' and `last_name` is 'Thomason' from the `Member` table.
2. Using the `member_id`, find the corresponding `link_to_major` from the `Member` table.
3. Using the `link_to_major`, find the `major_name` from the `Major` table.
4. Return the `major_name`.

Tables: Member, Major
Columns: first_name, last_name, link_to_major, major_name
Filters: first_name = 'Brent', last_name = 'Thomason'
Joins: Member.link_to_major = Major.major_id

NL2SQL: ```sql
SELECT
  T2.major_name
FROM Member AS T1
INNER JOIN Major AS T2
  ON T1.link_to_major = T2.major_id
WHERE
  T1.first_name = 'Brent' AND T1.last_name = 'Thomason';
```
Critic: ```sql
SELECT
  T2.major_name
FROM Member AS T1
INNER JOIN Major AS T2
  ON T1.link_to_major = T2.major_id
WHERE
  T1.first_name = 'Brent' AND T1.last_name = 'Thomason';
```
=====================
Question: For all the club members from "Business" major, how many of them wear medium size t-shirt?
 db_id: student_club
Planner: 1.  Find the `major_id` for the "Business" major from the `Major` table using the `major_name` column.
2.  Filter `Member` table, join `Major` table with `link_to_major` = `major_id`, and filter `t_shirt_size` = 'Medium'
3.  Count the number of members that satisfy this condition.

NL2SQL: ```sql
SELECT
  COUNT(T1.member_id)
FROM Member AS T1
INNER JOIN Major AS T2
  ON T1.link_to_major = T2.major_id
WHERE
  T2.major_name = 'Business' AND T1.t_shirt_size = 'Medium';
```
Critic: ```sql
SELECT
  COUNT(T1.member_id)
FROM Member AS T1
INNER JOIN Major AS T2
  ON T1.link_to_major = T2.major_id
WHERE
  T2.major_name = 'Business' AND T1.t_shirt_size = 'M';
```
=====================
Question: Which department was the President of the club in?
 db_id: student_club
Planner: 1. Find the `member_id` of the member who holds the 'President' position in the `Member` table.
2. Using the `member_id`, find the `link_to_major` from the `Member` table.
3. Using the `link_to_major`, find the `department` from the `Major` table.
4. Return the `department`.

The tables needed are `Member` and `Major`.
The join condition is `Member.link_to_major = Major.major_id`.
The filter condition is `Member.position = 'President'`.
The column to return is `Major.department`.

NL2SQL: ```sql
SELECT
  T2.department
FROM Member AS T1
INNER JOIN Major AS T2
  ON T1.link_to_major = T2.major_id
WHERE
  T1.position = 'President';
```
Critic: ```sql
SELECT DISTINCT
  T2.department
FROM Member AS T1
INNER JOIN Major AS T2
  ON T1.link_to_major = T2.major_id
WHERE
  T1.position = 'President';
```
=====================
Question: State the date Connor Hilton paid his/her dues.
 db_id: student_club
Planner: 1. Filter the `Member` table to find the `member_id` of the member with `first_name` as "Connor" and `last_name` as "Hilton".
2. Filter the `Income` table for records where `source` is "Dues" and `link_to_member` matches the `member_id` found in the previous step.
3. Retrieve the `date_received` from the filtered `Income` table.

SQL query:
```sql
SELECT
  T1.date_received
FROM Income AS T1
INNER JOIN Member AS T2
  ON T1.link_to_member = T2.member_id
WHERE
  T2.first_name = 'Connor' AND T2.last_name = 'Hilton' AND T1.source = 'Dues';
```
NL2SQL: ```sql
SELECT
  T1.date_received
FROM Income AS T1
INNER JOIN Member AS T2
  ON T1.link_to_member = T2.member_id
WHERE
  T2.first_name = 'Connor' AND T2.last_name = 'Hilton' AND T1.source = 'Dues';
```
Critic: ```sql
SELECT
  T1.date_received
FROM Income AS T1
INNER JOIN Member AS T2
  ON T1.link_to_member = T2.member_id
WHERE
  T2.first_name = 'Connor' AND T2.last_name = 'Hilton' AND T1.source = 'Dues';
```
=====================
Question: How many times was the budget in Advertisement for "Yearly Kickoff" meeting more than "October Meeting"?
 db_id: student_club
Planner: Here's my plan to answer the question:

1.  **Identify relevant tables:** The `Budget` and `Event` tables are necessary since we are dealing with budget amounts, advertisement budgets, and event names.
2.  **Join the tables:** Join `Budget` and `Event` tables on `Budget.link_to_event = Event.event_id`.
3.  **Filter for Advertisement Budgets:** Filter the joined table where `Budget.category = 'Advertisement'`.
4.  **Isolate budgets for "Yearly Kickoff" and "October Meeting":**
    *   Find the budget amount for 'Yearly Kickoff' where `Event.event_name = 'Yearly Kickoff'`.
    *   Find the budget amount for 'October Meeting' where `Event.event_name = 'October Meeting'`.
5.  **Calculate the ratio:** Divide the "Yearly Kickoff" advertisement budget by the "October Meeting" advertisement budget.
6.  **Count the times Yearly Kickoff budget exceeded October Meeting's:**
    *   Compare "Yearly Kickoff" budget to "October Meeting" budget. The question asks how many times the "Yearly Kickoff" budget was *more than* the "October Meeting" budget.
    *   If the "Yearly Kickoff" budget is greater than the "October Meeting" budget, increment the count.

Based on the requirements, the following tables, columns, joins, and filters are needed:

*   Tables: `Budget`, `Event`
*   Columns: `Budget.amount`, `Budget.category`, `Budget.link_to_event`, `Event.event_id`, `Event.event_name`
*   Join: `Budget.link_to_event = Event.event_id`
*   Filters: `Budget.category = 'Advertisement'`, `Event.event_name IN ('Yearly Kickoff', 'October Meeting')`

NL2SQL: ```sql
SELECT
  SUM(CASE WHEN T1.event_name = 'Yearly Kickoff' THEN T2.amount ELSE 0 END) > SUM(CASE WHEN T1.event_name = 'October Meeting' THEN T2.amount ELSE 0 END)
FROM Event AS T1
INNER JOIN Budget AS T2
  ON T1.event_id = T2.link_to_event
WHERE
  T2.category = 'Advertisement' AND T1.event_name IN ('Yearly Kickoff', 'October Meeting');
```
Critic: ```sql
SELECT
  SUM(CASE WHEN T1.event_name = 'Yearly Kickoff' AND T2.amount > (
    SELECT
      T2_sub.amount
    FROM Event AS T1_sub
    JOIN Budget AS T2_sub
      ON T1_sub.event_id = T2_sub.link_to_event
    WHERE
      T1_sub.event_name = 'October Meeting' AND T2_sub.category = 'Advertisement'
  ) THEN 1 ELSE 0 END)
FROM Event AS T1
JOIN Budget AS T2
  ON T1.event_id = T2.link_to_event
WHERE
  T2.category = 'Advertisement' AND T1.event_name = 'Yearly Kickoff';
```
=====================
Question: What is the total cost of the pizzas for all the events?
 db_id: student_club
Planner: 1. We need the `Expense` table because it contains the cost of each expense and the description of the expense.
2. Filter the `Expense` table where `expense_description` is 'Pizza'.
3. Calculate the sum of the `cost` column from the filtered `Expense` table.

NL2SQL: ```sql
SELECT sum(cost) FROM Expense WHERE expense_description = 'Pizza'
```
Critic: ```sql
SELECT sum(T1.cost) FROM expense AS T1 JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id WHERE T2.category = "food"
```
=====================
Question: How many cities are there in Orange County, Virginia?
 db_id: student_club
Planner: 1.  **Find the relevant table:** The `Zip_Code` table contains city, county, and state information.
2.  **Filter the table:** Filter the `Zip_Code` table where `county` is 'Orange County' and `state` is 'Virginia'.
3.  **Count the cities:** Count the distinct `city` values from the filtered table.

NL2SQL: ```sql
SELECT
  COUNT(DISTINCT city)
FROM Zip_Code
WHERE
  county = 'Orange County' AND state = 'Virginia';
```
Critic: ```sql
SELECT
  COUNT(DISTINCT city)
FROM Zip_Code
WHERE
  county = 'Orange County' AND state = 'Virginia';
```
=====================
Question: What does the person with the phone number "809-555-3360" major in?
 db_id: student_club
Planner: 1. Find the `member_id` of the person with the phone number "809-555-3360" from the `Member` table.
2. Using the `member_id`, find the `link_to_major` from the `Member` table.
3. Using the `link_to_major`, find the `major_name` from the `Major` table.

Required tables: `Member`, `Major`
Required columns:
- `Member`: `member_id`, `phone`, `link_to_major`
- `Major`: `major_id`, `major_name`
Filters:
- `Member`.`phone` = "809-555-3360"
Joins:
- `Member`.`link_to_major` = `Major`.`major_id`
Final select column: `Major`.`major_name`

NL2SQL: ```sql
SELECT
  T2.major_name
FROM Member AS T1
INNER JOIN Major AS T2
  ON T1.link_to_major = T2.major_id
WHERE
  T1.phone = '809-555-3360';
```
Critic: ```sql
SELECT
  T2.major_name
FROM Member AS T1
INNER JOIN Major AS T2
  ON T1.link_to_major = T2.major_id
WHERE
  T1.phone = "809-555-3360";
```
=====================
Question: How many members attended the "Women's Soccer" event?
 db_id: student_club
Planner: 1. Find the `event_id` for the event named "Women's Soccer" in the `Event` table.
2. Use the `event_id` to find all corresponding entries in the `Attendance` table using `link_to_event`.
3. Count the number of distinct `link_to_member` entries from the `Attendance` table to determine the number of members who attended the event.

Tables needed: `Event`, `Attendance`
Columns needed: `event_id`, `event_name`, `link_to_event`, `link_to_member`
Filters: `event_name` = "Women's Soccer"
Joins: `Event` and `Attendance` using `event_id` and `link_to_event`
Aggregation: COUNT(DISTINCT `link_to_member`)

NL2SQL: ```sql
SELECT
  COUNT(DISTINCT T2.link_to_member)
FROM Event AS T1
INNER JOIN Attendance AS T2
  ON T1.event_id = T2.link_to_event
WHERE
  T1.event_name = 'Women''s Soccer';
```
Critic: ```sql
SELECT
  COUNT(T1.link_to_member)
FROM Attendance AS T1
INNER JOIN Event AS T2
  ON T1.link_to_event = T2.event_id
WHERE
  T2.event_name = "Women's Soccer";
```
=====================
Question: List all the members of the "School of Applied Sciences, Technology and Education" department.
 db_id: student_club
Planner: Plan:
1. Filter the `Major` table to find the `major_id` where the `department` is "School of Applied Sciences, Technology and Education".
2. Join the `Member` table with the filtered `Major` table on `link_to_major` and `major_id` respectively.
3. Select the `first_name` and `last_name` from the joined table to get the full names of the members.

NL2SQL: ```sql
SELECT
  T1.first_name,
  T1.last_name
FROM Member AS T1
INNER JOIN Major AS T2
  ON T1.link_to_major = T2.major_id
WHERE
  T2.department = 'School of Applied Sciences, Technology and Education';
```
Critic: ```sql
SELECT
  first_name,
  last_name
FROM Member
WHERE
  link_to_major IN (
    SELECT
      major_id
    FROM Major
    WHERE
      department = 'School of Applied Sciences, Technology and Education'
  );
```
=====================
Question: Among all the closed events, which event has the highest spend-to-budget ratio?
 db_id: student_club
Planner: Plan:
1. Filter the `Event` table to get events where `status` is 'Closed'.
2. Join the `Budget` table with the filtered `Event` table on `event_id` and `link_to_event` respectively.
3. Calculate the spend-to-budget ratio for each event by dividing `spent` by `amount` in the `Budget` table.
4. Find the event with the maximum spend-to-budget ratio.
5. Select the `event_name` of the event with the highest ratio.

NL2SQL: ```sql
SELECT
  T1.event_name
FROM Event AS T1
INNER JOIN Budget AS T2
  ON T1.event_id = T2.link_to_event
WHERE
  T1.status = 'Closed'
ORDER BY
  T2.spent / T2.amount DESC
LIMIT 1;
```
Critic: ```sql
SELECT
  T1.event_name
FROM Event AS T1
INNER JOIN Budget AS T2
  ON T1.event_id = T2.link_to_event
WHERE
  T1.status = 'Closed' AND T2.amount != 0
ORDER BY
  T2.spent / T2.amount DESC
LIMIT 1;
```
=====================
Question: What is the highest amount of budget spend for an event?
 db_id: student_club
Planner: 1. Select the maximum value from the 'spent' column in the 'Budget' table.

NL2SQL: ```sql
SELECT max(spent) FROM Budget
```
Critic: ```sql
SELECT MAX(Amount) FROM Budget
```
=====================
Question: What is the total amount of money spent for food?
 db_id: student_club
Planner: 1.  **Table Selection:** We need the `Budget` table as it contains information about budgeted amounts for different categories and amounts spent.
2.  **Filtering:** Filter the `Budget` table to include only records where the `category` is 'Food'.
3.  **Aggregation:** Calculate the sum of the `spent` column for the filtered records. This will give the total amount spent on food.

NL2SQL: ```sql
SELECT
  SUM(spent)
FROM Budget
WHERE
  category = 'Food';
```
Critic: ```sql
SELECT
  SUM(T1.cost)
FROM Expense AS T1
INNER JOIN Budget AS T2
  ON T1.link_to_budget = T2.budget_id
WHERE
  T2.category = 'Food';
```
=====================
Question: List the name of students that have attended more than 7 events.
 db_id: student_club
Planner: 1.  Join the `Attendance` table with the `Member` table on `link_to_member` to link attendance records with member information.
2.  Group the results by `member_id`, `first_name`, and `last_name` to count the number of events attended by each student.
3.  Filter the grouped results to include only those students who have attended more than 7 events (`COUNT(link_to_event) > 7`).
4.  Select the `first_name` and `last_name` of the students who meet the criteria.
NL2SQL: ```sql
SELECT
  T1.first_name,
  T1.last_name
FROM Member AS T1
INNER JOIN Attendance AS T2
  ON T1.member_id = T2.link_to_member
GROUP BY
  T1.member_id,
  T1.first_name,
  T1.last_name
HAVING
  COUNT(T2.link_to_event) > 7;
```
Critic: ```sql
SELECT
  T1.first_name,
  T1.last_name
FROM Member AS T1
INNER JOIN Attendance AS T2
  ON T1.member_id = T2.link_to_member
GROUP BY
  T1.member_id
HAVING
  COUNT(T2.link_to_event) > 7;
```
=====================
Question: Which student has been entrusted to manage the budget for the Yearly Kickoff?
 db_id: student_club
Planner: Plan:
1. Find the `event_id` for the event named 'Yearly Kickoff' from the `Event` table.
2. Use the `event_id` to find the corresponding `budget_id` from the `Budget` table.
3. Use the `budget_id` to find the `link_to_member` from the `Expense` table.
4. Use the `link_to_member` to find the first name and last name from the `Member` table.
5. Concatenate first name and last name to get full name.

Tables:
*   `Event`: To find the `event_id` of the 'Yearly Kickoff' event.
*   `Budget`: To find the `budget_id` associated with the event.
*   `Expense`: To find the `link_to_member` associated with the `budget_id`.
*   `Member`: To find the first name and last name of the member.

Columns:
*   `Event`: `event_id`, `event_name`
*   `Budget`: `budget_id`, `link_to_event`
*   `Expense`: `link_to_member`, `link_to_budget`
*   `Member`: `member_id`, `first_name`, `last_name`

Filters:
*   `Event`: `event_name` = 'Yearly Kickoff'

Joins:
*   `Event` and `Budget` on `Event.event_id` = `Budget.link_to_event`
*   `Budget` and `Expense` on `Budget.budget_id` = `Expense.link_to_budget`
*   `Expense` and `Member` on `Expense.link_to_member` = `Member.member_id`

NL2SQL: ```sql
SELECT
  T1.first_name,
  T1.last_name
FROM Member AS T1
INNER JOIN Expense AS T2
  ON T1.member_id = T2.link_to_member
INNER JOIN Budget AS T3
  ON T2.link_to_budget = T3.budget_id
INNER JOIN Event AS T4
  ON T3.link_to_event = T4.event_id
WHERE
  T4.event_name = 'Yearly Kickoff';
```
Critic: ```sql
SELECT
  T1.first_name,
  T1.last_name
FROM Member AS T1
INNER JOIN Expense AS T2
  ON T1.member_id = T2.link_to_member
INNER JOIN Budget AS T3
  ON T2.link_to_budget = T3.budget_id
INNER JOIN Event AS T4
  ON T3.link_to_event = T4.event_id
WHERE
  T4.event_name = 'Yearly Kickoff';
```
=====================
Question: Which event has the lowest cost?
 db_id: student_club
Planner: The question asks to find the event with the lowest cost. The `Expense` table contains the cost of expenses. The `Budget` table contains budget information for events. The `Event` table contains the event names. We should join `Expense` table with `Budget` table using `link_to_budget`, and `Budget` table with `Event` table using `link_to_event`. Select `event_name` from `Event` table and `cost` from `Expense` table and find the event with the minimum cost.
Plan:
1. Join `Expense` and `Budget` on `link_to_budget`.
2. Join the result with `Event` on `link_to_event`.
3. Find the minimum cost and corresponding `event_name`.
4. Return the `event_name`.

NL2SQL: ```sql
SELECT
  T1.event_name
FROM Event AS T1
INNER JOIN Budget AS T2
  ON T1.event_id = T2.link_to_event
INNER JOIN Expense AS T3
  ON T2.budget_id = T3.link_to_budget
ORDER BY
  T3.cost
LIMIT 1;
```
Critic: ```sql
SELECT
  T1.event_name
FROM Event AS T1
INNER JOIN Budget AS T2
  ON T1.event_id = T2.link_to_event
INNER JOIN Expense AS T3
  ON T2.budget_id = T3.link_to_budget
ORDER BY
  T3.cost
LIMIT 1;
```
=====================
Question: Based on the total cost for all event, what is the percentage of cost for Yearly Kickoff event?
 db_id: student_club
Planner: Here's a plan to calculate the percentage of cost for the 'Yearly Kickoff' event based on the total cost of all events:

1.  **Calculate the total cost for all events:** We need to sum the `cost` column from the `Expense` table, joining `Expense` with `Budget` using `link_to_budget` and then `Budget` with `Event` using `link_to_event`. This will give us the total cost across all events.
2.  **Calculate the cost for the 'Yearly Kickoff' event:**  We need to sum the `cost` column from the `Expense` table, but filter the event name to be 'Yearly Kickoff' by joining `Expense` with `Budget` using `link_to_budget` and then `Budget` with `Event` using `link_to_event`.
3.  **Calculate the percentage:** Divide the cost of 'Yearly Kickoff' by the total cost of all events and multiply by 100.

Required Tables: `Expense`, `Budget`, `Event`
Required Columns: `Expense`.`cost`, `Budget`.`link_to_event`, `Budget`.`budget_id`, `Event`.`event_name`
Joins: `Expense` with `Budget` on `Expense`.`link_to_budget` = `Budget`.`budget_id`, `Budget` with `Event` on `Budget`.`link_to_event` = `Event`.`event_id`
Filters: `Event`.`event_name` = 'Yearly Kickoff' for the Yearly Kickoff event cost calculation.
Aggregations: `SUM(Expense.cost)` for the total cost of all events and the cost of 'Yearly Kickoff' event.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T2.event_name = 'Yearly Kickoff' THEN T1.cost ELSE 0 END) AS REAL) * 100 / SUM(T1.cost)
FROM Expense AS T1
INNER JOIN Budget AS T3
  ON T1.link_to_budget = T3.budget_id
INNER JOIN Event AS T2
  ON T3.link_to_event = T2.event_id;
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T2.event_name = 'Yearly Kickoff' THEN T1.cost ELSE 0 END) AS REAL) * 100 / SUM(T1.cost)
FROM Expense AS T1
INNER JOIN Budget AS T3
  ON T1.link_to_budget = T3.budget_id
INNER JOIN Event AS T2
  ON T3.link_to_event = T2.event_id;
```
=====================
Question: Indicate the top source of funds received in September 2019 based on their amount.
 db_id: student_club
Planner: 1.  Filter the Income table to include records where the date\_received is in September 2019.
2.  Group the filtered data by the source column and calculate the sum of the amount for each source.
3.  Order the results in descending order based on the total amount.
4.  Select the source with the highest total amount.

NL2SQL: ```sql
SELECT source FROM Income WHERE date_received BETWEEN '2019-09-01' AND '2019-09-30' GROUP BY source ORDER BY sum(amount) DESC LIMIT 1
```
Critic: ```sql
SELECT source FROM Income WHERE date_received LIKE '2019-09%' GROUP BY source ORDER BY sum(amount) DESC LIMIT 1
```
=====================
Question: How many members of the Student_Club have major in 'Physics Teaching'?
 db_id: student_club
Planner: 1. We need to find the number of members whose major is 'Physics Teaching'.
2. We need to use the `Major` table to find the `major_id` for 'Physics Teaching'.
3. We need to use the `Member` table and filter by `link_to_major` to count the number of members who have that major.
4. We need to perform a COUNT aggregate function to determine the number of members.

Tables: `Major`, `Member`
Columns: `Major`.`major_name`, `Major`.`major_id`, `Member`.`link_to_major`
Filters: `Major`.`major_name` = 'Physics Teaching'
Joins: None (all information is accessible via filters and the desired column)
Aggregation: COUNT(`Member`.`member_id`)

NL2SQL: ```sql
SELECT
  COUNT(T1.member_id)
FROM Member AS T1
INNER JOIN Major AS T2
  ON T1.link_to_major = T2.major_id
WHERE
  T2.major_name = 'Physics Teaching';
```
Critic: ```sql
SELECT
  COUNT(member_id)
FROM Member
WHERE
  link_to_major IN (
    SELECT
      major_id
    FROM Major
    WHERE
      major_name = 'Physics Teaching'
  );
```
=====================
Question: Name the event with the highest amount spent on advertisement.
 db_id: student_club
Planner: 1.  Find the amount spent on advertisement for each event from the Budget table where category is 'Advertisement'.
2.  Find the maximum amount spent.
3.  Join Event table and Budget table on link_to_event and find the corresponding event name for the maximum amount spent on advertisement.

NL2SQL: ```sql
SELECT
  T1.event_name
FROM Event AS T1
INNER JOIN Budget AS T2
  ON T1.event_id = T2.link_to_event
WHERE
  T2.category = 'Advertisement'
ORDER BY
  T2.spent DESC
LIMIT 1;
```
Critic: ```sql
SELECT
  T1.event_name
FROM Event AS T1
INNER JOIN Budget AS T2
  ON T1.event_id = T2.link_to_event
WHERE
  T2.category = 'Advertisement'
ORDER BY
  T2.spent DESC
LIMIT 1;
```
=====================
Question: Did Maya Mclean attend the 'Women's Soccer' event?
 db_id: student_club
Planner: Plan:
1. Find the `member_id` of the member named 'Maya Mclean' from the `Member` table.
2. Find the `event_id` of the event named 'Women's Soccer' from the `Event` table.
3. Check if there is a record in the `Attendance` table with the `member_id` and `event_id` found in the previous steps.
4. Return 'Yes' if such a record exists, and 'No' otherwise.

Tables:
- `Member`: To find the `member_id` of Maya Mclean.
- `Event`: To find the `event_id` of 'Women's Soccer'.
- `Attendance`: To check if Maya Mclean attended the 'Women's Soccer' event.

Columns:
- `Member.member_id`, `Member.first_name`, `Member.last_name`
- `Event.event_id`, `Event.event_name`
- `Attendance.link_to_member`, `Attendance.link_to_event`

Filters:
- `Member.first_name = 'Maya'` and `Member.last_name = 'Mclean'`
- `Event.event_name = 'Women\'s Soccer'`

Joins:
- None

NL2SQL: ```sql
SELECT
  CASE
    WHEN EXISTS(
      SELECT
        1
      FROM Member AS T1
      INNER JOIN Attendance AS T2
        ON T1.member_id = T2.link_to_member
      INNER JOIN Event AS T3
        ON T2.link_to_event = T3.event_id
      WHERE
        T1.first_name = 'Maya' AND T1.last_name = 'Mclean' AND T3.event_name = 'Women''s Soccer'
    )
    THEN 'Yes'
    ELSE 'No'
  END;
```
Critic: ```sql
SELECT
  CASE WHEN EXISTS (
    SELECT
      1
    FROM Member AS T1
    INNER JOIN Attendance AS T2
      ON T1.member_id = T2.link_to_member
    INNER JOIN Event AS T3
      ON T2.link_to_event = T3.event_id
    WHERE
      T1.first_name = 'Maya' AND T1.last_name = 'Mclean' AND T3.event_name = 'Women''s Soccer'
  ) THEN 'Yes' ELSE 'No' END;
```
=====================
Question: Indicate the cost of posters for 'September Speaker' event.
 db_id: student_club
Planner: 1. Find the `event_id` for the event named 'September Speaker' from the `Event` table.
2. Use the `event_id` to find the corresponding `budget_id` in the `Budget` table where the category is 'advertisement'.
3. Use the `budget_id` to filter the `Expense` table to find the expenses for posters.
4. Return the `cost` from the `Expense` table.
The tables needed are `Event`, `Budget`, and `Expense`.
The join conditions are `Event.event_id` = `Budget.link_to_event` and `Budget.budget_id` = `Expense.link_to_budget`.
Filters are `Event.event_name` = 'September Speaker' and `Budget.category` = 'advertisement' and `Expense.expense_description` = 'Posters'.
The final column to display is `Expense.cost`.

NL2SQL: ```sql
SELECT
  T1.cost
FROM Expense AS T1
INNER JOIN Budget AS T2
  ON T1.link_to_budget = T2.budget_id
INNER JOIN Event AS T3
  ON T2.link_to_event = T3.event_id
WHERE
  T3.event_name = 'September Speaker' AND T1.expense_description = 'Posters';
```
Critic: ```sql
SELECT
  T1.cost
FROM Expense AS T1
INNER JOIN Budget AS T2
  ON T1.link_to_budget = T2.budget_id
INNER JOIN Event AS T3
  ON T2.link_to_event = T3.event_id
WHERE
  T3.event_name = 'September Speaker' AND T1.expense_description = 'Posters';
```
=====================
Question: Indicate the name of the closed event whose cost has exceeded the budget the most.
 db_id: student_club
Planner: 1.  Find closed events: Filter the 'Event' table for events where status = 'Closed'.
2.  Calculate budget overrun for each event: Join 'Budget' and 'Event' tables on link_to_event = event_id. Filter for negative 'remaining' values (spent > amount). Group by event_id and calculate the minimum remaining for each event.
3.  Find the event with the most overrun: Order the results from step 2 by remaining in ascending order and select the event with the smallest remaining value.
4.  Retrieve the event name: Select event_name.

NL2SQL:
```sql
SELECT
  T1.event_name
FROM Event AS T1
INNER JOIN Budget AS T2
  ON T1.event_id = T2.link_to_event
WHERE
  T1.status = 'Closed'
GROUP BY
  T1.event_name
ORDER BY
  SUM(T2.remaining)
LIMIT 1;
```
NL2SQL: ```sql
SELECT
  T1.event_name
FROM Event AS T1
INNER JOIN Budget AS T2
  ON T1.event_id = T2.link_to_event
WHERE
  T1.status = 'Closed'
GROUP BY
  T1.event_name
ORDER BY
  SUM(T2.spent - T2.amount)
LIMIT 1;
```
Critic: ```sql
SELECT
  T1.event_name
FROM Event AS T1
INNER JOIN Budget AS T2
  ON T1.event_id = T2.link_to_event
WHERE
  T1.status = 'Closed'
GROUP BY
  T1.event_name
ORDER BY
  SUM(T2.amount - T2.spent)
LIMIT 1;
```
=====================
Question: Identify the type of expenses and their total value approved for 'October Meeting' event.
 db_id: student_club
Planner: 1. **Find the `event_id` for the event named 'October Meeting' from the `Event` table.**
2. **Join the `Budget` table with the `Event` table using `link_to_event` and `event_id` to filter `budget` records related to 'October Meeting'.**
3. **Join the `Expense` table with the `Budget` table on `link_to_budget` and `budget_id` to retrieve expenses related to 'October Meeting'.**
4. **Filter the `Expense` table to include only approved expenses (`approved` = 'TRUE').**
5. **Group the results by `expense_description` (expense type).**
6. **Calculate the sum of the `cost` for each expense type.**
7. **Return the `expense_description` and the sum of `cost` as total_value.**

NL2SQL: ```sql
SELECT
  T1.expense_description,
  SUM(T1.cost) AS total_value
FROM Expense AS T1
INNER JOIN Budget AS T2
  ON T1.link_to_budget = T2.budget_id
INNER JOIN Event AS T3
  ON T2.link_to_event = T3.event_id
WHERE
  T3.event_name = 'October Meeting' AND T1.approved = 'TRUE'
GROUP BY
  T1.expense_description;
```
Critic: ```sql
SELECT
  T1.expense_description,
  SUM(T1.cost)
FROM Expense AS T1
INNER JOIN Budget AS T2
  ON T1.link_to_budget = T2.budget_id
INNER JOIN Event AS T3
  ON T2.link_to_event = T3.event_id
WHERE
  T3.event_name = 'October Meeting'
GROUP BY
  T1.expense_description;
```
=====================
Question: Calculate the amount budgeted for 'April Speaker' event. List all the budgeted categories for said event in an ascending order based on their amount budgeted.
 db_id: student_club
Planner: 1.  **Find the `event_id` for the 'April Speaker' event:** Use the `Event` table and filter by `event_name` = 'April Speaker'.
2.  **Retrieve budget information for the specific event:** Use the `Budget` table and filter by `link_to_event` using the `event_id` found in the previous step.
3.  **Select the `category` and `amount` columns** from the `Budget` table.
4.  **Order the result set** by `amount` in ascending order.

NL2SQL: ```sql
SELECT
  category,
  amount
FROM Budget
WHERE
  link_to_event = (
    SELECT
      event_id
    FROM Event
    WHERE
      event_name = 'April Speaker'
  )
ORDER BY
  amount ASC;
```
Critic: ```sql
SELECT
  category,
  amount
FROM Budget
WHERE
  link_to_event = (
    SELECT
      event_id
    FROM Event
    WHERE
      event_name = 'April Speaker'
  )
ORDER BY
  amount ASC;
```
=====================
Question: Mention the total expense used on 8/20/2019.
 db_id: student_club
Planner: 1.  **Table**: Expense
2.  **Columns**:
    *   `cost`: To calculate the total expense.
    *   `expense_date`: To filter expenses by date.
3.  **Filters**:
    *   Filter the `Expense` table for rows where `expense_date` is equal to '2019-08-20'.
4.  **Aggregate**:
    *   Calculate the sum of the `cost` for the filtered rows to get the total expense.


NL2SQL: ```sql
SELECT sum(cost) FROM Expense WHERE expense_date = '2019-08-20'
```
Critic: ```sql
SELECT sum(cost) FROM expense WHERE expense_date = '08/20/2019'
```
=====================
Question: List out the full name and total cost that member id "rec4BLdZHS2Blfp4v" incurred?
 db_id: student_club
Planner: Plan:
1. Find the first name and last name of the member with member_id "rec4BLdZHS2Blfp4v" from the Member table.
2. Find the total cost incurred by the member with member_id "rec4BLdZHS2Blfp4v" from the Expense table by filtering on link_to_member and summing the cost.
3. Combine the first name, last name, and total cost.
Tables needed: Member, Expense
Columns needed: Member.first_name, Member.last_name, Expense.cost, Expense.link_to_member, Member.member_id
Filters: Member.member_id = "rec4BLdZHS2Blfp4v", Expense.link_to_member = "rec4BLdZHS2Blfp4v"
Joins: None
Aggregations: SUM(Expense.cost)
Final Result: first_name, last_name, total_cost

NL2SQL: ```sql
SELECT
  T1.first_name,
  T1.last_name,
  SUM(T2.cost)
FROM Member AS T1
JOIN Expense AS T2
  ON T1.member_id = T2.link_to_member
WHERE
  T1.member_id = 'rec4BLdZHS2Blfp4v';
```
Critic: ```sql
SELECT
  T1.first_name,
  T1.last_name,
  SUM(T2.cost)
FROM Member AS T1
INNER JOIN Expense AS T2
  ON T1.member_id = T2.link_to_member
WHERE
  T1.member_id = 'rec4BLdZHS2Blfp4v'
GROUP BY
  T1.first_name,
  T1.last_name;
```
=====================
Question: State what kind of expenses that Sacha Harrison incurred?
 db_id: student_club
Planner: 1. Find the `member_id` of Sacha Harrison from the `Member` table using `first_name` and `last_name`.
2. Use the `member_id` to filter the `Expense` table via `link_to_member`.
3. Retrieve the `expense_description` from the `Expense` table.

NL2SQL: ```sql
SELECT
  T1.expense_description
FROM Expense AS T1
INNER JOIN Member AS T2
  ON T1.link_to_member = T2.member_id
WHERE
  T2.first_name = 'Sacha' AND T2.last_name = 'Harrison';
```
Critic: ```sql
SELECT
  T1.expense_description
FROM Expense AS T1
INNER JOIN Member AS T2
  ON T1.link_to_member = T2.member_id
WHERE
  T2.first_name = 'Sacha' AND T2.last_name = 'Harrison';
```
=====================
Question: State the category of events were held at MU 215.
 db_id: student_club
Planner: 1. Find the `event_id` for events held at location 'MU 215' from the `Event` table using a WHERE clause to filter by location.
2. Retrieve the `type` (category) of those events from the `Event` table.

NL2SQL: ```sql
SELECT
  type
FROM Event
WHERE
  location = 'MU 215';
```
Critic: ```sql
SELECT
  Type
FROM Event
WHERE
  Location = 'MU 215';
```
=====================
Question: List the last name of members with a major in environmental engineering and include its department and college name.
 db_id: student_club
Planner: 1.  **Identify the tables needed:**
    *   `Member`: To get the last name of members.
    *   `Major`: To filter by major name and get department and college names.
2.  **Join the tables:**
    *   Join `Member` and `Major` using `Member.link_to_major = Major.major_id`.
3.  **Filter the results:**
    *   Filter by `Major.major_name = 'Environmental Engineering'`.
4.  **Select the desired columns:**
    *   Select `Member.last_name`, `Major.department`, and `Major.college`.

NL2SQL: ```sql
SELECT
  m.last_name,
  mj.department,
  mj.college
FROM Member AS m
JOIN Major AS mj
  ON m.link_to_major = mj.major_id
WHERE
  mj.major_name = 'Environmental Engineering';
```
Critic: ```sql
SELECT
  T1.last_name,
  T2.department,
  T2.college
FROM Member AS T1
INNER JOIN Major AS T2
  ON T1.link_to_major = T2.major_id
WHERE
  T2.major_name = 'Environmental Engineering';
```
=====================
Question: What are the budget category of the events located at MU 215 and a guest speaker type with a 0 budget spent?
 db_id: student_club
Planner: 1.  Filter the Event table to select events where the location is 'MU 215' and type is 'Guest Speaker'.
2.  Join the Event table with the Budget table on `event_id` = `link_to_event`.
3.  Filter the result of the join to select rows where spent is 0.
4.  Select the category from the Budget table.

NL2SQL: ```sql
SELECT
  T2.category
FROM Event AS T1
INNER JOIN Budget AS T2
  ON T1.event_id = T2.link_to_event
WHERE
  T1.location = 'MU 215' AND T1.type = 'Guest Speaker' AND T2.spent = 0;
```
Critic: ```sql
SELECT
  T1.category
FROM Budget AS T1
INNER JOIN Event AS T2
  ON T1.link_to_event = T2.event_id
WHERE
  T2.location = 'MU 215' AND T2.type = 'Guest Speaker' AND T1.spent = 0;
```
=====================
Question: Among the members with t-shirt size of medium, what is the percentage of the amount 50 received by the Student_Club?
 db_id: student_club
Planner: Plan:
1. Find all members with t-shirt size 'Medium' using the `Member` table.
2. Filter the `Income` table to find income records where the amount is 50.
3. Join the `Member` and `Income` tables using `member_id` and `link_to_member` to find the members with t-shirt size 'Medium' who received an amount of 50.
4. Calculate the number of members with t-shirt size 'Medium' who received an amount of 50.
5. Calculate the total number of members with t-shirt size 'Medium'.
6. Divide the number of members with t-shirt size 'Medium' who received an amount of 50 by the total number of members with t-shirt size 'Medium', then multiply by 100 to get the percentage.
7. Return the calculated percentage.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.amount = 50 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.amount)
FROM Income AS T1
INNER JOIN Member AS T2
  ON T1.link_to_member = T2.member_id
WHERE
  T2.t_shirt_size = 'Medium';
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.amount = 50 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.amount)
FROM Income AS T1
INNER JOIN Member AS T2
  ON T1.link_to_member = T2.member_id
WHERE
  T2.t_shirt_size = 'M';
```
=====================
Question: List the names of closed event as "game" that was closed from 3/15/2019 to 3/20/2020.
 db_id: student_club
Planner: Plan:
1. Filter the Event table by `type` = 'Game' and `status` = 'Closed'.
2. Filter the Event table by `event_date` between '2019-03-15' and '2020-03-20'.
3. Select the `event_name` column from the filtered Event table.

NL2SQL: ```sql
SELECT
  event_name AS game
FROM Event
WHERE
  type = 'Game' AND status = 'Closed' AND event_date BETWEEN '2019-03-15' AND '2020-03-20';
```
Critic: ```sql
SELECT
  event_name AS game
FROM Event
WHERE
  status = 'Closed' AND event_date BETWEEN '2019-03-15' AND '2020-03-20';
```
=====================
Question: Give the full name and contact number of members who had to spend more than average on each expense.
 db_id: student_club
Planner: Plan:
1. Calculate the average expense cost from the Expense table.
2. Filter the Expense table to include only expenses where the cost is greater than the average expense cost.
3. Join the filtered Expense table with the Member table using the link_to_member column to get member information.
4. Select the first name, last name, and phone number of the members who meet the criteria.

NL2SQL: ```sql
SELECT
  T1.first_name,
  T1.last_name,
  T1.phone
FROM Member AS T1
INNER JOIN Expense AS T2
  ON T1.member_id = T2.link_to_member
WHERE
  T2.cost > (
    SELECT
      AVG(cost)
    FROM Expense
  );
```
Critic: ```sql
SELECT
  T1.first_name,
  T1.last_name,
  T1.phone
FROM Member AS T1
INNER JOIN Expense AS T2
  ON T1.member_id = T2.link_to_member
WHERE
  T2.cost > (
    SELECT
      AVG(cost)
    FROM Expense
  );
```
=====================
Question: Write the full name of the member who spent money for water, veggie tray and supplies and include the cost of it.
 db_id: student_club
Planner: Plan:
1. Filter the `Expense` table for expenses where `expense_description` contains 'Water', 'Veggie tray', and 'supplies'.
2. Join the filtered `Expense` table with the `Member` table on `link_to_member` to retrieve the first name and last name of the member who incurred the expense.
3. Select the first name, last name, and the cost from the joined table.

NL2SQL: ```sql
SELECT
  T1.first_name,
  T1.last_name,
  T2.cost
FROM Member AS T1
JOIN Expense AS T2
  ON T1.member_id = T2.link_to_member
WHERE
  T2.expense_description LIKE '%Water%' AND T2.expense_description LIKE '%Veggie tray%' AND T2.expense_description LIKE '%supplies%';
```
Critic: ```sql
SELECT
  T1.first_name,
  T1.last_name,
  T2.cost
FROM Member AS T1
JOIN Expense AS T2
  ON T1.member_id = T2.link_to_member
WHERE
  T2.expense_description = 'Water, Veggie tray, supplies';
```
=====================
Question: Write the full names of students who received funds on the date of 9/9/2019 and include the amount received.
 db_id: student_club
Planner: Plan:
1. Select the first name and last name from the Member table.
2. Select the amount from the Income table.
3. Filter the Income table by date_received = 9/9/2019.
4. Join the Member table with the Income table using the link_to_member column.

NL2SQL: ```sql
SELECT
  T1.first_name,
  T1.last_name,
  T2.amount
FROM Member AS T1
INNER JOIN Income AS T2
  ON T1.member_id = T2.link_to_member
WHERE
  T2.date_received = '9/9/2019';
```
Critic: ```sql
SELECT
  T1.first_name,
  T1.last_name,
  T2.amount
FROM Member AS T1
INNER JOIN Income AS T2
  ON T1.member_id = T2.link_to_member
WHERE
  T2.date_received = '09/09/2019';
```
=====================
Question: Are there more in-patient or outpatient who were male? What is the deviation in percentage?
 db_id: thrombosis_prediction
Planner: Plan:
1. Count the number of male in-patients. Use the Patient table. Filter for SEX = 'M' and Admission = '+'.
2. Count the number of male outpatients. Use the Patient table. Filter for SEX = 'M' and Admission = '-'.
3. Calculate the percentage deviation between in-patients and outpatients: ABS((inpatient_count - outpatient_count) / outpatient_count) * 100.
4. Return the counts and the percentage deviation.

NL2SQL: ```sql
SELECT
  SUM(CASE WHEN T1.Admission = '+' THEN 1 ELSE 0 END) AS in_patient,
  SUM(CASE WHEN T1.Admission = '-' THEN 1 ELSE 0 END) AS out_patient,
  ABS(
    (
      SUM(CASE WHEN T1.Admission = '+' THEN 1 ELSE 0 END) - SUM(CASE WHEN T1.Admission = '-' THEN 1 ELSE 0 END)
    ) * 1.0 / SUM(CASE WHEN T1.Admission = '-' THEN 1 ELSE 0 END)
  ) * 100 AS percentage_deviation
FROM Patient AS T1
WHERE
  T1.SEX = 'M';
```
Critic: ```sql
SELECT
  SUM(CASE WHEN Admission = '+' THEN 1 ELSE 0 END) AS in_patient_count,
  SUM(CASE WHEN Admission = '-' THEN 1 ELSE 0 END) AS out_patient_count,
  ABS(
    (
      SUM(CASE WHEN Admission = '+' THEN 1 ELSE 0 END) - SUM(CASE WHEN Admission = '-' THEN 1 ELSE 0 END)
    ) * 100.0 / SUM(CASE WHEN Admission = '-' THEN 1 ELSE 0 END)
  ) AS percentage_deviation
FROM Patient
WHERE
  SEX = 'M';
```
=====================
Question: What is the percentage of female patient were born after 1930?
 db_id: thrombosis_prediction
Planner: Plan:
1.  Count the total number of female patients.
2.  Count the number of female patients born after 1930.
3.  Calculate the percentage.

Tables needed: Patient
Columns needed: SEX, Birthday, ID
Filters: SEX = 'F', YEAR(Birthday) > 1930
Aggregate functions: COUNT
Calculation: Divide the count of female patients born after 1930 by the total count of female patients.
NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN STRFTIME('%Y', Birthday) > '1930' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(ID)
FROM Patient
WHERE
  SEX = 'F';
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN STRFTIME('%Y', Birthday) > '1930' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(ID)
FROM Patient
WHERE
  SEX = 'F';
```
=====================
Question: What is the ratio of outpatient to inpatient followed up treatment among all the 'SLE' diagnosed patient?
 db_id: thrombosis_prediction
Planner: Plan:
1. Filter the Patient table for patients with 'SLE' diagnosis.
2. Count the number of SLE patients with Admission '+'.
3. Count the number of SLE patients with Admission '-'.
4. Calculate the ratio of outpatient to inpatient.
5. Divide the result of step 3 by the result of step 2.
Tables: Patient
Columns: ID, Diagnosis, Admission
Filters: Diagnosis = 'SLE', Admission = '+', Admission = '-'
Joins: None
Aggregations: COUNT
Calculations: division to calculate the ratio
Final Answer: The SQL query to implement this plan.
```sql
SELECT
  CAST(SUM(CASE WHEN Admission = '-' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN Admission = '+' THEN 1 ELSE 0 END)
FROM Patient
WHERE
  Diagnosis = 'SLE';
```
NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN Admission = '-' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN Admission = '+' THEN 1 ELSE 0 END)
FROM Patient
WHERE
  Diagnosis = 'SLE';
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN Admission = '-' THEN 1 ELSE 0 END) AS REAL) * 1.0 / SUM(CASE WHEN Admission = '+' THEN 1 ELSE 0 END)
FROM Patient
WHERE
  Diagnosis = 'SLE';
```
=====================
Question: What is the disease patient '30609' diagnosed with. List all the date of laboratory tests done for this patient.
 db_id: thrombosis_prediction
Planner: The question asks for the disease patient '30609' diagnosed with and the date of laboratory tests done for this patient.
1.  Find the diagnosis of the patient from the `Patient` table using the `ID` and `Diagnosis` columns. Filter by `ID = 30609`.
2.  Find the dates of laboratory tests from the `Laboratory` table using the `ID` and `Date` columns. Filter by `ID = 30609`.
3.  Present the results.

NL2SQL: ```sql
SELECT
  T1.Diagnosis,
  T2.Date
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
WHERE
  T1.ID = 30609;
```
Critic: ```sql
SELECT
  Diagnosis,
  Date
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
WHERE
  T1.ID = '30609';
```
=====================
Question: List the patient ID, sex and birthday of patient with LDH beyond normal range.
 db_id: thrombosis_prediction
Planner: Plan:
1.  Join the `Patient` and `Laboratory` tables on the common column `ID`.
2.  Filter the joined table where `LDH` > 500.
3.  Select the `ID`, `SEX`, and `Birthday` columns from the filtered table.

NL2SQL: ```sql
SELECT
  T1.ID,
  T1.SEX,
  T1.Birthday
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
WHERE
  T2.LDH > 500;
```
Critic: ```sql
SELECT
  ID,
  SEX,
  Birthday
FROM Patient
WHERE
  ID IN (
    SELECT
      ID
    FROM Laboratory
    WHERE
      LDH > 500
  );
```
=====================
Question: State the ID and age of patient with positive degree of coagulation.
 db_id: thrombosis_prediction
Planner: Plan:
1. Select the ID and age from the Patient table.
2. Filter patients based on 'RVVT' column value from the Examination table is '+'.
3. Join Patient and Examination tables on the common column 'ID'.

NL2SQL: ```sql
SELECT
  P.ID,
  CAST(SUBSTR(STRFTIME('%Y', 'now'), 3, 2) AS INTEGER) - CAST(SUBSTR(STRFTIME('%Y', P.Birthday), 3, 2) AS INTEGER)
FROM Patient AS P
JOIN Examination AS E
  ON P.ID = E.ID
WHERE
  E.RVVT = '+';
```
Critic: ```sql
SELECT
  P.ID,
  CAST(STRFTIME('%Y', 'now') AS INTEGER) - CAST(STRFTIME('%Y', P.Birthday) AS INTEGER)
FROM Patient AS P
JOIN Examination AS E
  ON P.ID = E.ID
WHERE
  E.RVVT = '+';
```
=====================
Question: For patients with severe degree of thrombosis, list their ID, sex and disease the patient is diagnosed with.
 db_id: thrombosis_prediction
Planner: Plan:
1. Filter the `Examination` table to select patients with `Thrombosis` equal to 2.
2. Join the filtered `Examination` table with the `Patient` table on `ID`.
3. Select the `ID`, `SEX`, and `Diagnosis` columns from the joined table.

NL2SQL: ```sql
SELECT
  p.ID,
  p.SEX,
  p.Diagnosis
FROM Examination AS e
JOIN Patient AS p
  ON e.ID = p.ID
WHERE
  e.Thrombosis = 2;
```
Critic: ```sql
SELECT
  ID,
  SEX,
  Diagnosis
FROM Patient
WHERE
  ID IN (
    SELECT
      ID
    FROM Examination
    WHERE
      Thrombosis = 2
  );
```
=====================
Question: How many female patients who came at the hospital in 1997 was immediately followed at the outpatient clinic?
 db_id: thrombosis_prediction
Planner: 1.  Filter the Patient table to select female patients (`SEX` = 'F') who came to the hospital in 1997 (`Description` year = 1997) and were immediately followed at the outpatient clinic (`Admission` = '-').
2.  Count the number of patients that meet the criteria.

NL2SQL: ```sql
SELECT
  COUNT(ID)
FROM Patient
WHERE
  SEX = 'F' AND STRFTIME('%Y', Description) = '1997' AND Admission = '-';
```
Critic: ```sql
SELECT
  COUNT(ID)
FROM Patient
WHERE
  SEX = 'F' AND STRFTIME('%Y', "First Date") = '1997' AND Admission = '-';
```
=====================
Question: How many of the patients with the most serious thrombosis cases examined in 1997 are women?
 db_id: thrombosis_prediction
Planner: Plan:
1. Filter the Examination table for examinations in 1997 where Thrombosis = 1.
2. Join the filtered Examination table with the Patient table on Patient.ID = Examination.ID.
3. Filter the joined table for patients where SEX = 'F'.
4. Count the number of patients who satisfy these conditions.
5. Return this count.

NL2SQL: ```sql
SELECT
  COUNT(DISTINCT T1.ID)
FROM Patient AS T1
INNER JOIN Examination AS T2
  ON T1.ID = T2.ID
WHERE
  STRFTIME('%Y', T2."Examination Date") = '1997' AND T2.Thrombosis = 1 AND T1.SEX = 'F';
```
Critic: ```sql
SELECT
  COUNT(T1.ID)
FROM Patient AS T1
INNER JOIN Examination AS T2
  ON T1.ID = T2.ID
WHERE
  T1.SEX = 'F' AND T2.Thrombosis = 1 AND STRFTIME('%Y', T2."Examination Date") = '1997';
```
=====================
Question: What are the symptoms observed by the youngest patient to ever did a medical examination? Identify their diagnosis.
 db_id: thrombosis_prediction
Planner: Here's a plan to retrieve the symptoms and diagnosis of the youngest patient who underwent a medical examination:

1.  **Find the youngest patient:**
    *   From the `Patient` table, find the patient with the maximum `Birthday`.
    *   Get the `ID` of this youngest patient.
2.  **Find examinations of the youngest patient:**
    *   Join the `Examination` table with the `Patient` table on `Patient.ID = Examination.ID`
    *   Filter the joined table to include only the examination records related to the youngest patient found in the previous step.
3.  **Retrieve required information:**
    *   Select the `Symptoms` and `Diagnosis` columns from the filtered and joined table.
    *   Filter out rows where `Symptoms` are NULL.

NL2SQL: ```sql
SELECT
  T1.Symptoms,
  T1.Diagnosis
FROM Examination AS T1
INNER JOIN Patient AS T2
  ON T1.ID = T2.ID
WHERE
  T2.Birthday = (
    SELECT
      MAX(Birthday)
    FROM Patient
  )
  AND T1.Symptoms IS NOT NULL;
```
Critic: ```sql
SELECT
  T1.Symptoms,
  T1.Diagnosis
FROM Examination AS T1
INNER JOIN Patient AS T2
  ON T1.ID = T2.ID
WHERE
  T2.Birthday = (
    SELECT
      MAX(Birthday)
    FROM Patient
  );
```
=====================
Question: The oldest SJS patient's medical laboratory work was completed on what date, and what age was the patient when they initially arrived at the hospital?
 db_id: thrombosis_prediction
Planner: Plan:
1. Filter the Patient table to select patients with 'SJS' in their Diagnosis.
2. Find the patient with the minimum birthday from the filtered patients. This is the oldest patient.
3. Join the Laboratory table with the filtered Patient table on Patient.ID = Laboratory.ID.
4. Find the maximum Date from the Laboratory table for the oldest patient. This is the latest laboratory test date.
5. Calculate the age of the patient when they first came to the hospital using `First Date` and `Birthday` in the Patient table.
6. Output the latest laboratory test date and the calculated age.

NL2SQL: ```sql
SELECT
  MAX(T2.Date),
  (
    CAST(SUBSTR(T2."Date", 1, 4) AS INTEGER) - CAST(SUBSTR(T1.Birthday, 1, 4) AS INTEGER)
  )
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
WHERE
  T1.Diagnosis = 'SJS'
ORDER BY
  T1.Birthday
LIMIT 1;
```
Critic: ```sql
SELECT
  T2.Date,
  CAST(SUBSTR(T2.Date, 1, 4) AS INTEGER) - CAST(SUBSTR(T1.Birthday, 1, 4) AS INTEGER)
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
WHERE
  T1.Diagnosis = 'SJS'
ORDER BY
  T1.Birthday
LIMIT 1;
```
=====================
Question: What is the ratio of male to female patients among all those with abnormal uric acid counts?
 db_id: thrombosis_prediction
Planner: Plan:
1. Filter the `Patient` table to get the sex of each patient.
2. Filter the `Laboratory` table to get the uric acid (UA) levels for each patient.
3. Join the `Patient` and `Laboratory` tables on the patient ID.
4. Filter the joined table to include only patients with abnormal uric acid levels based on their sex (UA <= 8.0 for males and UA <= 6.5 for females).
5. Count the number of male patients with abnormal uric acid levels.
6. Count the number of female patients with abnormal uric acid levels.
7. Calculate the ratio of male to female patients with abnormal uric acid levels by dividing the male count by the female count.
8. Return the calculated ratio.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.SEX = 'M' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN T1.SEX = 'F' THEN 1 ELSE 0 END)
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
WHERE
  (
    T1.SEX = 'M' AND T2.UA <= 8.0
  )
  OR (
    T1.SEX = 'F' AND T2.UA <= 6.5
  );
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.SEX = 'M' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN T1.SEX = 'F' THEN 1 ELSE 0 END)
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
WHERE
  (
    T1.SEX = 'M' AND T2.UA > 8.0
  )
  OR (
    T1.SEX = 'F' AND T2.UA > 6.5
  );
```
=====================
Question: How many underage patients were examined during the course of the three-year period from 1990 to 1993?
 db_id: thrombosis_prediction
Planner: Plan:
1. Filter the Patient table to find patients whose age at the time of examination (Examination Date - Birthday) was less than 18.
2. Filter the Examination table to find examinations performed between 1990 and 1993.
3. Join the filtered Patient and Examination tables on the ID column.
4. Count the number of distinct patient IDs in the joined table.

NL2SQL: ```sql
SELECT
  COUNT(DISTINCT T1.ID)
FROM Patient AS T1
INNER JOIN Examination AS T2
  ON T1.ID = T2.ID
WHERE
  CAST(SUBSTR(T2."Examination Date", 1, 4) AS INTEGER) BETWEEN 1990 AND 1993
  AND CAST(SUBSTR(T2."Examination Date", 1, 4) AS INTEGER) - CAST(SUBSTR(T1.Birthday, 1, 4) AS INTEGER) < 18;
```
Critic: ```sql
SELECT
  COUNT(DISTINCT T1.ID)
FROM Patient AS T1
INNER JOIN Examination AS T2
  ON T1.ID = T2.ID
WHERE
  STRFTIME('%Y', T2."Examination Date") BETWEEN '1990' AND '1993'
  AND STRFTIME('%Y', T2."Examination Date") - STRFTIME('%Y', T1.Birthday) < 18;
```
=====================
Question: How old was the patient who had the highest hemoglobin count at the time of the examination, and what is the doctor's diagnosis?
 db_id: thrombosis_prediction
Planner: Here's a plan to determine the age of the patient with the highest hemoglobin and their diagnosis:

1.  **Find the highest Hemoglobin (HGB) value:** Select the maximum value from the HGB column in the Laboratory table.
2.  **Find the patient ID associated with the highest HGB:** Find the Patient ID from the Laboratory table where HGB is equal to the maximum HGB.
3.  **Join Patient and Examination tables:** Join the Patient and Examination tables on the common ID column.
4.  **Filter based on Patient ID:** Filter the result of the join based on the patient ID obtained in Step 2.
5.  **Calculate Age:** Calculate the age of the patient by subtracting the birth year from the examination year.
6.  **Select Age and Diagnosis:** Select the calculated age and the diagnosis from the Patient table.

NL2SQL: ```sql
SELECT
  CAST(STRFTIME('%Y', T1."Examination Date") AS INTEGER) - CAST(STRFTIME('%Y', T2.Birthday) AS INTEGER),
  T2.Diagnosis
FROM Examination AS T1
INNER JOIN Patient AS T2
  ON T1.ID = T2.ID
WHERE
  T1.ID = (
    SELECT
      ID
    FROM Laboratory
    ORDER BY
      HGB DESC
    LIMIT 1
  );
```
Critic: ```sql
SELECT
  STRFTIME('%Y', T1."Examination Date") - STRFTIME('%Y', T2.Birthday),
  T2.Diagnosis
FROM Examination AS T1
INNER JOIN Patient AS T2
  ON T1.ID = T2.ID
WHERE
  T1.ID = (
    SELECT
      ID
    FROM Laboratory
    ORDER BY
      HGB DESC
    LIMIT 1
  );
```
=====================
Question: For the patient who was diagnosed with SLE on 1994/2/19, what was his/her anti-Cardiolipin antibody concentration status on 1993/11/12?
 db_id: thrombosis_prediction
Planner: Plan:
1. Find the patient ID from the Patient table who was diagnosed with SLE on 1994-02-19.
2. Using the patient ID, find the anti-Cardiolipin antibody concentration status (aCL IgG) on 1993-11-12 from the Examination table.

Tables: Patient, Examination
Columns:
*   Patient: ID, Diagnosis, Description
*   Examination: ID, Examination Date, aCL IgG

Filters:
*   Patient: Diagnosis = 'SLE', Description = '1994-02-19'
*   Examination: Examination Date = '1993-11-12'

Joins:
*   Patient.ID = Examination.ID

NL2SQL: ```sql
SELECT
  T2."aCL IgG"
FROM Patient AS T1
INNER JOIN Examination AS T2
  ON T1.ID = T2.ID
WHERE
  T1.Diagnosis = 'SLE' AND T1.Description = '1994-02-19' AND T2."Examination Date" = '1993-11-12';
```
Critic: ```sql
SELECT
  T1."aCL IgG"
FROM Examination AS T1
INNER JOIN Patient AS T2
  ON T1.ID = T2.ID
WHERE
  T2.Diagnosis = 'SLE' AND T2.Description = '1994-02-19' AND T1."Examination Date" = '1993-11-12';
```
=====================
Question: For the patient who was born on 1959/2/18, what is the decrease rate for his/her total cholesterol from November to December in 1981?
 db_id: thrombosis_prediction
Planner: Here's a plan to determine the decrease rate of total cholesterol for a specific patient:

1.  **Identify the patient:** Use the `Patient` table to find the patient with `Birthday = '1959-02-18'`. Get the `ID` of this patient.
2.  **Retrieve cholesterol levels for November 1981:** Use the `Laboratory` table, filter by the patient's `ID` (obtained in step 1) and `Date` between '1981-11-01' and '1981-11-30'. Select `T-CHO` (total cholesterol) for these records. Compute the average of 'T-CHO' for this month.
3.  **Retrieve cholesterol levels for December 1981:** Use the `Laboratory` table, filter by the patient's `ID` (obtained in step 1) and `Date` between '1981-12-01' and '1981-12-31'. Select `T-CHO` (total cholesterol) for these records. Compute the average of 'T-CHO' for this month.
4.  **Calculate the decrease rate:**
    *   Subtract the average December `T-CHO` from the average November `T-CHO`.
    *   Divide the result by the average November `T-CHO`.
    *   Multiply by 100 to express the rate as a percentage.

Tables: `Patient`, `Laboratory`
Columns: `Patient.ID`, `Patient.Birthday`, `Laboratory.ID`, `Laboratory.Date`, `Laboratory.T-CHO`
Joins: None (Patient.ID = Laboratory.ID is implicit in the filtering)
Filters: `Patient.Birthday = '1959-02-18'`, `Laboratory.Date` within specified ranges for November and December 1981.
Aggregations: Average of `Laboratory.T-CHO` for November and December.
Calculations: Decrease rate based on the average `T-CHO` values.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN STRFTIME('%Y-%m', Date) = '1981-11' THEN `T-CHO` ELSE 0 END) - SUM(CASE WHEN STRFTIME('%Y-%m', Date) = '1981-12' THEN `T-CHO` ELSE 0 END) AS REAL) * 100 / SUM(CASE WHEN STRFTIME('%Y-%m', Date) = '1981-11' THEN `T-CHO` ELSE 0 END)
FROM Laboratory
WHERE
  ID = (
    SELECT
      ID
    FROM Patient
    WHERE
      Birthday = '1959-02-18'
  )
  AND STRFTIME('%Y', Date) = '1981'
  AND STRFTIME('%m', Date) IN ('11', '12');
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN STRFTIME('%Y-%m', Date) = '1981-11' THEN `T-CHO` ELSE 0 END) - SUM(CASE WHEN STRFTIME('%Y-%m', Date) = '1981-12' THEN `T-CHO` ELSE 0 END) AS REAL) * 100 / SUM(CASE WHEN STRFTIME('%Y-%m', Date) = '1981-11' THEN `T-CHO` ELSE 0 END)
FROM Laboratory
WHERE
  ID IN (
    SELECT
      ID
    FROM Patient
    WHERE
      Birthday = '1959-02-18'
  )
  AND STRFTIME('%Y', Date) = '1981'
  AND STRFTIME('%m', Date) IN ('11', '12');
```
=====================
Question: How many patients who were examined between 1987/7/6 and 1996/1/31 had a GPT level greater than 30 and an ALB level less than 4? List them by their ID.
 db_id: thrombosis_prediction
Planner: Plan:
1. Select the ID from the Laboratory table.
2. Filter the Laboratory table based on the conditions: Date BETWEEN '1987-07-06' AND '1996-01-31', GPT > 30, and ALB < 4.
3. Return the distinct IDs.

NL2SQL: ```sql
SELECT DISTINCT ID FROM Laboratory WHERE Date BETWEEN '1987-07-06' AND '1996-01-31' AND GPT > 30 AND ALB < 4
```
Critic: ```sql
SELECT DISTINCT ID FROM Laboratory WHERE Date BETWEEN '1987-07-06' AND '1996-01-31' AND GPT > 30 AND ALB < 4
```
=====================
Question: What number of patients with a degree of thrombosis level 2 and ANA pattern of only S, have a level of anti-Cardiolip in antibody (IgM) 20% higher than average?
 db_id: thrombosis_prediction
Planner: Here's a plan to address the question:

1.  **Calculate the average aCL IgM:** Calculate the average of the 'aCL IgM' column from the 'Examination' table.
2.  **Calculate 20% higher than the average:** Multiply the calculated average by 0.2 and add it to the original average to determine the threshold.
3.  **Filter for Thrombosis level 2 and ANA pattern 'S':** Filter the 'Examination' table for rows where 'Thrombosis' is equal to 2 and 'ANA Pattern' is equal to 'S'.
4.  **Filter for aCL IgM above the threshold:** Filter the results from step 3 to include only patients where 'aCL IgM' is greater than the threshold calculated in step 2.
5.  **Count the distinct patients:** Count the number of distinct patient IDs ('ID') that meet all the filtering criteria. This will give the number of patients satisfying the specified conditions.

Tables: Examination

Columns: Examination.ID, Examination.aCL IgM, Examination.Thrombosis, Examination.ANA Pattern

NL2SQL: ```sql
SELECT
  COUNT(DISTINCT ID)
FROM Examination
WHERE
  Thrombosis = 2 AND ANA Pattern = 'S' AND "aCL IgM" > (
    SELECT
      AVG("aCL IgM") * 1.2
    FROM Examination
  );
```
Critic: ```sql
SELECT
  COUNT(DISTINCT T1.ID)
FROM Examination AS T1
INNER JOIN Patient AS T2
  ON T1.ID = T2.ID
WHERE
  T1.Thrombosis = 2 AND T1."ANA Pattern" = 'S' AND T1."aCL IgM" > (
    SELECT
      AVG("aCL IgM") * 1.2
    FROM Examination
  );
```
=====================
Question: List all patients who were followed up at the outpatient clinic who underwent a laboratory test in October 1991 and had a total blood bilirubin level within the normal range.
 db_id: thrombosis_prediction
Planner: Here's a plan to retrieve the requested patient information:

1.  **Identify relevant tables:** We need the `Patient` and `Laboratory` tables since we are looking for patient information, outpatient clinic visits, laboratory tests, and bilirubin levels.
2.  **Filter for outpatient clinic patients:** Filter the `Patient` table for records where `Admission` is equal to '-'.
3.  **Filter for laboratory tests in October 1991:** Filter the `Laboratory` table for records where the `Date` falls within October 1991 (i.e., Date like '1991-10%').
4.  **Filter for normal bilirubin levels:** Filter the `Laboratory` table for records where `T-BIL` is less than 2.0.
5.  **Join the tables:** Join the filtered `Patient` and `Laboratory` tables using the common column `ID`.
6.  **Select the patient IDs:** Select the `ID` column from the joined table.

NL2SQL:
```sql
SELECT DISTINCT
  T1.ID
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
WHERE
  T1.Admission = '-' AND T2.Date LIKE '1991-10%' AND T2."T-BIL" < 2;
```
NL2SQL: ```sql
SELECT DISTINCT
  T1.ID
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
WHERE
  T1.Admission = '-' AND T2.Date LIKE '9110%' AND T2."T-BIL" < 2;
```
Critic: ```sql
SELECT DISTINCT
  T1.ID
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
WHERE
  T1.Admission = '-' AND STRFTIME('%Y-%m', T2.Date) = '1991-10' AND T2."T-BIL" < 2;
```
=====================
Question: What is the average blood albumin level for female patients with a PLT greater than 400 who have been diagnosed with SLE?
 db_id: thrombosis_prediction
Planner: Plan:
1. Filter Patient table by SEX = 'F' and Diagnosis = 'SLE'.
2. Filter Laboratory table by PLT > 400.
3. Join the filtered Patient and Laboratory tables on Patient.ID = Laboratory.ID.
4. Calculate the average of ALB from the joined table.
5. Return the average albumin level.

NL2SQL: ```sql
SELECT
  AVG(T1.ALB)
FROM Laboratory AS T1
INNER JOIN Patient AS T2
  ON T1.ID = T2.ID
WHERE
  T2.SEX = 'F' AND T1.PLT > 400 AND T2.Diagnosis = 'SLE';
```
Critic: ```sql
SELECT
  AVG(T1.ALB)
FROM Laboratory AS T1
INNER JOIN Patient AS T2
  ON T1.ID = T2.ID
WHERE
  T2.SEX = 'F' AND T1.PLT > 400 AND T2.Diagnosis = 'SLE';
```
=====================
Question: How many female patients were given an APS diagnosis?
 db_id: thrombosis_prediction
Planner: 1.  From the `Patient` table, filter for patients where `SEX` is 'F' and `Diagnosis` is 'APS'.
2.  Count the number of patients that meet the criteria.

Return the count.
NL2SQL: ```sql
SELECT
  COUNT(ID)
FROM Patient
WHERE
  SEX = 'F' AND Diagnosis = 'APS';
```
Critic: ```sql
SELECT
  COUNT(ID)
FROM Patient
WHERE
  SEX = 'F' AND Diagnosis = 'APS';
```
=====================
Question: What percentage of patients who were born in 1980 and were diagnosed with RA are women?
 db_id: thrombosis_prediction
Planner: Plan:
1. Filter the Patient table to select patients born in 1980 (YEAR(Birthday) = 1980) and diagnosed with 'RA' (Diagnosis = 'RA').
2. Count the total number of patients who satisfy the conditions in step 1.
3. Count the number of female patients (SEX = 'F') from the patients selected in step 1.
4. Calculate the percentage of female patients by dividing the count from step 3 by the count from step 2, and multiplying by 100.
5. Return the calculated percentage.
Tables: Patient
Columns: Birthday, Diagnosis, SEX
Filters: YEAR(Birthday) = 1980, Diagnosis = 'RA', SEX = 'F'
Aggregations: COUNT, SUM
Calculation: SUM(CASE WHEN SEX = 'F' THEN 1 ELSE 0 END) * 100 / COUNT(*)

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN SEX = 'F' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*)
FROM Patient
WHERE
  STRFTIME('%Y', Birthday) = '1980' AND Diagnosis = 'RA';
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN SEX = 'F' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*)
FROM Patient
WHERE
  STRFTIME('%Y', Birthday) = '1980' AND Diagnosis = 'RA';
```
=====================
Question: What is the ratio of customers who pay in EUR against customers who pay in CZK?
 db_id: debit_card_specializing
Planner: Here's my plan to calculate the ratio of customers paying in EUR versus CZK:

1.  **Table:** Start with the `customers` table, as it contains the currency information.
2.  **Filter:** No filtering is needed initially, as we want to count all customers in EUR and CZK.
3.  **Aggregation:** Count the number of customers for each currency (EUR and CZK) using `COUNT()` and `GROUP BY Currency`.
4.  **Calculation:** Calculate the ratio of EUR customers to CZK customers (EUR count / CZK count).
5.  **Final Result:** The final result is the ratio.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN Currency = 'EUR' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN Currency = 'CZK' THEN 1 ELSE 0 END)
FROM customers;
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN Currency = 'EUR' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN Currency = 'CZK' THEN 1 ELSE 0 END)
FROM Customers;
```
=====================
Question: In 2012, who had the least consumption in LAM?
 db_id: debit_card_specializing
Planner: Plan:
1. Filter the `yearmonth` table to include only records where the year is 2012. This can be achieved by extracting the year from the `Date` column.
2. Filter the `yearmonth` table to include only records where the customer segment is 'LAM'. Need to join with `customers` table.
3. Find the minimum consumption among the filtered records.
4. Retrieve the `CustomerID` associated with the minimum consumption.
5. Return the `CustomerID` of the customer with the least consumption.
Tables: `yearmonth`, `customers`
Columns: `yearmonth.Date`, `yearmonth.CustomerID`, `yearmonth.Consumption`, `customers.CustomerID`, `customers.Segment`
Filters: Year in `yearmonth.Date` is 2012, `customers.Segment` is 'LAM'
Join: `yearmonth.CustomerID` = `customers.CustomerID`
Aggregation: Minimum consumption

NL2SQL: ```sql
SELECT T1.CustomerID FROM yearmonth AS T1 JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.Segment = 'LAM' AND substr(T1.Date, 1, 4) = '2012' ORDER BY T1.Consumption ASC LIMIT 1
```
Critic: ```sql
SELECT CustomerID FROM yearmonth WHERE substr(Date, 1, 4) = '2012' AND CustomerID IN (SELECT CustomerID FROM customers WHERE Segment = 'LAM') ORDER BY Consumption ASC LIMIT 1
```
=====================
Question: What was the average monthly consumption of customers in SME for the year 2013?
 db_id: debit_card_specializing
Planner: Plan:
1. Filter the `customers` table to include only customers with the segment 'SME'.
2. Join the filtered `customers` table with the `yearmonth` table using `CustomerID`.
3. Filter the joined table to include only records where the year extracted from the `Date` column in `yearmonth` is 2013. The year is extracted from the date as the first 4 characters of Date string.
4. Calculate the average monthly consumption by averaging the `Consumption` values for the filtered records and dividing by 12.
5. Select the calculated average monthly consumption.

NL2SQL: ```sql
SELECT AVG(Consumption) / 12
FROM customers AS t1
INNER JOIN yearmonth AS t2 ON t1.CustomerID = t2.CustomerID
WHERE
  t1.Segment = 'SME' AND SUBSTR(t2.Date, 1, 4) = '2013';
```
Critic: ```sql
SELECT
  AVG(Consumption)
FROM yearmonth AS T1
INNER JOIN customers AS T2
  ON T1.CustomerID = T2.CustomerID
WHERE
  T2.Segment = 'SME' AND STRFTIME('%Y', T1.Date) = '2013';
```
=====================
Question: What was the difference in gas consumption between CZK-paying customers and EUR-paying customers in 2012?
 db_id: debit_card_specializing
Planner: Plan:
1. Calculate the total gas consumption for CZK-paying customers in 2012.
    - Join `customers` and `yearmonth` on `CustomerID`.
    - Filter `customers` for `Currency = 'CZK'`.
    - Filter `yearmonth` for dates between '201201' and '201212'.
    - Sum the `Consumption`.
2. Calculate the total gas consumption for EUR-paying customers in 2012.
    - Join `customers` and `yearmonth` on `CustomerID`.
    - Filter `customers` for `Currency = 'EUR'`.
    - Filter `yearmonth` for dates between '201201' and '201212'.
    - Sum the `Consumption`.
3. Calculate the difference between the CZK consumption and EUR consumption.

NL2SQL: ```sql
SELECT
  SUM(CASE WHEN T1.Currency = 'CZK' THEN T2.Consumption ELSE 0 END) - SUM(CASE WHEN T1.Currency = 'EUR' THEN T2.Consumption ELSE 0 END)
FROM customers AS T1
INNER JOIN yearmonth AS T2
  ON T1.CustomerID = T2.CustomerID
WHERE
  T2.Date BETWEEN '201201' AND '201212';
```
Critic: ```sql
SELECT
  SUM(CASE WHEN T1.Currency = 'CZK' THEN T2.Consumption ELSE 0 END) - SUM(CASE WHEN T1.Currency = 'EUR' THEN T2.Consumption ELSE 0 END)
FROM customers AS T1
INNER JOIN yearmonth AS T2
  ON T1.CustomerID = T2.CustomerID
WHERE
  SUBSTR(T2.Date, 1, 4) = '2012';
```
=====================
Question: Which year recorded the most consumption of gas paid in CZK?
 db_id: debit_card_specializing
Planner: Plan:
1. Filter `customers` table to get `CustomerID` where `Currency` is 'CZK'.
2. Join `transactions_1k` table with the filtered `customers` table on `CustomerID` to get transactions paid in CZK.
3. Filter `products` table to get `ProductID` related to 'gas'.
4. Join `transactions_1k` table with the filtered `products` table on `ProductID` to get transactions related to gas.
5. Join `transactions_1k` table with `yearmonth` table on `CustomerID` and `Date` to get 'Consumption'
6. Group the result by year (extracted from the 'Date' column of `yearmonth` table).
7. Calculate the sum of 'Consumption' for each year.
8. Order the result in descending order of total consumption.
9. Limit the result to the top 1 year to find the year with the most consumption.
10. Select the year.

NL2SQL: ```sql
SELECT
  SUBSTR(T2.Date, 1, 4)
FROM transactions_1k AS T1
INNER JOIN yearmonth AS T2
  ON T1.CustomerID = T2.CustomerID
INNER JOIN customers AS T3
  ON T1.CustomerID = T3.CustomerID
INNER JOIN products AS T4
  ON T1.ProductID = T4.ProductID
WHERE
  T3.Currency = 'CZK' AND T4.Description = 'gas'
GROUP BY
  SUBSTR(T2.Date, 1, 4)
ORDER BY
  SUM(T2.Consumption) DESC
LIMIT 1;
```
Critic: ```sql
SELECT
  SUBSTR(Date, 1, 4)
FROM yearmonth
WHERE
  CustomerID IN (
    SELECT
      CustomerID
    FROM customers
    WHERE
      Currency = 'CZK'
  )
GROUP BY
  SUBSTR(Date, 1, 4)
ORDER BY
  SUM(Consumption) DESC
LIMIT 1;
```
=====================
Question: What was the gas consumption peak month for SME customers in 2013?
 db_id: debit_card_specializing
Planner: Plan:
1. Filter `customers` table for SME segment.
2. Filter `yearmonth` table for the year 2013 using `Date` column.
3. Join the filtered tables `customers` and `yearmonth` on `CustomerID`.
4. Group the result by month extracted from the `Date` column and sum the `Consumption`.
5. Order the result by total consumption in descending order and take the top month.
6. Extract the month part from `Date` column.

NL2SQL: ```sql
SELECT
  SUBSTR(Date, 5, 2)
FROM customers AS t1
INNER JOIN yearmonth AS t2
  ON t1.CustomerID = t2.CustomerID
WHERE
  t1.Segment = 'SME' AND SUBSTR(Date, 1, 4) = '2013'
GROUP BY
  SUBSTR(Date, 5, 2)
ORDER BY
  SUM(Consumption) DESC
LIMIT 1;
```
Critic: ```sql
SELECT
  SUBSTR(Date, 5, 2)
FROM yearmonth AS t1
INNER JOIN customers AS t2
  ON t1.CustomerID = t2.CustomerID
WHERE
  SUBSTR(Date, 1, 4) = '2013' AND t2.Segment = 'SME'
GROUP BY
  SUBSTR(Date, 5, 2)
ORDER BY
  SUM(Consumption) DESC
LIMIT 1;
```
=====================
Question: What is the difference in the annual average consumption of the customers with the least amount of consumption paid in CZK for 2013 between SME and LAM, LAM and KAM, and KAM and SME?
 db_id: debit_card_specializing
Planner: Here's a plan to determine the differences in annual average consumption for the lowest-consuming customers in 2013 between SME, LAM, and KAM segments:

1.  **Identify Relevant Tables:**
    *   `customers`: To get customer segments (SME, LAM, KAM) and currency.
    *   `yearmonth`: To get customer consumption data for 2013.

2.  **Filter for Year 2013 and CZK currency:**
    *   Filter `yearmonth` for records where the year is 2013 (first 4 characters of Date column = 2013).
    *   Filter `customers` for records where Currency is CZK

3.  **Calculate Total Consumption for Each Customer in 2013:**
    *   Join `yearmonth` and `customers` tables on `CustomerID`.
    *   Group the joined data by `CustomerID` and `Segment` and sum the `Consumption` to get total consumption for each customer in 2013.

4.  **Identify Lowest Consumption Customer in Each Segment:**
    *   Use `RANK()` within each segment to determine the rank according to the calculated consumption.
    *   Filter to find the customers with rank = 1 for each segment.

5.  **Calculate Annual Average Consumption for the customer with lowest consumption:**
    *   Annual Average Consumption = Total consumption of each customer

6.  **Calculate the Differences in Annual Average Consumption:**
    *   Calculate the difference between SME and LAM annual average consumption.
    *   Calculate the difference between LAM and KAM annual average consumption.
    *   Calculate the difference between KAM and SME annual average consumption.

7.  **Present the Results:**
    *   Display the calculated differences.

Now, let's pass this plan to the NL2SQL to generate the SQL query.

NL2SQL: ```sql
WITH yearly_consumption AS (
  SELECT
    ym.CustomerID,
    SUM(ym.Consumption) AS total_consumption
  FROM yearmonth AS ym
  WHERE
    SUBSTR(ym.Date, 1, 4) = '2013'
  GROUP BY
    ym.CustomerID
), customer_segment_consumption AS (
  SELECT
    c.Segment,
    yc.total_consumption,
    RANK() OVER (PARTITION BY c.Segment ORDER BY yc.total_consumption ASC) AS consumption_rank
  FROM customers AS c
  JOIN yearly_consumption AS yc
    ON c.CustomerID = yc.CustomerID
  WHERE
    c.Currency = 'CZK'
), lowest_consumption AS (
  SELECT
    Segment,
    total_consumption
  FROM customer_segment_consumption
  WHERE
    consumption_rank = 1
), segment_list AS (
  SELECT
    (
      SELECT
        total_consumption
      FROM lowest_consumption
      WHERE
        Segment = 'SME'
    ) AS SME,
    (
      SELECT
        total_consumption
      FROM lowest_consumption
      WHERE
        Segment = 'LAM'
    ) AS LAM,
    (
      SELECT
        total_consumption
      FROM lowest_consumption
      WHERE
        Segment = 'KAM'
    ) AS KAM
)
SELECT
  SME - LAM AS SME_LAM_difference,
  LAM - KAM AS LAM_KAM_difference,
  KAM - SME AS KAM_SME_difference
FROM segment_list;
```
Critic: ```sql
WITH YearlyConsumption AS (
  SELECT
    ym.CustomerID,
    SUM(ym.Consumption) AS TotalConsumption
  FROM yearmonth AS ym
  WHERE
    SUBSTR(ym.Date, 1, 4) = '2013'
  GROUP BY
    ym.CustomerID
), CustomerSegmentConsumption AS (
  SELECT
    c.Segment,
    yc.TotalConsumption,
    RANK() OVER (PARTITION BY c.Segment ORDER BY yc.TotalConsumption ASC) AS ConsumptionRank,
    c.Currency
  FROM customers AS c
  JOIN YearlyConsumption AS yc
    ON c.CustomerID = yc.CustomerID
), LowestConsumption AS (
  SELECT
    Segment,
    TotalConsumption
  FROM CustomerSegmentConsumption
  WHERE
    ConsumptionRank = 1 AND Currency = 'CZK'
)
SELECT
  (
    SELECT
      TotalConsumption
    FROM LowestConsumption
    WHERE
      Segment = 'SME'
  ) - (
    SELECT
      TotalConsumption
    FROM LowestConsumption
    WHERE
      Segment = 'LAM'
  ) AS SME_LAM_Difference,
  (
    SELECT
      TotalConsumption
    FROM LowestConsumption
    WHERE
      Segment = 'LAM'
  ) - (
    SELECT
      TotalConsumption
    FROM LowestConsumption
    WHERE
      Segment = 'KAM'
  ) AS LAM_KAM_Difference,
  (
    SELECT
      TotalConsumption
    FROM LowestConsumption
    WHERE
      Segment = 'KAM'
  ) - (
    SELECT
      TotalConsumption
    FROM LowestConsumption
    WHERE
      Segment = 'SME'
  ) AS KAM_SME_Difference;
```
=====================
Question: Which of the three segments—SME, LAM and KAM—has the biggest and lowest percentage increases in consumption paid in EUR between 2012 and 2013?
 db_id: debit_card_specializing
Planner: Plan:
1. Filter the `yearmonth` table to get the consumption for each customer in 2012 and 2013.
2. Join the filtered `yearmonth` table with the `customers` table using `CustomerID` to get the segment and currency for each customer.
3. Filter the joined table to only include customers with currency EUR.
4. Calculate the total consumption for each segment in 2012 and 2013.
5. Calculate the percentage increase in consumption between 2012 and 2013 for each segment.
6. Find the segment with the biggest and lowest percentage increase.

NL2SQL: ```sql
WITH Consumption2012 AS (
  SELECT
    ym.CustomerID,
    ym.Consumption AS Consumption2012
  FROM yearmonth AS ym
  WHERE
    SUBSTR(ym.Date, 1, 4) = '2012'
), Consumption2013 AS (
  SELECT
    ym.CustomerID,
    ym.Consumption AS Consumption2013
  FROM yearmonth AS ym
  WHERE
    SUBSTR(ym.Date, 1, 4) = '2013'
), CustomerSegmentConsumption AS (
  SELECT
    c.Segment,
    c.Currency,
    COALESCE(SUM(c12.Consumption2012), 0) AS TotalConsumption2012,
    COALESCE(SUM(c13.Consumption2013), 0) AS TotalConsumption2013
  FROM customers AS c
  LEFT JOIN Consumption2012 AS c12
    ON c.CustomerID = c12.CustomerID
  LEFT JOIN Consumption2013 AS c13
    ON c.CustomerID = c13.CustomerID
  GROUP BY
    c.Segment,
    c.Currency
  HAVING
    c.Currency = 'EUR'
), PercentageIncrease AS (
  SELECT
    Segment,
    (
      (
        TotalConsumption2013 - TotalConsumption2012
      ) * 100.0
    ) / TotalConsumption2012 AS PercentageIncrease
  FROM CustomerSegmentConsumption
)
SELECT
  Segment,
  PercentageIncrease
FROM PercentageIncrease
WHERE
  PercentageIncrease = (
    SELECT
      MAX(PercentageIncrease)
    FROM PercentageIncrease
  )
UNION ALL
SELECT
  Segment,
  PercentageIncrease
FROM PercentageIncrease
WHERE
  PercentageIncrease = (
    SELECT
      MIN(PercentageIncrease)
    FROM PercentageIncrease
  );
```
Critic: ```sql
WITH Consumption2012 AS (
  SELECT
    ym.CustomerID,
    ym.Consumption AS Consumption2012
  FROM yearmonth AS ym
  WHERE
    SUBSTR(ym.Date, 1, 4) = '2012'
), Consumption2013 AS (
  SELECT
    ym.CustomerID,
    ym.Consumption AS Consumption2013
  FROM yearmonth AS ym
  WHERE
    SUBSTR(ym.Date, 1, 4) = '2013'
), CustomerSegmentConsumption AS (
  SELECT
    c.Segment,
    SUM(COALESCE(c12.Consumption2012, 0)) AS TotalConsumption2012,
    SUM(COALESCE(c13.Consumption2013, 0)) AS TotalConsumption2013
  FROM customers AS c
  LEFT JOIN Consumption2012 AS c12
    ON c.CustomerID = c12.CustomerID
  LEFT JOIN Consumption2013 AS c13
    ON c.CustomerID = c13.CustomerID
  WHERE
    c.Currency = 'EUR'
  GROUP BY
    c.Segment
), PercentageIncrease AS (
  SELECT
    Segment,
    (
      (
        TotalConsumption2013 - TotalConsumption2012
      ) * 100.0 / TotalConsumption2012
    ) AS PercentageIncrease
  FROM CustomerSegmentConsumption
)
SELECT
  Segment,
  PercentageIncrease
FROM PercentageIncrease
WHERE
  PercentageIncrease = (
    SELECT
      MAX(PercentageIncrease)
    FROM PercentageIncrease
  )
UNION ALL
SELECT
  Segment,
  PercentageIncrease
FROM PercentageIncrease
WHERE
  PercentageIncrease = (
    SELECT
      MIN(PercentageIncrease)
    FROM PercentageIncrease
  );
```
=====================
Question: How much did customer 6 consume in total between August and November 2013?
 db_id: debit_card_specializing
Planner: Plan:
1. Filter the `yearmonth` table to include only records where the `CustomerID` is 6.
2. Further filter the `yearmonth` table to include only records where the `Date` falls between '201308' and '201311' (inclusive).
3. Calculate the sum of the `Consumption` for the filtered records.
4. Return the calculated sum as the total consumption.

NL2SQL: ```sql
SELECT sum(Consumption) FROM yearmonth WHERE CustomerID = 6 AND Date BETWEEN '201308' AND '201311'
```
Critic: ```sql
SELECT sum(Consumption) FROM yearmonth WHERE CustomerID = 6 AND substr(Date, 1, 6) BETWEEN '201308' AND '201311'
```
=====================
Question: How many more "discount" gas stations does the Czech Republic have compared to Slovakia?
 db_id: debit_card_specializing
Planner: Plan:
1. Count the number of gas stations in the Czech Republic where the segment is "discount".
2. Count the number of gas stations in Slovakia where the segment is "discount".
3. Subtract the second count from the first count to find the difference.
Tables: gasstations
Columns: Country, Segment
Filters: Country = 'CZE' and Segment = 'discount', Country = 'SVK' and Segment = 'discount'
Aggregation: COUNT(GasStationID) for both countries.
Final Calculation: (Czech Republic count) - (Slovakia count)

NL2SQL: ```sql
SELECT
  (
    SELECT
      COUNT(*)
    FROM gasstations
    WHERE
      Country = 'CZE' AND Segment = 'discount'
  ) - (
    SELECT
      COUNT(*)
    FROM gasstations
    WHERE
      Country = 'SVK' AND Segment = 'discount'
  );
```
Critic: ```sql
SELECT
  (
    SELECT
      COUNT(*)
    FROM gasstations
    WHERE
      Country = 'CZE' AND Segment = 'Discount'
  ) - (
    SELECT
      COUNT(*)
    FROM gasstations
    WHERE
      Country = 'SVK' AND Segment = 'Discount'
  );
```
=====================
Question: Is it true that more SMEs pay in Czech koruna than in euros? If so, how many more?
 db_id: debit_card_specializing
Planner: Plan:
1. Count the number of SMEs that pay in Czech koruna (CZK).
2. Count the number of SMEs that pay in euros (EUR).
3. Subtract the number of SMEs that pay in euros from the number of SMEs that pay in Czech koruna to find the difference.
4. Return a boolean representing if there are more SMEs using CZK.
5. Return the calculated difference.
Tables: customers
Columns: Segment, Currency
Filters: Segment = 'SME'
Joins: None
Aggregations: COUNT
Math: subtraction
Output: Boolean, integer

NL2SQL: ```sql
SELECT
  CASE
    WHEN (
      SELECT
        COUNT(*)
      FROM customers
      WHERE
        Segment = 'SME' AND Currency = 'CZK'
    ) > (
      SELECT
        COUNT(*)
      FROM customers
      WHERE
        Segment = 'SME' AND Currency = 'EUR'
    )
    THEN TRUE
    ELSE FALSE
  END,
  (
    SELECT
      COUNT(*)
    FROM customers
    WHERE
      Segment = 'SME' AND Currency = 'CZK'
  ) - (
    SELECT
      COUNT(*)
    FROM customers
    WHERE
      Segment = 'SME' AND Currency = 'EUR'
  );
```
Critic: ```sql
SELECT
  (
    SELECT
      COUNT(*)
    FROM customers
    WHERE
      Segment = 'SME' AND Currency = 'CZK'
  ) - (
    SELECT
      COUNT(*)
    FROM customers
    WHERE
      Segment = 'SME' AND Currency = 'EUR'
  );
```
=====================
Question: How many percent of LAM customer consumed more than 46.73?
 db_id: debit_card_specializing
Planner: Plan:
1. Find the total number of LAM customers from the `customers` table using `Segment = 'LAM'`.
2. Join `yearmonth` and `customers` table on `CustomerID`.
3. Filter `yearmonth` table where `Consumption > 46.73` and `Segment = 'LAM'`. Count the number of distinct customer IDs.
4. Calculate the percentage.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T2.Consumption > 46.73 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.CustomerID)
FROM customers AS T1
INNER JOIN yearmonth AS T2
  ON T1.CustomerID = T2.CustomerID
WHERE
  T1.Segment = 'LAM';
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T2.Consumption > 46.73 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.CustomerID)
FROM customers AS T1
INNER JOIN yearmonth AS T2
  ON T1.CustomerID = T2.CustomerID
WHERE
  T1.Segment = 'LAM';
```
=====================
Question: In February 2012, what percentage of customers consumed more than 528.3?
 db_id: debit_card_specializing
Planner: Plan:
1. Filter the `yearmonth` table to include only records from February 2012 (where `Date` is like '201202').
2. Filter this subset to include only customers whose consumption is greater than 528.3.
3. Count the number of customers who meet the consumption criteria.
4. Count the total number of customers in February 2012.
5. Calculate the percentage by dividing the number of customers who meet the consumption criteria by the total number of customers in February 2012 and multiplying by 100.
Needed Tables: `yearmonth`
Needed Columns: `yearmonth.Date`, `yearmonth.CustomerID`, `yearmonth.Consumption`
Filters: `yearmonth.Date` like '201202', `yearmonth.Consumption` > 528.3
Aggregations: COUNT(DISTINCT `yearmonth.CustomerID`) for both filtered and total customer counts.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN Consumption > 528.3 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(CustomerID)
FROM yearmonth
WHERE
  Date LIKE '201202';
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN Consumption > 528.3 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(CustomerID)
FROM yearmonth
WHERE
  Date = '201202';
```
=====================
Question: What is the highest monthly consumption in the year 2012?
 db_id: debit_card_specializing
Planner: Plan:
1. Filter the `yearmonth` table to include only records where the year is 2012 by extracting the year from the `Date` column.
2. Group the filtered data by month (extracting the month from the `Date` column).
3. Calculate the sum of `Consumption` for each month.
4. Find the maximum monthly consumption from the aggregated results.
5. Return the maximum monthly consumption.

Tables: `yearmonth`
Columns: `Date`, `Consumption`
Filters: `year = 2012`
Aggregate Functions: `SUM(Consumption)`
Grouping: `month`
Order By: None
Limit: None

NL2SQL: ```sql
SELECT MAX(monthly_consumption)
FROM (
    SELECT SUM(Consumption) AS monthly_consumption
    FROM yearmonth
    WHERE SUBSTR(Date, 1, 4) = '2012'
    GROUP BY SUBSTR(Date, 5, 2)
) AS monthly_consumptions;
```
Critic: ```sql
SELECT MAX(Consumption) FROM yearmonth WHERE substr(Date,1,4)='2012'
```
=====================
Question: Please list the product description of the products consumed in September, 2013.
 db_id: debit_card_specializing
Planner: Plan:
1. Filter `yearmonth` table to get `CustomerID` where `Date` starts with '201309'.
2. Find corresponding `ProductID` from `transactions_1k` table using `CustomerID` from step 1.
3. Find `Description` from `products` table using `ProductID` from step 2.
4. Return `Description`.

NL2SQL: ```sql
SELECT DISTINCT
  T1.Description
FROM products AS T1
INNER JOIN transactions_1k AS T2
  ON T1.ProductID = T2.ProductID
INNER JOIN yearmonth AS T3
  ON T2.CustomerID = T3.CustomerID
WHERE
  substr(T3.Date, 1, 6) = '201309';
```
Critic: ```sql
SELECT DISTINCT T1.Description FROM products AS T1 INNER JOIN transactions_1k AS T2 ON T1.ProductID = T2.ProductID WHERE strftime('%Y%m', T2.Date) = '201309'
```
=====================
Question: Please list the countries of the gas stations with transactions taken place in June, 2013.
 db_id: debit_card_specializing
Planner: Plan:
1. Filter the `transactions_1k` table to include only transactions that occurred in June 2013. This can be achieved by filtering the `Date` column.
2. Join the filtered `transactions_1k` table with the `gasstations` table using the `GasStationID` to retrieve the country of each gas station.
3. Select the distinct countries from the joined table.
Tables:
* `transactions_1k`: To filter transactions by date.
* `gasstations`: To retrieve the country of the gas station.

Columns:
* `transactions_1k.Date`: To filter transactions by date.
* `transactions_1k.GasStationID`: To join with the `gasstations` table.
* `gasstations.GasStationID`: To join with the `transactions_1k` table.
* `gasstations.Country`: To retrieve the country of the gas station.

Filters:
* `transactions_1k.Date` LIKE '2013-06%'

Joins:
* `transactions_1k` JOIN `gasstations` ON `transactions_1k.GasStationID` = `gasstations.GasStationID`

NL2SQL: ```sql
SELECT DISTINCT
  T1.Country
FROM gasstations AS T1
INNER JOIN transactions_1k AS T2
  ON T1.GasStationID = T2.GasStationID
WHERE
  T2.Date LIKE '2013-06%';
```
Critic: ```sql
SELECT DISTINCT
  T1.Country
FROM gasstations AS T1
INNER JOIN transactions_1k AS T2
  ON T1.GasStationID = T2.GasStationID
WHERE
  STRFTIME('%Y-%m', T2.Date) = '2013-06';
```
=====================
Question: Among the customers who paid in euro, how many of them have a monthly consumption of over 1000?
 db_id: debit_card_specializing
Planner: Plan:
1. Filter the `customers` table to find customers who paid in euro (Currency = 'EUR').
2. Join the filtered `customers` table with the `yearmonth` table on `CustomerID` to get the monthly consumption for each customer.
3. Filter the joined table to find customers with a monthly consumption over 1000.
4. Count the number of distinct customers who meet the criteria.

Needed tables: `customers`, `yearmonth`
Needed columns: `customers.CustomerID`, `customers.Currency`, `yearmonth.CustomerID`, `yearmonth.Consumption`
Joins: `customers.CustomerID` = `yearmonth.CustomerID`
Filters: `customers.Currency` = 'EUR', `yearmonth.Consumption` > 1000
Aggregation: `COUNT(DISTINCT customers.CustomerID)`

NL2SQL: ```sql
SELECT COUNT(DISTINCT t1.CustomerID)
FROM customers AS t1
INNER JOIN yearmonth AS t2 ON t1.CustomerID = t2.CustomerID
WHERE t1.Currency = 'EUR' AND t2.Consumption > 1000;
```
Critic: ```sql
SELECT count(DISTINCT T1.CustomerID) FROM Customers AS T1 INNER JOIN YearMonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Currency = 'EUR' AND T2.Consumption > 1000
```
=====================
Question: Please list the product descriptions of the transactions taken place in the gas stations in the Czech Republic.
 db_id: debit_card_specializing
Planner: Here's my plan to answer the question:

1.  **Identify relevant tables:**
    *   `transactions_1k`: To link transactions to gas stations and products.
    *   `gasstations`: To filter gas stations located in the Czech Republic.
    *   `products`: To retrieve the product descriptions.

2.  **Join tables:**
    *   Join `transactions_1k` with `gasstations` on `GasStationID` to filter transactions based on gas station country.
    *   Join the result with `products` on `ProductID` to retrieve the product description for each transaction.

3.  **Filter data:**
    *   Filter `gasstations` for `Country = 'CZE'` to select gas stations in the Czech Republic.

4.  **Select the desired column:**
    *   Select the `Description` column from the `products` table.

Now, let's generate the SQL query.

NL2SQL: ```sql
SELECT
  T1.Description
FROM products AS T1
INNER JOIN transactions_1k AS T2
  ON T1.ProductID = T2.ProductID
INNER JOIN gasstations AS T3
  ON T2.GasStationID = T3.GasStationID
WHERE
  T3.Country = 'CZE';
```
Critic: ```sql
SELECT
  T1.Description
FROM products AS T1
INNER JOIN transactions_1k AS T2
  ON T1.ProductID = T2.ProductID
INNER JOIN gasstations AS T3
  ON T2.GasStationID = T3.GasStationID
WHERE
  T3.Country = 'CZE';
```
=====================
Question: Please list the disparate time of the transactions taken place in the gas stations from chain no. 11.
 db_id: debit_card_specializing
Planner: Plan:
1. Filter `gasstations` table for `ChainID` equal to 11.
2. Join `transactions_1k` table with the filtered `gasstations` table on `GasStationID`.
3. Select distinct `Time` from the joined table.

NL2SQL: ```sql
SELECT DISTINCT
  T2.Time
FROM gasstations AS T1
INNER JOIN transactions_1k AS T2
  ON T1.GasStationID = T2.GasStationID
WHERE
  T1.ChainID = 11;
```
Critic: ```sql
SELECT DISTINCT
  Time
FROM transactions_1k
WHERE
  GasStationID IN (
    SELECT
      GasStationID
    FROM gasstations
    WHERE
      ChainID = 11
  );
```
=====================
Question: Among the transactions made in the gas stations in the Czech Republic, how many of them are taken place after 2012/1/1?
 db_id: debit_card_specializing
Planner: Plan:
1. Filter the `gasstations` table to only include gas stations in the Czech Republic (Country = 'CZE').
2. Join the filtered `gasstations` table with the `transactions_1k` table on `GasStationID`.
3. Filter the joined table to include transactions after 2012-01-01.
4. Count the number of transactions after filtering.

NL2SQL: ```sql
SELECT
  COUNT(T1.TransactionID)
FROM transactions_1k AS T1
INNER JOIN gasstations AS T2
  ON T1.GasStationID = T2.GasStationID
WHERE
  T2.Country = 'CZE' AND T1.Date > '2012-01-01'
```
Critic: ```sql
SELECT
  COUNT(T1.TransactionID)
FROM transactions_1k AS T1
INNER JOIN gasstations AS T2
  ON T1.GasStationID = T2.GasStationID
WHERE
  T2.Country = 'CZE' AND T1.Date > '2012-01-01'
```
=====================
Question: What kind of currency did the customer paid at 16:25:00 in 2012/8/24?
 db_id: debit_card_specializing
Planner: Plan:
1. Filter the `transactions_1k` table by `Date` = '2012-08-24' and `Time` = '16:25:00' to find the relevant `CustomerID`.
2. Join the filtered `transactions_1k` table with the `customers` table on `CustomerID` to retrieve the `Currency` for the customer.
3. Return the `Currency` column from the `customers` table.

NL2SQL: ```sql
SELECT
  T2.Currency
FROM transactions_1k AS T1
INNER JOIN customers AS T2
  ON T1.CustomerID = T2.CustomerID
WHERE
  T1.Date = '2012-08-24' AND T1.Time = '16:25:00';
```
Critic: ```sql
SELECT
  T1.Currency
FROM customers AS T1
INNER JOIN transactions_1k AS T2
  ON T1.CustomerID = T2.CustomerID
WHERE
  T2.Date = '2012-08-24' AND T2.Time = '16:25:00';
```
=====================
Question: What segment did the customer have at 2012/8/23 21:20:00?
 db_id: debit_card_specializing
Planner: Plan:
1. Filter the `transactions_1k` table by date '2012-08-23' and time '21:20:00'.
2. Get the `CustomerID` from the filtered `transactions_1k` table.
3. Join the `customers` table with the `CustomerID` to get the `Segment` of the customer.
4. Return the `Segment`.

NL2SQL: ```sql
SELECT
  T1.Segment
FROM customers AS T1
INNER JOIN transactions_1k AS T2
  ON T1.CustomerID = T2.CustomerID
WHERE
  T2.Date = '2012-08-23' AND T2.Time = '21:20:00';
```
Critic: ```sql
SELECT
  T1.Segment
FROM Customers AS T1
INNER JOIN TRANSACTIONS_1K AS T2
  ON T1.CustomerID = T2.CustomerID
WHERE
  T2.Date = '2012-08-23' AND T2.Time = '21:20:00';
```
=====================
Question: For all the transactions happened during 8:00-9:00 in 2012/8/26, how many happened in CZE?
 db_id: debit_card_specializing
Planner: Plan:
1. Filter the transactions table for transactions that occurred on '2012-08-26' and between 08:00:00 and 09:00:00.
2. Join the filtered transactions with the gasstations table on GasStationID.
3. Filter the joined table for transactions where the gas station's country is 'CZE'.
4. Count the number of transactions that satisfy all conditions.

NL2SQL: ```sql
SELECT
  COUNT(T1.TransactionID)
FROM transactions_1k AS T1
INNER JOIN gasstations AS T2
  ON T1.GasStationID = T2.GasStationID
WHERE
  T1.Date = '2012-08-26' AND T1.Time BETWEEN '08:00:00' AND '09:00:00' AND T2.Country = 'CZE';
```
Critic: ```sql
SELECT
  COUNT(T1.TransactionID)
FROM transactions_1k AS T1
INNER JOIN gasstations AS T2
  ON T1.GasStationID = T2.GasStationID
WHERE
  T1.Date = '2012-08-26' AND T1.Time >= '08:00:00' AND T1.Time < '09:00:00' AND T2.Country = 'CZE';
```
=====================
Question: What's the nationality of the customer who spent 548.4 in 2012/8/24?
 db_id: debit_card_specializing
Planner: Plan:
1. Filter the `transactions_1k` table to find the `CustomerID` where `Date` is '2012-08-24' and `Amount` * `Price` is 548.4.
2. Join the `customers` table with the result from step 1 using `CustomerID` to get the `Segment` representing the nationality of the customer.
3. Return the `Segment` column.

NL2SQL: ```sql
SELECT
  T1.Segment
FROM customers AS T1
INNER JOIN transactions_1k AS T2
  ON T1.CustomerID = T2.CustomerID
WHERE
  T2.Date = '2012-08-24' AND T2.Amount * T2.Price = 548.4;
```
Critic: ```sql
SELECT
  T1.Segment
FROM customers AS T1
INNER JOIN transactions_1k AS T2
  ON T1.CustomerID = T2.CustomerID
WHERE
  T2.Date = '2012-08-24' AND T2.Amount * T2.Price = 548.40;
```
=====================
Question: What is the percentage of the customers who used EUR in 2012/8/25?
 db_id: debit_card_specializing
Planner: Plan:
1. Find the total number of customers using the `customers` table.
2. Filter the transactions table to only include transactions on '2012-08-25'.
3. Join the filtered transactions table with the `customers` table on `CustomerID`.
4. Filter the joined table to only include customers using EUR.
5. Count the number of unique customers using EUR on '2012-08-25'.
6. Calculate the percentage of customers using EUR by dividing the number of EUR customers by the total number of customers and multiplying by 100.
7. Return the percentage.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.Currency = 'EUR' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.CustomerID)
FROM customers AS T1
INNER JOIN transactions_1k AS T2
  ON T1.CustomerID = T2.CustomerID
WHERE
  T2.Date = '2012-08-25';
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.Currency = 'EUR' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.CustomerID)
FROM customers AS T1
INNER JOIN transactions_1k AS T2
  ON T1.CustomerID = T2.CustomerID
WHERE
  T2.Date = '2012-08-25'
```
=====================
Question: For the customer who paid 634.8 in 2012/8/25, what was the consumption decrease rate from Year 2012 to 2013?
 db_id: debit_card_specializing
Planner: Plan:
1. Find the `CustomerID` of the customer who paid 634.8 on '2012-08-25' from the `transactions_1k` table.
2. Calculate the total consumption for the found `CustomerID` in the year 2012 from the `yearmonth` table.
3. Calculate the total consumption for the same `CustomerID` in the year 2013 from the `yearmonth` table.
4. Calculate the consumption decrease rate using the formula: (consumption_2012 - consumption_2013) / consumption_2012.

NL2SQL: ```sql
WITH CustomerOfInterest AS (
  SELECT
    CustomerID
  FROM transactions_1k
  WHERE
    Date = '2012-08-25' AND Price = 634.8
), Consumption2012 AS (
  SELECT
    SUM(Consumption) AS TotalConsumption2012
  FROM yearmonth
  WHERE
    CustomerID IN (
      SELECT
        CustomerID
      FROM CustomerOfInterest
    ) AND substr(Date, 1, 4) = '2012'
), Consumption2013 AS (
  SELECT
    SUM(Consumption) AS TotalConsumption2013
  FROM yearmonth
  WHERE
    CustomerID IN (
      SELECT
        CustomerID
      FROM CustomerOfInterest
    ) AND substr(Date, 1, 4) = '2013'
)
SELECT
  (
    (
      SELECT
        TotalConsumption2012
      FROM Consumption2012
    ) - (
      SELECT
        TotalConsumption2013
      FROM Consumption2013
    )
  ) * 1.0 / (
    SELECT
      TotalConsumption2012
    FROM Consumption2012
  );
```
Critic: ```sql
WITH CustomerOfInterest AS (
  SELECT
    CustomerID
  FROM transactions_1k
  WHERE
    DATE(Date) = '2012-08-25' AND Price = 634.8
), Consumption2012 AS (
  SELECT
    SUM(Consumption) AS TotalConsumption2012
  FROM yearmonth
  WHERE
    CustomerID IN (
      SELECT
        CustomerID
      FROM CustomerOfInterest
    ) AND substr(Date, 1, 4) = '2012'
), Consumption2013 AS (
  SELECT
    SUM(Consumption) AS TotalConsumption2013
  FROM yearmonth
  WHERE
    CustomerID IN (
      SELECT
        CustomerID
      FROM CustomerOfInterest
    ) AND substr(Date, 1, 4) = '2013'
)
SELECT
  CAST((
    (
      SELECT
        TotalConsumption2012
      FROM Consumption2012
    ) - (
      SELECT
        TotalConsumption2013
      FROM Consumption2013
    )
  ) AS REAL) / (
    SELECT
      TotalConsumption2012
    FROM Consumption2012
  );
```
=====================
Question: What is the percentage of "premium" against the overall segment in Country = "SVK"?
 db_id: debit_card_specializing
Planner: Here's my plan to calculate the percentage of "premium" segment gas stations in "SVK":

1.  **Identify "premium" gas stations in "SVK":** Filter the `gasstations` table where `Country` is "SVK" and `Segment` is "premium". Count these gas stations.
2.  **Identify all gas stations in "SVK":** Filter the `gasstations` table where `Country` is "SVK". Count these gas stations.
3.  **Calculate the percentage:** Divide the number of "premium" gas stations by the total number of gas stations and multiply by 100.

I don't need to join any tables. I only need to use the `gasstations` table.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN Segment = 'premium' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*)
FROM gasstations
WHERE
  Country = 'SVK';
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN Segment = 'premium' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*)
FROM gasstations
WHERE
  Country = 'SVK';
```
=====================
Question: What is the amount spent by customer "38508" at the gas stations? How much had the customer spent in January 2012?
 db_id: debit_card_specializing
Planner: Here's my plan to answer the question:

1.  **Find total amount spent by customer "38508" at gas stations:**
    *   Use the `transactions_1k` table.
    *   Filter by `CustomerID` = 38508.
    *   Join `transactions_1k` with `products` on `ProductID` to filter for gas purchases (using `Description` containing "Gas").
    *   Calculate the sum of `Amount`.

2.  **Find total amount spent by customer "38508" at gas stations in January 2012:**
    *   Use the `transactions_1k` table.
    *   Filter by `CustomerID` = 38508.
    *   Filter by `Date` where `Date` is between '2012-01-01' and '2012-01-31'.
    *   Join `transactions_1k` with `products` on `ProductID` to filter for gas purchases (using `Description` containing "Gas").
    *   Calculate the sum of `Amount`.

NL2SQL: ```sql
SELECT
  SUM(CASE WHEN T1.Date LIKE '2012-01%' THEN T1.Amount ELSE 0 END),
  SUM(T1.Amount)
FROM transactions_1k AS T1
INNER JOIN products AS T2
  ON T1.ProductID = T2.ProductID
WHERE
  T1.CustomerID = 38508 AND T2.Description LIKE '%Gas%';
```
Critic: ```sql
SELECT
  SUM(CASE WHEN STRFTIME('%Y%m', T1.Date) = '201201' THEN T1.Amount ELSE 0 END),
  SUM(T1.Amount)
FROM transactions_1k AS T1
INNER JOIN products AS T2
  ON T1.ProductID = T2.ProductID
WHERE
  T1.CustomerID = 38508 AND T2.Description LIKE '%Gas%';
```
=====================
Question: Who is the top spending customer and how much is the average price per single item purchased by this customer? What currency was being used?
 db_id: debit_card_specializing
Planner: Plan:
1.  Find the top spending customer:
    *   Join `transactions_1k` with `customers` on `CustomerID`.
    *   Calculate the total spending for each customer using `SUM(Price)`.
    *   Find the customer with the maximum total spending using `ORDER BY` and `LIMIT`.
    *   Select the `CustomerID` of the top spending customer.
2.  Calculate the average price per single item for the top spending customer:
    *   Filter `transactions_1k` by the `CustomerID` of the top spending customer.
    *   Calculate the sum of `Price` and the sum of `Amount`.
    *   Calculate the average price per item by dividing the sum of `Price` by the sum of `Amount`.
3.  Find the currency of the top spending customer:
    *   From the `customers` table, get the `Currency` of the top spending `CustomerID`.
4.  Output the top spending customer's `CustomerID`, the average price per item, and the currency.

NL2SQL: ```sql
SELECT
  t1.CustomerID,
  SUM(t1.Price) / SUM(t1.Amount),
  t2.Currency
FROM transactions_1k AS t1
JOIN customers AS t2
  ON t1.CustomerID = t2.CustomerID
WHERE
  t1.CustomerID = (
    SELECT
      t3.CustomerID
    FROM transactions_1k AS t3
    JOIN customers AS t4
      ON t3.CustomerID = t4.CustomerID
    GROUP BY
      t3.CustomerID
    ORDER BY
      SUM(t3.Price) DESC
    LIMIT 1
  )
GROUP BY
  t1.CustomerID,
  t2.Currency;
```
Critic: ```sql
SELECT
  c.CustomerID,
  SUM(t.Price) / SUM(t.Amount) AS avg_price_per_item,
  c.Currency
FROM customers AS c
JOIN transactions_1k AS t
  ON c.CustomerID = t.CustomerID
WHERE
  c.CustomerID = (
    SELECT
      CustomerID
    FROM transactions_1k
    GROUP BY
      CustomerID
    ORDER BY
      SUM(Price) DESC
    LIMIT 1
  )
GROUP BY
  c.CustomerID,
  c.Currency;
```
=====================
Question: For all the people who paid more than 29.00 per unit of product id No.5. Give their consumption status in the August of 2012.
 db_id: debit_card_specializing
Planner: Plan:
1.  Find the `CustomerID` from the `transactions_1k` table where `ProductID` is 5 and `Price` / `Amount` is greater than 29.00.
2.  Filter the `yearmonth` table to include only records from August 2012 (Date = '201208').
3.  Join the results from step 1 and step 2 on `CustomerID` to find the consumption status of those customers in August 2012.
4.  Select the `Consumption` column from the joined table.

NL2SQL: ```sql
SELECT
  T2.Consumption
FROM transactions_1k AS T1
INNER JOIN yearmonth AS T2
  ON T1.CustomerID = T2.CustomerID
WHERE
  T1.ProductID = 5 AND T1.Price / T1.Amount > 29.00 AND T2.Date = '201208';
```
Critic: ```sql
SELECT
  T2.Consumption
FROM transactions_1k AS T1
INNER JOIN yearmonth AS T2
  ON T1.CustomerID = T2.CustomerID
WHERE
  T1.ProductID = 5 AND T1.Price / T1.Amount > 29.00 AND SUBSTR(T2.Date, 1, 6) = '201208';
```
=====================
Question: What's Angela Sanders's major?
 db_id: student_club
Planner: Plan:
1. Find the `member_id` of the member whose first name is 'Angela' and last name is 'Sanders' from the `Member` table.
2. Using the `member_id`, find the corresponding `link_to_major` from the `Member` table.
3. Using the `link_to_major`, find the `major_name` from the `Major` table.
4. Return the `major_name`.
Tables: Member, Major
Columns: first_name, last_name, link_to_major, major_name
Filters: first_name = 'Angela', last_name = 'Sanders'
Joins: Member.link_to_major = Major.major_id
Final Answer: SELECT T2.major_name FROM Member AS T1 JOIN Major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.first_name = "Angela" AND T1.last_name = "Sanders"
NL2SQL: ```sql
SELECT T2.major_name FROM Member AS T1 JOIN Major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.first_name = "Angela" AND T1.last_name = "Sanders"
```
Critic: ```sql
SELECT T2.major_name FROM Member AS T1 JOIN Major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.first_name = "Angela" AND T1.last_name = "Sanders"
```
=====================
Question: Among the students from the Student_Club who attended the event "Women's Soccer", how many of them want a T-shirt that's in medium size?
 db_id: student_club
Planner: 1. Find the `event_id` for the event named "Women's Soccer" from the `Event` table.
2. Use the `event_id` to find the `member_id` of students who attended the event from the `Attendance` table.
3. Use the `member_id` to find the members whose `t_shirt_size` is "Medium" from the `Member` table.
4. Count the number of such members.
5. Use `COUNT(*)` to count such members.
Tables needed: Event, Attendance, Member
Columns needed: event_id, event_name, link_to_event, link_to_member, member_id, t_shirt_size
Filters: event_name = "Women's Soccer", t_shirt_size = "Medium"
Joins: Event with Attendance on event_id = link_to_event, Attendance with Member on link_to_member = member_id
Final Answer: The query counts number of members.

NL2SQL: ```sql
SELECT
  COUNT(T1.member_id)
FROM Member AS T1
INNER JOIN Attendance AS T2
  ON T1.member_id = T2.link_to_member
INNER JOIN Event AS T3
  ON T2.link_to_event = T3.event_id
WHERE
  T3.event_name = 'Women''s Soccer' AND T1.t_shirt_size = 'Medium';
```
Critic: ```sql
SELECT
  COUNT(T1.member_id)
FROM Member AS T1
INNER JOIN Attendance AS T2
  ON T1.member_id = T2.link_to_member
INNER JOIN Event AS T3
  ON T2.link_to_event = T3.event_id
WHERE
  T3.event_name = 'Women''s Soccer' AND T1.t_shirt_size = 'M';
```
=====================
Question: Among the events attended by more than 10 members of the Student_Club, how many of them are meetings?
 db_id: student_club
Planner: 1. **Find events with more than 10 attendees:**
   - Use the `Attendance` table to count the number of members (`link_to_member`) for each event (`link_to_event`).
   - Filter events where the count is greater than 10.
2. **Filter for meetings:**
   - Join the results with the `Event` table using `event_id` and `link_to_event`.
   - Filter for events where the `type` is 'Meeting'.
3. **Count the number of meetings:**
   - Count the distinct `event_id` values.
Plan completed. Passing to NL2SQL.

NL2SQL: ```sql
SELECT
  COUNT(T1.event_id)
FROM Event AS T1
INNER JOIN (
  SELECT
    link_to_event
  FROM Attendance
  GROUP BY
    link_to_event
  HAVING
    COUNT(link_to_member) > 10
) AS T2
  ON T1.event_id = T2.link_to_event
WHERE
  T1.type = 'Meeting';
```
Critic: ```sql
SELECT
  COUNT(event_id)
FROM Event
WHERE
  type = 'Meeting'
  AND event_id IN (
    SELECT
      link_to_event
    FROM Attendance
    GROUP BY
      link_to_event
    HAVING
      COUNT(*) > 10
  );
```
=====================
Question: List all the names of events that had an attendance of over 20 students but were not fundraisers.
 db_id: student_club
Planner: 1.  **Join** the `Event` and `Attendance` tables on `event_id` and `link_to_event` respectively.
2.  **Filter** the events to exclude those with the type "Fundraiser".
3.  **Group** the results by `event_name`.
4.  **Filter** the grouped results to include only those with a count of attendees greater than 20 using `HAVING COUNT(*) > 20`.
5.  **Select** the `event_name` for the final result.

NL2SQL: ```sql
SELECT
  T1.event_name
FROM Event AS T1
INNER JOIN Attendance AS T2
  ON T1.event_id = T2.link_to_event
WHERE
  T1.type != 'Fundraiser'
GROUP BY
  T1.event_name
HAVING
  COUNT(*) > 20;
```
Critic: ```sql
SELECT
  event_name
FROM Event
WHERE
  event_id IN (
    SELECT
      link_to_event
    FROM Attendance
    GROUP BY
      link_to_event
    HAVING
      COUNT(*) > 20
  )
  AND type != 'Fundraiser';
```
=====================
Question: What is the amount of the funds that the Vice President received?
 db_id: student_club
Planner: Plan:
1. Find the member_id of the Vice President from the Member table.
2. Use the member_id to filter the Income table and sum the amount.
3. Return the sum of the amount.

Tables:
*   Member: To identify the member_id of the 'Vice President'.
*   Income: To find the amount received by that member.

Columns:
*   Member: member_id, position
*   Income: link_to_member, amount

Joins:
*   None needed

Filters:
*   Member: position = 'Vice President'
*   Income: link_to_member = member_id from Member table

Aggregate function:
*   SUM(Income.amount)

NL2SQL: ```sql
SELECT
  SUM(T1.amount)
FROM Income AS T1
INNER JOIN Member AS T2
  ON T1.link_to_member = T2.member_id
WHERE
  T2.position = 'Vice President';
```
Critic: ```sql
SELECT
  SUM(T1.amount)
FROM Income AS T1
INNER JOIN Member AS T2
  ON T1.link_to_member = T2.member_id
WHERE
  T2.position = 'Vice President';
```
=====================
Question: List the full name of the Student_Club members that grew up in Illinois state.
 db_id: student_club
Planner: Plan:
1. We need to find members who grew up in Illinois. This information is in the `Member` table with `zip` and the `Zip_Code` table with `state`.
2. Join `Member` and `Zip_Code` on `Member.zip = Zip_Code.zip_code`.
3. Filter the joined table where `Zip_Code.state = 'Illinois'`.
4. Select the `first_name` and `last_name` from the `Member` table for the filtered results and concatenate them to get the full name.

NL2SQL: ```sql
SELECT
  T1.first_name,
  T1.last_name
FROM Member AS T1
INNER JOIN Zip_Code AS T2
  ON T1.zip = T2.zip_code
WHERE
  T2.state = 'Illinois';
```
Critic: ```sql
SELECT
  first_name,
  last_name
FROM Member AS T1
INNER JOIN Zip_Code AS T2
  ON T1.zip = T2.zip_code
WHERE
  T2.state = 'Illinois';
```
=====================
Question: Was each expense in October Meeting on October 8, 2019 approved?
 db_id: student_club
Planner: 1. Find the `event_id` for the event named 'October Meeting' that occurred on '2019-10-08' from the `Event` table.
2. Use the `event_id` to find the corresponding `budget_id` from the `Budget` table where `link_to_event` equals the `event_id` found in the previous step.
3. Use the `budget_id` to find all `expense_id` from the `Expense` table where `link_to_budget` equals the `budget_id` from the previous step, and the `expense_date` falls in October.
4. For each expense in that group check to see if the approved field is True.
5. The final SELECT statement is required to determine if all expenses were approved.

NL2SQL: ```sql
SELECT
  CASE
    WHEN COUNT(CASE WHEN T1.approved = 'False' THEN 1 ELSE NULL END) > 0
    THEN 'No'
    ELSE 'Yes'
  END
FROM Expense AS T1
INNER JOIN Budget AS T2
  ON T1.link_to_budget = T2.budget_id
INNER JOIN Event AS T3
  ON T2.link_to_event = T3.event_id
WHERE
  T3.event_name = 'October Meeting' AND T3.event_date = '2019-10-08';
```
Critic: ```sql
SELECT
  CASE
    WHEN SUM(CASE WHEN T1.approved = 'TRUE' THEN 1 ELSE 0 END) = COUNT(T1.expense_id)
    THEN 'Yes'
    ELSE 'No'
  END
FROM Expense AS T1
INNER JOIN Budget AS T2
  ON T1.link_to_budget = T2.budget_id
INNER JOIN Event AS T3
  ON T2.link_to_event = T3.event_id
WHERE
  T3.event_name = 'October Meeting' AND T3.event_date = '2019-10-08';
```
=====================
Question: Calculate the total average cost that Elijah Allen spent in the events on September and October.
 db_id: student_club
Planner: Plan:
1. Find the `member_id` of Elijah Allen from the `Member` table using `first_name` and `last_name`.
2. Filter the `Expense` table to include only expenses incurred by Elijah Allen (using the `member_id` found in step 1) and during September and October (using the `expense_date` column).
3. Calculate the average of the `cost` for the filtered expenses.

Tables:
- Member
- Expense

Columns:
- Member: member_id, first_name, last_name
- Expense: link_to_member, expense_date, cost

Joins:
- None

Filters:
- Member: first_name = 'Elijah', last_name = 'Allen'
- Expense: link_to_member = (member_id from Member), month(expense_date) in (9, 10)

Aggregation:
- AVG(Expense.cost)

NL2SQL: ```sql
SELECT avg(T1.cost) FROM Expense AS T1 JOIN Member AS T2 ON T1.link_to_member = T2.member_id WHERE T2.first_name = 'Elijah' AND T2.last_name = 'Allen' AND STRFTIME('%m', T1.expense_date) IN ('09', '10')
```
Critic: ```sql
SELECT AVG(T1.cost) FROM Expense AS T1 INNER JOIN Member AS T2 ON T1.link_to_member = T2.member_id WHERE T2.first_name = 'Elijah' AND T2.last_name = 'Allen' AND STRFTIME('%m', T1.expense_date) IN ('09', '10')
```
=====================
Question: Calculate the difference of the total amount spent in all events by the Student_Club in year 2019 and 2020.
 db_id: student_club
Planner: Here's a plan to calculate the difference in total spending between 2019 and 2020:

1.  **Identify relevant tables:** We need the `Event` table to filter events by year and the `Budget` table to get the amount spent for each event.
2.  **Filter Events by Year:** Extract the year from the `event_date` column in the `Event` table and filter for events in 2019 and 2020 separately.
3.  **Join Tables:** Join the `Event` table and the `Budget` table using the `link_to_event` column in the `Budget` table and the `event_id` column in the `Event` table.
4.  **Calculate Total Spending for Each Year:** Group the results by year and sum the `spent` column from the `Budget` table to get the total spending for each year.
5.  **Calculate the Difference:** Subtract the total spending in 2020 from the total spending in 2019.
6. **Return the result.** The final result will be a single number representing the difference.

Now, let's convert this plan into an SQL query.

NL2SQL: ```sql
SELECT
  SUM(CASE WHEN STRFTIME('%Y', T1.event_date) = '2019' THEN T2.spent ELSE 0 END) - SUM(CASE WHEN STRFTIME('%Y', T1.event_date) = '2020' THEN T2.spent ELSE 0 END)
FROM Event AS T1
INNER JOIN Budget AS T2
  ON T1.event_id = T2.link_to_event;
```
Critic: ```sql
SELECT
  SUM(CASE WHEN STRFTIME('%Y', T1.event_date) = '2019' THEN T2.spent ELSE 0 END) - SUM(CASE WHEN STRFTIME('%Y', T1.event_date) = '2020' THEN T2.spent ELSE 0 END)
FROM Event AS T1
INNER JOIN Budget AS T2
  ON T1.event_id = T2.link_to_event;
```
=====================
Question: What was the notes of the fundraising on 2019/9/14?
 db_id: student_club
Planner: 1. Filter the Income table by `date_received` = '2019-09-14'.
2. Filter the Income table by `source` = 'Fundraising'.
3. Select the `notes` column from the filtered table.

NL2SQL: ```sql
SELECT
  notes
FROM Income
WHERE
  date_received = '2019-09-14' AND source = 'Fundraising';
```
Critic: ```sql
SELECT
  notes
FROM Income
WHERE
  date_received = '2019-09-14' AND source = 'Fundraising';
```
=====================
Question: Tell the phone number of "Carlo Jacobs".
 db_id: student_club
Planner: The question asks for the phone number of "Carlo Jacobs".
We need to look at the `Member` table since it contains member information, including first name, last name, and phone number.
We need to filter the `Member` table on `first_name` = "Carlo" and `last_name` = "Jacobs".
We need to select the `phone` column.

NL2SQL: ```sql
SELECT
  phone
FROM Member
WHERE
  first_name = 'Carlo' AND last_name = 'Jacobs';
```
Critic: ```sql
SELECT
  phone
FROM Member
WHERE
  first_name = 'Carlo' AND last_name = 'Jacobs';
```
=====================
Question: What is the status of the event which bought "Post Cards, Posters" on 2019/8/20?
 db_id: student_club
Planner: 1. Find the `expense_id` from the `Expense` table where `expense_description` is "Post Cards, Posters" and `expense_date` is "2019-08-20".
2. Find the `link_to_budget` from the `Expense` table using the `expense_id` found in step 1.
3. Find the `link_to_event` and `event_status` from the `Budget` table using the `link_to_budget` found in step 2.
4. Return the `event_status`.

Tables:
* Expense: `expense_description`, `expense_date`, `link_to_budget`
* Budget: `link_to_event`, `event_status`

Filters:
* Expense: `expense_description` = "Post Cards, Posters" and `expense_date` = "2019-08-20"

Joins:
* Expense JOIN Budget on Expense.link_to_budget = Budget.budget_id

Columns:
* Budget: `event_status`

NL2SQL: ```sql
SELECT
  T2.event_status
FROM Expense AS T1
INNER JOIN Budget AS T2
  ON T1.link_to_budget = T2.budget_id
WHERE
  T1.expense_description = 'Post Cards, Posters' AND T1.expense_date = '2019-08-20';
```
Critic: ```sql
SELECT
  T2.status
FROM Expense AS T1
INNER JOIN Budget AS T3
  ON T1.link_to_budget = T3.budget_id
INNER JOIN Event AS T2
  ON T3.link_to_event = T2.event_id
WHERE
  T1.expense_description = 'Post Cards, Posters' AND T1.expense_date = '2019-08-20';
```
=====================
Question: What was Brent Thomason's major?
 db_id: student_club
Planner: The question asks about the major of a person named Brent Thomason.
1.  Find the `member_id` of the member with `first_name` 'Brent' and `last_name` 'Thomason' in the `Member` table.
2.  Use the `link_to_major` from the `Member` table to find the corresponding `major_id` in the `Major` table.
3.  Retrieve the `major_name` from the `Major` table using the found `major_id`.
Tables: `Member`, `Major`
Columns:
*   `Member`: `member_id`, `first_name`, `last_name`, `link_to_major`
*   `Major`: `major_id`, `major_name`

Plan:
1.  Filter the `Member` table to find the `member_id` of the member named 'Brent Thomason'.
2.  Join the `Member` table with the `Major` table using `link_to_major` and `major_id`.
3.  Select the `major_name` from the `Major` table.

NL2SQL: ```sql
SELECT
  T2.major_name
FROM Member AS T1
INNER JOIN Major AS T2
  ON T1.link_to_major = T2.major_id
WHERE
  T1.first_name = 'Brent' AND T1.last_name = 'Thomason';
```
Critic: ```sql
SELECT
  T2.major_name
FROM Member AS T1
INNER JOIN Major AS T2
  ON T1.link_to_major = T2.major_id
WHERE
  T1.first_name = 'Brent' AND T1.last_name = 'Thomason';
```
=====================
Question: For all the club members from "Business" major, how many of them wear medium size t-shirt?
 db_id: student_club
Planner: 1.  Find the `major_id` for the "Business" major from the `Major` table.
2.  Filter the `Member` table to find members whose `link_to_major` matches the `major_id` found in the previous step and whose `t_shirt_size` is 'Medium'.
3.  Count the number of members that satisfy both conditions.

NL2SQL: ```sql
SELECT
  COUNT(member_id)
FROM Member
WHERE
  link_to_major = (
    SELECT
      major_id
    FROM Major
    WHERE
      major_name = 'Business'
  )
  AND t_shirt_size = 'Medium';
```
Critic: ```sql
SELECT
  COUNT(T1.member_id)
FROM Member AS T1
INNER JOIN Major AS T2
  ON T1.link_to_major = T2.major_id
WHERE
  T2.major_name = 'Business' AND T1.t_shirt_size = 'Medium';
```
=====================
Question: Which department was the President of the club in?
 db_id: student_club
Planner: Plan:
1. Find the member(s) with the position 'President' in the `Member` table.
2. Get the `link_to_major` of those member(s)
3. Use these `link_to_major` values to find the corresponding records in the `Major` table.
4. Retrieve the `department` from the `Major` table.

NL2SQL: ```sql
SELECT
  T2.department
FROM Member AS T1
INNER JOIN Major AS T2
  ON T1.link_to_major = T2.major_id
WHERE
  T1.position = 'President';
```
Critic: ```sql
SELECT
  T2.department
FROM Member AS T1
INNER JOIN Major AS T2
  ON T1.link_to_major = T2.major_id
WHERE
  T1.position = 'President';
```
=====================
Question: State the date Connor Hilton paid his/her dues.
 db_id: student_club
Planner: 1.  Find the `member_id` of Connor Hilton from the `Member` table using `first_name` and `last_name`.
2.  Use the `member_id` to find the `date_received` from the `Income` table where `link_to_member` matches the `member_id` and `source` is 'Dues'.
3.  Return the `date_received`.

Tables:

*   `Member`: To find the `member_id` of Connor Hilton.
*   `Income`: To find the `date_received` when Connor Hilton paid his dues.

Columns:

*   `Member`: `member_id`, `first_name`, `last_name`
*   `Income`: `date_received`, `link_to_member`, `source`

Filters:

*   `Member`: `first_name` = 'Connor', `last_name` = 'Hilton'
*   `Income`: `link_to_member` = Connor Hilton's `member_id`, `source` = 'Dues'

NL2SQL: ```sql
SELECT
  T1.date_received
FROM Income AS T1
INNER JOIN Member AS T2
  ON T1.link_to_member = T2.member_id
WHERE
  T2.first_name = 'Connor' AND T2.last_name = 'Hilton' AND T1.source = 'Dues';
```
Critic: ```sql
SELECT
  T1.date_received
FROM Income AS T1
INNER JOIN Member AS T2
  ON T1.link_to_member = T2.member_id
WHERE
  T2.first_name = 'Connor' AND T2.last_name = 'Hilton' AND T1.source = 'Dues';
```
=====================
Question: How many times was the budget in Advertisement for "Yearly Kickoff" meeting more than "October Meeting"?
 db_id: student_club
Planner: 1.  Filter the Event table to find the `event_id` for events named "Yearly Kickoff" and "October Meeting".
2.  Filter the Budget table to find budget entries where `category` is "Advertisement" and the `link_to_event` matches either the "Yearly Kickoff" or "October Meeting" event IDs.
3.  Calculate the sum of `amount` from Budget for "Yearly Kickoff" and "October Meeting".
4.  Calculate how many times the budget in Advertisement for "Yearly Kickoff" meeting more than "October Meeting".

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.event_name = 'Yearly Kickoff' THEN T2.amount ELSE 0 END) AS REAL) / SUM(CASE WHEN T1.event_name = 'October Meeting' THEN T2.amount ELSE 0 END)
FROM Event AS T1
INNER JOIN Budget AS T2
  ON T1.event_id = T2.link_to_event
WHERE
  T2.category = 'Advertisement'
  AND T1.event_name IN ('Yearly Kickoff', 'October Meeting');
```
Critic: ```sql
SELECT
  COUNT(CASE WHEN T1.amount > T2.amount THEN 1 ELSE NULL END)
FROM Budget AS T1
INNER JOIN Budget AS T2
  ON T2.link_to_event = (
    SELECT
      event_id
    FROM Event
    WHERE
      event_name = 'October Meeting'
  )
WHERE
  T1.link_to_event = (
    SELECT
      event_id
    FROM Event
    WHERE
      event_name = 'Yearly Kickoff'
  )
  AND T1.category = 'Advertisement'
  AND T2.category = 'Advertisement';
```
=====================
Question: What is the total cost of the pizzas for all the events?
 db_id: student_club
Planner: 1.  From the `Expense` table, filter the records where `expense_description` is 'Pizza'.
2.  Calculate the sum of the `cost` column for the filtered records.

NL2SQL: ```sql
SELECT sum(cost) FROM Expense WHERE expense_description = 'Pizza'
```
Critic: ```sql
SELECT SUM(cost) FROM Expense WHERE expense_description = 'Pizza'
```
=====================
Question: How many cities are there in Orange County, Virginia?
 db_id: student_club
Planner: 1.  **Select the Table:** We need to query the `Zip_Code` table to find the cities in Orange County, Virginia.
2.  **Filter the Table:** Filter the `Zip_Code` table where `county` is "Orange County" and `state` is "Virginia".
3.  **Count Distinct Cities:** Count the distinct values in the `city` column of the filtered table.

NL2SQL: ```sql
SELECT
  COUNT(DISTINCT city)
FROM Zip_Code
WHERE
  county = 'Orange County' AND state = 'Virginia';
```
Critic: ```sql
SELECT
  COUNT(DISTINCT city)
FROM Zip_Code
WHERE
  county = 'Orange' AND state = 'Virginia';
```
=====================
Question: What does the person with the phone number "809-555-3360" major in?
 db_id: student_club
Planner: The question asks about the major of a person identified by their phone number.
1.  Find the `member_id` in the `Member` table using the phone number "809-555-3360".
2.  Get the `link_to_major` from the `Member` table, which connects to the `Major` table.
3.  Use the `link_to_major` to find the corresponding entry in the `Major` table.
4.  Retrieve the `major_name` from the `Major` table.
Tables needed: `Member`, `Major`.
Columns needed: `phone` from `Member`, `link_to_major` from `Member`, `major_name` from `Major`.
Filters: `phone` = "809-555-3360" in `Member`.
Join: `Member.link_to_major` = `Major.major_id`
Final Answer: The query should return the major name.

NL2SQL: ```sql
SELECT
  T2.major_name
FROM Member AS T1
INNER JOIN Major AS T2
  ON T1.link_to_major = T2.major_id
WHERE
  T1.phone = '809-555-3360';
```
Critic: ```sql
SELECT
  T2.major_name
FROM Member AS T1
INNER JOIN Major AS T2
  ON T1.link_to_major = T2.major_id
WHERE
  T1.phone = "809-555-3360";
```
=====================
Question: How many members attended the "Women's Soccer" event?
 db_id: student_club
Planner: Plan:
1. Find the `event_id` from the `Event` table where `event_name` is "Women's Soccer".
2. Use the `event_id` to filter the `Attendance` table via `link_to_event` to find all attendance records for the specified event.
3. Count the number of attendance records found in the `Attendance` table, which represents the number of members who attended.
Tables:
* Event: To get the `event_id` for "Women's Soccer".
* Attendance: To count the number of members who attended the event using `link_to_event`.

Columns:
* Event: `event_id`, `event_name`
* Attendance: `link_to_event`

Filters:
* Event: `event_name` = "Women's Soccer"

Joins: None, because we can perform the count using only the Attendance and Event tables.

NL2SQL: ```sql
SELECT
  COUNT(T1.link_to_member)
FROM Attendance AS T1
INNER JOIN Event AS T2
  ON T1.link_to_event = T2.event_id
WHERE
  T2.event_name = 'Women''s Soccer';
```
Critic: ```sql
SELECT
  COUNT(T1.link_to_member)
FROM Attendance AS T1
INNER JOIN Event AS T2
  ON T1.link_to_event = T2.event_id
WHERE
  T2.event_name = "Women's Soccer";
```
=====================
Question: List all the members of the "School of Applied Sciences, Technology and Education" department.
 db_id: student_club
Planner: Plan:
1. Filter the `Major` table to find the `major_id` of majors belonging to the "School of Applied Sciences, Technology and Education" department.
2. Join the `Member` table with the filtered `Major` table using `link_to_major` and `major_id` to find members associated with the specified department.
3. Select the `first_name` and `last_name` of the members to list their full names.

NL2SQL: ```sql
SELECT
  T1.first_name,
  T1.last_name
FROM Member AS T1
INNER JOIN Major AS T2
  ON T1.link_to_major = T2.major_id
WHERE
  T2.department = 'School of Applied Sciences, Technology and Education';
```
Critic: ```sql
SELECT
  T1.first_name,
  T1.last_name
FROM Member AS T1
INNER JOIN Major AS T2
  ON T1.link_to_major = T2.major_id
WHERE
  T2.department = 'School of Applied Sciences, Technology and Education';
```
=====================
Question: Among all the closed events, which event has the highest spend-to-budget ratio?
 db_id: student_club
Planner: Here's a plan to determine the event with the highest spend-to-budget ratio among closed events:

1.  **Filter Events:** Select events from the `Event` table where `status` is 'Closed'.
2.  **Join Budget:** Join the filtered `Event` table with the `Budget` table using `event_id` and `link_to_event` respectively.
3.  **Calculate Spend-to-Budget Ratio:** Calculate the ratio of `spent` to `amount` (spent / amount) for each event.
4.  **Find the Maximum Ratio:** Determine the maximum spend-to-budget ratio among all closed events.
5.  **Retrieve the Event:** Retrieve the event with the maximum spend-to-budget ratio. We need the `event_name`.

NL2SQL:
```sql
SELECT
  T1.event_name
FROM Event AS T1
INNER JOIN Budget AS T2
  ON T1.event_id = T2.link_to_event
WHERE
  T1.status = 'Closed'
ORDER BY
  T2.spent / T2.amount DESC
LIMIT 1;
```
NL2SQL: ```sql
SELECT
  T1.event_name
FROM Event AS T1
INNER JOIN Budget AS T2
  ON T1.event_id = T2.link_to_event
WHERE
  T1.status = 'Closed'
ORDER BY
  T2.spent / T2.amount DESC
LIMIT 1;
```
Critic: ```sql
SELECT
  T1.event_name
FROM Event AS T1
INNER JOIN Budget AS T2
  ON T1.event_id = T2.link_to_event
WHERE
  T1.status = 'Closed' AND T2.amount > 0
ORDER BY
  T2.spent / T2.amount DESC
LIMIT 1;
```
=====================
Question: What is the highest amount of budget spend for an event?
 db_id: student_club
Planner: 1.  **Table Selection:** We need to find the highest amount of budget spent. The `Budget` table contains information about budget spending, specifically the `spent` column.
2.  **Column Selection:** We need to select the `spent` column from the `Budget` table.
3.  **Aggregation:** Apply the MAX aggregate function to `spent` column to find the maximum spent amount.

NL2SQL: ```sql
SELECT MAX(spent) FROM Budget
```
Critic: ```sql
SELECT MAX(amount) FROM Budget
```
=====================
Question: What is the total amount of money spent for food?
 db_id: student_club
Planner: 1.  Table: Budget
2.  Filter: category = 'Food'
3.  Aggregate: SUM(spent)
NL2SQL: ```sql
SELECT sum(Spent) FROM Budget WHERE Category = 'Food'
```
Critic: ```sql
SELECT sum(spent) FROM Budget WHERE category = 'Food'
```
=====================
Question: List the name of students that have attended more than 7 events.
 db_id: student_club
Planner: Plan:
1. Join the Attendance table and Member table using the link_to_member column.
2. Group the results by member_id, first_name, and last_name.
3. Filter the groups to include only those where the count of distinct link_to_event is greater than 7.
4. Select and display the first_name and last_name for the filtered groups.

NL2SQL: ```sql
SELECT
  T1.first_name,
  T1.last_name
FROM Member AS T1
INNER JOIN Attendance AS T2
  ON T1.member_id = T2.link_to_member
GROUP BY
  T1.member_id,
  T1.first_name,
  T1.last_name
HAVING
  COUNT(T2.link_to_event) > 7;
```
Critic: ```sql
SELECT
  T1.first_name,
  T1.last_name
FROM Member AS T1
INNER JOIN Attendance AS T2
  ON T1.member_id = T2.link_to_member
GROUP BY
  T1.member_id
HAVING
  COUNT(T2.link_to_event) > 7;
```
=====================
Question: Which student has been entrusted to manage the budget for the Yearly Kickoff?
 db_id: student_club
Planner: Plan:
1. Find the event ID for the event named 'Yearly Kickoff' from the `Event` table.
2. Find the budget ID associated with the event ID from the `Budget` table, where category is 'Overall Budget'
3. Find the member ID from the `Expense` table that are associated with the budget ID.
4. Get the first name and last name of the member from the `Member` table using the member ID.
5. Concatenate the first name and last name to display the full name of the student.

Need to join the following tables:
- Event and Budget tables on Event.event_id = Budget.link_to_event
- Budget and Expense tables on Budget.budget_id = Expense.link_to_budget
- Expense and Member tables on Expense.link_to_member = Member.member_id

Columns:
- Event: event_id, event_name
- Budget: budget_id, link_to_event, amount
- Expense: link_to_budget, link_to_member
- Member: member_id, first_name, last_name

NL2SQL: ```sql
SELECT
  T1.first_name,
  T1.last_name
FROM Member AS T1
INNER JOIN Expense AS T2
  ON T1.member_id = T2.link_to_member
INNER JOIN Budget AS T3
  ON T2.link_to_budget = T3.budget_id
INNER JOIN Event AS T4
  ON T3.link_to_event = T4.event_id
WHERE
  T4.event_name = 'Yearly Kickoff';
```
Critic: ```sql
SELECT
  T1.first_name,
  T1.last_name
FROM Member AS T1
INNER JOIN Budget AS T2
  ON T1.member_id = T2.link_to_event
INNER JOIN Event AS T3
  ON T2.link_to_event = T3.event_id
WHERE
  T3.event_name = 'Yearly Kickoff';
```
=====================
Question: Which event has the lowest cost?
 db_id: student_club
Planner: The question asks for the event with the lowest cost.
1. Need to use the `Expense` table to get the cost of each expense.
2. Need to join `Expense` table with the `Budget` table on `link_to_budget` to find the associated event.
3. Need to find the event with the minimum cost.
4. Need to display `event_name` for the event with minimum cost.
Tables: `Expense`, `Budget`, `Event`
Columns: `Event.event_name`, `Expense.cost`
Joins: `Expense.link_to_budget` = `Budget.budget_id`, `Budget.link_to_event` = `Event.event_id`
Filters: None
Aggregate Function: MIN(`Expense.cost`)
Output: `Event.event_name`

NL2SQL: ```sql
SELECT T1.event_name FROM Event AS T1 JOIN Budget AS T2 ON T1.event_id = T2.link_to_event JOIN Expense AS T3 ON T2.budget_id = T3.link_to_budget ORDER BY T3.cost ASC LIMIT 1
```
Critic: ```sql
SELECT T1.event_name FROM Event AS T1 JOIN Budget AS T2 ON T1.event_id = T2.link_to_event JOIN Expense AS T3 ON T2.budget_id = T3.link_to_budget ORDER BY T3.cost ASC LIMIT 1
```
=====================
Question: Based on the total cost for all event, what is the percentage of cost for Yearly Kickoff event?
 db_id: student_club
Planner: Here's the plan to calculate the percentage of cost for the 'Yearly Kickoff' event based on the total cost for all events:

1.  **Calculate the total cost for all events:**
    *   Use the `Expense` table.
    *   `SUM` the `cost` column to get the total cost for all expenses.

2.  **Calculate the cost for the 'Yearly Kickoff' event:**
    *   Join the `Expense` table with the `Budget` table using `link_to_budget`.
    *   Join the `Budget` table with the `Event` table using `link_to_event`.
    *   Filter the results where `event_name` is 'Yearly Kickoff'.
    *   `SUM` the `cost` column from the `Expense` table to get the total cost for the 'Yearly Kickoff' event.

3.  **Calculate the percentage:**
    *   Divide the total cost of the 'Yearly Kickoff' event (from step 2) by the total cost of all events (from step 1).
    *   Multiply the result by 100 to express it as a percentage.
    *   Present the calculated percentage.

NL2SQL:
```sql
SELECT
  CAST(SUM(CASE WHEN T1.event_name = 'Yearly Kickoff' THEN T2.cost ELSE 0 END) AS REAL) * 100 / SUM(T2.cost)
FROM Event AS T1
INNER JOIN Budget AS T3
  ON T1.event_id = T3.link_to_event
INNER JOIN Expense AS T2
  ON T3.budget_id = T2.link_to_budget;
```
NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.event_name = 'Yearly Kickoff' THEN T2.cost ELSE 0 END) AS REAL) * 100 / SUM(T2.cost)
FROM Event AS T1
INNER JOIN Budget AS T3
  ON T1.event_id = T3.link_to_event
INNER JOIN Expense AS T2
  ON T3.budget_id = T2.link_to_budget;
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.event_name = 'Yearly Kickoff' THEN T2.cost ELSE 0 END) AS REAL) * 100 / SUM(T2.cost)
FROM Event AS T1
INNER JOIN Expense AS T2
  ON T1.event_id = T2.link_to_event;
```
=====================
Question: Indicate the top source of funds received in September 2019 based on their amount.
 db_id: student_club
Planner: Plan:
1. Filter the Income table for records where the date_received is in September 2019.
2. Group the filtered records by source and calculate the sum of the amount for each source.
3. Order the results in descending order of the total amount and select the source with the highest amount.
4. Return the source with the highest amount.

NL2SQL: ```sql
SELECT source FROM Income WHERE date_received BETWEEN '2019-09-01' AND '2019-09-30' GROUP BY source ORDER BY sum(amount) DESC LIMIT 1
```
Critic: ```sql
SELECT source FROM Income WHERE strftime('%Y-%m', date_received) = '2019-09' GROUP BY source ORDER BY sum(amount) DESC LIMIT 1
```
=====================
Question: How many members of the Student_Club have major in 'Physics Teaching'?
 db_id: student_club
Planner: 1.  We need to find members whose major is 'Physics Teaching'.
2.  We need to count these members.
3.  Tables needed: `Member`, `Major`
4.  Join `Member` and `Major` on `Member.link_to_major = Major.major_id`
5.  Filter: `Major.major_name = 'Physics Teaching'`
6.  Count the number of members satisfying the condition.

NL2SQL: ```sql
SELECT
  COUNT(T1.member_id)
FROM Member AS T1
INNER JOIN Major AS T2
  ON T1.link_to_major = T2.major_id
WHERE
  T2.major_name = 'Physics Teaching';
```
Critic: ```sql
SELECT
  COUNT(member_id)
FROM Member
WHERE
  link_to_major IN (
    SELECT
      major_id
    FROM Major
    WHERE
      major_name = 'Physics Teaching'
  );
```
=====================
Question: Name the event with the highest amount spent on advertisement.
 db_id: student_club
Planner: 1.  Find the `spent` for each `event_id` where `category` is 'Advertisement' in the `Budget` table.
2.  Find the maximum `spent` among them.
3.  Join the `Budget` table with the `Event` table using `link_to_event` and `event_id` respectively.
4.  Return the `event_name` of the event with the maximum `spent` on advertisement.

NL2SQL: ```sql
SELECT
  T1.event_name
FROM Event AS T1
INNER JOIN Budget AS T2
  ON T1.event_id = T2.link_to_event
WHERE
  T2.category = 'Advertisement'
ORDER BY
  T2.spent DESC
LIMIT 1;
```
Critic: ```sql
SELECT
  T1.event_name
FROM Event AS T1
INNER JOIN Budget AS T2
  ON T1.event_id = T2.link_to_event
WHERE
  T2.category = 'Advertisement'
ORDER BY
  T2.spent DESC
LIMIT 1;
```
=====================
Question: Did Maya Mclean attend the 'Women's Soccer' event?
 db_id: student_club
Planner: Plan:
1. Find the `member_id` of the member with `first_name` as 'Maya' and `last_name` as 'Mclean' from the `Member` table.
2. Find the `event_id` of the event with `event_name` as 'Women\'s Soccer' from the `Event` table.
3. Check if there is a record in the `Attendance` table with the `link_to_member` equal to the `member_id` found in step 1 and `link_to_event` equal to the `event_id` found in step 2.
4. Return 'Yes' if such a record exists in `Attendance` table, otherwise return 'No'.

NL2SQL: ```sql
SELECT
  CASE
    WHEN EXISTS(
      SELECT
        1
      FROM Member AS T1
      INNER JOIN Attendance AS T2
        ON T1.member_id = T2.link_to_member
      INNER JOIN Event AS T3
        ON T2.link_to_event = T3.event_id
      WHERE
        T1.first_name = 'Maya' AND T1.last_name = 'Mclean' AND T3.event_name = 'Women''s Soccer'
    )
    THEN 'Yes'
    ELSE 'No'
  END;
```
Critic: ```sql
SELECT
  CASE
    WHEN EXISTS(
      SELECT
        1
      FROM Member AS T1
      INNER JOIN Attendance AS T2
        ON T1.member_id = T2.link_to_member
      INNER JOIN Event AS T3
        ON T2.link_to_event = T3.event_id
      WHERE
        T1.first_name = 'Maya' AND T1.last_name = 'Mclean' AND T3.event_name = "Women's Soccer"
    )
    THEN 'Yes'
    ELSE 'No'
  END;
```
=====================
Question: Indicate the cost of posters for 'September Speaker' event.
 db_id: student_club
Planner: 1. Find the `event_id` of the event named 'September Speaker' from the `Event` table.
2. Find the `budget_id` from the `Budget` table where `link_to_event` equals the `event_id` obtained in the previous step and the `category` is 'advertisement'.
3. Find the `cost` from the `Expense` table where `link_to_budget` equals the `budget_id` obtained in the previous step and `expense_description` is 'posters'.
4. Return the `cost`.

Tables: `Event`, `Budget`, `Expense`
Columns: `event_name`, `event_id`, `link_to_event`, `budget_id`, `category`, `link_to_budget`, `expense_description`, `cost`
Joins: `Event` with `Budget` on `event_id` = `link_to_event`, `Budget` with `Expense` on `budget_id` = `link_to_budget`
Filters: `event_name` = 'September Speaker', `category` = 'advertisement', `expense_description` = 'posters'
Final Result: `cost`

NL2SQL: ```sql
SELECT
  T1.cost
FROM Expense AS T1
INNER JOIN Budget AS T2
  ON T1.link_to_budget = T2.budget_id
INNER JOIN Event AS T3
  ON T2.link_to_event = T3.event_id
WHERE
  T3.event_name = 'September Speaker' AND T2.category = 'advertisement' AND T1.expense_description = 'posters';
```
Critic: ```sql
SELECT
  T1.cost
FROM Expense AS T1
JOIN Budget AS T2
  ON T1.link_to_budget = T2.budget_id
JOIN Event AS T3
  ON T2.link_to_event = T3.event_id
WHERE
  T3.event_name = 'September Speaker' AND T1.expense_description = 'Posters';
```
=====================
Question: Indicate the name of the closed event whose cost has exceeded the budget the most.
 db_id: student_club
Planner: Plan:
1. Filter the 'Event' table for events with a 'Closed' status.
2. Join the 'Event' table with the 'Budget' table using the 'event_id' and 'link_to_event' columns.
3. Filter for cases where the remaining amount in 'Budget' is less than 0 (spent > budgeted).
4. Calculate how much the budget was exceeded by (amount - spent).
5. Find the maximum value of how much the budget was exceeded.
6. Return the event_name of the event with the maximum exceeded budget.

NL2SQL: ```sql
SELECT
  T1.event_name
FROM Event AS T1
INNER JOIN Budget AS T2
  ON T1.event_id = T2.link_to_event
WHERE
  T1.status = 'Closed' AND T2.remaining < 0
ORDER BY
  T2.remaining
LIMIT 1;
```
Critic: ```sql
SELECT
  T1.event_name
FROM Event AS T1
INNER JOIN Budget AS T2
  ON T1.event_id = T2.link_to_event
WHERE
  T1.status = 'Closed' AND T2.remaining < 0
ORDER BY
  T2.remaining
LIMIT 1;
```
=====================
Question: Identify the type of expenses and their total value approved for 'October Meeting' event.
 db_id: student_club
Planner: 1.  **Join `Expense` and `Budget` tables:** Join `Expense` and `Budget` tables on `link_to_budget` to connect expenses to their corresponding budget categories.
2.  **Join `Budget` and `Event` tables:** Join `Budget` and `Event` tables on `link_to_event` to filter for expenses related to the 'October Meeting' event.
3.  **Filter for the 'October Meeting' event:** Filter the results to include only expenses associated with the event named 'October Meeting'.
4.  **Filter for approved expenses:** Filter the expenses where `approved` is 'TRUE'.
5.  **Group by expense category:** Group the results by `category` from the `Budget` table.
6.  **Calculate the sum of expenses:** Calculate the sum of the `cost` for each expense category.
7.  **Select the expense category and the total cost:** Select the `category` and the calculated sum of `cost` as the final result.

NL2SQL: ```sql
SELECT
  T1.category,
  SUM(T2.cost)
FROM Budget AS T1
INNER JOIN Expense AS T2
  ON T1.budget_id = T2.link_to_budget
INNER JOIN Event AS T3
  ON T1.link_to_event = T3.event_id
WHERE
  T3.event_name = 'October Meeting' AND T2.approved = 'TRUE'
GROUP BY
  T1.category;
```
Critic: ```sql
SELECT
  T1.expense_description,
  SUM(T1.cost)
FROM Expense AS T1
INNER JOIN Budget AS T2
  ON T1.link_to_budget = T2.budget_id
INNER JOIN Event AS T3
  ON T2.link_to_event = T3.event_id
WHERE
  T3.event_name = 'October Meeting' AND T1.approved = 'TRUE'
GROUP BY
  T1.expense_description;
```
=====================
Question: Calculate the amount budgeted for 'April Speaker' event. List all the budgeted categories for said event in an ascending order based on their amount budgeted.
 db_id: student_club
Planner: 1.  Find the `event_id` for the event named 'April Speaker' from the `Event` table.
2.  Use the `event_id` to filter the `Budget` table to only include budget entries for the 'April Speaker' event.
3.  Select the `category` and `amount` columns from the filtered `Budget` table.
4.  Order the results in ascending order based on the `amount` column.

NL2SQL: ```sql
SELECT
  category,
  amount
FROM Budget
WHERE
  link_to_event = (
    SELECT
      event_id
    FROM Event
    WHERE
      event_name = 'April Speaker'
  )
ORDER BY
  amount ASC;
```
Critic: ```sql
SELECT
  category,
  amount
FROM Budget
WHERE
  link_to_event = (
    SELECT
      event_id
    FROM Event
    WHERE
      event_name = 'April Speaker'
  )
ORDER BY
  amount;
```
=====================
Question: Mention the total expense used on 8/20/2019.
 db_id: student_club
Planner: 1. **Table Selection:** The `Expense` table is needed to find the expense cost and date.
2. **Filtering:** Filter the `Expense` table where `expense_date` is equal to '2019-08-20'.
3. **Aggregation:** Calculate the sum of the `cost` column for the filtered data.

NL2SQL: ```sql
SELECT sum(cost) FROM Expense WHERE expense_date = '2019-08-20'
```
Critic: ```sql
SELECT sum(cost) FROM Expense WHERE expense_date = '08/20/2019'
```
=====================
Question: List out the full name and total cost that member id "rec4BLdZHS2Blfp4v" incurred?
 db_id: student_club
Planner: Plan:
1. Join the `Member` and `Expense` tables on `member_id` and `link_to_member` respectively.
2. Filter the joined table to include only the member with `member_id` = "rec4BLdZHS2Blfp4v".
3. Calculate the total cost for that member by summing the `cost` column from the `Expense` table.
4. Retrieve the `first_name` and `last_name` from the `Member` table and the calculated total cost.

NL2SQL: ```sql
SELECT
  T1.first_name,
  T1.last_name,
  SUM(T2.cost)
FROM Member AS T1
INNER JOIN Expense AS T2
  ON T1.member_id = T2.link_to_member
WHERE
  T1.member_id = 'rec4BLdZHS2Blfp4v'
GROUP BY
  T1.first_name,
  T1.last_name;
```
Critic: ```sql
SELECT
  T1.first_name,
  T1.last_name,
  SUM(T2.cost)
FROM Member AS T1
INNER JOIN Expense AS T2
  ON T1.member_id = T2.link_to_member
WHERE
  T1.member_id = "rec4BLdZHS2Blfp4v"
GROUP BY
  T1.member_id;
```
=====================
Question: State what kind of expenses that Sacha Harrison incurred?
 db_id: student_club
Planner: 1. Find the `member_id` of the member named 'Sacha Harrison' from the `Member` table, using the `first_name` and `last_name` columns.
2. Using the `member_id` obtained in the previous step, find the corresponding `expense_description` from the `Expense` table, using the `link_to_member` column.
3. Return the `expense_description` column.

Join tables:
- Member and Expense.
Join condition:
- Member.member_id = Expense.link_to_member
Filters:
- Member.first_name = "Sacha" AND Member.last_name = "Harrison"
Columns to return:
- Expense.expense_description

NL2SQL: ```sql
SELECT
  T1.expense_description
FROM Expense AS T1
INNER JOIN Member AS T2
  ON T1.link_to_member = T2.member_id
WHERE
  T2.first_name = 'Sacha' AND T2.last_name = 'Harrison';
```
Critic: ```sql
SELECT
  T1.expense_description
FROM Expense AS T1
INNER JOIN Member AS T2
  ON T1.link_to_member = T2.member_id
WHERE
  T2.first_name = 'Sacha' AND T2.last_name = 'Harrison';
```
=====================
Question: State the category of events were held at MU 215.
 db_id: student_club
Planner: 1.  Find the `event_id` of events that took place at location 'MU 215' from the `Event` table.
2.  Find the `type` of the events, based on the `event_id` found in step 1.
3.  Return the distinct `type` of the events.

SQL would require selecting `type` from the `Event` table where `location` is `MU 215`.

NL2SQL: ```sql
SELECT DISTINCT type FROM Event WHERE location = 'MU 215'
```
Critic: ```sql
SELECT DISTINCT Type FROM event WHERE Location = "MU 215"
```
=====================
Question: List the last name of members with a major in environmental engineering and include its department and college name.
 db_id: student_club
Planner: Plan:
1. Filter the `Major` table for the major named 'Environmental Engineering'.
2. Join the `Member` table to the filtered `Major` table using `link_to_major` and `major_id` to find members with the specified major.
3. Select the `last_name` from the `Member` table, and `department` and `college` from the `Major` table.

NL2SQL: ```sql
SELECT
  m.last_name,
  ma.department,
  ma.college
FROM Member AS m
JOIN Major AS ma
  ON m.link_to_major = ma.major_id
WHERE
  ma.major_name = 'Environmental Engineering';
```
Critic: ```sql
SELECT
  T1.last_name,
  T2.department,
  T2.college
FROM Member AS T1
INNER JOIN Major AS T2
  ON T1.link_to_major = T2.major_id
WHERE
  T2.major_name = 'Environmental Engineering';
```
=====================
Question: What are the budget category of the events located at MU 215 and a guest speaker type with a 0 budget spent?
 db_id: student_club
Planner: 1.  Filter the `Event` table to find events where the `location` is 'MU 215' and the `type` is 'Guest Speaker'.
2.  Join the `Event` table with the `Budget` table using the `event_id` and `link_to_event` columns.
3.  Filter the joined table to include only records where `spent` is 0.
4.  Select the `category` from the `Budget` table.


NL2SQL: ```sql
SELECT
  T2.category
FROM Event AS T1
INNER JOIN Budget AS T2
  ON T1.event_id = T2.link_to_event
WHERE
  T1.location = 'MU 215' AND T1.type = 'Guest Speaker' AND T2.spent = 0;
```
Critic: ```sql
SELECT
  T1.category
FROM Budget AS T1
INNER JOIN Event AS T2
  ON T1.link_to_event = T2.event_id
WHERE
  T2.location = 'MU 215' AND T2.type = 'Guest Speaker' AND T1.spent = 0;
```
=====================
Question: Among the members with t-shirt size of medium, what is the percentage of the amount 50 received by the Student_Club?
 db_id: student_club
Planner: 1.  Find the members with a t-shirt size of 'Medium' using the `Member` table.
2.  Find the total income amount received by the Student\_Club by joining the `Income` table to the `Member` table using the `member_id`. Filter the results for members with medium t-shirt size.
3.  Calculate the percentage of the amount 50 received from the total income.

Return the percentage.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.amount = 50 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.amount)
FROM Income AS T1
INNER JOIN Member AS T2
  ON T1.link_to_member = T2.member_id
WHERE
  T2.t_shirt_size = 'Medium';
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.amount = 50 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.amount)
FROM Income AS T1
INNER JOIN Member AS T2
  ON T1.link_to_member = T2.member_id
WHERE
  T2.t_shirt_size = 'MEMBER';
```
=====================
Question: List the names of closed event as "game" that was closed from 3/15/2019 to 3/20/2020.
 db_id: student_club
Planner: ```json
{
"plan": "To answer the question, we need to query the `Event` table. We need to filter by `type` being 'Game' and `status` being 'Closed', and the `event_date` being between '2019-03-15' and '2020-03-20'. Finally, we select the `event_name`."
}
```
NL2SQL: ```sql
SELECT
  event_name AS game
FROM Event
WHERE
  type = 'Game' AND status = 'Closed' AND event_date BETWEEN '2019-03-15' AND '2020-03-20';
```
Critic: ```sql
SELECT
  event_name AS game
FROM Event
WHERE
  status = 'Closed' AND type = 'Game' AND event_date BETWEEN '2019-03-15' AND '2020-03-20';
```
=====================
Question: Give the full name and contact number of members who had to spend more than average on each expense.
 db_id: student_club
Planner: Plan:
1. Calculate the average expense cost from the `Expense` table.
2. Filter the `Expense` table to include only expenses where the cost is greater than the average cost.
3. Join the filtered `Expense` table with the `Member` table on `link_to_member` to get the member's information.
4. Select the first name, last name, and phone number of the members.

NL2SQL: ```sql
SELECT
  T1.first_name,
  T1.last_name,
  T1.phone
FROM Member AS T1
INNER JOIN Expense AS T2
  ON T1.member_id = T2.link_to_member
WHERE
  T2.cost > (
    SELECT
      AVG(cost)
    FROM Expense
  );
```
Critic: ```sql
SELECT
  T1.first_name,
  T1.last_name,
  T1.phone
FROM Member AS T1
INNER JOIN Expense AS T2
  ON T1.member_id = T2.link_to_member
WHERE
  T2.cost > (
    SELECT
      AVG(cost)
    FROM Expense
  );
```
=====================
Question: Write the full name of the member who spent money for water, veggie tray and supplies and include the cost of it.
 db_id: student_club
Planner: Plan:
1. Join the Member and Expense tables using the link_to_member column to link members to their expenses.
2. Filter the Expense table to include only expenses where the expense_description is 'water', 'veggie tray', and 'supplies'.
3. Select the first name, last name from the Member table and cost from the Expense table.
4. Concatenate first name and last name to get full name.

NL2SQL: ```sql
SELECT
  M.first_name,
  M.last_name,
  E.cost
FROM Member AS M
JOIN Expense AS E
  ON M.member_id = E.link_to_member
WHERE
  E.expense_description = 'Water, Veggie tray, supplies';
```
Critic: ```sql
SELECT
  T1.first_name,
  T1.last_name,
  T2.cost
FROM Member AS T1
INNER JOIN Expense AS T2
  ON T1.member_id = T2.link_to_member
WHERE
  T2.expense_description = 'Water, Veggie tray, supplies';
```
=====================
Question: Write the full names of students who received funds on the date of 9/9/2019 and include the amount received.
 db_id: student_club
Planner: Plan:
1. Select the first name and last name from the Member table.
2. Select the amount from the Income table.
3. Join the Member table and the Income table on the link_to_member column.
4. Filter the Income table by date_received = '9/9/2019'.

NL2SQL: ```sql
SELECT
  M.first_name,
  M.last_name,
  I.amount
FROM Member AS M
JOIN Income AS I
  ON M.member_id = I.link_to_member
WHERE
  I.date_received = '9/9/2019';
```
Critic: ```sql
SELECT
  T1.first_name,
  T1.last_name,
  T2.amount
FROM Member AS T1
INNER JOIN Income AS T2
  ON T1.member_id = T2.link_to_member
WHERE
  T2.date_received = '9/9/2019';
```
=====================
Question: Are there more in-patient or outpatient who were male? What is the deviation in percentage?
 db_id: thrombosis_prediction
Planner: Here's the plan to determine if there are more in-patient or outpatient males and the percentage deviation:

1.  **Identify the relevant tables:** We need the `Patient` table since it contains information about patient demographics (sex) and admission type.
2.  **Filter for males:** Filter the `Patient` table for patients where `SEX` is 'M'.
3.  **Count in-patients:** Count the number of male patients where `Admission` is '+'.
4.  **Count out-patients:** Count the number of male patients where `Admission` is '-'.
5.  **Compare the counts:** Compare the counts from steps 3 and 4 to determine if there are more in-patient or outpatient males.
6.  **Calculate the percentage deviation:** Compute the percentage deviation.
7.  **Return Results:** Return both the values and the deviation.

Output Columns:
*   Inpatient Count
*   Outpatient Count
*   Percentage Deviation

Tables:
*   Patient

Columns:
*   Patient.ID
*   Patient.SEX
*   Patient.Admission

NL2SQL: ```sql
SELECT
  SUM(CASE WHEN Admission = '+' THEN 1 ELSE 0 END) AS Inpatient_Count,
  SUM(CASE WHEN Admission = '-' THEN 1 ELSE 0 END) AS Outpatient_Count,
  CAST(SUM(CASE WHEN Admission = '+' THEN 1 ELSE 0 END) AS REAL) * 100 / SUM(CASE WHEN Admission = '-' THEN 1 ELSE 0 END)
FROM Patient
WHERE
  SEX = 'M';
```
Critic: ```sql
SELECT
  SUM(CASE WHEN T1.Admission = '+' THEN 1 ELSE 0 END) AS Inpatient_Count,
  SUM(CASE WHEN T1.Admission = '-' THEN 1 ELSE 0 END) AS Outpatient_Count,
  CAST(SUM(CASE WHEN T1.Admission = '+' THEN 1 ELSE 0 END) - SUM(CASE WHEN T1.Admission = '-' THEN 1 ELSE 0 END) AS REAL) * 100 / SUM(CASE WHEN T1.Admission = '-' THEN 1 ELSE 0 END)
FROM Patient AS T1
WHERE
  T1.SEX = 'M';
```
=====================
Question: What is the percentage of female patient were born after 1930?
 db_id: thrombosis_prediction
Planner: Plan:
1. Count the total number of female patients. Use the Patient table. Filter by SEX = 'F'.
2. Count the number of female patients born after 1930. Use the Patient table. Filter by SEX = 'F' and year(Birthday) > 1930.
3. Calculate the percentage by dividing the count from step 2 by the count from step 1 and multiplying by 100.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN SUBSTR(Birthday, 1, 4) > '1930' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(ID)
FROM Patient
WHERE
  SEX = 'F';
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN STRFTIME('%Y', Birthday) > '1930' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(ID)
FROM Patient
WHERE
  SEX = 'F';
```
=====================
Question: What is the ratio of outpatient to inpatient followed up treatment among all the 'SLE' diagnosed patient?
 db_id: thrombosis_prediction
Planner: Plan:
1. Filter the `Patient` table to get patients diagnosed with 'SLE'.
2. Count the number of 'SLE' patients who were admitted to the hospital (Admission = '+').
3. Count the number of 'SLE' patients who were followed at the outpatient clinic (Admission = '-').
4. Calculate the ratio of outpatient to inpatient 'SLE' patients by dividing the outpatient count by the inpatient count.
5. Handle potential division by zero by returning 0 if the inpatient count is zero.
6. Select only patient IDs, Admissions and Diagnosis columns from table Patient

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN Admission = '+' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN Admission = '-' THEN 1 ELSE 0 END)
FROM Patient
WHERE
  Diagnosis = 'SLE';
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN Admission = '-' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN Admission = '+' THEN 1 ELSE 0 END)
FROM Patient
WHERE
  Diagnosis = 'SLE';
```
=====================
Question: What is the disease patient '30609' diagnosed with. List all the date of laboratory tests done for this patient.
 db_id: thrombosis_prediction
Planner: The question asks for the disease and the dates of laboratory tests for patient '30609'.
1.  Find the diagnosis of the patient '30609' from the `Patient` table.
2.  Find all laboratory test dates for the patient '30609' from the `Laboratory` table.

Join is not needed.

NL2SQL: ```sql
SELECT
  Diagnosis
FROM Patient
WHERE
  ID = 30609;
```
Critic: ```sql
SELECT
  T1.Date
FROM Laboratory AS T1
INNER JOIN Patient AS T2
  ON T1.ID = T2.ID
WHERE
  T2.ID = 30609;
```
=====================
Question: List the patient ID, sex and birthday of patient with LDH beyond normal range.
 db_id: thrombosis_prediction
Planner: The question asks for patient ID, sex and birthday of patients with LDH beyond normal range.
1.  We need to select `ID`, `SEX`, and `Birthday` from the `Patient` table.
2.  We need to filter patients based on their LDH value in the `Laboratory` table. The condition is `LDH > 500`.
3.  We need to join `Patient` and `Laboratory` tables on `Patient.ID = Laboratory.ID`.

NL2SQL: ```sql
SELECT
  p.ID,
  p.SEX,
  p.Birthday
FROM Patient AS p
JOIN Laboratory AS l
  ON p.ID = l.ID
WHERE
  l.LDH > 500;
```
Critic: ```sql
SELECT
  p.ID,
  p.SEX,
  p.Birthday
FROM Patient AS p
INNER JOIN Laboratory AS l
  ON p.ID = l.ID
WHERE
  l.LDH > 500;
```
=====================
Question: State the ID and age of patient with positive degree of coagulation.
 db_id: thrombosis_prediction
Planner: Plan:
1. Filter the 'Examination' table to find records where RVVT equals '+'.
2. Join 'Examination' table with the 'Patient' table using the 'ID' column.
3. Calculate the age of each patient using current year minus birthday year.
4. Select the 'ID' and calculated age for the patients that satisfy the conditions.
NL2SQL: ```sql
SELECT
  T1.ID,
  CAST(STRFTIME('%Y', 'now') AS INTEGER) - CAST(STRFTIME('%Y', T2.Birthday) AS INTEGER)
FROM Examination AS T1
INNER JOIN Patient AS T2
  ON T1.ID = T2.ID
WHERE
  T1.RVVT = '+';
```
Critic: ```sql
SELECT
  T1.ID,
  CAST(STRFTIME('%Y', 'now') AS INTEGER) - CAST(STRFTIME('%Y', T2.Birthday) AS INTEGER)
FROM Examination AS T1
INNER JOIN Patient AS T2
  ON T1.ID = T2.ID
WHERE
  T1.RVVT = '+';
```
=====================
Question: For patients with severe degree of thrombosis, list their ID, sex and disease the patient is diagnosed with.
 db_id: thrombosis_prediction
Planner: Plan:
1. Filter the `Examination` table to select records where `Thrombosis` is equal to 2.
2. Join the filtered `Examination` table with the `Patient` table using the `ID` column.
3. Select the `ID`, `SEX`, and `Diagnosis` columns from the joined table.

NL2SQL: ```sql
SELECT
  T1.ID,
  T1.SEX,
  T1.Diagnosis
FROM Patient AS T1
INNER JOIN Examination AS T2
  ON T1.ID = T2.ID
WHERE
  T2.Thrombosis = 2;
```
Critic: ```sql
SELECT
  p.ID,
  p.SEX,
  p.Diagnosis
FROM Patient AS p
JOIN Examination AS e
  ON p.ID = e.ID
WHERE
  e.Thrombosis = 2;
```
=====================
Question: How many female patients who came at the hospital in 1997 was immediately followed at the outpatient clinic?
 db_id: thrombosis_prediction
Planner: Here's the plan to determine the number of female patients who visited the hospital in 1997 and were immediately followed at the outpatient clinic:

1.  **Filter the `Patient` table:**
    *   Filter by `SEX = 'F'` to select female patients.
    *   Filter by `Admission = '-'` to select patients who were followed at the outpatient clinic.
    *   Filter by `YEAR(Description) = 1997` to select patients whose first recorded data was in 1997.

2.  **Count the number of patients:**
    *   Count the number of distinct patient IDs (`ID`) that satisfy all the filter conditions.

3.  **Return the count.**

NL2SQL: ```sql
SELECT
  COUNT(ID)
FROM Patient
WHERE
  SEX = 'F' AND Admission = '-' AND STRFTIME('%Y', Description) = '1997';
```
Critic: ```sql
SELECT
  COUNT(ID)
FROM Patient
WHERE
  SEX = 'F' AND Admission = '-' AND STRFTIME('%Y', "First Date") = '1997';
```
=====================
Question: How many of the patients with the most serious thrombosis cases examined in 1997 are women?
 db_id: thrombosis_prediction
Planner: Here's my plan to figure out how many women had the most serious thrombosis in 1997:

1.  **Identify patients with the most serious thrombosis in 1997:**
    *   I'll need to use the `Examination` table.
    *   I'll filter for records where `Examination Date` is in 1997.
    *   I'll further filter for records where `Thrombosis` is equal to 1 (most serious).
2.  **Link these patients to the `Patient` table to determine their sex:**
    *   I'll join the `Examination` table with the `Patient` table using the shared `ID` column.
3.  **Count the number of women:**
    *   I'll filter the joined table for patients where `SEX` is equal to 'F'.
    *   I will count the number of patients.

**Tables:** `Examination`, `Patient`

**Columns:**

*   `Examination`: `ID`, `Examination Date`, `Thrombosis`
*   `Patient`: `ID`, `SEX`

**Filters:**

*   `Examination`: `Examination Date` is in 1997, `Thrombosis` = 1
*   `Patient`: `SEX` = 'F'

**Join:** `Examination` JOIN `Patient` ON `Examination`.`ID` = `Patient`.`ID`

NL2SQL: ```sql
SELECT
  COUNT(T1.ID)
FROM Patient AS T1
INNER JOIN Examination AS T2
  ON T1.ID = T2.ID
WHERE
  STRFTIME('%Y', T2."Examination Date") = '1997' AND T2.Thrombosis = 1 AND T1.SEX = 'F';
```
Critic: ```sql
SELECT
  COUNT(T1.ID)
FROM Patient AS T1
INNER JOIN Examination AS T2
  ON T1.ID = T2.ID
WHERE
  STRFTIME('%Y', T2."Examination Date") = '1997' AND T2.Thrombosis = 1 AND T1.SEX = 'F';
```
=====================
Question: What are the symptoms observed by the youngest patient to ever did a medical examination? Identify their diagnosis.
 db_id: thrombosis_prediction
Planner: Here's my plan to answer the question:

1.  Find the youngest patient's ID. This involves finding the maximum birthday from the `Patient` table.
2.  Join the `Patient` table with the `Examination` table on the patient ID to connect the patient with their examinations.
3.  Filter the joined table to only include records of the youngest patient.
4.  Select the `Symptoms` and `Diagnosis` columns from the filtered table. Since we want the symptoms observed during examinations, symptoms is not NULL.

NL2SQL: ```sql
SELECT
  T1.Symptoms,
  T1.Diagnosis
FROM Examination AS T1
INNER JOIN Patient AS T2
  ON T1.ID = T2.ID
WHERE
  T2.Birthday = (
    SELECT
      MAX(Birthday)
    FROM Patient
  )
  AND T1.Symptoms IS NOT NULL;
```
Critic: ```sql
SELECT
  T1.Symptoms,
  T1.Diagnosis
FROM Examination AS T1
INNER JOIN Patient AS T2
  ON T1.ID = T2.ID
WHERE
  T2.Birthday = (
    SELECT
      MAX(Birthday)
    FROM Patient
  );
```
=====================
Question: The oldest SJS patient's medical laboratory work was completed on what date, and what age was the patient when they initially arrived at the hospital?
 db_id: thrombosis_prediction
Planner: Plan:
1. Find the oldest patient with 'SJS' diagnosis from the `Patient` table.
2. Get the `ID` and `First Date` and `Birthday` of the oldest patient.
3. Find the latest `Date` from the `Laboratory` table where the `ID` matches the patient's `ID`.
4. Calculate age using First Date and Birthday columns of patient table.
5. Return the `Date` and age.
I need to join `Patient` and `Laboratory` tables using `ID`.
I need to filter `Patient` table using `Diagnosis = 'SJS'`.
I need to order the `Patient` table by `Birthday` in ascending order and limit to 1 to get the oldest patient.
I need to find the maximum `Date` from the `Laboratory` table for the patient that I found.
I need to calculate the age using the `First Date` and `Birthday` from the `Patient` table.

NL2SQL: ```sql
SELECT
  T1.Date,
  CAST(SUBSTR(T2."First Date", 1, 4) AS INTEGER) - CAST(SUBSTR(T2.Birthday, 1, 4) AS INTEGER)
FROM Laboratory AS T1
INNER JOIN Patient AS T2
  ON T1.ID = T2.ID
WHERE
  T2.Diagnosis = 'SJS'
ORDER BY
  T2.Birthday
LIMIT 1;
```
Critic: ```sql
SELECT
  T1.Date,
  CAST(STRFTIME('%Y', T2."First Date") AS INTEGER) - CAST(STRFTIME('%Y', T2.Birthday) AS INTEGER)
FROM Laboratory AS T1
INNER JOIN Patient AS T2
  ON T1.ID = T2.ID
WHERE
  T2.Diagnosis = 'SJS'
ORDER BY
  T2.Birthday
LIMIT 1;
```
=====================
Question: What is the ratio of male to female patients among all those with abnormal uric acid counts?
 db_id: thrombosis_prediction
Planner: Plan:
1. Join the Patient and Laboratory tables on the common column ID.
2. Filter the joined table for patients with abnormal uric acid levels. The abnormal uric acid level is defined as UA <= 8.0 for males (SEX = 'M') and UA <= 6.5 for females (SEX = 'F').
3. Count the number of male patients and the number of female patients with abnormal uric acid levels.
4. Calculate the ratio of male to female patients by dividing the number of male patients by the number of female patients.
5. Return the calculated ratio.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.SEX = 'M' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN T1.SEX = 'F' THEN 1 ELSE 0 END)
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
WHERE
  (
    T1.SEX = 'M' AND T2.UA <= 8.0
  )
  OR (
    T1.SEX = 'F' AND T2.UA <= 6.5
  );
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.SEX = 'M' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN T1.SEX = 'F' THEN 1 ELSE 0 END)
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
WHERE
  (
    T1.SEX = 'M' AND T2.UA > 8.0
  )
  OR (
    T1.SEX = 'F' AND T2.UA > 6.5
  );
```
=====================
Question: How many underage patients were examined during the course of the three-year period from 1990 to 1993?
 db_id: thrombosis_prediction
Planner: Here's the plan to determine the number of underage patients examined between 1990 and 1993:

1.  **Join Tables:** Join the `Patient` and `Examination` tables on the common `ID` (patient ID) column.
2.  **Filter by Date:** Filter the joined table to include only examinations performed between January 1, 1990, and December 31, 1993.
3.  **Calculate Age:** Determine the age of each patient at the time of their examination by subtracting the birth year from the examination year.
4.  **Filter by Age:** Filter the results to include only patients who were under 18 years old at the time of their examination.
5.  **Count Distinct Patients:** Count the distinct number of patient IDs to get the total number of underage patients examined during the specified period.

NL2SQL:
```sql
SELECT
  COUNT(DISTINCT T1.ID)
FROM Patient AS T1
INNER JOIN Examination AS T2
  ON T1.ID = T2.ID
WHERE
  CAST(strftime('%Y', T2."Examination Date") AS INTEGER) BETWEEN 1990 AND 1993
  AND CAST(strftime('%Y', T2."Examination Date") AS INTEGER) - CAST(strftime('%Y', T1.Birthday) AS INTEGER) < 18;
```
NL2SQL: ```sql
SELECT
  COUNT(DISTINCT T1.ID)
FROM Patient AS T1
INNER JOIN Examination AS T2
  ON T1.ID = T2.ID
WHERE
  CAST(strftime('%Y', T2."Examination Date") AS INTEGER) BETWEEN 1990 AND 1993
  AND CAST(strftime('%Y', T2."Examination Date") AS INTEGER) - CAST(strftime('%Y', T1.Birthday) AS INTEGER) < 18;
```
Critic: ```sql
SELECT
  COUNT(DISTINCT T1.ID)
FROM Patient AS T1
INNER JOIN Examination AS T2
  ON T1.ID = T2.ID
WHERE
  STRFTIME('%Y', T2."Examination Date") BETWEEN '1990' AND '1993'
  AND STRFTIME('%Y', T2."Examination Date") - STRFTIME('%Y', T1.Birthday) < 18;
```
=====================
Question: How old was the patient who had the highest hemoglobin count at the time of the examination, and what is the doctor's diagnosis?
 db_id: thrombosis_prediction
Planner: Here's my plan to determine the age of the patient with the highest hemoglobin count at the time of examination and their diagnosis:

1.  **Find the highest hemoglobin (HGB) value:** Select the maximum `HGB` value from the `Laboratory` table.
2.  **Find the patient ID with max HGB:** Select `ID` from the `Laboratory` table where `HGB` equals the maximum `HGB` found in step 1.
3.  **Join `Patient` and `Examination` tables on `ID`:** Join the `Patient` and `Examination` tables using the common column `ID`.
4.  **Filter joined table on patient IDs from Laboratory:** Filter the result of the join to include only records where the `Patient.ID` matches the `ID` found in step 2.
5.  **Calculate age:** Calculate the patient's age at the time of examination by subtracting the birth year from the examination year: `year(Examination.Examination Date) - year(Patient.Birthday)`.
6.  **Retrieve diagnosis:** Select the `Patient.Diagnosis` and calculated age.

NL2SQL: ```sql
SELECT
  Patient.Diagnosis,
  CAST(SUBSTR(STRFTIME('%Y', Examination."Examination Date"), 3, 2) AS INTEGER) - CAST(SUBSTR(STRFTIME('%Y', Patient.Birthday), 3, 2) AS INTEGER)
FROM Patient
JOIN Examination
  ON Patient.ID = Examination.ID
JOIN Laboratory
  ON Examination.ID = Laboratory.ID
WHERE
  Laboratory.HGB = (
    SELECT
      MAX(HGB)
    FROM Laboratory
  );
```
Critic: ```sql
SELECT
  p.Diagnosis,
  CAST(STRFTIME('%Y', e."Examination Date") AS INTEGER) - CAST(STRFTIME('%Y', p.Birthday) AS INTEGER)
FROM Patient AS p
JOIN Examination AS e
  ON p.ID = e.ID
JOIN Laboratory AS l
  ON e.ID = l.ID
WHERE
  l.HGB = (
    SELECT
      MAX(HGB)
    FROM Laboratory
  );
```
=====================
Question: For the patient who was diagnosed with SLE on 1994/2/19, what was his/her anti-Cardiolipin antibody concentration status on 1993/11/12?
 db_id: thrombosis_prediction
Planner: Here's my plan to retrieve the anti-Cardiolipin antibody (IgM) concentration status for the specified patient:

1. **Identify the patient:** Use the `Patient` table to find the `ID` of the patient whose `Diagnosis` is 'SLE' and `Description` is '1994-02-19'.
2. **Retrieve anti-Cardiolipin antibody (IgM) concentration:** Use the `Examination` table, filter by the `ID` found in the previous step and `Examination Date` equal to '1993-11-12'. Select the `aCL IgM` column.

NL2SQL: ```sql
SELECT
  T2."aCL IgM"
FROM Patient AS T1
INNER JOIN Examination AS T2
  ON T1.ID = T2.ID
WHERE
  T1.Diagnosis = 'SLE' AND T1.Description = '1994-02-19' AND T2."Examination Date" = '1993-11-12';
```
Critic: ```sql
SELECT
  T1."aCL IgM"
FROM Examination AS T1
INNER JOIN Patient AS T2
  ON T1.ID = T2.ID
WHERE
  T2.Diagnosis = 'SLE' AND T2.Description = '1994-02-19' AND T1."Examination Date" = '1993-11-12';
```
=====================
Question: For the patient who was born on 1959/2/18, what is the decrease rate for his/her total cholesterol from November to December in 1981?
 db_id: thrombosis_prediction
Planner: Plan:
1. Find the patient ID using the Patient table where Birthday is '1959-02-18'.
2. Using the patient ID, find the total cholesterol (T-CHO) from the Laboratory table for November 1981 (Date like '1981-11-%').
3. Using the patient ID, find the total cholesterol (T-CHO) from the Laboratory table for December 1981 (Date like '1981-12-%').
4. Calculate the decrease rate using the formula: (November T-CHO - December T-CHO) / December T-CHO.
We need to use the Patient and Laboratory tables. We need to join them on Patient.ID = Laboratory.ID. We need to filter by Birthday = '1959-02-18' and Date like '1981-11-%' or Date like '1981-12-%'. We need to calculate the sum of T-CHO for each month.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.Date LIKE '1981-11%' THEN T2."T-CHO" ELSE 0 END) - SUM(CASE WHEN T1.Date LIKE '1981-12%' THEN T2."T-CHO" ELSE 0 END) AS REAL) / SUM(CASE WHEN T1.Date LIKE '1981-12%' THEN T2."T-CHO" ELSE 0 END)
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
WHERE
  T1.Birthday = '1959-02-18' AND (
    T2.Date LIKE '1981-11%' OR T2.Date LIKE '1981-12%'
  );
```
Critic: ```sql
SELECT
  CAST((
    SUM(CASE WHEN STRFTIME('%Y-%m', T2.Date) = '1981-11' THEN T2."T-CHO" ELSE 0 END) - SUM(CASE WHEN STRFTIME('%Y-%m', T2.Date) = '1981-12' THEN T2."T-CHO" ELSE 0 END)
  ) AS REAL) * 100 / SUM(CASE WHEN STRFTIME('%Y-%m', T2.Date) = '1981-11' THEN T2."T-CHO" ELSE 0 END)
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
WHERE
  T1.Birthday = '1959-02-18' AND STRFTIME('%Y', T2.Date) = '1981' AND (
    STRFTIME('%m', T2.Date) = '11' OR STRFTIME('%m', T2.Date) = '12'
  );
```
=====================
Question: How many patients who were examined between 1987/7/6 and 1996/1/31 had a GPT level greater than 30 and an ALB level less than 4? List them by their ID.
 db_id: thrombosis_prediction
Planner: Plan:
1. Select the ID from the Laboratory table.
2. Filter the Laboratory table by Date between '1987-07-06' and '1996-01-31', GPT > 30 and ALB < 4.
3. Return distinct IDs to avoid duplicates.

NL2SQL: ```sql
SELECT DISTINCT ID FROM Laboratory WHERE Date BETWEEN '1987-07-06' AND '1996-01-31' AND GPT > 30 AND ALB < 4
```
Critic: ```sql
SELECT DISTINCT ID FROM Laboratory WHERE Date BETWEEN '1987-07-06' AND '1996-01-31' AND GPT > 30 AND ALB < 4
```
=====================
Question: What number of patients with a degree of thrombosis level 2 and ANA pattern of only S, have a level of anti-Cardiolip in antibody (IgM) 20% higher than average?
 db_id: thrombosis_prediction
Planner: Here's my plan to determine the number of patients satisfying the specified criteria:

1.  **Calculate the average 'aCL IgM'**: Use the `Examination` table to calculate the average value of the `aCL IgM` column across all records.
2.  **Calculate the threshold for 'aCL IgM'**: Add 20% of the average `aCL IgM` value to the average `aCL IgM` itself. This will serve as the threshold.
3.  **Filter the Examination table**:
    *   Filter the `Examination` table for records where `Thrombosis` is equal to 2 and `ANA Pattern` is equal to 'S'.
    *   Further filter the table to include only records where `aCL IgM` is greater than the calculated threshold.
4.  **Count the distinct patients**: Count the number of distinct `ID` values from the filtered `Examination` table. This will give the number of patients satisfying all the conditions.
I will use the Examination table for the conditions related to `Thrombosis`, `ANA Pattern`, and `aCL IgM`. I'll count the distinct `ID` values to get the number of patients.

NL2SQL: ```sql
SELECT
  COUNT(DISTINCT ID)
FROM Examination
WHERE
  Thrombosis = 2 AND "ANA Pattern" = 'S' AND "aCL IgM" > (
    SELECT
      AVG("aCL IgM") * 1.2
    FROM Examination
  );
```
Critic: ```sql
SELECT
  COUNT(T1.ID)
FROM Examination AS T1
INNER JOIN Patient AS T2
  ON T1.ID = T2.ID
WHERE
  T1.Thrombosis = 2 AND T1."ANA Pattern" = 'S' AND T1."aCL IgM" > (
    SELECT
      AVG("aCL IgM") * 1.2
    FROM Examination
  );
```
=====================
Question: List all patients who were followed up at the outpatient clinic who underwent a laboratory test in October 1991 and had a total blood bilirubin level within the normal range.
 db_id: thrombosis_prediction
Planner: 1. Filter the `Patient` table to select patients who were followed up at the outpatient clinic (`Admission` = '-').
2. Filter the `Laboratory` table to select laboratory tests performed in October 1991 (`Date` LIKE '1991-10%') and where the total blood bilirubin level (`T-BIL`) is within the normal range (T-BIL < 2.0).
3. Join the `Patient` and `Laboratory` tables on the `ID` column.
4. Select the `ID` column from the joined table.

NL2SQL: ```sql
SELECT
  T1.ID
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
WHERE
  T1.Admission = '-' AND T2.Date LIKE '1991-10%' AND T2."T-BIL" < 2.0;
```
Critic: ```sql
SELECT
  T1.ID
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
WHERE
  T1.Admission = '-' AND STRFTIME('%Y-%m', T2.Date) = '1991-10' AND T2."T-BIL" < 2.0;
```
=====================
Question: What is the average blood albumin level for female patients with a PLT greater than 400 who have been diagnosed with SLE?
 db_id: thrombosis_prediction
Planner: Plan:
1. Join the `Patient` and `Laboratory` tables on `ID` to link patient information with their lab results.
2. Filter the joined table to include only female patients (`SEX = 'F'`) with PLT greater than 400 (`PLT > 400`) and diagnosed with SLE (`Diagnosis = 'SLE'`).
3. Calculate the average albumin level (`ALB`) for the filtered data.
4. Return the average albumin level.

NL2SQL: ```sql
SELECT AVG(T1.ALB) FROM Laboratory AS T1 JOIN Patient AS T2 ON T1.ID = T2.ID WHERE T2.SEX = 'F' AND T1.PLT > 400 AND T2.Diagnosis = 'SLE'
```
Critic: ```sql
SELECT AVG(T1.ALB) FROM Laboratory AS T1 INNER JOIN Patient AS T2 ON T1.ID = T2.ID WHERE T2.SEX = 'F' AND T1.PLT > 400 AND T2.Diagnosis = 'SLE'
```
=====================
Question: How many female patients were given an APS diagnosis?
 db_id: thrombosis_prediction
Planner: 1.  **Identify the relevant tables:** We need the `Patient` table because it contains information about the patient's sex and diagnosis.
2.  **Filter for female patients:** Filter the `Patient` table to include only patients where `SEX` is 'F'.
3.  **Filter for APS diagnosis:** Filter the `Patient` table to include only patients where `Diagnosis` is 'APS'.
4.  **Combine filters and count:** Combine the filters for sex and diagnosis to find the number of female patients with an APS diagnosis.

NL2SQL: ```sql
SELECT
  COUNT(ID)
FROM Patient
WHERE
  SEX = 'F' AND Diagnosis = 'APS';
```
Critic: ```sql
SELECT
  COUNT(ID)
FROM Patient
WHERE
  SEX = 'F' AND Diagnosis = 'APS';
```
=====================
Question: What percentage of patients who were born in 1980 and were diagnosed with RA are women?
 db_id: thrombosis_prediction
Planner: Plan:
1. Filter the Patient table to include only patients born in 1980.
2. Filter the Patient table to include only patients diagnosed with RA.
3. Join the filtered Patient table with itself since both filters are applied to the same table.
4. Calculate the number of female patients.
5. Calculate the total number of patients.
6. Calculate the percentage of female patients out of the total number of patients.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.SEX = 'F' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.SEX)
FROM Patient AS T1
WHERE
  STRFTIME('%Y', T1.Birthday) = '1980' AND T1.Diagnosis = 'RA';
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN SEX = 'F' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*)
FROM Patient
WHERE
  STRFTIME('%Y', Birthday) = '1980' AND Diagnosis = 'RA';
```
=====================
Question: Was the patient with the number 57266's uric acid within a normal range?
 db_id: thrombosis_prediction
Planner: Plan:
1. Find the patient's sex from the Patient table using the given ID.
2. Find the patient's uric acid (UA) value from the Laboratory table using the same ID.
3. Compare the UA value to the normal range based on the patient's sex. The normal ranges are UA > 8.0 for males and UA > 6.5 for females.
4. Return 'Yes' if within normal range, 'No' if not.

Tables: Patient, Laboratory
Columns:
- Patient: ID, SEX
- Laboratory: ID, UA
Joins:
- Patient.ID = Laboratory.ID
Filters:
- Patient.ID = 57266
Output:
- Whether the UA is within the normal range.

NL2SQL: ```sql
SELECT
  CASE
    WHEN T1.SEX = 'M' AND T2.UA > 8.0 THEN 'Yes'
    WHEN T1.SEX = 'F' AND T2.UA > 6.5 THEN 'Yes'
    ELSE 'No'
  END
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
WHERE
  T1.ID = 57266;
```
Critic: ```sql
SELECT
  CASE
    WHEN T1.SEX = 'M' AND T2.UA > 8.0 THEN 'Yes'
    WHEN T1.SEX = 'F' AND T2.UA > 6.5 THEN 'Yes'
    ELSE 'No'
  END
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
WHERE
  T1.ID = 57266;
```
=====================
Question: Provide IDs for male patients with ALT glutamic pylvic transaminase (GPT) that have history of ALT glutamic pylvic transaminase (GPT) exceed the normal range.
 db_id: thrombosis_prediction
Planner: Plan:
1. Filter Patient table to get male patients (SEX = 'M').
2. Filter Laboratory table to get records where GPT >= 60.
3. Join Patient and Laboratory tables on Patient.ID = Laboratory.ID.
4. Select the IDs from the joined table.

NL2SQL: ```sql
SELECT DISTINCT
  T1.ID
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
WHERE
  T1.SEX = 'M' AND T2.GPT >= 60;
```
Critic: ```sql
SELECT DISTINCT
  ID
FROM Patient
WHERE
  SEX = 'M'
  AND ID IN (
    SELECT
      ID
    FROM Laboratory
    WHERE
      GPT >= 60
  );
```
=====================
Question: Please provide the diagnosis of patients with ALT glutamic pylvic transaminase beyond the normal range by ascending order of their date of birth.
 db_id: thrombosis_prediction
Planner: Plan:
1. Filter Laboratory table to get records where GPT > 60.
2. Join Laboratory table with Patient table on patient ID.
3. Select Diagnosis from Patient table and Birthday from Patient table.
4. Order the result by Birthday in ascending order.

NL2SQL: ```sql
SELECT
  p.Diagnosis
FROM Laboratory AS l
JOIN Patient AS p
  ON l.ID = p.ID
WHERE
  l.GPT > 60
ORDER BY
  p.Birthday;
```
Critic: ```sql
SELECT
  T1.Diagnosis
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
WHERE
  T2.GPT > 60
ORDER BY
  T1.Birthday;
```
=====================
Question: Provide all ID, sex and birthday of patients whose urea nitrogen (UN) just within the borderline of passing?
 db_id: thrombosis_prediction
Planner: Plan:
1. Filter the `Laboratory` table to find records where `UN` is equal to 29.
2. Join the filtered `Laboratory` table with the `Patient` table using the `ID` column.
3. Select the `ID`, `SEX`, and `Birthday` columns from the joined table.

NL2SQL: ```sql
SELECT
  p.ID,
  p.SEX,
  p.Birthday
FROM Patient AS p
JOIN Laboratory AS l
  ON p.ID = l.ID
WHERE
  l.UN = 29;
```
Critic: ```sql
SELECT
  p.ID,
  p.SEX,
  p.Birthday
FROM Patient AS p
JOIN Laboratory AS l
  ON p.ID = l.ID
WHERE
  l.UN = 29;
```
=====================
Question: List and group all patients by sex for total bilirubin (T-BIL) level not within the normal range.
 db_id: thrombosis_prediction
Planner: Plan:
1. Join the Patient and Laboratory tables on the common ID column.
2. Filter the results where T-BIL is greater than or equal to 2.0.
3. Group the results by sex.
4. List the distinct patient IDs for each sex.
5. Select the sex and the concatenated list of patient IDs.
NL2SQL: ```sql
SELECT
  p.SEX,
  GROUP_CONCAT(DISTINCT p.ID)
FROM Patient AS p
JOIN Laboratory AS l
  ON p.ID = l.ID
WHERE
  l.T_BIL >= 2.0
GROUP BY
  p.SEX;
```
Critic: ```sql
SELECT
  p.SEX,
  GROUP_CONCAT(DISTINCT p.ID)
FROM Patient AS p
JOIN Laboratory AS l
  ON p.ID = l.ID
WHERE
  l.T_BIL >= 2.0
GROUP BY
  p.SEX;
```
=====================
Question: What is the average age of the male patient with high cholesterol?
 db_id: thrombosis_prediction
Planner: Here's my plan to determine the average age of male patients with high cholesterol:

1.  **Identify male patients:** Filter the `Patient` table for patients where `SEX` is 'M'.
2.  **Identify patients with high cholesterol:** Filter the `Laboratory` table for patients with `T-CHO` greater than or equal to 250.
3.  **Join the tables:** Join `Patient` and `Laboratory` tables on their common column `ID`.
4.  **Calculate age:** For each patient, calculate their age by subtracting the year of their `Birthday` from the current year.
5.  **Calculate the average age:** Calculate the average of the ages of the patients identified in the previous steps.

NL2SQL: ```sql
SELECT
  AVG(YEAR(DATE('now')) - YEAR(T1.Birthday))
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
WHERE
  T1.SEX = 'M' AND T2."T-CHO" >= 250;
```
Critic: ```sql
SELECT
  AVG(STRFTIME('%Y', 'now') - STRFTIME('%Y', T1.Birthday))
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
WHERE
  T1.SEX = 'M' AND T2."T-CHO" >= 250;
```
=====================
Question: For all patients with triglyceride (TG) level beyond the normal range, how many are age more than 50 years?
 db_id: thrombosis_prediction
Planner: Here's the plan to determine the number of patients with triglyceride levels beyond the normal range who are also over 50 years old:

1.  **Identify patients with high triglyceride levels:**
    *   Use the `Laboratory` table.
    *   Filter for records where `TG >= 200`.
    *   Select the `ID` of these patients.
2.  **Identify patients older than 50:**
    *   Use the `Patient` table.
    *   Calculate the age of each patient using `SUBTRACT(year(current_timestamp), year(Birthday))`.
    *   Filter for patients where the calculated age is greater than 50.
    *   Select the `ID` of these patients.
3.  **Combine the results:**
    *   Join the results from steps 1 and 2 on the `ID` column.
    *   This will give us the patients who meet both criteria.
4.  **Count the number of patients:**
    *   Use `COUNT(DISTINCT ID)` to count the number of unique patients who meet both criteria.
    *   Return the count.

NL2SQL:
```sql
SELECT
  COUNT(DISTINCT T1.ID)
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
WHERE
  T2.TG >= 200 AND SUBSTR(CAST(strftime('%Y', 'now') AS TEXT), 3, 2) - SUBSTR(T1.Birthday, 1, 2) > 50;
```
NL2SQL: ```sql
SELECT
  COUNT(DISTINCT T1.ID)
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
WHERE
  T2.TG >= 200 AND CAST(SUBSTR(STRFTIME('%Y', 'now'), 3, 2) AS INTEGER) - CAST(SUBSTR(STRFTIME('%Y', T1.Birthday), 3, 2) AS INTEGER) > 50;
```
Critic: ```sql
SELECT
  COUNT(DISTINCT T1.ID)
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
WHERE
  T2.TG >= 200 AND CAST(SUBSTR(STRFTIME('%Y', 'now'), 1, 4) AS INTEGER) - CAST(SUBSTR(STRFTIME('%Y', T1.Birthday), 1, 4) AS INTEGER) > 50;
```
=====================
Question: For patient born between 1936-1956, how many male patients have creatinine phosphokinase beyond the normal range?
 db_id: thrombosis_prediction
Planner: Plan:
1. Filter the Patient table to get male patients born between 1936 and 1956.
2. Join the filtered Patient table with the Laboratory table on Patient.ID = Laboratory.ID.
3. Filter the joined table where CPK >= 250.
4. Count the distinct Patient IDs to get the number of patients.

NL2SQL: ```sql
SELECT
  COUNT(DISTINCT T1.ID)
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
WHERE
  T1.SEX = 'M' AND STRFTIME('%Y', T1.Birthday) BETWEEN '1936' AND '1956' AND T2.CPK >= 250;
```
Critic: ```sql
SELECT
  COUNT(DISTINCT T1.ID)
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
WHERE
  T1.SEX = 'M' AND CAST(strftime('%Y', T1.Birthday) AS INTEGER) BETWEEN 1936 AND 1956 AND T2.CPK >= 250;
```
=====================
Question: Provide ID, sex and age of patient who has blood glucose (GLU) not within normal range but with total cholesterol(T-CHO) within normal range.
 db_id: thrombosis_prediction
Planner: Here's a plan to retrieve the requested information:

1.  **Identify relevant tables:** We need the `Patient` table to get `ID`, `SEX`, and `Birthday` and the `Laboratory` table to filter based on `GLU` and `T-CHO` values.
2.  **Define normal ranges:** The problem defines the normal ranges for blood glucose (GLU) and total cholesterol (T-CHO). GLU >= 180 and T-CHO < 250.
3.  **Join tables:** Join `Patient` and `Laboratory` tables on the common column `ID`.
4.  **Filter based on conditions:** Filter the joined table to include only patients with `GLU` >= 180 and `T-CHO` < 250.
5.  **Calculate age:** calculate age as year(current\_timestamp) - year(Birthday)
6.  **Select desired columns:** Select the `ID`, `SEX`, and calculated age columns from the filtered table.

NL2SQL: ```sql
SELECT
  P.ID,
  P.SEX,
  CAST(STRFTIME('%Y', 'now') AS INTEGER) - CAST(STRFTIME('%Y', P.Birthday) AS INTEGER)
FROM Patient AS P
JOIN Laboratory AS L
  ON P.ID = L.ID
WHERE
  L.GLU >= 180 AND L."T-CHO" < 250;
```
Critic: ```sql
SELECT
  P.ID,
  P.SEX,
  CAST(STRFTIME('%Y', 'now') AS INTEGER) - CAST(STRFTIME('%Y', P.Birthday) AS INTEGER)
FROM Patient AS P
JOIN Laboratory AS L
  ON P.ID = L.ID
WHERE
  L.GLU >= 180 AND L."T-CHO" < 250;
```
=====================
Question: What are the patient's diagnosis for those who has lower red blood blood cell? State their ID and age.
 db_id: thrombosis_prediction
Planner: Plan:
1. Filter the `Laboratory` table to find patients with RBC < 3.5.
2. Join the filtered `Laboratory` table with the `Patient` table on `ID` to retrieve patient information (ID, Birthday, Diagnosis).
3. Calculate the age of each patient using the Birthday.
4. Select the patient's ID, age and diagnosis.

NL2SQL: ```sql
SELECT
  p.ID,
  CAST(STRFTIME('%Y', 'now') AS INTEGER) - CAST(STRFTIME('%Y', p.Birthday) AS INTEGER) AS age,
  p.Diagnosis
FROM Laboratory AS l
JOIN Patient AS p
  ON l.ID = p.ID
WHERE
  l.RBC < 3.5;
```
Critic: ```sql
SELECT
  p.ID,
  CAST(STRFTIME('%Y', 'now') AS INTEGER) - CAST(STRFTIME('%Y', p.Birthday) AS INTEGER) AS age,
  p.Diagnosis
FROM Patient AS p
JOIN Laboratory AS l
  ON p.ID = l.ID
WHERE
  l.RBC < 3.5;
```
=====================
Question: Among the patients who were diagnosed with SLE, who is the oldest with normal hemoglobin level. Provide the ID and sex.
 db_id: thrombosis_prediction
Planner: Here's my plan to determine the oldest SLE patient with normal hemoglobin:

1.  **Filter Patients with SLE:** Start by filtering the `Patient` table to include only patients diagnosed with SLE (`Diagnosis` = 'SLE').
2.  **Identify Patients with Normal Hemoglobin:** Join the filtered `Patient` table with the `Laboratory` table using `ID` to access hemoglobin levels (`HGB`). Filter the joined table to include only patients with hemoglobin levels between 10 and 17 (inclusive).
3.  **Determine the Oldest Patient:** Order the resulting table by `Birthday` in ascending order (oldest first).
4.  **Select and Display Required Information:** Select the `ID` and `SEX` of the oldest patient (first row after sorting).

NL2SQL: ```sql
SELECT
  p.ID,
  p.SEX
FROM Patient AS p
JOIN Laboratory AS l
  ON p.ID = l.ID
WHERE
  p.Diagnosis = 'SLE' AND l.HGB > 10 AND l.HGB < 17
ORDER BY
  p.Birthday
LIMIT 1;
```
Critic: ```sql
SELECT
  p.ID,
  p.SEX
FROM Patient AS p
JOIN Laboratory AS l
  ON p.ID = l.ID
WHERE
  p.Diagnosis = 'SLE' AND l.HGB > 10 AND l.HGB < 17
ORDER BY
  p.Birthday
LIMIT 1;
```
=====================
Question: Name the ID and age of patient with two or more laboratory examinations which show their hematoclit level exceeded the normal range.
 db_id: thrombosis_prediction
Planner: Plan:
1. Filter the `Laboratory` table for records where `HCT` is greater than or equal to 52.
2. Group the filtered `Laboratory` data by `ID` and count the number of examinations (`HCT` >= 52) for each patient.
3. Filter the grouped results to include only patients with a count of 2 or more examinations.
4. Join the result with the `Patient` table on `ID` to retrieve the `age` of the qualified patients.
5. Calculate the age for each patient using the current timestamp and the `Birthday` column.
6. Select the `ID` and calculated `age` for the final output.
NL2SQL: ```sql
SELECT
  T1.ID,
  CAST(STRFTIME('%Y', 'now') AS INTEGER) - CAST(STRFTIME('%Y', T1.Birthday) AS INTEGER)
FROM Patient AS T1
INNER JOIN (
  SELECT
    ID
  FROM Laboratory
  WHERE
    HCT >= 52
  GROUP BY
    ID
  HAVING
    COUNT(ID) >= 2
) AS T2
  ON T1.ID = T2.ID;
```
Critic: ```sql
SELECT
  T1.ID,
  CAST(STRFTIME('%Y', 'now') AS INTEGER) - CAST(STRFTIME('%Y', T1.Birthday) AS INTEGER)
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
WHERE
  T2.HCT >= 52
GROUP BY
  T1.ID
HAVING
  COUNT(T1.ID) >= 2;
```
=====================
Question: For patients with abnormal platelet level, state the number of patients with lower than normal range. How is it compare to the number of patients with higher than normal range?
 db_id: thrombosis_prediction
Planner: Plan:
1. Filter the `Laboratory` table for records where `PLT` is less than 100 or greater than 400.
2. Calculate the number of patients with `PLT` less than 100.
3. Calculate the number of patients with `PLT` greater than 400.
4. Calculate the difference between the counts from steps 2 and 3.
5. Display the counts from steps 2 and 3 and the difference calculated in step 4.

NL2SQL: ```sql
SELECT
  SUM(CASE WHEN PLT < 100 THEN 1 ELSE 0 END) AS num_patients_lower,
  SUM(CASE WHEN PLT > 400 THEN 1 ELSE 0 END) AS num_patients_higher,
  SUM(CASE WHEN PLT < 100 THEN 1 ELSE 0 END) - SUM(CASE WHEN PLT > 400 THEN 1 ELSE 0 END) AS difference
FROM Laboratory
WHERE
  PLT <= 100 OR PLT >= 400;
```
Critic: ```sql
SELECT
  SUM(CASE WHEN PLT < 100 THEN 1 ELSE 0 END) AS lower_than_normal,
  SUM(CASE WHEN PLT > 400 THEN 1 ELSE 0 END) AS higher_than_normal
FROM Laboratory
WHERE
  PLT < 100 OR PLT > 400;
```
=====================
Question: For laboratory examinations take in 1984, list all patients below 50 years old with normal platelet level.
 db_id: thrombosis_prediction
Planner: Plan:
1. Select patient IDs.
2. Filter Laboratory table by `Date` in 1984 and `PLT` (platelet level) between 100 and 400.
3. Filter Patient table by age (less than 50 years old).
4. Join Laboratory and Patient tables on Patient.ID = Laboratory.ID.
5. Return the Patient IDs.

NL2SQL: ```sql
SELECT
  T1.ID
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
WHERE
  CAST(strftime('%Y', 'now') AS INTEGER) - CAST(strftime('%Y', T1.Birthday) AS INTEGER) < 50
  AND T2.PLT BETWEEN 100 AND 400
  AND STRFTIME('%Y', T2.Date) = '1984';
```
Critic: ```sql
SELECT
  T1.ID
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
WHERE
  CAST(strftime('%Y', 'now') AS INTEGER) - CAST(strftime('%Y', T1.Birthday) AS INTEGER) < 50
  AND T2.PLT BETWEEN 100 AND 400
  AND STRFTIME('%Y', T2.Date) = '1984';
```
=====================
Question: For all patients who are older than 55 years old, what is the percentage of female who has abnormal prothrombin time (PT)?
 db_id: thrombosis_prediction
Planner: Here's my plan to determine the percentage of female patients older than 55 with abnormal prothrombin time (PT):

1.  **Identify relevant tables:** We need the `Patient` table for patient information (age and gender) and the `Laboratory` table for prothrombin time (PT) values.
2.  **Join tables:** Join `Patient` and `Laboratory` tables using the `ID` (patient identification) column.
3.  **Filter for age:** Filter the joined table to include only patients older than 55 years.
4.  **Filter for abnormal PT:** Filter the joined table to include records where PT is greater than or equal to 14.
5.  **Filter for Female:** Filter the joined table to include records where SEX is 'F'.
6.  **Calculate the percentage:**

    *   Count the number of female patients older than 55 with abnormal PT.
    *   Divide the count by the total number of patients older than 55 with abnormal PT.
    *   Multiply the result by 100 to express it as a percentage.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.SEX = 'F' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.ID)
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
WHERE
  SUBSTR(T1.Birthday, 1, 4) < SUBSTR(DATE('now'), 1, 4) - 55 AND T2.PT >= 14;
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.SEX = 'F' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.ID)
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
WHERE
  CAST(SUBSTR(T1.Birthday, 1, 4) AS INTEGER) < CAST(SUBSTR(DATE('now'), 1, 4) AS INTEGER) - 55 AND T2.PT >= 14;
```
=====================
Question: Among the male patients who have a normal level of white blood cells, how many of them have an abnormal fibrinogen level?
 db_id: thrombosis_prediction
Planner: 1.  Find male patients from the `Patient` table. Filter `Patient` table using `SEX` = 'M'. Get the `ID` of male patients.
2.  Find patients with normal white blood cell levels from the `Laboratory` table. Filter `Laboratory` table using `WBC` > 3.5 and `WBC` < 9.0. Get the `ID` of patients with normal WBC levels.
3.  Find patients with abnormal fibrinogen levels from the `Laboratory` table. Filter `Laboratory` table using `FG` <= 150 or `FG` >= 450. Get the `ID` of patients with abnormal FG levels.
4.  Join the results from steps 1, 2, and 3 on the `ID` column to find the patients who satisfy all three conditions.
5.  Count the number of distinct patients who satisfy all three conditions.

NL2SQL: ```sql
SELECT
  COUNT(DISTINCT T1.ID)
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
WHERE
  T1.SEX = 'M' AND T2.WBC > 3.5 AND T2.WBC < 9.0 AND (
    T2.FG <= 150 OR T2.FG >= 450
  );
```
Critic: ```sql
SELECT
  COUNT(DISTINCT T1.ID)
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
WHERE
  T1.SEX = 'M' AND T2.WBC > 3.5 AND T2.WBC < 9.0 AND (
    T2.FG <= 150 OR T2.FG >= 450
  );
```
=====================
Question: How many patients with an Ig G higher than normal?
 db_id: thrombosis_prediction
Planner: Plan:
1. Filter the Laboratory table to select records where IGG is greater than or equal to 2000.
2. Count the distinct number of patients' IDs.
3. Return the count.

NL2SQL: ```sql
SELECT
  COUNT(DISTINCT ID)
FROM Laboratory
WHERE
  IGG >= 2000;
```
Critic: ```sql
SELECT
  COUNT(DISTINCT ID)
FROM Laboratory
WHERE
  IGG > 2000;
```
=====================
Question: Among the patients with a normal Ig G level, how many of them have symptoms?
 db_id: thrombosis_prediction
Planner: Here's my plan to answer the question:

1.  **Identify patients with normal Ig G levels:**
    *   Use the `Laboratory` table.
    *   Filter for patients where `IGG` is greater than 900 and less than 2000.
2.  **Join with Examination table:**
    *   Join the `Laboratory` table with the `Examination` table using the common column `ID`.
3.  **Filter for patients with symptoms:**
    *   Filter the joined table for records where the `Symptoms` column in the `Examination` table is not null (meaning symptoms are present).
4.  **Count the number of patients:**
    *   Count the number of distinct `ID`s to determine how many unique patients meet both criteria.

Based on the plan, I will need the `Laboratory` and `Examination` tables. I need to filter the `Laboratory` table by the `IGG` column, join it with the `Examination` table on `ID`, and then filter by `Symptoms` IS NOT NULL. Finally, I need to count the distinct IDs.

NL2SQL: ```sql
SELECT
  COUNT(DISTINCT T1.ID)
FROM Laboratory AS T1
INNER JOIN Examination AS T2
  ON T1.ID = T2.ID
WHERE
  T1.IGG > 900 AND T1.IGG < 2000 AND T2.Symptoms IS NOT NULL;
```
Critic: ```sql
SELECT
  COUNT(T1.ID)
FROM Laboratory AS T1
INNER JOIN Patient AS T2
  ON T1.ID = T2.ID
INNER JOIN Examination AS T3
  ON T2.ID = T3.ID
WHERE
  T1.IGG > 900 AND T1.IGG < 2000 AND T3.Symptoms IS NOT NULL;
```
=====================
Question: How many patients with a normal Ig A level came to the hospital after 1990/1/1?
 db_id: thrombosis_prediction
Planner: Here's my plan to determine the number of patients with a normal Ig A level who came to the hospital after 1990/1/1:

1.  **Join Tables:** We need to join the `Patient` table with the `Laboratory` table using the common column `ID`.
2.  **Filter by IgA Level:** Filter the results based on the `IGA` column in the `Laboratory` table to include patients with normal IgA levels. This means `IGA` should be greater than 80 and less than 500.
3.  **Filter by First Date:** Filter the results based on the `First Date` column in the `Patient` table to include patients who came to the hospital after 1990/1/1. YEAR(`First Date`) >= 1990
4.  **Count Patients:** Count the number of distinct patient IDs that satisfy both conditions.

Now, let's generate the SQL query.

NL2SQL: ```sql
SELECT
  COUNT(DISTINCT T1.ID)
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
WHERE
  T2.IGA > 80 AND T2.IGA < 500 AND STRFTIME('%Y', T1."First Date") >= '1990';
```
Critic: ```sql
SELECT
  COUNT(DISTINCT T1.ID)
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
WHERE
  T2.IGA > 80 AND T2.IGA < 500 AND T1."First Date" >= '1990-01-01';
```
=====================
Question: For the patients with an abnormal Ig M level, what is the most common disease they are diagnosed with?
 db_id: thrombosis_prediction
Planner: Here's a plan to determine the most common disease among patients with abnormal Ig M levels:

1.  **Identify patients with abnormal Ig M levels:** Filter the `Laboratory` table for records where `IGM` is outside the normal range (<=40 or >= 400). Extract the `ID` (patient ID) from these records.
2.  **Join with Patient table:** Join the filtered `Laboratory` table with the `Patient` table using the `ID` column.
3.  **Count disease occurrences:** Group the joined table by `Diagnosis` and count the number of patients for each disease.
4.  **Find the most common disease:** Order the counts in descending order and select the top `Diagnosis` to find the most common disease.

NL2SQL: ```sql
SELECT Diagnosis FROM Patient WHERE ID IN (SELECT ID FROM Laboratory WHERE IGM <= 40 OR IGM >= 400) GROUP BY Diagnosis ORDER BY COUNT(*) DESC LIMIT 1
```
Critic: ```sql
SELECT Diagnosis FROM Patient WHERE ID IN (SELECT ID FROM Laboratory WHERE IGM <= 40 OR IGM >= 400) GROUP BY Diagnosis ORDER BY COUNT(*) DESC LIMIT 1
```
=====================
Question: How many patients with a abnormal C-reactive protein don't have their data recorded?
 db_id: thrombosis_prediction
Planner: Plan:
1. Find patients with abnormal C-reactive protein (CRP = '+') from the Laboratory table.
2. Find patients whose data are not recorded (Description IS NULL) from the Patient table.
3. Join the above two sets of patients based on the patient ID.
4. Count the distinct number of patients satisfying the conditions.
Needed Tables: Laboratory, Patient
Needed Columns:
*   Laboratory: ID, CRP
*   Patient: ID, Description
Filters:
*   Laboratory: CRP = '+'
*   Patient: Description IS NULL
Join:
*   Laboratory.ID = Patient.ID
Final Operation: COUNT(DISTINCT ID)

NL2SQL: ```sql
SELECT
  COUNT(DISTINCT T1.ID)
FROM Laboratory AS T1
INNER JOIN Patient AS T2
  ON T1.ID = T2.ID
WHERE
  T1.CRP = '+' AND T2.Description IS NULL;
```
Critic: ```sql
SELECT
  COUNT(T1.ID)
FROM Laboratory AS T1
LEFT JOIN Patient AS T2
  ON T1.ID = T2.ID
WHERE
  T1.CRP = '+' AND T2.Description IS NULL;
```
=====================
Question: Among the patients whose creatinine level is abnormal, how many of them aren't 70 yet?
 db_id: thrombosis_prediction
Planner: Plan:
1. Filter the Laboratory table to find records where CRE >= 1.5 (abnormal creatinine level).
2. Join the filtered Laboratory table with the Patient table using the common ID column.
3. Filter the joined table to select patients whose age is less than 70. Age is calculated by subtracting the birth year from the current year.
4. Count the number of distinct patients that meet the filter criteria.

NL2SQL: ```sql
SELECT
  COUNT(DISTINCT T1.ID)
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
WHERE
  T2.CRE >= 1.5 AND YEAR(CURDATE()) - YEAR(T1.Birthday) < 70;
```
Critic: ```sql
SELECT
  COUNT(DISTINCT T1.ID)
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
WHERE
  T2.CRE >= 1.5 AND (
    CAST(strftime('%Y', 'now') AS INTEGER) - CAST(strftime('%Y', T1.Birthday) AS INTEGER)
  ) < 70;
```
=====================
Question: How many patients have a normal level of anti-ribonuclear protein and have been admitted to the hospital?
 db_id: thrombosis_prediction
Planner: Plan:
1. Filter the `Laboratory` table to find patients with normal levels of anti-ribonuclear protein (RNP is '-' or '+-').
2. Filter the `Patient` table to find patients who have been admitted to the hospital (Admission is '+').
3. Join the filtered `Laboratory` and `Patient` tables on the patient ID.
4. Count the distinct number of patients satisfying the conditions.
5. Return the count.

NL2SQL: ```sql
SELECT
  COUNT(DISTINCT T1.ID)
FROM Laboratory AS T1
INNER JOIN Patient AS T2
  ON T1.ID = T2.ID
WHERE
  T1.RNP IN ('-', '+-') AND T2.Admission = '+';
```
Critic: ```sql
SELECT
  COUNT(DISTINCT T1.ID)
FROM Laboratory AS T1
INNER JOIN Patient AS T2
  ON T1.ID = T2.ID
WHERE
  T1.RNP IN ('-', '+-') AND T2.Admission = '+';
```
=====================
Question: Among the patients with normal anti-SM, how many of them does not have thrombosis?
 db_id: thrombosis_prediction
Planner: Here's my plan to determine the number of patients with normal anti-SM who do not have thrombosis:

1.  **Identify normal anti-SM values:** Determine the values in the `SM` column of the `Laboratory` table that represent "normal." Based on the evidence, normal means `SM` is in `('-', '+-')`.
2.  **Filter Laboratory table for normal anti-SM:**  Select the `ID` from the `Laboratory` table where `SM` is in `('-', '+-')`.
3.  **Filter Examination table for no thrombosis:** Select the `ID` from the `Examination` table where `Thrombosis` is 0.
4.  **Join the filtered tables:**  Join the two intermediate tables using the `ID` column. This will give us patients who have both normal anti-SM and no thrombosis.
5.  **Count the distinct patients:** Count the distinct `ID` values to get the number of patients meeting both conditions.

**Tables Used:**

*   `Laboratory`
*   `Examination`

**Columns Used:**

*   `Laboratory.ID`
*   `Laboratory.SM`
*   `Examination.ID`
*   `Examination.Thrombosis`

**Filters:**

*   `Laboratory.SM IN('-', '+-')`
*   `Examination.Thrombosis = 0`

**Join:**

*   `Laboratory.ID = Examination.ID`

NL2SQL: ```sql
SELECT
  COUNT(DISTINCT T1.ID)
FROM Laboratory AS T1
INNER JOIN Examination AS T2
  ON T1.ID = T2.ID
WHERE
  T1.SM IN ('-', '+-') AND T2.Thrombosis = 0;
```
Critic: ```sql
SELECT
  COUNT(DISTINCT T1.ID)
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
INNER JOIN Examination AS T3
  ON T1.ID = T3.ID
WHERE
  T2.SM IN ('-', '+-') AND T3.Thrombosis = 0;
```
=====================
Question: Among the patients who has a normal anti-scl70, how many of them are female and does not have any symptom?
 db_id: thrombosis_prediction
Planner: Here's a plan to determine the number of female patients with normal anti-scl70 who do not have any symptoms:

1.  **Identify patients with normal anti-scl70:**
    *   Table: `Laboratory`
    *   Filter: `SC170 IN ('negative', '0')`
    *   Column: `ID` (patient identifier)

2.  **Join with Patient table:**
    *   Table: `Patient`
    *   Join condition: `Laboratory.ID = Patient.ID`
    *   Filter: `Patient.SEX = 'F'`

3.  **Join with Examination table:**
    *   Table: `Examination`
    *   Join condition: `Laboratory.ID = Examination.ID`
    *   Filter: `Examination.Symptoms IS NULL`

4.  **Count the number of distinct patients:**
    *   Use `COUNT(DISTINCT Patient.ID)` to get the final count.

NL2SQL: ```sql
SELECT
  COUNT(DISTINCT T1.ID)
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
INNER JOIN Examination AS T3
  ON T1.ID = T3.ID
WHERE
  T2.SC170 IN ('negative', '0') AND T1.SEX = 'F' AND T3.Symptoms IS NULL;
```
Critic: ```sql
SELECT
  COUNT(DISTINCT T1.ID)
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
LEFT JOIN Examination AS T3
  ON T1.ID = T3.ID
WHERE
  T2.SC170 IN ('negative', '0') AND T1.SEX = 'F' AND T3.Symptoms IS NULL;
```
=====================
Question: Among the patients who has a normal level of anti-centromere and a normal level of anti-SSB, how many of them are male?
 db_id: thrombosis_prediction
Planner: Plan:
1. Filter the `Laboratory` table for patients with normal anti-centromere and normal anti-SSB.
2. Join the filtered `Laboratory` table with the `Patient` table on the patient ID.
3. Filter the joined table for male patients.
4. Count the number of distinct patient IDs in the filtered and joined table.

NL2SQL: ```sql
SELECT
  COUNT(DISTINCT T1.ID)
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
WHERE
  T2.CENTROMEA IN ('-', '+-') AND T2.SSB IN ('-', '+-') AND T1.SEX = 'M';
```
Critic: ```sql
SELECT
  COUNT(DISTINCT T1.ID)
FROM Patient AS T1
INNER JOIN Laboratory AS T2
  ON T1.ID = T2.ID
WHERE
  T2.CENTROMEA IN ('-', '+-') AND T2.SSB IN ('-', '+-') AND T1.SEX = 'M';
```
=====================
Question: Among the patients who have an abnormal level of glutamic oxaloacetic transaminase, when was the youngest of them born?
 db_id: thrombosis_prediction
Planner: Here's a plan to determine the birthday of the youngest patient with an abnormal GOT level:

1.  **Filter Laboratory Table:** Filter the `Laboratory` table to select records where `GOT` is greater than or equal to 60.
2.  **Join Laboratory and Patient Tables:** Join the filtered `Laboratory` table with the `Patient` table using the `ID` column.
3.  **Select Birthday:** Select the `Birthday` column from the joined table.
4.  **Find Maximum Birthday:** Find the maximum (most recent) `Birthday` from the selected birthdays. This corresponds to the youngest patient.

NL2SQL: ```sql
SELECT
  MAX(T2.Birthday)
FROM Laboratory AS T1
INNER JOIN Patient AS T2
  ON T1.ID = T2.ID
WHERE
  T1.GOT >= 60;
```
Critic: ```sql
SELECT
  MIN(Birthday)
FROM Patient
WHERE
  ID IN (
    SELECT
      ID
    FROM Laboratory
    WHERE
      GOT >= 60
  );
```
=====================
Question: For the patients with a normal range of creatinine phosphokinase, how many of them have a positive measure of degree of coagulation?
 db_id: thrombosis_prediction
Planner: Here's a plan to answer the question using SQL:

1.  **Filter Laboratory Table:** Select records where `CPK` (creatinine phosphokinase) is less than 250 (normal range).
2.  **Join Laboratory and Examination tables:** Join the filtered `Laboratory` table with the `Examination` table using the `ID` column to link patient records.
3.  **Filter Examination Table:**  Filter the joined table where `KCT` is '+', `RVVT` is '+', or `LAC` is '+', indicating a positive measure of the degree of coagulation.
4.  **Count Distinct Patient IDs:** Count the distinct `ID` values from the resulting table. This will give the number of patients meeting both criteria.

NL2SQL:
```sql
SELECT
  COUNT(DISTINCT L.ID)
FROM Laboratory AS L
JOIN Examination AS E
  ON L.ID = E.ID
WHERE
  L.CPK < 250 AND (
    E.KCT = '+' OR E.RVVT = '+' OR E.LAC = '+'
  );
```
NL2SQL: ```sql
SELECT
  COUNT(DISTINCT L.ID)
FROM Laboratory AS L
JOIN Examination AS E
  ON L.ID = E.ID
WHERE
  L.CPK < 250 AND (
    E.KCT = '+' OR E.RVVT = '+' OR E.LAC = '+'
  );
```
Critic: ```sql
SELECT
  COUNT(DISTINCT L.ID)
FROM Laboratory AS L
JOIN Examination AS E
  ON L.ID = E.ID
WHERE
  L.CPK < 250 AND (
    E.KCT = '+' OR E.RVVT = '+' OR E.LAC = '+'
  );
```
=====================
Question: Give the name of the league had the most goals in the 2016 season?
 db_id: european_football_2
Planner: 1.  **Filter Matches:** Select matches played in the '2015/2016' season from the `Match` table.
2.  **Calculate Total Goals per League:** Group the filtered matches by `league_id` and calculate the sum of `home_team_goal` and `away_team_goal` for each league.
3.  **Join with League Table:** Join the result with the `League` table using `league_id` to get the `name` of each league.
4.  **Find League with Maximum Goals:** Order the results by the total goals in descending order and select the league name with the highest goal count.

NL2SQL: ```sql
SELECT
  T1.name
FROM League AS T1
INNER JOIN Match AS T2
  ON T1.id = T2.league_id
WHERE
  T2.season = '2015/2016'
GROUP BY
  T1.name
ORDER BY
  SUM(T2.home_team_goal + T2.away_team_goal) DESC
LIMIT 1;
```
Critic: ```sql
SELECT
  T1.name
FROM League AS T1
INNER JOIN Match AS T2
  ON T1.id = T2.league_id
WHERE
  T2.season = '2015/2016'
GROUP BY
  T1.name
ORDER BY
  SUM(T2.home_team_goal + T2.away_team_goal) DESC
LIMIT 1;
```
=====================
Question: In Scotland Premier League, which away team won the most during the 2010 season?
 db_id: european_football_2
Planner: 1. Filter the `League` table to find the `id` corresponding to 'Scotland Premier League'.
2. Filter the `Match` table to include only matches from the 2010 season ('2009/2010') and the `league_id` obtained in the previous step.
3. In the `Match` table, determine the winning away team for each match by comparing `home_team_goal` and `away_team_goal`.
4. Group the results by `away_team_api_id` and count the number of wins for each away team.
5. Find the `away_team_api_id` with the maximum number of wins.
6. Join the `Match` table with the `Team` table using `away_team_api_id` to obtain the `team_long_name` of the winning away team.
7. Return the `team_long_name` of the away team with the most wins.

NL2SQL: ```sql
SELECT
  T.team_long_name
FROM (
  SELECT
    M.away_team_api_id,
    COUNT(*) AS win_count
  FROM Match AS M
  JOIN League AS L
    ON M.league_id = L.id
  WHERE
    L.name = 'Scotland Premier League' AND M.season = '2009/2010' AND M.away_team_goal > M.home_team_goal
  GROUP BY
    M.away_team_api_id
  ORDER BY
    win_count DESC
  LIMIT 1
) AS subquery
JOIN Team AS T
  ON subquery.away_team_api_id = T.team_api_id;
```
Critic: ```sql
SELECT
  T.team_long_name
FROM Match AS M
JOIN League AS L
  ON M.league_id = L.id
JOIN Team AS T
  ON M.away_team_api_id = T.team_api_id
WHERE
  L.name = 'Scotland Premier League' AND M.season = '2009/2010' AND M.away_team_goal > M.home_team_goal
GROUP BY
  T.team_long_name
ORDER BY
  COUNT(*) DESC
LIMIT 1;
```
=====================
Question: What are the speed in which attacks are put together of the top 4 teams with the highest build Up Play Speed?
 db_id: european_football_2
Planner: 1.  Find the top 4 teams with the highest buildUpPlaySpeed from the `Team_Attributes` table.
2.  Retrieve the `buildUpPlaySpeed` for these top 4 teams.
3.  Display the `buildUpPlaySpeed` for each of these teams.
4. Use `team_api_id` to JOIN tables.
5. Use `team_api_id` to get the team name.

NL2SQL: ```sql
SELECT
  T1.buildUpPlaySpeed
FROM Team_Attributes AS T1
INNER JOIN (
  SELECT
    team_api_id
  FROM Team_Attributes
  ORDER BY
    buildUpPlaySpeed DESC
  LIMIT 4
) AS T2
  ON T1.team_api_id = T2.team_api_id
GROUP BY
  T1.buildUpPlaySpeed
ORDER BY
  T1.buildUpPlaySpeed DESC
LIMIT 4;
```
Critic: ```sql
SELECT
  T1.buildUpPlaySpeed
FROM Team_Attributes AS T1
INNER JOIN (
  SELECT
    team_api_id
  FROM Team_Attributes
  GROUP BY
    team_api_id
  ORDER BY
    AVG(buildUpPlaySpeed) DESC
  LIMIT 4
) AS T2
  ON T1.team_api_id = T2.team_api_id
GROUP BY
  T1.buildUpPlaySpeed
ORDER BY
  T1.buildUpPlaySpeed DESC;
```
=====================
Question: Give the name of the league had the most matches end as draw in the 2016 season?
 db_id: european_football_2
Planner: 1. Filter the `Match` table for matches in the '2015/2016' season.
2. Identify matches that ended in a draw (where `home_team_goal` equals `away_team_goal`).
3. Group the draw matches by `league_id` and count the number of draws for each league.
4. Join the aggregated draw counts with the `League` table on `league_id` to get the `name` of each league.
5. Find the league with the maximum number of draws.
6. Return the `name` of the league with the most draws.

NL2SQL: ```sql
SELECT
  T2.name
FROM (
  SELECT
    league_id,
    COUNT(*) AS num_draws
  FROM Match
  WHERE
    season = '2015/2016' AND home_team_goal = away_team_goal
  GROUP BY
    league_id
  ORDER BY
    num_draws DESC
  LIMIT 1
) AS T1
INNER JOIN League AS T2
  ON T1.league_id = T2.id;
```
Critic: ```sql
SELECT
  T2.name
FROM Match AS T1
INNER JOIN League AS T2
  ON T1.league_id = T2.id
WHERE
  T1.season = '2015/2016' AND T1.home_team_goal = T1.away_team_goal
GROUP BY
  T2.name
ORDER BY
  COUNT(T1.id) DESC
LIMIT 1;
```
=====================
Question: At present, calculate for the player's age who have a sprint speed of no less than 97 between 2013 to 2015.
 db_id: european_football_2
Planner: 1.  Join `Player` and `Player_Attributes` tables on `player_api_id`.
2.  Filter `Player_Attributes` table for sprint\_speed >= 97 and date between 2013 and 2015.
3.  Calculate the age of the player using current date and birthday from Player table.
4.  Select the calculated age.

NL2SQL: ```sql
SELECT
  STRFTIME('%Y', 'now') - STRFTIME('%Y', T1.birthday) AS Age
FROM Player AS T1
INNER JOIN Player_Attributes AS T2
  ON T1.player_api_id = T2.player_api_id
WHERE
  T2.sprint_speed >= 97 AND STRFTIME('%Y', T2.date) BETWEEN '2013' AND '2015'
GROUP BY
  T1.player_api_id;
```
Critic: ```sql
SELECT
  CAST(STRFTIME('%Y', 'now') AS INTEGER) - CAST(STRFTIME('%Y', T1.birthday) AS INTEGER)
FROM Player AS T1
INNER JOIN Player_Attributes AS T2
  ON T1.player_api_id = T2.player_api_id
WHERE
  T2.sprint_speed >= 97 AND STRFTIME('%Y', T2.date) BETWEEN '2013' AND '2015'
GROUP BY
  T1.player_api_id;
```
=====================
Question: Give the name of the league with the highest matches of all time and how many matches were played in the said league.
 db_id: european_football_2
Planner: 1. Join the `Match` table with the `League` table using the `league_id` to connect matches to their respective leagues.
2. Group the results by `League.name` to count the number of matches per league.
3. Order the grouped results by the count of matches in descending order.
4. Select the `League.name` and the count of matches for the league with the highest number of matches.

NL2SQL: ```sql
SELECT
  T2.name,
  COUNT(T1.league_id)
FROM Match AS T1
INNER JOIN League AS T2
  ON T1.league_id = T2.id
GROUP BY
  T1.league_id
ORDER BY
  COUNT(T1.league_id) DESC
LIMIT 1;
```
Critic: ```sql
SELECT
  T2.name,
  COUNT(T1.league_id)
FROM Match AS T1
INNER JOIN League AS T2
  ON T1.league_id = T2.id
GROUP BY
  T2.name
ORDER BY
  COUNT(T1.league_id) DESC
LIMIT 1;
```
=====================
Question: Give the team_fifa_api_id of teams with more than 50 but less than 60 build-up play speed.
 db_id: european_football_2
Planner: 1.  **Table Selection:** We need the `Team_Attributes` table because it contains `team_fifa_api_id` and `buildUpPlaySpeed`.
2.  **Filtering:** We need to filter `Team_Attributes` to include only rows where `buildUpPlaySpeed` is greater than 50 and less than 60.
3.  **Selection:** Select the `team_fifa_api_id` from the filtered results.

NL2SQL: ```sql
SELECT
  team_fifa_api_id
FROM Team_Attributes
WHERE
  buildUpPlaySpeed > 50 AND buildUpPlaySpeed < 60
GROUP BY
  team_fifa_api_id;
```
Critic: ```sql
SELECT DISTINCT
  team_fifa_api_id
FROM Team_Attributes
WHERE
  buildUpPlaySpeed > 50 AND buildUpPlaySpeed < 60;
```
=====================
Question: List the long name of teams with above-average build-up play passing in 2012.
 db_id: european_football_2
Planner: 1. Calculate the average `buildUpPlayPassing` for the year 2012 from the `Team_Attributes` table.
2. Select the `team_api_id` and filter the data in `Team_Attributes` where the year is 2012 and `buildUpPlayPassing` is greater than the calculated average.
3. Join the `Team` table with the filtered `Team_Attributes` table on `team_api_id`.
4. Select the `team_long_name` from the `Team` table.

NL2SQL: ```sql
SELECT
  T.team_long_name
FROM Team AS T
JOIN Team_Attributes AS TA
  ON T.team_api_id = TA.team_api_id
WHERE
  STRFTIME('%Y', TA.date) = '2012'
  AND TA.buildUpPlayPassing > (
    SELECT
      AVG(buildUpPlayPassing)
    FROM Team_Attributes
    WHERE
      STRFTIME('%Y', date) = '2012'
  );
```
Critic: ```sql
SELECT
  T.team_long_name
FROM Team AS T
INNER JOIN Team_Attributes AS TA
  ON T.team_api_id = TA.team_api_id
WHERE
  TA.buildUpPlayPassing > (
    SELECT
      AVG(buildUpPlayPassing)
    FROM Team_Attributes
    WHERE
      STRFTIME('%Y', date) = '2012'
  )
  AND STRFTIME('%Y', TA.date) = '2012'
GROUP BY
  T.team_long_name;
```
=====================
Question: Calculate the percentage of players who prefer left foot, who were born between 1987 and 1992.
 db_id: european_football_2
Planner: 1.  Join the `Player` and `Player_Attributes` tables on `player_api_id`.
2.  Filter the joined table for players born between 1987 and 1992 (inclusive) using the `birthday` column in the `Player` table.
3.  Filter the joined table for players with `preferred_foot` as 'left' in the `Player_Attributes` table.
4.  Calculate the count of all players born between 1987 and 1992.
5.  Calculate the count of players born between 1987 and 1992 that prefer 'left' foot.
6.  Calculate the percentage by dividing the number of left-footed players by the total number of players and multiplying by 100.
NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T2.preferred_foot = 'left' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id)
FROM Player AS T1
INNER JOIN Player_Attributes AS T2
  ON T1.player_api_id = T2.player_api_id
WHERE
  STRFTIME('%Y', T1.birthday) BETWEEN '1987' AND '1992';
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T2.preferred_foot = 'left' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id)
FROM Player AS T1
INNER JOIN Player_Attributes AS T2
  ON T1.player_api_id = T2.player_api_id
WHERE
  CAST(strftime('%Y', T1.birthday) AS INTEGER) BETWEEN 1987 AND 1992;
```
=====================
Question: Find the average number of long-shot done by Ahmed Samir Farag.
 db_id: european_football_2
Planner: 1. Find the `player_api_id` for the player named 'Ahmed Samir Farag' from the `Player` table.
2. Using the `player_api_id`, calculate the average `long_shots` from the `Player_Attributes` table.
3. Return the average `long_shots`.
Tables: `Player`, `Player_Attributes`
Columns: `player_api_id`, `player_name`, `long_shots`
Filters: `player_name` = 'Ahmed Samir Farag'
Aggregate Function: AVG(`long_shots`)
Join: `Player.player_api_id` = `Player_Attributes.player_api_id`

NL2SQL: ```sql
SELECT
  AVG(T2.long_shots)
FROM Player AS T1
INNER JOIN Player_Attributes AS T2
  ON T1.player_api_id = T2.player_api_id
WHERE
  T1.player_name = 'Ahmed Samir Farag';
```
Critic: ```sql
SELECT
  AVG(long_shots)
FROM Player_Attributes
WHERE
  player_api_id = (
    SELECT
      player_api_id
    FROM Player
    WHERE
      player_name = 'Ahmed Samir Farag'
  );
```
=====================
Question: List the top 10 players' names whose heights are above 180 in descending order of average heading accuracy.
 db_id: european_football_2
Planner: 1. Select the player's name from the `Player` table and calculate the average heading accuracy from the `Player_Attributes` table.
2. Join `Player` table and `Player_Attributes` table on `player_api_id`.
3. Filter the players whose heights are greater than 180.
4. Group the results by player name.
5. Order the results in descending order of average heading accuracy.
6. Limit the results to the top 10.

NL2SQL: ```sql
SELECT
  p.player_name
FROM Player AS p
JOIN Player_Attributes AS pa
  ON p.player_api_id = pa.player_api_id
WHERE
  p.height > 180
GROUP BY
  p.player_name
ORDER BY
  AVG(pa.heading_accuracy) DESC
LIMIT 10;
```
Critic: ```sql
SELECT
  p.player_name
FROM Player AS p
JOIN Player_Attributes AS pa
  ON p.player_api_id = pa.player_api_id
WHERE
  p.height > 180
GROUP BY
  p.player_name
ORDER BY
  AVG(pa.heading_accuracy) DESC
LIMIT 10;
```
=====================
Question: List the name of leagues in which the average goals by the home team is higher than the away team in the 2009/2010 season.
 db_id: european_football_2
Planner: 1.  Join `Match` and `League` tables on `league_id`.
2.  Filter the data for the season '2009/2010'.
3.  Group the data by `League.name`.
4.  Calculate the average home team goals and average away team goals for each league.
5.  Filter the leagues where the average home team goals are greater than the average away team goals.
6.  Select the `League.name` for the resulting leagues.
NL2SQL: ```sql
SELECT
  T1.name
FROM League AS T1
INNER JOIN Match AS T2
  ON T1.id = T2.league_id
WHERE
  T2.season = '2009/2010'
GROUP BY
  T1.name
HAVING
  AVG(T2.home_team_goal) > AVG(T2.away_team_goal);
```
Critic: ```sql
SELECT
  T1.name
FROM League AS T1
INNER JOIN Match AS T2
  ON T1.id = T2.league_id
WHERE
  T2.season = '2009/2010'
GROUP BY
  T1.name
HAVING
  SUM(T2.home_team_goal) * 1.0 / COUNT(T2.id) > SUM(T2.away_team_goal) * 1.0 / COUNT(T2.id);
```
=====================
Question: List the football players with a birthyear of 1970 and a birthmonth of October.
 db_id: european_football_2
Planner: 1.  **Tables**: We need the `Player` table to access player information, specifically the `birthday` and `player_name`.
2.  **Filtering**: We need to filter the `Player` table based on the `birthday` column. We want players born in October 1970.
3.  **Columns**: We need to select the `player_name` column to display the names of the players who meet the criteria.
4.  **SQL Logic**: Extract the year and month from the `birthday` column using SUBSTR function. Filter data WHERE the year is equal to '1970' and month is equal to '10'.

NL2SQL: ```sql
SELECT
  player_name
FROM Player
WHERE
  SUBSTR(birthday, 1, 4) = '1970' AND SUBSTR(birthday, 6, 2) = '10';
```
Critic: ```sql
SELECT
  player_name
FROM Player
WHERE
  CAST(SUBSTR(birthday, 1, 4) AS INTEGER) = 1970 AND CAST(SUBSTR(birthday, 6, 2) AS INTEGER) = 10;
```
=====================
Question: What is the overall rating of the football player Gabriel Tamas in year 2011?
 db_id: european_football_2
Planner: 1.  Find the `player_api_id` for the player named 'Gabriel Tamas' from the `Player` table.
2.  Using the `player_api_id`, find the `overall_rating` from the `Player_Attributes` table.
3.  Filter the results from `Player_Attributes` where the year of the `date` is 2011 using `strftime('%Y', date) = '2011'`.
4.  Return the `overall_rating`.

NL2SQL: ```sql
SELECT
  pa.overall_rating
FROM Player AS p
JOIN Player_Attributes AS pa
  ON p.player_api_id = pa.player_api_id
WHERE
  p.player_name = 'Gabriel Tamas' AND STRFTIME('%Y', pa.date) = '2011';
```
Critic: ```sql
SELECT
  AVG(pa.overall_rating)
FROM Player AS p
JOIN Player_Attributes AS pa
  ON p.player_api_id = pa.player_api_id
WHERE
  p.player_name = 'Gabriel Tamas' AND STRFTIME('%Y', pa.date) = '2011';
```
=====================
Question: Calculate the average home team goal in the 2010/2011 season in the country of Poland.
 db_id: european_football_2
Planner: 1.  Join the `Match` table with the `Country` table on `country_id` to filter matches played in Poland.
2.  Filter the matches for the 2010/2011 season.
3.  Calculate the average `home_team_goal` for the filtered matches.
4.  Select the calculated average `home_team_goal`.

NL2SQL: ```sql
SELECT
  AVG(T1.home_team_goal)
FROM Match AS T1
INNER JOIN Country AS T2
  ON T1.country_id = T2.id
WHERE
  T2.name = 'Poland' AND T1.season = '2010/2011';
```
Critic: ```sql
SELECT
  AVG(home_team_goal)
FROM Match
WHERE
  season = '2010/2011'
  AND country_id = (
    SELECT
      id
    FROM Country
    WHERE
      name = 'Poland'
  );
```
=====================
Question: Who has the highest average finishing rate between the highest and shortest football player?
 db_id: european_football_2
Planner: Here's a plan to determine who has the highest average finishing rate between the tallest and shortest football players:

1.  **Find the tallest and shortest players:**
    *   Use the `Player` table to find the maximum and minimum `height`.
    *   Get the `player_api_id` of the tallest and shortest players.

2.  **Calculate the average finishing rate for each player:**
    *   Join `Player` with `Player_Attributes` using `player_api_id`.
    *   Calculate the average `finishing` for each player.

3.  **Filter for the tallest and shortest players:**
    *   Filter the results from step 2 to include only the players identified in step 1 (tallest and shortest).

4.  **Find the player with the highest average finishing rate:**
    *   Order the filtered results from step 3 by average finishing in descending order.
    *   Select the `player_name` of the player with the highest average finishing rate.

NL2SQL: ```sql
SELECT
  p.player_name
FROM Player AS p
JOIN Player_Attributes AS pa
  ON p.player_api_id = pa.player_api_id
WHERE
  p.player_api_id IN (
    SELECT
      player_api_id
    FROM Player
    WHERE
      height = (
        SELECT
          MAX(height)
        FROM Player
      )
  ) OR p.player_api_id IN (
    SELECT
      player_api_id
    FROM Player
    WHERE
      height = (
        SELECT
          MIN(height)
        FROM Player
      )
  )
GROUP BY
  p.player_name
ORDER BY
  AVG(pa.finishing) DESC
LIMIT 1;
```
Critic: ```sql
SELECT
  p.player_name
FROM Player AS p
JOIN Player_Attributes AS pa
  ON p.player_api_id = pa.player_api_id
WHERE
  p.player_api_id IN (
    SELECT
      player_api_id
    FROM Player
    WHERE
      height = (
        SELECT
          MAX(height)
        FROM Player
      )
    UNION
    SELECT
      player_api_id
    FROM Player
    WHERE
      height = (
        SELECT
          MIN(height)
        FROM Player
      )
  )
GROUP BY
  p.player_name
ORDER BY
  AVG(pa.finishing) DESC
LIMIT 1;
```
=====================
Question: From 2010 to 2015, what was the average overall rating of players who are higher than 170?
 db_id: european_football_2
Planner: 1. Join `Player` table with `Player_Attributes` table on `player_api_id` to link player height with their attributes.
2. Filter `Player_Attributes` table by date to include only records from 2010 to 2015 (inclusive).
3. Filter the joined table to include only players whose height is greater than 170.
4. Calculate the average `overall_rating` for the filtered players.
5. Return the average overall rating.

NL2SQL: ```sql
SELECT
  AVG(T1.overall_rating)
FROM Player_Attributes AS T1
INNER JOIN Player AS T2
  ON T1.player_api_id = T2.player_api_id
WHERE
  T2.height > 170 AND STRFTIME('%Y', T1.date) >= '2010' AND STRFTIME('%Y', T1.date) <= '2015';
```
Critic: ```sql
SELECT
  AVG(PA.overall_rating)
FROM Player_Attributes AS PA
INNER JOIN Player AS P
  ON PA.player_api_id = P.player_api_id
WHERE
  P.height > 170 AND STRFTIME('%Y', PA.date) BETWEEN '2010' AND '2015';
```
=====================
Question: What is the difference of the average ball control score between Abdou Diallo and Aaron Appindangoye
?
 db_id: european_football_2
Planner: 1.  Find the `player_api_id` for Abdou Diallo from the `Player` table.
2.  Find the average `ball_control` score for Abdou Diallo from the `Player_Attributes` table using the `player_api_id`.
3.  Find the `player_api_id` for Aaron Appindangoye from the `Player` table.
4.  Find the average `ball_control` score for Aaron Appindangoye from the `Player_Attributes` table using the `player_api_id`.
5.  Calculate the difference between the average `ball_control` scores.
```sql
SELECT
  (
    SELECT
      AVG(PA.ball_control)
    FROM Player AS P
    JOIN Player_Attributes AS PA
      ON P.player_api_id = PA.player_api_id
    WHERE
      P.player_name = 'Abdou Diallo'
  ) - (
    SELECT
      AVG(PA.ball_control)
    FROM Player AS P
    JOIN Player_Attributes AS PA
      ON P.player_api_id = PA.player_api_id
    WHERE
      P.player_name = 'Aaron Appindangoye'
  );
```
NL2SQL: ```sql
SELECT
  (
    SELECT
      AVG(ball_control)
    FROM Player_Attributes
    WHERE
      player_api_id = (
        SELECT
          player_api_id
        FROM Player
        WHERE
          player_name = 'Abdou Diallo'
      )
  ) - (
    SELECT
      AVG(ball_control)
    FROM Player_Attributes
    WHERE
      player_api_id = (
        SELECT
          player_api_id
        FROM Player
        WHERE
          player_name = 'Aaron Appindangoye'
      )
  );
```
Critic: ```sql
SELECT
  (
    SELECT
      AVG(T1.ball_control)
    FROM Player_Attributes AS T1
    INNER JOIN Player AS T2
      ON T1.player_api_id = T2.player_api_id
    WHERE
      T2.player_name = 'Abdou Diallo'
  ) - (
    SELECT
      AVG(T1.ball_control)
    FROM Player_Attributes AS T1
    INNER JOIN Player AS T2
      ON T1.player_api_id = T2.player_api_id
    WHERE
      T2.player_name = 'Aaron Appindangoye'
  );
```
=====================
Question: Which player is older, Aaron Lennon or Abdelaziz Barrada?
 db_id: european_football_2
Planner: Plan:
1. Access the `Player` table.
2. Filter the table for 'Aaron Lennon' and 'Abdelaziz Barrada'.
3. Retrieve the `player_name` and `birthday` for both players.
4. Compare the birthdays. The player with the earlier birthday is older.
5. Return the `player_name` of the older player.

NL2SQL: ```sql
SELECT
  player_name
FROM Player
WHERE
  player_name = 'Aaron Lennon'
ORDER BY
  birthday
LIMIT 1;
```
Critic: ```sql
SELECT
  CASE WHEN (
    SELECT
      birthday
    FROM Player
    WHERE
      player_name = 'Aaron Lennon'
  ) < (
    SELECT
      birthday
    FROM Player
    WHERE
      player_name = 'Abdelaziz Barrada'
  ) THEN 'Aaron Lennon' ELSE 'Abdelaziz Barrada'
  END;
```
=====================
Question: Which player is the tallest?
 db_id: european_football_2
Planner: 1. Select the `player_name` from the `Player` table.
2. Find the maximum `height` from the `Player` table.
3. Filter the `Player` table to select only the player(s) with the maximum height.

NL2SQL: ```sql
SELECT
  player_name
FROM Player
WHERE
  height = (
    SELECT
      MAX(height)
    FROM Player
  );
```
Critic: ```sql
SELECT
  player_name
FROM Player
ORDER BY
  height DESC
LIMIT 1;
```
=====================
Question: Among the players whose preferred foot was the left foot when attacking, how many of them would remain in his position when the team attacked?
 db_id: european_football_2
Planner: 1.  Filter the `Player_Attributes` table for players whose `preferred_foot` is 'left'.
2.  Further filter the result for the players with attacking work rate is low `attacking_work_rate` = 'low'
3.  Count the number of such players.

NL2SQL: ```sql
SELECT
  COUNT(player_api_id)
FROM Player_Attributes
WHERE
  preferred_foot = 'left' AND attacking_work_rate = 'low';
```
Critic: ```sql
SELECT
  COUNT(T1.player_api_id)
FROM Player_Attributes AS T1
INNER JOIN Player AS T2
  ON T1.player_api_id = T2.player_api_id
WHERE
  T1.preferred_foot = 'left' AND T1.attacking_work_rate = 'low';
```
=====================
Question: Among the players born before the year 1986, how many of them would remain in his position and defense while the team attacked?
 db_id: european_football_2
Planner: 1. Filter the `Player` table to select players born before 1986. Extract `player_api_id` from this filtered table.
2. Filter the `Player_Attributes` table to select records where `defensive_work_rate` is 'high'. Extract `player_api_id` from this filtered table.
3. Perform an inner join between the filtered `Player` and `Player_Attributes` tables on `player_api_id`.
4. Count the distinct `player_api_id` from the joined table. This gives the number of players born before 1986 with a high defensive work rate.
NL2SQL: ```sql
SELECT
  COUNT(DISTINCT T1.player_api_id)
FROM Player AS T1
INNER JOIN Player_Attributes AS T2
  ON T1.player_api_id = T2.player_api_id
WHERE
  STRFTIME('%Y', T1.birthday) < '1986' AND T2.defensive_work_rate = 'high';
```
Critic: ```sql
SELECT
  COUNT(DISTINCT T1.player_api_id)
FROM Player AS T1
INNER JOIN Player_Attributes AS T2
  ON T1.player_api_id = T2.player_api_id
WHERE
  STRFTIME('%Y', T1.birthday) < '1986' AND T2.defensive_work_rate = 'High';
```
=====================
Question: Please list the names of the players whose volley score and dribbling score are over 70.
 db_id: european_football_2
Planner: 1.  Join the `Player` table and the `Player_Attributes` table on `player_api_id`.
2.  Filter the results to include only players where `volleys` > 70 and `dribbling` > 70.
3.  Select the `player_name` from the `Player` table.

NL2SQL: ```sql
SELECT
  T1.player_name
FROM Player AS T1
INNER JOIN Player_Attributes AS T2
  ON T1.player_api_id = T2.player_api_id
WHERE
  T2.volleys > 70 AND T2.dribbling > 70
GROUP BY
  T1.player_name;
```
Critic: ```sql
SELECT
  T1.player_name
FROM Player AS T1
INNER JOIN Player_Attributes AS T2
  ON T1.player_api_id = T2.player_api_id
WHERE
  T2.volleys > 70 AND T2.dribbling > 70
GROUP BY
  T1.player_name;
```
=====================
Question: How many matches were held in the Belgium Jupiler League in April, 2009?
 db_id: european_football_2
Planner: 1. **Find the `league_id` for the 'Belgium Jupiler League' from the `League` table.**
2. **Filter the `Match` table for matches played in April 2009 and the specific `league_id`.**
3. **Count the number of matches that satisfy the conditions.**
4. **Return the count.**

Required Tables: League, Match
Required Columns: League.name, League.id, Match.date, Match.league_id
Filters: League.name = 'Belgium Jupiler League', Match.date like '2009-04%'
Joins: League.id = Match.league_id
Aggregate Function: COUNT(Match.id)
NL2SQL: ```sql
SELECT
  COUNT(CASE WHEN STRFTIME('%Y-%m', date) = '2009-04' THEN id ELSE NULL END)
FROM Match
WHERE
  league_id = (
    SELECT
      id
    FROM League
    WHERE
      name = 'Belgium Jupiler League'
  );
```
Critic: ```sql
SELECT
  COUNT(CASE WHEN STRFTIME('%Y-%m', date) = '2009-04' THEN id ELSE NULL END)
FROM Match
WHERE
  league_id = (
    SELECT
      id
    FROM League
    WHERE
      name = 'Belgium Jupiler League'
  );
```
=====================
Question: Give the name of the league had the most matches in the 2008/2009 season?
 db_id: european_football_2
Planner: 1. Filter the `Match` table for the season '2008/2009'.
2. Join the filtered `Match` table with the `League` table on `league_id`.
3. Group the results by `League.name` and count the number of matches in each league.
4. Order the results in descending order based on the match count.
5. Limit the result to the top 1 to find the league with the most matches.
6. Select the `League.name` from the result.

NL2SQL: ```sql
SELECT
  T2.name
FROM Match AS T1
INNER JOIN League AS T2
  ON T1.league_id = T2.id
WHERE
  T1.season = '2008/2009'
GROUP BY
  T2.name
ORDER BY
  COUNT(T1.id) DESC
LIMIT 1;
```
Critic: ```sql
SELECT
  T2.name
FROM Match AS T1
INNER JOIN League AS T2
  ON T1.league_id = T2.id
WHERE
  T1.season = '2008/2009'
GROUP BY
  T2.name
ORDER BY
  COUNT(*) DESC
LIMIT 1;
```
=====================
Question: How much higher in percentage is Ariel Borysiuk's overall rating than that of Paulin Puel?
 db_id: european_football_2
Planner: 1. Find the player\_api\_id for Ariel Borysiuk and Paulin Puel from the Player table.
2. Find the latest overall\_rating for each player from the Player\_Attributes table using their player\_api\_id and ordering by date descending.
3. Calculate the percentage difference between Ariel Borysiuk's overall rating and Paulin Puel's overall rating. The formula is ((Ariel Borysiuk's Rating - Paulin Puel's Rating) / Paulin Puel's Rating) * 100.
4. Return the calculated percentage difference.

NL2SQL: ```sql
SELECT
  (
    (
      (
        SELECT
          overall_rating
        FROM Player_Attributes
        WHERE
          player_api_id = (
            SELECT
              player_api_id
            FROM Player
            WHERE
              player_name = 'Ariel Borysiuk'
          )
        ORDER BY
          date DESC
        LIMIT 1
      ) - (
        SELECT
          overall_rating
        FROM Player_Attributes
        WHERE
          player_api_id = (
            SELECT
              player_api_id
            FROM Player
            WHERE
              player_name = 'Paulin Puel'
          )
        ORDER BY
          date DESC
        LIMIT 1
      )
    ) * 1.0 / (
      SELECT
        overall_rating
      FROM Player_Attributes
      WHERE
        player_api_id = (
          SELECT
            player_api_id
          FROM Player
          WHERE
            player_name = 'Paulin Puel'
        )
      ORDER BY
        date DESC
      LIMIT 1
    )
  ) * 100;
```
Critic: ```sql
SELECT
  (
    (
      (
        SELECT
          overall_rating
        FROM Player_Attributes
        WHERE
          player_api_id = (
            SELECT
              player_api_id
            FROM Player
            WHERE
              player_name = 'Ariel Borysiuk'
          )
        ORDER BY
          date DESC
        LIMIT 1
      ) - (
        SELECT
          overall_rating
        FROM Player_Attributes
        WHERE
          player_api_id = (
            SELECT
              player_api_id
            FROM Player
            WHERE
              player_name = 'Paulin Puel'
          )
        ORDER BY
          date DESC
        LIMIT 1
      )
    ) * 100.0 / (
      SELECT
        overall_rating
      FROM Player_Attributes
      WHERE
        player_api_id = (
          SELECT
            player_api_id
          FROM Player
          WHERE
            player_name = 'Paulin Puel'
        )
      ORDER BY
        date DESC
      LIMIT 1
    )
  );
```
=====================
Question: Calculate the average overall rating of Pietro Marino.
 db_id: european_football_2
Planner: 1. Find the `player_api_id` for the player named "Pietro Marino" from the `Player` table.
2. Use the `player_api_id` to find all the overall ratings for that player from the `Player_Attributes` table.
3. Calculate the average of these overall ratings.

Required tables: `Player`, `Player_Attributes`
Required columns: `Player`.`player_api_id`, `Player`.`player_name`, `Player_Attributes`.`player_api_id`, `Player_Attributes`.`overall_rating`

Filters: `Player`.`player_name` = 'Pietro Marino'

Joins: `Player` JOIN `Player_Attributes` ON `Player`.`player_api_id` = `Player_Attributes`.`player_api_id`

Aggregate function: AVG(`Player_Attributes`.`overall_rating`)

NL2SQL: ```sql
SELECT
  AVG(T1.overall_rating)
FROM Player_Attributes AS T1
INNER JOIN Player AS T2
  ON T1.player_api_id = T2.player_api_id
WHERE
  T2.player_name = 'Pietro Marino';
```
Critic: ```sql
SELECT
  AVG(T1.overall_rating)
FROM Player_Attributes AS T1
INNER JOIN Player AS T2
  ON T1.player_api_id = T2.player_api_id
WHERE
  T2.player_name = 'Pietro Marino';
```
=====================
Question: What is Ajax's highest chance creation passing score and what is it classified as?
 db_id: european_football_2
Planner: 1.  Filter the Team table for the team with team\_long\_name = 'Ajax'.
2.  Join the Team table with the Team\_Attributes table using team\_api\_id.
3.  Find the maximum chanceCreationPassing and its corresponding chanceCreationPassingClass.
4.  Display the MAX(chanceCreationPassing) and chanceCreationPassingClass.

NL2SQL: ```sql
SELECT
  MAX(T2.chanceCreationPassing),
  T2.chanceCreationPassingClass
FROM Team AS T1
INNER JOIN Team_Attributes AS T2
  ON T1.team_api_id = T2.team_api_id
WHERE
  T1.team_long_name = 'Ajax';
```
Critic: ```sql
SELECT
  T1.chanceCreationPassing,
  T1.chanceCreationPassingClass
FROM Team_Attributes AS T1
INNER JOIN Team AS T2
  ON T1.team_api_id = T2.team_api_id
WHERE
  T2.team_long_name = 'Ajax'
ORDER BY
  T1.chanceCreationPassing DESC
LIMIT 1;
```
=====================
Question: For the players who had a 77 points overall rating on 2016/6/23, who was the oldest? Give the name of the player.
 db_id: european_football_2
Planner: 1.  Join `Player_Attributes` and `Player` tables on `player_api_id`.
2.  Filter the joined table to select records where `overall_rating` is 77 and `date` is '2016-06-23'.
3.  Order the results by birthday in ascending order to find the oldest player.
4.  Select the `player_name` of the oldest player.

NL2SQL: ```sql
SELECT
  p.player_name
FROM Player_Attributes AS pa
JOIN Player AS p
  ON pa.player_api_id = p.player_api_id
WHERE
  pa.overall_rating = 77 AND pa.date LIKE '2016-06-23%'
ORDER BY
  p.birthday
LIMIT 1;
```
Critic: ```sql
SELECT
  p.player_name
FROM Player_Attributes AS pa
JOIN Player AS p
  ON pa.player_api_id = p.player_api_id
WHERE
  pa.overall_rating = 77 AND pa.date = '2016-06-23 00:00:00'
ORDER BY
  p.birthday
LIMIT 1;
```
=====================
Question: What was the overall rating for Aaron Mooy on 2016/2/4?
 db_id: european_football_2
Planner: 1.  Find the `player_api_id` for Aaron Mooy from the `Player` table using the condition `player_name` = 'Aaron Mooy'.
2.  Use the `player_api_id` obtained in the previous step to find the `overall_rating` from the `Player_Attributes` table.
3.  Filter the `Player_Attributes` table using the condition `date` = '2016-02-04'.

NL2SQL: ```sql
SELECT
  pa.overall_rating
FROM Player AS p
JOIN Player_Attributes AS pa
  ON p.player_api_id = pa.player_api_id
WHERE
  p.player_name = 'Aaron Mooy' AND pa.date LIKE '2016-02-04%';
```
Critic: ```sql
SELECT
  T1.overall_rating
FROM Player_Attributes AS T1
INNER JOIN Player AS T2
  ON T1.player_api_id = T2.player_api_id
WHERE
  T2.player_name = 'Aaron Mooy' AND T1.date = '2016-02-04 00:00:00';
```
=====================
Question: How was Francesco Migliore's attacking work rate on 2015/5/1?
 db_id: european_football_2
Planner: 1.  Find the `player_api_id` for Francesco Migliore from the `Player` table.
2.  Use the `player_api_id` and the date '2015-05-01' to find the `attacking_work_rate` from the `Player_Attributes` table.

NL2SQL: ```sql
SELECT
  pa.attacking_work_rate
FROM Player AS p
JOIN Player_Attributes AS pa
  ON p.player_api_id = pa.player_api_id
WHERE
  p.player_name = 'Francesco Migliore' AND pa.date LIKE '2015-05-01%';
```
Critic: ```sql
SELECT
  T1.attacking_work_rate
FROM Player_Attributes AS T1
INNER JOIN Player AS T2
  ON T1.player_api_id = T2.player_api_id
WHERE
  T2.player_name = 'Francesco Migliore' AND T1.date = '2015-05-01 00:00:00';
```
=====================
Question: When was the first time did Kevin Constant have his highest crossing score? Give the date.
 db_id: european_football_2
Planner: Here's a plan to determine the first date Kevin Constant achieved his highest crossing score:

1.  **Find Kevin Constant's `player_api_id`:**
    *   Use the `Player` table and filter by `player_name` = 'Kevin Constant'.
    *   Select the `player_api_id`.

2.  **Find Kevin Constant's maximum crossing score:**
    *   Use the `Player_Attributes` table and filter by the `player_api_id` obtained in step 1.
    *   Select the maximum `crossing` score.

3.  **Find the earliest date when Kevin Constant had the maximum crossing score:**
    *   Use the `Player_Attributes` table again, filtering by `player_api_id` and `crossing` equal to the maximum crossing score obtained in step 2.
    *   Select the minimum `date`.

NL2SQL:
```sql
SELECT
  MIN(T1.date)
FROM Player_Attributes AS T1
INNER JOIN Player AS T2
  ON T1.player_api_id = T2.player_api_id
WHERE
  T2.player_name = 'Kevin Constant'
  AND T1.crossing = (
    SELECT
      MAX(T3.crossing)
    FROM Player_Attributes AS T3
    INNER JOIN Player AS T4
      ON T3.player_api_id = T4.player_api_id
    WHERE
      T4.player_name = 'Kevin Constant'
  );
```
NL2SQL: ```sql
SELECT
  date
FROM Player_Attributes
WHERE
  player_api_id = (
    SELECT
      player_api_id
    FROM Player
    WHERE
      player_name = 'Kevin Constant'
  )
ORDER BY
  crossing DESC
LIMIT 1;
```
Critic: ```sql
SELECT
  date
FROM Player_Attributes
WHERE
  player_api_id = (
    SELECT
      player_api_id
    FROM Player
    WHERE
      player_name = 'Kevin Constant'
  )
ORDER BY
  crossing DESC
LIMIT 1;
```
=====================
Question: Tell the build Up play passing class for "FC Lorient" on 2010/2/22.
 db_id: european_football_2
Planner: 1.  **Find the team ID:** Find the `team_api_id` for "FC Lorient" in the `Team` table.
2.  **Filter the Team_Attributes:** Filter the `Team_Attributes` table by the `team_api_id` and the date.
3.  **Select the buildUpPlayPassingClass:** Retrieve the `buildUpPlayPassingClass` column.

Return buildUpPlayPassingClass.

Tables: Team, Team_Attributes
Columns: Team.team_api_id, Team.team_long_name, Team_Attributes.team_api_id, Team_Attributes.date, Team_Attributes.buildUpPlayPassingClass
Conditions: Team.team_long_name = "FC Lorient", Team_Attributes.date LIKE "2010-02-22%"

NL2SQL: ```sql
SELECT
  T1.buildUpPlayPassingClass
FROM Team_Attributes AS T1
INNER JOIN Team AS T2
  ON T1.team_api_id = T2.team_api_id
WHERE
  T2.team_long_name = 'FC Lorient' AND T1.date LIKE '2010-02-22%';
```
Critic: ```sql
SELECT
  T1.buildUpPlayPassingClass
FROM Team_Attributes AS T1
INNER JOIN Team AS T2
  ON T1.team_api_id = T2.team_api_id
WHERE
  T2.team_long_name = 'FC Lorient' AND T1.date = '2010-02-22 00:00:00';
```
=====================
Question: For the team "Hannover 96", what was its defence aggression class on 2015/9/10?
 db_id: european_football_2
Planner: 1.  Find the `team_api_id` for the team "Hannover 96" from the `Team` table using the `team_long_name` column.
2.  Filter the `Team_Attributes` table by `team_api_id` from the previous step and `date` equal to '2015-09-10'.
3.  Retrieve the `defenceAggressionClass` from the filtered `Team_Attributes` table.

NL2SQL: ```sql
SELECT
  T2.defenceAggressionClass
FROM Team AS T1
INNER JOIN Team_Attributes AS T2
  ON T1.team_api_id = T2.team_api_id
WHERE
  T1.team_long_name = 'Hannover 96' AND T2.date LIKE '2015-09-10%';
```
Critic: ```sql
SELECT
  T2.defenceAggressionClass
FROM Team AS T1
INNER JOIN Team_Attributes AS T2
  ON T1.team_api_id = T2.team_api_id
WHERE
  T1.team_long_name = 'Hannover 96' AND T2.date = '2015-09-10 00:00:00';
```
=====================
Question: What was the average overall rating for Marko Arnautovic from 2007/2/22 to 2016/4/21?
 db_id: european_football_2
Planner: 1.  Join the `Player` and `Player_Attributes` tables on `player_api_id`.
2.  Filter the joined table by `player_name = 'Marko Arnautovic'` and the `date` column, ensuring it falls between '2007-02-22' and '2016-04-21'.  Since only the first 10 characters of the date are relevant, use `SUBSTR(date, 1, 10)`.
3.  Calculate the average `overall_rating` from the filtered results.

NL2SQL: ```sql
SELECT
  AVG(T2.overall_rating)
FROM Player AS T1
INNER JOIN Player_Attributes AS T2
  ON T1.player_api_id = T2.player_api_id
WHERE
  T1.player_name = 'Marko Arnautovic' AND SUBSTR(T2.date, 1, 10) BETWEEN '2007-02-22' AND '2016-04-21';
```
Critic: ```sql
SELECT
  AVG(T2.overall_rating)
FROM Player AS T1
INNER JOIN Player_Attributes AS T2
  ON T1.player_api_id = T2.player_api_id
WHERE
  T1.player_name = 'Marko Arnautovic' AND T2.date BETWEEN '2007-02-22' AND '2016-04-21';
```
=====================
Question: What percentage is Landon Donovan's overall rating higher than Jordan Bowery on 2013/7/12?
 db_id: european_football_2
Planner: 1.  Find the `player_api_id` for Landon Donovan and Jordan Bowery from the `Player` table.
2.  Retrieve the `overall_rating` for Landon Donovan and Jordan Bowery from the `Player_Attributes` table on the date '2013-07-12', using the `player_api_id` found in step 1.
3.  Calculate the percentage difference between Landon Donovan's and Jordan Bowery's `overall_rating` using the formula: `((Landon Donovan's overall_rating - Jordan Bowery's overall_rating) / Jordan Bowery's overall_rating) * 100`.
4.  Return the calculated percentage.

NL2SQL: ```sql
SELECT
  CAST(
    (
      (
        SELECT
          overall_rating
        FROM Player_Attributes AS PA
        JOIN Player AS P
          ON PA.player_api_id = P.player_api_id
        WHERE
          P.player_name = 'Landon Donovan' AND PA.date = '2013-07-12'
      ) - (
        SELECT
          overall_rating
        FROM Player_Attributes AS PA
        JOIN Player AS P
          ON PA.player_api_id = P.player_api_id
        WHERE
          P.player_name = 'Jordan Bowery' AND PA.date = '2013-07-12'
      )
    ) AS REAL
  ) * 100 / (
    SELECT
      overall_rating
    FROM Player_Attributes AS PA
    JOIN Player AS P
      ON PA.player_api_id = P.player_api_id
    WHERE
      P.player_name = 'Jordan Bowery' AND PA.date = '2013-07-12'
  );
```
Critic: ```sql
SELECT
  CAST(
    (
      (
        SELECT
          overall_rating
        FROM Player_Attributes AS PA
        JOIN Player AS P
          ON PA.player_api_id = P.player_api_id
        WHERE
          P.player_name = 'Landon Donovan' AND PA.date = '2013-07-12'
      ) - (
        SELECT
          overall_rating
        FROM Player_Attributes AS PA
        JOIN Player AS P
          ON PA.player_api_id = P.player_api_id
        WHERE
          P.player_name = 'Jordan Bowery' AND PA.date = '2013-07-12'
      )
    ) AS REAL
  ) * 100 / (
    SELECT
      overall_rating
    FROM Player_Attributes AS PA
    JOIN Player AS P
      ON PA.player_api_id = P.player_api_id
    WHERE
      P.player_name = 'Jordan Bowery' AND PA.date = '2013-07-12'
  );
```
=====================
Question: List down most tallest players' name.
 db_id: european_football_2
Planner: 1. Select the `player_name` from the `Player` table.
2. Order the results by `height` in descending order.
3. Limit the results to the top 1.
NL2SQL: ```sql
SELECT
  player_name
FROM Player
ORDER BY
  height DESC
LIMIT 1;
```
Critic: ```sql
SELECT
  player_name
FROM Player
ORDER BY
  height DESC
LIMIT 1;
```
=====================
Question: State the name of the most strongest player.
 db_id: european_football_2
Planner: 1. Join `Player` and `Player_Attributes` tables on `player_api_id`.
2. Find the maximum `overall_rating` from the `Player_Attributes` table.
3. Filter the joined table to include only those players whose `overall_rating` is equal to the maximum `overall_rating`.
4. Select the `player_name` from the filtered table.

NL2SQL: ```sql
SELECT
  p.player_name
FROM Player AS p
JOIN Player_Attributes AS pa
  ON p.player_api_id = pa.player_api_id
ORDER BY
  pa.overall_rating DESC
LIMIT 1;
```
Critic: ```sql
SELECT
  p.player_name
FROM Player AS p
JOIN Player_Attributes AS pa
  ON p.player_api_id = pa.player_api_id
ORDER BY
  pa.overall_rating DESC
LIMIT 1;
```
=====================
Question: Who are the players that tend to be attacking when their mates were doing attack moves? List down their name.
 db_id: european_football_2
Planner: 1.  Join `Match` and `Player` to link match information to player information for home players. Perform this join 11 times using `home_player_1`, `home_player_2`, ..., `home_player_11` to `player_api_id` in `Player`.
2.  Join `Match` and `Player` to link match information to player information for away players. Perform this join 11 times using `away_player_1`, `away_player_2`, ..., `away_player_11` to `player_api_id` in `Player`.
3.  Join the above result with `Player_Attributes` table to get attacking work rate.
4.  Filter the results based on `attacking_work_rate` = 'high'.
5.  Select the distinct `player_name` to avoid duplicates.

NL2SQL: ```sql
SELECT DISTINCT T1.player_name
FROM Player AS T1
INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id
WHERE
  T2.attacking_work_rate = 'high';
```
Critic: ```sql
SELECT DISTINCT
  p.player_name
FROM Player AS p
JOIN Player_Attributes AS pa
  ON p.player_api_id = pa.player_api_id
WHERE
  pa.attacking_work_rate = 'high';
```
=====================
Question: What are the short name of team who played safe while creating chance of passing?
 db_id: european_football_2
Planner: Here's a plan to retrieve the short names of teams that played safe while creating chances of passing:

1.  **Table Selection:**
    *   Start with the `Team_Attributes` table because it contains the `chanceCreationPassingClass` column, which indicates the passing style.
    *   Join `Team` table to get the `team_short_name`.

2.  **Filtering:**
    *   Filter the `Team_Attributes` table to select rows where `chanceCreationPassingClass` is 'Safe'.

3.  **Joining:**
    *   Join the filtered `Team_Attributes` table with the `Team` table using `team_api_id` to link the team attributes to the team's information.

4.  **Column Selection:**
    *   Select the `team_short_name` from the `Team` table.

5.  **Distinct Values:**
    *   Use `DISTINCT` clause to avoid showing the same team name multiple times if needed.

NL2SQL: ```sql
SELECT DISTINCT T2.team_short_name FROM Team_Attributes AS T1 INNER JOIN Team AS T2 ON T1.team_api_id = T2.team_api_id WHERE T1.chanceCreationPassingClass = 'Safe'
```
Critic: ```sql
SELECT T2.team_short_name FROM Team_Attributes AS T1 INNER JOIN Team AS T2 ON T1.team_api_id = T2.team_api_id WHERE T1.chanceCreationPassingClass = 'Safe' GROUP BY T2.team_short_name
```
=====================
Question: How many football players born after the 1990s have the first name "Aaron"?
 db_id: european_football_2
Planner: 1.  **Table Selection:** Use the `Player` table.
2.  **Filtering:**
    *   Filter `player_name` to include only players whose first name is "Aaron".
    *   Filter `birthday` to include only players born after 1990.
3.  **Aggregation:** Count the number of players that meet the criteria.
4.  **Final Result:** Return the count.
NL2SQL: ```sql
SELECT
  COUNT(id)
FROM Player
WHERE
  player_name LIKE 'Aaron%' AND birthday > '1990';
```
Critic: ```sql
SELECT
  COUNT(id)
FROM Player
WHERE
  player_name LIKE 'Aaron%' AND substr(birthday, 1, 4) > '1990';
```
=====================
Question: What is the difference between players 6 and 23's jumping scores?
 db_id: european_football_2
Planner: 1. Join the `Player` table with the `Player_Attributes` table using `player_api_id`.
2. Filter the joined table for player with `id = 6` and extract the `jumping` score.
3. Filter the joined table for player with `id = 23` and extract the `jumping` score.
4. Calculate the difference between the two `jumping` scores.

NL2SQL: ```sql
SELECT
  SUM(CASE WHEN T1.id = 6 THEN T2.jumping ELSE 0 END) - SUM(CASE WHEN T1.id = 23 THEN T2.jumping ELSE 0 END)
FROM Player AS T1
INNER JOIN Player_Attributes AS T2
  ON T1.player_api_id = T2.player_api_id;
```
Critic: ```sql
SELECT
  (
    SELECT
      jumping
    FROM Player_Attributes
    WHERE
      player_api_id = (
        SELECT
          player_api_id
        FROM Player
        WHERE
          id = 6
      )
    ORDER BY
      date DESC
    LIMIT 1
  ) - (
    SELECT
      jumping
    FROM Player_Attributes
    WHERE
      player_api_id = (
        SELECT
          player_api_id
        FROM Player
        WHERE
          id = 23
      )
    ORDER BY
      date DESC
    LIMIT 1
  );
```
=====================
Question: Please provide top four football players' IDs who are among the lowest potential players and prefer to use the right foot when attacking.
 db_id: european_football_2
Planner: Here's my plan to get the top four player IDs:

1.  **Join `Player` and `Player_Attributes`:** Join these tables using `player_api_id` to link player information with their attributes.
2.  **Filter for preferred foot:** Filter the joined table to include only players whose `preferred_foot` is 'right'.
3.  **Order by potential:** Order the results by `potential` in ascending order to find the players with the lowest potential.
4.  **Limit the results:** Limit the output to the top four players using `LIMIT 4`.
5.  **Select player IDs:** Select the `id` column from the `Player` table.

NL2SQL: ```sql
SELECT
  T1.id
FROM Player AS T1
INNER JOIN Player_Attributes AS T2
  ON T1.player_api_id = T2.player_api_id
WHERE
  T2.preferred_foot = 'right'
ORDER BY
  T2.potential
LIMIT 4;
```
Critic: ```sql
SELECT
  player_api_id
FROM Player_Attributes
WHERE
  preferred_foot = 'right'
ORDER BY
  potential
LIMIT 4;
```
=====================
Question: How many players had the highest potential score for crossing that preferred to use their left foots while attacking?
 db_id: european_football_2
Planner: 1. Find the maximum crossing score from the Player_Attributes table.
2. Filter the Player_Attributes table to include only players whose preferred foot is 'left' and crossing score is equal to the maximum crossing score found in step 1.
3. Count the number of players that satisfy the conditions in step 2.

NL2SQL: ```sql
SELECT
  COUNT(DISTINCT T1.player_api_id)
FROM Player_Attributes AS T1
WHERE
  T1.preferred_foot = 'left' AND T1.crossing = (
    SELECT
      MAX(crossing)
    FROM Player_Attributes
  );
```
Critic: ```sql
SELECT
  COUNT(DISTINCT T1.player_api_id)
FROM Player_Attributes AS T1
WHERE
  T1.preferred_foot = 'left' AND T1.potential = (
    SELECT
      MAX(potential)
    FROM Player_Attributes
  );
```
=====================
Question: What was the final score for the match on September 24, 2008, in the Belgian Jupiler League between the home team and the away team?
 db_id: european_football_2
Planner: 1.  Filter the `Match` table by `date` to find the match on September 24, 2008.
2.  Join the `Match` table with the `League` table on `league_id` to filter for matches in the Belgian Jupiler League.
3.  Select the `home_team_goal` and `away_team_goal` from the `Match` table for the filtered match.
NL2SQL: ```sql
SELECT
  home_team_goal,
  away_team_goal
FROM Match
JOIN League
  ON Match.league_id = League.id
WHERE
  League.name = 'Belgium Jupiler League' AND date LIKE '2008-09-24%';
```
Critic: ```sql
SELECT
  home_team_goal,
  away_team_goal
FROM Match
JOIN League
  ON Match.league_id = League.id
WHERE
  League.name = 'Belgium Jupiler League' AND DATE = '2008-09-24';
```
=====================
Question: Does the KSV Cercle Brugge team have a slow, balanced or fast speed class?
 db_id: european_football_2
Planner: 1. Find the `team_api_id` for the team 'KSV Cercle Brugge' from the `Team` table.
2. Use the `team_api_id` to filter the `Team_Attributes` table.
3. Retrieve the `buildUpPlaySpeedClass` from the `Team_Attributes` table.

NL2SQL: ```sql
SELECT
  T2.buildUpPlaySpeedClass
FROM Team AS T1
INNER JOIN Team_Attributes AS T2
  ON T1.team_api_id = T2.team_api_id
WHERE
  T1.team_long_name = 'KSV Cercle Brugge'
LIMIT 1;
```
Critic: ```sql
SELECT
  buildUpPlaySpeedClass
FROM Team_Attributes
WHERE
  team_api_id = (
    SELECT
      team_api_id
    FROM Team
    WHERE
      team_long_name = 'KSV Cercle Brugge'
  )
LIMIT 1;
```
=====================
Question: Please state the finishing rate and curve score of the player who has the heaviest weight.
 db_id: european_football_2
Planner: 1. Find the player with the maximum weight using the `Player` table.
2. Get the `player_api_id` of the player with the maximum weight.
3. Find the finishing rate and curve score for the player with the `player_api_id` obtained in the previous step from the `Player_Attributes` table.
4. Display the finishing rate and curve score.

Tables needed: `Player`, `Player_Attributes`

Columns needed:
- `Player`: `player_api_id`, `weight`
- `Player_Attributes`: `player_api_id`, `finishing`, `curve`

Filters:
- `Player`: `weight` = (maximum weight)
- `Player_Attributes`: `player_api_id` = (player_api_id of the player with maximum weight)

Joins: No joins are needed.

NL2SQL: ```sql
SELECT
  T2.finishing,
  T2.curve
FROM Player AS T1
INNER JOIN Player_Attributes AS T2
  ON T1.player_api_id = T2.player_api_id
WHERE
  T1.weight = (
    SELECT
      MAX(weight)
    FROM Player
  );
```
Critic: ```sql
SELECT
  T2.finishing,
  T2.curve
FROM Player AS T1
INNER JOIN Player_Attributes AS T2
  ON T1.player_api_id = T2.player_api_id
WHERE
  T1.weight = (
    SELECT
      MAX(weight)
    FROM Player
  )
GROUP BY
  T2.finishing,
  T2.curve
ORDER BY
  COUNT(*) DESC
LIMIT 1;
```
=====================
Question: Which top 4 leagues had the most games in the 2015-2016 season?
 db_id: european_football_2
Planner: 1.  Filter the `Match` table for the season '2015/2016'.
2.  Join `Match` with `League` table using `league_id` to retrieve the league name for each match.
3.  Group the results by league name and count the number of matches in each league.
4.  Order the results in descending order based on the match count.
5.  Limit the result to the top 4 leagues.
6.  Display the league name and the corresponding match count.

NL2SQL: ```sql
SELECT
  l.name,
  COUNT(m.id) AS match_count
FROM Match AS m
JOIN League AS l
  ON m.league_id = l.id
WHERE
  m.season = '2015/2016'
GROUP BY
  l.name
ORDER BY
  match_count DESC
LIMIT 4;
```
Critic: ```sql
SELECT
  T1.name,
  COUNT(T2.id)
FROM League AS T1
INNER JOIN Match AS T2
  ON T1.id = T2.league_id
WHERE
  T2.season = '2015/2016'
GROUP BY
  T1.name
ORDER BY
  COUNT(T2.id) DESC
LIMIT 4;
```
=====================
Question: Please provide the full name of the away team that scored the most goals.
 db_id: european_football_2
Planner: 1. Join the `Match` and `Team` tables on `Match.away_team_api_id = Team.team_api_id`.
2. Group the results by `Team.team_long_name`.
3. Calculate the sum of `Match.away_team_goal` for each team.
4. Order the results in descending order based on the sum of away goals.
5. Limit the result to the top 1 team.
6. Select the `Team.team_long_name` for the team with the most away goals.

NL2SQL: ```sql
SELECT
  T.team_long_name
FROM Team AS T
JOIN Match AS M
  ON T.team_api_id = M.away_team_api_id
GROUP BY
  T.team_long_name
ORDER BY
  SUM(M.away_team_goal) DESC
LIMIT 1;
```
Critic: ```sql
SELECT
  T.team_long_name
FROM Match AS M
JOIN Team AS T
  ON M.away_team_api_id = T.team_api_id
GROUP BY
  T.team_long_name
ORDER BY
  SUM(M.away_team_goal) DESC
LIMIT 1;
```
=====================
Question: Please name one player whose overall strength is the greatest.
 db_id: european_football_2
Planner: 1.  Join Player and Player\_Attributes tables on `player_api_id`.
2.  Find the maximum `overall_rating` from the Player_Attributes table.
3.  Filter the joined table where `overall_rating` equals the maximum `overall_rating`.
4.  Select the `player_name` from the Player table.
5.  Limit to one result.
NL2SQL: ```sql
SELECT
  p.player_name
FROM Player AS p
JOIN Player_Attributes AS pa
  ON p.player_api_id = pa.player_api_id
ORDER BY
  pa.overall_rating DESC
LIMIT 1;
```
Critic: ```sql
SELECT
  P.player_name
FROM Player AS P
JOIN Player_Attributes AS PA
  ON P.player_api_id = PA.player_api_id
ORDER BY
  PA.overall_rating DESC
LIMIT 1;
```
=====================
Question: What is the percentage of players that are under 180 cm who have an overall strength of more than 70?
 db_id: european_football_2
Planner: 1.  Join the `Player` and `Player_Attributes` tables on `player_api_id`.
2.  Filter the joined table for players with `height` less than 180 cm and `overall_rating` greater than 70.
3.  Count the number of players that satisfy the above condition.
4.  Calculate the total number of players in the `Player` table.
5.  Divide the number of players satisfying the condition by the total number of players and multiply by 100 to get the percentage.
NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.height < 180 AND T2.overall_rating > 70 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id)
FROM Player AS T1
INNER JOIN Player_Attributes AS T2
  ON T1.player_api_id = T2.player_api_id;
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.height < 180 AND T2.overall_rating > 70 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id)
FROM Player AS T1
INNER JOIN Player_Attributes AS T2
  ON T1.player_api_id = T2.player_api_id;
```
=====================
Question: Please list the reference names of the drivers who are eliminated in the first period in race number 20.
 db_id: formula_1
Planner: Plan:
1. Find the `raceId` for race number 20 from the `Races` table.
2. Find the `statusId` which represent "Eliminated" status in the `Status` table. It means drivers who are eliminated in the first period. Status contains information about "Eliminated".
3. Find the `driverId` from the `Results` table where `raceId` matches the race ID found in step 1 and `statusId` match with the status ID of "Eliminated".
4. Retrieve the `driverRef` from the `Drivers` table using the `driverId`s found in step 3.

NL2SQL: ```sql
SELECT
  T1.driverRef
FROM drivers AS T1
INNER JOIN results AS T2
  ON T1.driverId = T2.driverId
INNER JOIN status AS T3
  ON T2.statusId = T3.statusId
WHERE
  T2.raceId = 20 AND T3.status = 'Finished';
```
Critic: ```sql
SELECT
  T1.driverRef
FROM drivers AS T1
INNER JOIN results AS T2
  ON T1.driverId = T2.driverId
WHERE
  T2.raceId = 20 AND T2.statusId = 1;
```
=====================
Question: What is the surname of the driver with the best lap time in race number 19 in the second qualifying period?
 db_id: formula_1
Planner: Plan:
1. Find the `driverId` with the minimum `q2` time in the `qualifying` table where `raceId` is 19.
2. Retrieve the `surname` of the driver from the `drivers` table using the `driverId` found in the previous step.
3. Return the surname.

NL2SQL: ```sql
SELECT
  T2.surname
FROM qualifying AS T1
INNER JOIN drivers AS T2
  ON T1.driverId = T2.driverId
WHERE
  T1.raceId = 19
ORDER BY
  T1.q2
LIMIT 1;
```
Critic: ```sql
SELECT
  T2.surname
FROM qualifying AS T1
INNER JOIN drivers AS T2
  ON T1.driverId = T2.driverId
WHERE
  T1.raceId = 19
  AND T1.q2 IS NOT NULL
ORDER BY
  T1.q2
LIMIT 1;
```
=====================
Question: Please give the name of the race held on the circuits in Germany.
 db_id: formula_1
Planner: 1.  Find the `circuitId` of circuits located in Germany from the `circuits` table.
2.  Using the `circuitId`, find the corresponding `raceId` from the `races` table.
3.  Using the `raceId`, find the `name` of the race from the `races` table.

NL2SQL: ```sql
SELECT
  T1.name
FROM races AS T1
INNER JOIN circuits AS T2
  ON T1.circuitId = T2.circuitId
WHERE
  T2.country = 'Germany';
```
Critic: ```sql
SELECT DISTINCT
  T1.name
FROM races AS T1
INNER JOIN circuits AS T2
  ON T1.circuitId = T2.circuitId
WHERE
  T2.country = 'Germany';
```
=====================
Question: What is the coordinates location of the circuits for Australian grand prix?
 db_id: formula_1
Planner: 1.  Find the `circuitId` for races named 'Australian Grand Prix' from the `races` table.
2.  Retrieve the `lat` and `lng` columns from the `circuits` table, filtering by the `circuitId` obtained in the previous step.

Join:
None.
Tables:
`races`, `circuits`
Columns:
`circuits.lat`, `circuits.lng`
Filters:
`races.name` = 'Australian Grand Prix'
`circuits.circuitId` = `races.circuitId`

NL2SQL: ```sql
SELECT DISTINCT
  T1.lat,
  T1.lng
FROM circuits AS T1
INNER JOIN races AS T2
  ON T1.circuitId = T2.circuitId
WHERE
  T2.name = 'Australian Grand Prix';
```
Critic: ```sql
SELECT
  lat,
  lng
FROM circuits
WHERE
  country = 'Australia';
```
=====================
Question: Give the coordinate position for Abu Dhabi Grand Prix.
 db_id: formula_1
Planner: 1. Find the `circuitId` for the race named 'Abu Dhabi Grand Prix' in the `races` table.
2. Using the `circuitId` found in the previous step, retrieve the `lat` and `lng` from the `circuits` table.
3. Return the `lat` and `lng` values.

NL2SQL: ```sql
SELECT
  T2.lat,
  T2.lng
FROM races AS T1
INNER JOIN circuits AS T2
  ON T1.circuitId = T2.circuitId
WHERE
  T1.name = 'Abu Dhabi Grand Prix';
```
Critic: ```sql
SELECT
  lat,
  lng
FROM circuits
WHERE
  name = 'Yas Marina Circuit';
```
=====================
Question: What's Bruno Senna's Q1 result in the qualifying race No. 354?
 db_id: formula_1
Planner: 1.  Find the `driverId` of Bruno Senna from the `drivers` table using `forename` and `surname`.
2.  Find the `q1` result from the `qualifying` table.
3.  Join `qualifying` table with `races` table using `raceId`.
4.  Filter the `qualifying` table by `driverId` obtained in step 1 and `raceId` = 354.
5.  Select the `q1` column from the filtered table.

NL2SQL: ```sql
SELECT
  T1.q1
FROM qualifying AS T1
INNER JOIN drivers AS T2
  ON T1.driverId = T2.driverId
WHERE
  T2.forename = 'Bruno' AND T2.surname = 'Senna' AND T1.raceId = 354;
```
Critic: ```sql
SELECT
  T1.q1
FROM qualifying AS T1
INNER JOIN drivers AS T2
  ON T1.driverId = T2.driverId
WHERE
  T2.forename = 'Bruno' AND T2.surname = 'Senna' AND T1.raceId = 354;
```
=====================
Question: What is his number of the driver who finished 0:01:54 in the Q3 of qualifying race No.903?
 db_id: formula_1
Planner: Here's a plan to retrieve the driver's number:

1.  **Identify the qualifying record:** Use the `qualifying` table to find the `qualifyId` where the `raceId` is 903 and `q3` is '0:01:54'.
2.  **Get the driver ID:** From the qualifying record found in step 1, retrieve the `driverId`.
3.  **Retrieve driver's number:** Use the `drivers` table and the `driverId` obtained in step 2 to find the driver's `number`.
Tables: `qualifying`, `drivers`

Columns:

*   `qualifying`: `raceId`, `driverId`, `q3`
*   `drivers`: `driverId`, `number`

Filters:

*   `qualifying`: `raceId` = 903, `q3` = '0:01:54'

Joins:

*   Join `qualifying` and `drivers` on `driverId`

Final selection: `drivers.number`

NL2SQL: ```sql
SELECT
  T1.number
FROM drivers AS T1
INNER JOIN qualifying AS T2
  ON T1.driverId = T2.driverId
WHERE
  T2.raceId = 903 AND T2.q3 = '0:01:54';
```
Critic: ```sql
SELECT
  T1.number
FROM drivers AS T1
INNER JOIN qualifying AS T2
  ON T1.driverId = T2.driverId
WHERE
  T2.raceId = 903 AND T2.q3 = '1:54.0';
```
=====================
Question: For the Bahrain Grand Prix in 2007, how many drivers not finished the game?
 db_id: formula_1
Planner: Plan:
1. Find the `raceId` for the Bahrain Grand Prix in 2007 from the `races` table using `year` and `name`.
2. Join the `results` table with the `races` table using `raceId`.
3. Join the `results` table with the `status` table using `statusId`.
4. Filter the results to include only drivers from the 2007 Bahrain Grand Prix
5. Filter out results of finished drivers by checking the `status`
6. Count the number of drivers who did not finish the race.
7. Return the count.

NL2SQL: ```sql
SELECT
  COUNT(T1.driverId)
FROM results AS T1
INNER JOIN races AS T2
  ON T1.raceId = T2.raceId
INNER JOIN status AS T3
  ON T1.statusId = T3.statusId
WHERE
  T2.year = 2007 AND T2.name = 'Bahrain Grand Prix' AND T3.status != 'Finished';
```
Critic: ```sql
SELECT
  COUNT(T1.driverId)
FROM results AS T1
INNER JOIN races AS T2
  ON T1.raceId = T2.raceId
WHERE
  T2.year = 2007 AND T2.name = 'Bahrain Grand Prix' AND T1.statusId IN (SELECT statusId FROM status WHERE status != 'Finished');
```
=====================
Question: For all the drivers who finished the game in race No. 592, who is the oldest?
 db_id: formula_1
Planner: Plan:
1. Find the `driverId` of drivers who finished the race with `raceId` = 592 from the `results` table where `time` is not NULL.
2. Retrieve the `driverId` and `dob` from the `drivers` table for the `driverId`s obtained in step 1.
3. Find the maximum `dob` (oldest driver) from the `drivers` table.
4. Display the `forename`, `surname` of that driver.

NL2SQL: ```sql
SELECT
  forename,
  surname
FROM drivers
WHERE
  driverId IN (
    SELECT
      driverId
    FROM results
    WHERE
      raceId = 592 AND time IS NOT NULL
  )
ORDER BY
  dob
LIMIT 1;
```
Critic: ```sql
SELECT
  forename,
  surname
FROM drivers
WHERE
  driverId IN (
    SELECT
      driverId
    FROM results
    WHERE
      raceId = 592
  )
ORDER BY
  dob
LIMIT 1;
```
=====================
Question: Who was the player that got the lap time of 0:01:27 in the race No. 161? Show his introduction website.
 db_id: formula_1
Planner: 1.  Find the `driverId` from the `lapTimes` table where `raceId` is 161 and `time` is '0:01:27'.
2.  Retrieve the `url` (introduction website) from the `drivers` table using the `driverId` obtained in the previous step.

Join tables:
`lapTimes` and `drivers` tables on `driverId`.

Filter:
`lapTimes` table with `raceId` = 161 and `time` = '0:01:27'.

Columns to select:
`drivers.url`

NL2SQL: ```sql
SELECT
  T2.url
FROM lapTimes AS T1
INNER JOIN drivers AS T2
  ON T1.driverId = T2.driverId
WHERE
  T1.raceId = 161 AND T1.time = '1:27.8';
```
Critic: ```sql
SELECT
  T2.url
FROM lapTimes AS T1
INNER JOIN drivers AS T2
  ON T1.driverId = T2.driverId
WHERE
  T1.raceId = 161 AND T1.time = '0:01:27';
```
=====================
Question: Where is Malaysian Grand Prix held? Give the location coordinates.
 db_id: formula_1
Planner: 1. Find the `circuitId` from the `races` table where `name` is 'Malaysian Grand Prix'.
2. Use the `circuitId` to find the `lat` and `lng` from the `circuits` table.

NL2SQL: ```sql
SELECT
  T2.lat,
  T2.lng
FROM races AS T1
INNER JOIN circuits AS T2
  ON T1.circuitId = T2.circuitId
WHERE
  T1.name = 'Malaysian Grand Prix';
```
Critic: ```sql
SELECT
  lat,
  lng
FROM circuits
WHERE
  location = 'Kuala Lumpur';
```
=====================
Question: For the constructor which got the highest point in the race No. 9 , what is its introduction website?
 db_id: formula_1
Planner: Plan:
1. Find the `raceId` corresponding to race number 9 from the `Races` table.
2. Find the `constructorId` that scored the maximum points in the race identified in step 1 from the `constructorResults` table.
3. Retrieve the constructor's introduction website (`url`) from the `constructors` table using the `constructorId` obtained in step 2.

NL2SQL: ```sql
SELECT
  T2.url
FROM constructorResults AS T1
INNER JOIN constructors AS T2
  ON T1.constructorId = T2.constructorId
WHERE
  T1.raceId = 9
ORDER BY
  T1.points DESC
LIMIT 1;
```
Critic: ```sql
SELECT
  T2.url
FROM constructorResults AS T1
INNER JOIN constructors AS T2
  ON T1.constructorId = T2.constructorId
WHERE
  T1.raceId = 9
ORDER BY
  T1.points DESC
LIMIT 1;
```
=====================
Question: In the race No. 45, for the driver who had the Q3 time as 0:01:33, what is his abbreviated code?
 db_id: formula_1
Planner: Plan:
1. Filter the `qualifying` table by `raceId` = 45 and `q3` = '1:33.000'.
2. Get the `driverId` from the filtered table.
3. Retrieve the `code` from the `drivers` table using the `driverId`.

NL2SQL: ```sql
SELECT
  T2.code
FROM qualifying AS T1
INNER JOIN drivers AS T2
  ON T1.driverId = T2.driverId
WHERE
  T1.raceId = 45 AND T1.q3 = '1:33.000';
```
Critic: ```sql
SELECT
  T2.code
FROM qualifying AS T1
INNER JOIN drivers AS T2
  ON T1.driverId = T2.driverId
WHERE
  T1.raceId = 45 AND T1.q3 = '01:33.000';
```
=====================
Question: Show me the season page of year when the race No. 901 took place.
 db_id: formula_1
Planner: 1. Find the `year` from the `races` table where `raceId` is 901.
2. Find the `url` from the `seasons` table using the `year` obtained in the previous step.

NL2SQL: ```sql
SELECT
  T2.url
FROM races AS T1
INNER JOIN seasons AS T2
  ON T1.year = T2.year
WHERE
  T1.raceId = 901;
```
Critic: ```sql
SELECT
  url
FROM seasons
WHERE
  year = (
    SELECT
      year
    FROM races
    WHERE
      raceId = 901
  );
```
=====================
Question: For all the drivers who finished the game in race No. 872, who is the youngest?
 db_id: formula_1
Planner: 1. **Find drivers who finished race No. 872:**
   - Use the `results` table.
   - Filter by `raceId = 872` and `time IS NOT NULL` to identify drivers who finished the race.
   - Extract the `driverId` of these drivers.

2. **Find the youngest driver:**
   - Use the `drivers` table.
   - Filter by `driverId` IN (driverIds from step 1).
   - Find the driver with the maximum date of birth (`dob`).

3. **Output:**
   - Output the `forename`, `surname` from `drivers` table.

NL2SQL: ```sql
SELECT
  forename,
  surname
FROM drivers
WHERE
  driverId IN (
    SELECT
      driverId
    FROM results
    WHERE
      raceId = 872 AND time IS NOT NULL
  )
ORDER BY
  dob DESC
LIMIT 1;
```
Critic: ```sql
SELECT
  forename,
  surname
FROM drivers
WHERE
  driverId IN (
    SELECT
      driverId
    FROM results
    WHERE
      raceId = 872
  )
ORDER BY
  dob DESC
LIMIT 1;
```
=====================
Question: For the driver who set the fastest lap speed, what is his nationality?
 db_id: formula_1
Planner: 1. Find the maximum `fastestLapSpeed` from the `results` table.
2. Filter the `results` table for records that have `fastestLapSpeed` equal to the maximum speed.
3. Get the `driverId` of the driver who achieved the fastest lap speed.
4. Join the `drivers` table with the filtered `results` table using `driverId`.
5. Select the `nationality` from the `drivers` table.

NL2SQL: ```sql
SELECT
  T2.nationality
FROM results AS T1
INNER JOIN drivers AS T2
  ON T1.driverId = T2.driverId
WHERE
  T1.fastestLapSpeed = (
    SELECT
      MAX(fastestLapSpeed)
    FROM results
  )
LIMIT 1;
```
Critic: ```sql
SELECT
  T2.nationality
FROM results AS T1
INNER JOIN drivers AS T2
  ON T1.driverId = T2.driverId
ORDER BY
  T1.fastestLapSpeed DESC
LIMIT 1;
```
=====================
Question: Paul di Resta was in the No. 853 race, what percent faster did he finish in the 853rd race than the next race for the fastest lap speed?
 db_id: formula_1
Planner: 1.  Find the `driverId` for Paul di Resta from the `drivers` table where `forename` is 'Paul' and `surname` is 'di Resta'.
2.  Find the `fastestLapSpeed` for Paul di Resta in race `853` from the `results` table, joining on `driverId` and filtering on `raceId = 853`.
3.  Find the `fastestLapSpeed` for Paul di Resta in race `854` from the `results` table, joining on `driverId` and filtering on `raceId = 854`.
4.  Calculate the percentage difference between the `fastestLapSpeed` in race `853` and race `854`.  The formula is `((853_fastestLapSpeed - 854_fastestLapSpeed) / 853_fastestLapSpeed) * 100`.

NL2SQL: ```sql
SELECT
  CAST(
    (
      (
        (
          SELECT
            fastestLapSpeed
          FROM results
          WHERE
            raceId = 853 AND driverId = (
              SELECT
                driverId
              FROM drivers
              WHERE
                forename = 'Paul' AND surname = 'di Resta'
            )
        ) - (
          SELECT
            fastestLapSpeed
          FROM results
          WHERE
            raceId = 854 AND driverId = (
              SELECT
                driverId
              FROM drivers
              WHERE
                forename = 'Paul' AND surname = 'di Resta'
            )
        )
      ) * 100
    ) AS REAL
  ) / (
    SELECT
      fastestLapSpeed
    FROM results
    WHERE
      raceId = 853 AND driverId = (
        SELECT
          driverId
        FROM drivers
        WHERE
          forename = 'Paul' AND surname = 'di Resta'
      )
  )
FROM drivers
LIMIT 1;
```
Critic: ```sql
SELECT
  CAST(
    (
      (
        (
          SELECT
            fastestLapSpeed
          FROM results
          WHERE
            raceId = 853 AND driverId = (
              SELECT
                driverId
              FROM drivers
              WHERE
                forename = 'Paul' AND surname = 'di Resta'
            )
        ) - (
          SELECT
            fastestLapSpeed
          FROM results
          WHERE
            raceId = 854 AND driverId = (
              SELECT
                driverId
              FROM drivers
              WHERE
                forename = 'Paul' AND surname = 'di Resta'
            )
        )
      ) / (
        SELECT
          fastestLapSpeed
        FROM results
        WHERE
          raceId = 854 AND driverId = (
            SELECT
              driverId
            FROM drivers
            WHERE
              forename = 'Paul' AND surname = 'di Resta'
          )
      )
    ) * 100 AS REAL
  );
```
=====================
Question: For the drivers who took part in the race in 1983/7/16, what's their race completion rate?
 db_id: formula_1
Planner: 1.  **Find the raceId for the race on '1983-07-16'**:
    *   Use the `races` table.
    *   Filter by `date = '1983-07-16'`.
    *   Select the `raceId`.
2.  **Find all driverIds that participated in that race:**
    *   Use the `results` table.
    *   Filter by the `raceId` found in the previous step.
    *   Select the `driverId`.
3.  **Count total drivers participated in the race**
    *   Use the `results` table.
    *   Filter by the `raceId` found in the previous step.
    *   Count the `driverId`.
4.  **Count finished drivers in the race**
    *   Use the `results` table.
    *   Filter by the `raceId` found in the previous step and time is not NULL.
    *   Count the `driverId`.
5.  **Calculate the completion rate:**
    *   Divide the number of finished drivers by the total number of drivers.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.time IS NOT NULL THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.driverId)
FROM results AS T1
INNER JOIN races AS T2
  ON T1.raceId = T2.raceId
WHERE
  T2.date = '1983-07-16';
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.statusId = 1 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.driverId)
FROM results AS T1
INNER JOIN races AS T2
  ON T1.raceId = T2.raceId
WHERE
  T2.date = '1983-07-16';
```
=====================
Question: List the names of all races that occurred in the earliest recorded year and month.
 db_id: formula_1
Planner: 1. Find the earliest year and month from the `races` table using the `MIN(date)` function.
2. Filter the `races` table to include only races that occurred in the earliest year and month.
3. Select the `name` column from the filtered `races` table to get the names of the races that match the criteria.

NL2SQL: ```sql
SELECT
  name
FROM races
WHERE
  STRFTIME('%Y', date) = (
    SELECT
      STRFTIME('%Y', MIN(date))
    FROM races
  )
  AND STRFTIME('%m', date) = (
    SELECT
      STRFTIME('%m', MIN(date))
    FROM races
  );
```
Critic: ```sql
SELECT
  name
FROM races
WHERE
  date = (
    SELECT
      MIN(date)
    FROM races
  );
```
=====================
Question: State the driver with the most points scored. Find his full name with that points.
 db_id: formula_1
Planner: 1. Find the driver with the maximum points scored using the `driverStandings` table.
2. Get the `driverId` of that driver.
3. Use the `driverId` to find the forename and surname of the driver from the `drivers` table.
4. Concatenate forename and surname to get the full name.

NL2SQL: ```sql
SELECT
  T2.forename,
  T2.surname
FROM driverStandings AS T1
INNER JOIN drivers AS T2
  ON T1.driverId = T2.driverId
ORDER BY
  T1.points DESC
LIMIT 1;
```
Critic: ```sql
SELECT
  T2.forename,
  T2.surname
FROM driverStandings AS T1
INNER JOIN drivers AS T2
  ON T1.driverId = T2.driverId
ORDER BY
  T1.points DESC
LIMIT 1;
```
=====================
Question: What is the best lap time recorded? List the driver and race with such recorded lap time.
 db_id: formula_1
Planner: Plan:
1. Find the minimum lap time (milliseconds) from the lapTimes table.
2. Join lapTimes with races on raceId to get the race name.
3. Join lapTimes with drivers on driverId to get the driver's forename and surname.
4. Filter the result where the lap time (milliseconds) equals the minimum lap time found in step 1.
5. Select the driver's forename, surname, and the race name.

NL2SQL: ```sql
SELECT
  T1.forename,
  T1.surname,
  T2.name
FROM drivers AS T1
INNER JOIN races AS T2
  ON T1.driverId = T2.raceId
INNER JOIN lapTimes AS T3
  ON T1.driverId = T3.driverId
WHERE
  T3.milliseconds = (
    SELECT
      MIN(milliseconds)
    FROM lapTimes
  );
```
Critic: ```sql
SELECT
  T1.forename,
  T1.surname,
  T2.name
FROM drivers AS T1
INNER JOIN lapTimes AS T3
  ON T1.driverId = T3.driverId
INNER JOIN races AS T2
  ON T3.raceId = T2.raceId
WHERE
  T3.milliseconds = (
    SELECT
      MIN(milliseconds)
    FROM lapTimes
  );
```
=====================
Question: What is the average lap time for Lewis Hamilton in the 2009 Malaysian Grand Prix?
 db_id: formula_1
Planner: 1. Find the `raceId` for the 2009 Malaysian Grand Prix from the `races` table. Filter by `year = 2009` and `name = 'Malaysian Grand Prix'`.
2. Find the `driverId` for Lewis Hamilton from the `drivers` table. Filter by `forename = 'Lewis'` and `surname = 'Hamilton'`.
3. Using the `raceId` and `driverId` found above, calculate the average lap time in milliseconds from the `lapTimes` table.
4. Return the average lap time.

NL2SQL: ```sql
SELECT AVG(T1.milliseconds) FROM lapTimes AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId INNER JOIN drivers AS T3 ON T1.driverId = T3.driverId WHERE T2.year = 2009 AND T2.name = "Malaysian Grand Prix" AND T3.forename = "Lewis" AND T3.surname = "Hamilton"
```
Critic: ```sql
SELECT AVG(T1.milliseconds) FROM lapTimes AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId INNER JOIN drivers AS T3 ON T1.driverId = T3.driverId WHERE T2.year = 2009 AND T2.name = "Malaysian Grand Prix" AND T3.forename = "Lewis" AND T3.surname = "Hamilton"
```
=====================
Question: Calculate the percentage whereby Hamilton was not at the 1st track of the the f1 circuit since 2010.
 db_id: formula_1
Planner: Here's my plan to calculate the percentage of races where Hamilton did not finish in the first position since 2010:

1.  **Identify Hamilton's driverId:** Use the `drivers` table to find the `driverId` associated with the surname 'Hamilton'.
2.  **Filter races since 2010:** Use the `races` table to select races with a `year` greater than or equal to 2010.
3.  **Join `races` and `results`:** Join the `races` table (filtered by year) with the `results` table using `raceId`.
4.  **Filter results for Hamilton:** Filter the joined table to include only results where `driverId` matches Hamilton's `driverId`.
5.  **Count total races:** Count the total number of races Hamilton participated in since 2010.
6.  **Count races not in first position:** Count the number of races where Hamilton's `positionOrder` is greater than 1.
7.  **Calculate the percentage:** Divide the number of races where Hamilton's `positionOrder` was greater than 1 by the total number of races and multiply by 100.
Tables:
*   races
*   results
*   drivers
Join:
*   races with results on raceId
*   drivers with results on driverId
Filters:
*   year >= 2010
*   surname = 'Hamilton'
*   positionOrder > 1
Columns:
*   COUNT(races.raceId)
*   races.year
*   drivers.driverId
*   drivers.surname
*   results.positionOrder

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.positionOrder > 1 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.raceId)
FROM results AS T1
INNER JOIN races AS T2
  ON T1.raceId = T2.raceId
INNER JOIN drivers AS T3
  ON T1.driverId = T3.driverId
WHERE
  T3.surname = 'Hamilton' AND T2.year >= 2010;
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.position > 1 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.raceId)
FROM results AS T1
INNER JOIN races AS T2
  ON T1.raceId = T2.raceId
INNER JOIN drivers AS T3
  ON T1.driverId = T3.driverId
WHERE
  T3.surname = 'Hamilton' AND T2.year >= 2010;
```
=====================
Question: Name the driver with the most winning. Mention his nationality and what is his maximum point scores.
 db_id: formula_1
Planner: Plan:
1. Find the driver with the most wins using `driverStandings` table. Group by `driverId` and count the wins, then find the maximum wins.
2. Join `drivers` table with `driverStandings` table using `driverId` to get the driver's nationality.
3. Find the maximum point scores from the `driverStandings` table for the driver with the most wins.
4. Select the driver's forename, surname, nationality, and maximum points.

NL2SQL: ```sql
SELECT
  T1.forename,
  T1.surname,
  T1.nationality,
  MAX(T2.points)
FROM drivers AS T1
INNER JOIN driverStandings AS T2
  ON T1.driverId = T2.driverId
WHERE
  T1.driverId = (
    SELECT
      driverId
    FROM driverStandings
    GROUP BY
      driverId
    ORDER BY
      SUM(wins) DESC
    LIMIT 1
  );
```
Critic: ```sql
SELECT
  T1.forename,
  T1.surname,
  T1.nationality,
  MAX(T2.points)
FROM drivers AS T1
INNER JOIN driverStandings AS T2
  ON T1.driverId = T2.driverId
WHERE
  T1.driverId = (
    SELECT
      driverId
    FROM driverStandings
    GROUP BY
      driverId
    ORDER BY
      SUM(wins) DESC
    LIMIT 1
  );
```
=====================
Question: How old is the youngest Japanese driver? What is his name?
 db_id: formula_1
Planner: Here's a plan to determine the youngest Japanese driver's name:

1.  **Filter Drivers:** Select drivers with `nationality = 'Japanese'` from the `drivers` table.
2.  **Find the Youngest:** Order the Japanese drivers by their date of birth (`dob`) in descending order (latest date first) and limit the result to the first row to find the youngest.
3.  **Retrieve Name:** Retrieve the `forename` and `surname` of the youngest driver.

NL2SQL:
```sql
SELECT
  forename,
  surname
FROM drivers
WHERE
  nationality = 'Japanese'
ORDER BY
  dob DESC
LIMIT 1;
```
NL2SQL: ```sql
SELECT
  forename,
  surname
FROM drivers
WHERE
  nationality = 'Japanese'
ORDER BY
  dob DESC
LIMIT 1;
```
Critic: ```sql
SELECT
  forename,
  surname
FROM drivers
WHERE
  nationality = 'Japanese'
ORDER BY
  dob DESC
LIMIT 1;
```
=====================
Question: Name the races along with its circuit name and location for f1 races hosted in September 2005.
 db_id: formula_1
Planner: 1.  **Filter races table:** Filter the `races` table to select races where the year is 2005 and the month of the date is 9.
2.  **Join races and circuits tables:** Join the filtered `races` table with the `circuits` table using the `circuitId` column.
3.  **Select columns:** Select the `name` (circuit name) and `location` from the `circuits` table, and `name` (race name) from the `races` table.

NL2SQL: ```sql
SELECT
  r.name,
  c.name,
  c.location
FROM races AS r
JOIN circuits AS c
  ON r.circuitId = c.circuitId
WHERE
  STRFTIME('%Y', r.date) = '2005' AND STRFTIME('%m', r.date) = '09';
```
Critic: ```sql
SELECT
  T1.name,
  T2.name,
  T2.location
FROM races AS T1
INNER JOIN circuits AS T2
  ON T1.circuitId = T2.circuitId
WHERE
  STRFTIME('%m', T1.date) = '09' AND STRFTIME('%Y', T1.date) = '2005';
```
=====================
Question: Which race was Alex Yoong in when he was in track number less than 20?
 db_id: formula_1
Planner: 1.  Find the `driverId` of Alex Yoong from the `drivers` table by filtering `forename` and `surname`.
2.  Find the `raceId` from the `driverStandings` table, where `driverId` matches the `driverId` found in the previous step and `position` is less than 20.
3.  Find the `name` of the race from the `races` table, where `raceId` matches the `raceId` found in the previous step.

Join `drivers` and `driverStandings` on `driverId`, then join `races` on `raceId`. Filter `drivers` by name, and filter the results where `position < 20`. Select race name from the races table.

NL2SQL: ```sql
SELECT
  T2.name
FROM drivers AS T1
INNER JOIN driverStandings AS T3
  ON T1.driverId = T3.driverId
INNER JOIN races AS T2
  ON T3.raceId = T2.raceId
WHERE
  T1.forename = 'Alex' AND T1.surname = 'Yoong' AND T3.position < 20;
```
Critic: ```sql
SELECT
  T2.name
FROM drivers AS T1
INNER JOIN results AS T3
  ON T1.driverId = T3.driverId
INNER JOIN races AS T2
  ON T3.raceId = T2.raceId
WHERE
  T1.forename = 'Alex' AND T1.surname = 'Yoong' AND T3.position < 20;
```
=====================
Question: State the race and year of race in which Michael Schumacher had his fastest lap.
 db_id: formula_1
Planner: 1. Find the `driverId` for Michael Schumacher from the `drivers` table.
2. Find the raceId's corresponding to the fastest lap times (minimum milliseconds) achieved by Michael Schumacher (using `driverId`) from the `lapTimes` table.
3. Join `races` table with the results filtered using the `raceId` to get the year of the race.
4. Retrieve the nationality of the driver from the `drivers` table.
5. Return the year of the race and the nationality.

NL2SQL: ```sql
SELECT
  T2.year,
  T1.nationality
FROM drivers AS T1
INNER JOIN lapTimes AS T3
  ON T1.driverId = T3.driverId
INNER JOIN races AS T2
  ON T3.raceId = T2.raceId
WHERE
  T1.forename = 'Michael' AND T1.surname = 'Schumacher'
ORDER BY
  T3.milliseconds
LIMIT 1;
```
Critic: ```sql
SELECT
  T1.year,
  T2.nationality
FROM races AS T1
INNER JOIN results AS T3
  ON T1.raceId = T3.raceId
INNER JOIN drivers AS T2
  ON T3.driverId = T2.driverId
WHERE
  T2.forename = 'Michael' AND T2.surname = 'Schumacher'
ORDER BY
  T3.fastestLapTime
LIMIT 1;
```
=====================
Question: Which was Lewis Hamilton first race? What was his points recorded for his first race event?
 db_id: formula_1
Planner: Here's the plan to retrieve the requested information:

1.  **Find Lewis Hamilton's driverId:**  Look in the `drivers` table to find the `driverId` associated with the name "Lewis Hamilton". Need to combine forename and surname.
2.  **Find the raceId of Lewis Hamilton's first race:** Use the `results` table, filtering by `driverId` to find all races Lewis Hamilton participated in.  Find the minimum `raceId` among these races to identify his first race.
3.  **Find the race name:** Use the `races` table and filter with the min raceId to find the name of the race.
4.  **Retrieve Lewis Hamilton's points for his first race:** Using the `results` table, filter by the `driverId` of Lewis Hamilton and the `raceId` of his first race.  Retrieve the `points` from that record.
5.  **Present the results:** Display the race name and the points recorded for that race.

JOIN is not needed because all needed information is available in tables: drivers, results and races

NL2SQL: ```sql
SELECT
  T2.name,
  T1.points
FROM results AS T1
INNER JOIN races AS T2
  ON T1.raceId = T2.raceId
INNER JOIN drivers AS T3
  ON T1.driverId = T3.driverId
WHERE
  T3.forename = 'Lewis' AND T3.surname = 'Hamilton'
ORDER BY
  T2.year
LIMIT 1;
```
Critic: ```sql
SELECT
  T2.name,
  T1.points
FROM results AS T1
INNER JOIN races AS T2
  ON T1.raceId = T2.raceId
INNER JOIN drivers AS T3
  ON T1.driverId = T3.driverId
WHERE
  T3.forename = 'Lewis' AND T3.surname = 'Hamilton'
ORDER BY
  T2.date
LIMIT 1;
```
=====================
Question: Among all European Grand Prix races, what is the percentage of the races were hosted in Germany?
 db_id: formula_1
Planner: 1. Find the `raceId` of races where `name` is 'European Grand Prix' from the `races` table.
2. From the `races` table, join with the `circuits` table on `circuitId`.
3. Filter the races where `name` is 'European Grand Prix' and count all such races.
4. Filter the races where `name` is 'European Grand Prix' and `country` is 'Germany' and count these races.
5. Calculate the percentage by dividing the count from step 4 by the count from step 3, multiplying by 100.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T2.country = 'Germany' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.name)
FROM races AS T1
INNER JOIN circuits AS T2
  ON T1.circuitId = T2.circuitId
WHERE
  T1.name = 'European Grand Prix';
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T2.country = 'Germany' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.name)
FROM races AS T1
INNER JOIN circuits AS T2
  ON T1.circuitId = T2.circuitId
WHERE
  T1.name LIKE '%Grand Prix%' AND T2.country = 'Germany';
```
=====================
Question: What's the location coordinates of Silverstone Circuit?
 db_id: formula_1
Planner: 1. **Find the table containing circuit information:** The `circuits` table contains information about circuits, including their names, latitude (`lat`), and longitude (`lng`).
2. **Filter for Silverstone Circuit:** Filter the `circuits` table to find the row where the `name` column is equal to 'Silverstone Circuit'.
3. **Select the latitude and longitude:** Select the `lat` and `lng` columns from the filtered row to get the coordinates of Silverstone Circuit.

NL2SQL: ```sql
SELECT
  lat,
  lng
FROM circuits
WHERE
  name = 'Silverstone Circuit';
```
Critic: ```sql
SELECT
  lat,
  lng
FROM circuits
WHERE
  name = 'Silverstone Circuit';
```
=====================
Question: What's the reference name of Marina Bay Street Circuit?
 db_id: formula_1
Planner: 1.  Find the `circuitRef` from the `circuits` table.
2.  Filter the `circuits` table by `name = 'Marina Bay Street Circuit'`.
3.  Return the `circuitRef` column.

NL2SQL: ```sql
SELECT
  circuitRef
FROM circuits
WHERE
  name = 'Marina Bay Street Circuit';
```
Critic: ```sql
SELECT
  circuitRef
FROM circuits
WHERE
  name = 'Marina Bay Street Circuit';
```
=====================
Question: Which country is the oldest driver from?
 db_id: formula_1
Planner: Plan:
1. Find the oldest driver by finding the minimum date of birth from the `drivers` table.
2. Get the nationality of the oldest driver.
3. Return the nationality.

Tables:
- drivers
Columns:
- dob (for finding the minimum date of birth)
- nationality (for returning the nationality of the oldest driver)

NL2SQL: ```sql
SELECT nationality FROM drivers ORDER BY dob ASC LIMIT 1
```
Critic: ```sql
SELECT nationality FROM drivers ORDER BY dob ASC LIMIT 1
```
=====================
Question: Which driver ranked the first in the Canadian Grand Prix in 2007? Please give his reference name.
 db_id: formula_1
Planner: Plan:
1. Find the `raceId` for the 'Canadian Grand Prix' in 2007 from the `races` table.
2. From the `results` table, filter by the `raceId` obtained in step 1 and `positionOrder` = 1.
3. Get the `driverId` from the filtered `results` table.
4. Retrieve the `driverRef` from the `drivers` table using the `driverId` obtained in step 3.

NL2SQL: ```sql
SELECT
  T2.driverRef
FROM races AS T1
INNER JOIN results AS T3
  ON T1.raceId = T3.raceId
INNER JOIN drivers AS T2
  ON T3.driverId = T2.driverId
WHERE
  T1.name = 'Canadian Grand Prix' AND T1.year = 2007 AND T3.positionOrder = 1;
```
Critic: ```sql
SELECT
  T2.driverRef
FROM races AS T1
INNER JOIN results AS T3
  ON T1.raceId = T3.raceId
INNER JOIN drivers AS T2
  ON T3.driverId = T2.driverId
WHERE
  T1.name = 'Canadian Grand Prix' AND T1.year = 2007 AND T3.position = 1;
```
=====================
Question: In which Formula_1 race did Lewis Hamilton rank the highest?
 db_id: formula_1
Planner: Plan:
1. Find the `driverId` for Lewis Hamilton from the `drivers` table using `forename` and `surname`.
2. Join the `results` table with the `races` table on `raceId`.
3. Filter the `results` table for Lewis Hamilton's `driverId`.
4. Find the minimum `rank` for Lewis Hamilton.
5. Select the `name` of the race where Lewis Hamilton achieved the minimum `rank`.

NL2SQL: ```sql
SELECT
  T2.name
FROM results AS T1
INNER JOIN races AS T2
  ON T1.raceId = T2.raceId
INNER JOIN drivers AS T3
  ON T1.driverId = T3.driverId
WHERE
  T3.forename = 'Lewis' AND T3.surname = 'Hamilton'
ORDER BY
  T1.rank
LIMIT 1;
```
Critic: ```sql
SELECT
  T1.name
FROM races AS T1
INNER JOIN results AS T2
  ON T1.raceId = T2.raceId
INNER JOIN drivers AS T3
  ON T2.driverId = T3.driverId
WHERE
  T3.forename = 'Lewis' AND T3.surname = 'Hamilton'
ORDER BY
  T2.rank
LIMIT 1;
```
=====================
Question: What was the fastest lap speed among all drivers in the 2009 Spanish Grand Prix?
 db_id: formula_1
Planner: 1.  Find the `raceId` for the 2009 Spanish Grand Prix from the `races` table using the conditions `year = 2009` and `name = 'Spanish Grand Prix'`.
2.  From the `results` table, filter by the `raceId` obtained in step 1.
3.  Select the maximum `fastestLapSpeed` from the filtered results.

NL2SQL: ```sql
SELECT
  MAX(fastestLapSpeed)
FROM results
JOIN races
  ON results.raceId = races.raceId
WHERE
  races.year = 2009 AND races.name = 'Spanish Grand Prix';
```
Critic: ```sql
SELECT
  MAX(T1.fastestLapSpeed)
FROM results AS T1
INNER JOIN races AS T2
  ON T1.raceId = T2.raceId
WHERE
  T2.year = 2009 AND T2.name = 'Spanish Grand Prix';
```
=====================
Question: What was Lewis Hamilton's final rank in the 2008 Chinese Grand Prix?
 db_id: formula_1
Planner: 1.  Find the `raceId` for the 2008 Chinese Grand Prix from the `races` table, filtering by `year` = 2008 and `name` = "Chinese Grand Prix".
2.  Find the `driverId` for Lewis Hamilton from the `drivers` table, filtering by `forename` = "Lewis" and `surname` = "Hamilton".
3.  Using the `raceId` and `driverId` obtained in the previous steps, find the `positionOrder` (final rank) from the `results` table, filtering by the `raceId` and `driverId`.

NL2SQL: ```sql
SELECT
  T1.positionOrder
FROM results AS T1
INNER JOIN races AS T2
  ON T1.raceId = T2.raceId
INNER JOIN drivers AS T3
  ON T1.driverId = T3.driverId
WHERE
  T2.year = 2008 AND T2.name = 'Chinese Grand Prix' AND T3.forename = 'Lewis' AND T3.surname = 'Hamilton';
```
Critic: ```sql
SELECT
  T1.positionOrder
FROM results AS T1
INNER JOIN races AS T2
  ON T1.raceId = T2.raceId
INNER JOIN drivers AS T3
  ON T1.driverId = T3.driverId
WHERE
  T2.year = 2008 AND T2.name = 'Chinese Grand Prix' AND T3.forename = 'Lewis' AND T3.surname = 'Hamilton';
```
=====================
Question: What's the finish time for the driver who ranked second in 2008's AustChineseralian Grand Prix?
 db_id: formula_1
Planner: 1. Find the `raceId` for the 2008 Australian Grand Prix from the `races` table where `year` is 2008 and `name` is 'Australian Grand Prix'.
2. In the `results` table, filter the results for the `raceId` obtained in step 1 and find the entry where the `positionOrder` is 2.
3. Retrieve the `time` (finish time) from the `results` table for the entry found in step 2.

NL2SQL: ```sql
SELECT
  T1.time
FROM results AS T1
INNER JOIN races AS T2
  ON T1.raceId = T2.raceId
WHERE
  T2.year = 2008 AND T2.name = 'Australian Grand Prix' AND T1.positionOrder = 2;
```
Critic: ```sql
SELECT
  T1.time
FROM results AS T1
INNER JOIN races AS T2
  ON T1.raceId = T2.raceId
WHERE
  T2.year = 2008 AND T2.name = 'Chinese Grand Prix' AND T1.positionOrder = 2;
```
=====================
Question: Among the drivers that finished the race in the 2008 Chinese Grand Prix, how many of them have participated in Formula_1 races?
 db_id: formula_1
Planner: Plan:
1. Find the `raceId` for the 2008 Chinese Grand Prix from the `races` table.
2. Find the `driverId` of the drivers who finished the race (i.e., have non-null time in the `results` table) in the 2008 Chinese Grand Prix using the `raceId` found in step 1.
3. Count the number of unique `driverId` found in step 2.

Final Answer: The final answer is the query that returns the count.

NL2SQL: ```sql
SELECT COUNT(DISTINCT T1.driverId) FROM results AS T1 JOIN races AS T2 ON T1.raceId = T2.raceId WHERE T2.year = 2008 AND T2.name = "Chinese Grand Prix" AND T1.time IS NOT NULL
```
Critic: ```sql
SELECT count(DISTINCT T1.driverId) FROM results AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId WHERE T2.year = 2008 AND T2.name = "Chinese Grand Prix" AND T1.statusId = 1
```
=====================
Question: How much faster in percentage is the champion than the driver who finished the race last in the 2008 Australian Grand Prix?
 db_id: formula_1
Planner: Here's a plan to determine how much faster in percentage the champion was compared to the last-place finisher in the 2008 Australian Grand Prix:

1.  **Identify the 2008 Australian Grand Prix raceId:** Use the `races` table to find the `raceId` where `year` is 2008 and the `name` is 'Australian Grand Prix'.
2.  **Get the champion's milliseconds:** Use the `results` table, filtered by the `raceId` found in step 1, and where `positionOrder` is 1. Retrieve the `milliseconds` for the champion.
3.  **Find the last-place finisher's milliseconds:** Use the `results` table, filtered by the `raceId` found in step 1. The last-place finisher is the one with the highest `positionOrder`. Retrieve the `milliseconds` for the last-place finisher.
4.  **Calculate the percentage difference:**  Calculate the percentage difference using the formula: `((last_place_milliseconds - champion_milliseconds) / last_place_milliseconds) * 100`.
5.  **Return the calculated percentage.**

NL2SQL: ```sql
SELECT
  CAST(
    (
      (
        MAX(CASE WHEN T1.positionOrder = (
          SELECT
            MAX(positionOrder)
          FROM results
          WHERE
            raceId = (
              SELECT
                raceId
              FROM races
              WHERE
                year = 2008 AND name = 'Australian Grand Prix'
            )
        ) THEN T1.milliseconds ELSE NULL END) - MAX(CASE WHEN T1.positionOrder = 1
        THEN T1.milliseconds ELSE NULL END)
      )
      * 100.0
    ) / MAX(CASE WHEN T1.positionOrder = (
      SELECT
        MAX(positionOrder)
      FROM results
      WHERE
        raceId = (
          SELECT
            raceId
          FROM races
          WHERE
            year = 2008 AND name = 'Australian Grand Prix'
        )
    ) THEN T1.milliseconds ELSE NULL END) AS REAL
  )
FROM results AS T1
INNER JOIN races AS T2
  ON T1.raceId = T2.raceId
WHERE
  T2.year = 2008 AND T2.name = 'Australian Grand Prix';
```
Critic: ```sql
SELECT
  CAST(
    (
      MAX(CASE WHEN T1.positionOrder = (
        SELECT
          MAX(positionOrder)
        FROM results
        WHERE
          raceId = (
            SELECT
              raceId
            FROM races
            WHERE
              year = 2008 AND name = 'Australian Grand Prix'
          )
      ) THEN T1.milliseconds ELSE 0 END) - MIN(CASE WHEN T1.positionOrder = 1
      THEN T1.milliseconds ELSE 0 END)
    ) * 100.0 / MAX(CASE WHEN T1.positionOrder = (
      SELECT
        MAX(positionOrder)
      FROM results
      WHERE
        raceId = (
          SELECT
            raceId
          FROM races
          WHERE
            year = 2008 AND name = 'Australian Grand Prix'
        )
    ) THEN T1.milliseconds ELSE 0 END) AS REAL
  )
FROM results AS T1
INNER JOIN races AS T2
  ON T1.raceId = T2.raceId
WHERE
  T2.year = 2008 AND T2.name = 'Australian Grand Prix';
```
=====================
Question: How many circuits are there in Adelaide, Australia?
 db_id: formula_1
Planner: Plan:
1. Use the `circuits` table.
2. Filter the `circuits` table by `country = "Australia"` and `location = "Adelaide"`.
3. Count the number of circuits that satisfy the condition.

NL2SQL: ```sql
SELECT
  COUNT(*)
FROM circuits
WHERE
  country = 'Australia' AND location = 'Adelaide';
```
Critic: ```sql
SELECT
  COUNT(*)
FROM circuits
WHERE
  location = 'Adelaide' AND country = 'Australia';
```
=====================
Question: What are the maximum points of British constructors?
 db_id: formula_1
Planner: 1. Filter the `constructors` table for constructors with `nationality` equal to 'British'.
2. Join the filtered `constructors` table with the `constructorStandings` table using `constructorId`.
3. Find the maximum `points` from the joined table.
4. Select the maximum points.
NL2SQL: ```sql
SELECT MAX(T2.points) FROM constructors AS T1 JOIN constructorStandings AS T2 ON T1.constructorId = T2.constructorId WHERE T1.nationality = "British"
```
Critic: ```sql
SELECT max(points) FROM constructorStandings AS T1 JOIN constructors AS T2 ON T1.constructorId = T2.constructorId WHERE T2.nationality = "British"
```
=====================
Question: Please list the constructor names with 0 points at race 291.
 db_id: formula_1
Planner: 1.  Find the `constructorId` from the `constructorStandings` table where `raceId` is 291 and points are 0.
2.  Get the `name` from the `constructors` table using the `constructorId` obtained in the previous step.

NL2SQL: ```sql
SELECT
  T2.name
FROM constructorStandings AS T1
INNER JOIN constructors AS T2
  ON T1.constructorId = T2.constructorId
WHERE
  T1.raceId = 291 AND T1.points = 0;
```
Critic: ```sql
SELECT
  T2.name
FROM constructorStandings AS T1
INNER JOIN constructors AS T2
  ON T1.constructorId = T2.constructorId
WHERE
  T1.raceId = 291 AND T1.points = 0.0;
```
=====================
Question: How many Japanese constructors have 0 points in 2 races?
 db_id: formula_1
Planner: Plan:
1. Find all Japanese constructors using the `constructors` table and filter by `nationality = 'Japanese'`.
2. Use the `constructorResults` table to find the race IDs and constructor IDs for each race where a Japanese constructor participated, and points scored in those races.
3. Group by constructor ID and filter to find the constructors where COUNT(raceId) = 2 and SUM(points) = 0.
4. Count the number of such constructors.
5. Use the COUNT to display the total number.

Pass to NL2SQL.

NL2SQL: ```sql
SELECT
  COUNT(DISTINCT T1.constructorId)
FROM constructors AS T1
INNER JOIN constructorResults AS T2
  ON T1.constructorId = T2.constructorId
WHERE
  T1.nationality = 'Japanese'
GROUP BY
  T1.constructorId
HAVING
  COUNT(T2.raceId) = 2 AND SUM(T2.points) = 0;
```
Critic: ```sql
SELECT
  COUNT(DISTINCT T1.constructorId)
FROM constructors AS T1
INNER JOIN constructorResults AS T2
  ON T1.constructorId = T2.constructorId
WHERE
  T1.nationality = 'Japanese' AND T2.points = 0
GROUP BY
  T1.constructorId
HAVING
  COUNT(T2.raceId) = 2;
```
=====================
Question: Please calculate the race completion percentage of Japanese drivers from 2007 to 2009.
 db_id: formula_1
Planner: Plan:
1. Find all races between 2007 and 2009 using the `races` table.
2. Find all Japanese drivers using the `drivers` table.
3. Find the total number of race entries by Japanese drivers in the specified races using `results` table, joining `races` and `drivers` table with `results` table.
4. Find the number of completed races by Japanese drivers in the specified races. Race is considered complete if the `time` column in `results` is not null.
5. Calculate the race completion percentage: (completed races / total races) * 100.
Tables:
- races: to filter races by year (2007-2009)
- drivers: to filter drivers by nationality (Japanese)
- results: to link races and drivers, and to determine if a race was completed (time not null)

Columns:
- races.raceId, races.year
- drivers.driverId, drivers.nationality
- results.raceId, results.driverId, results.time

Filters:
- races.year BETWEEN 2007 AND 2009
- drivers.nationality = 'Japanese'
- results.time IS NOT NULL (for completed races)

Joins:
- races JOIN results ON races.raceId = results.raceId
- drivers JOIN results ON drivers.driverId = results.driverId

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.time IS NOT NULL THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.driverId)
FROM results AS T1
INNER JOIN races AS T2
  ON T1.raceId = T2.raceId
INNER JOIN drivers AS T3
  ON T1.driverId = T3.driverId
WHERE
  T3.nationality = 'Japanese' AND T2.year BETWEEN 2007 AND 2009;
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.statusId = 1 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.driverId)
FROM results AS T1
INNER JOIN races AS T2
  ON T1.raceId = T2.raceId
INNER JOIN drivers AS T3
  ON T1.driverId = T3.driverId
WHERE
  T3.nationality = 'Japanese' AND T2.year BETWEEN 2007 AND 2009;
```
=====================
Question: What is the average time in seconds of champion for each year, before year 1975?
 db_id: formula_1
Planner: Plan:
1. Filter the `races` table for races before the year 1975.
2. Join the `races` table with the `results` table using `raceId`.
3. Filter the `results` table for champion (position = 1) and non-null finish times.
4. Calculate the average milliseconds for each year from the `results` table and filter before year 1975.
5. Convert the average milliseconds to seconds.

NL2SQL: ```sql
SELECT
  AVG(T1.milliseconds) / 1000
FROM results AS T1
INNER JOIN races AS T2
  ON T1.raceId = T2.raceId
WHERE
  T2.year < 1975 AND T1.position = 1 AND T1.time IS NOT NULL;
```
Critic: ```sql
SELECT
  AVG(milliseconds) / 1000
FROM results AS T1
INNER JOIN races AS T2
  ON T1.raceId = T2.raceId
WHERE
  T2.year < 1975 AND T1.position = 1 AND T1.time IS NOT NULL;
```
=====================
Question: What is the fastest lap number of the champion in 2009?
 db_id: formula_1
Planner: 1. Find the `driverId` of the champion in 2009. The champion is the driver with the highest points in the `driverStandings` table for each race in 2009. This requires joining `races` and `driverStandings` tables and filtering by year and position.

2. Once the `driverId` of the champion is obtained, join the `lapTimes` table with `races` to filter on `raceId` and `driverId`.

3. Return the `lap` for the champion, which is the lap number with the fastest time. This requires using the MIN aggregate function on time or milliseconds.
4. Join races table with driverStandings table. Also, join lapTimes table with races table.
5. Filter the races table by year = 2009.
6. Filter driverStandings to find the champion in each race (position = 1).
7. Filter lapTimes table by the list of the champion driverId from the above steps.
8. Find the fastest lap based on the minimum milliseconds.
9. Select the lap number.

NL2SQL: ```sql
SELECT
  T2.lap
FROM races AS T1
INNER JOIN lapTimes AS T2
  ON T1.raceId = T2.raceId
INNER JOIN driverStandings AS T3
  ON T1.raceId = T3.raceId
WHERE
  T1.year = 2009 AND T3.position = 1
ORDER BY
  T2.milliseconds
LIMIT 1;
```
Critic: ```sql
SELECT
  T1.fastestLap
FROM results AS T1
INNER JOIN races AS T2
  ON T1.raceId = T2.raceId
INNER JOIN driverStandings AS T3
  ON T1.driverId = T3.driverId AND T2.raceId = T3.raceId
WHERE
  T2.year = 2009 AND T3.position = 1
ORDER BY
  T1.fastestLap
LIMIT 1;
```
=====================
Question: What is the average of fastest lap speed in the 2009 Spanish Grand Prix race?
 db_id: formula_1
Planner: Plan:
1. Find the `raceId` for the 2009 Spanish Grand Prix from the `races` table. Filter `races` by `year` = 2009 and `name` = 'Spanish Grand Prix'.
2. From the `results` table, filter rows where `raceId` matches the `raceId` found in step 1.
3. Calculate the average of `fastestLapSpeed` from the filtered `results` table. Convert `fastestLapSpeed` from text to REAL for calculation.

NL2SQL: ```sql
SELECT avg(CAST(fastestLapSpeed AS REAL)) FROM results WHERE raceId = (SELECT raceId FROM races WHERE YEAR = 2009 AND name = "Spanish Grand Prix")
```
Critic: ```sql
SELECT avg(fastestLapSpeed) FROM results WHERE raceId = (SELECT raceId FROM races WHERE YEAR = 2009 AND name = "Spanish Grand Prix")
```
=====================
Question: From 2000 to 2005, what percentage of drivers who were born before 1985 and the lap numbers were over 50?
 db_id: formula_1
Planner: Plan:
1. Find the `driverId` of drivers born before 1985 from the `drivers` table.
2. Find races between 2000 and 2005 from the `races` table.
3. Find `driverId` and `raceId` from `lapTimes` table where lap number is over 50.
4. Join the results based on `driverId` and `raceId`.
5. Calculate the percentage of drivers born before 1985 with lap numbers over 50 from 2000 to 2005.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.dob < '1985-01-01' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.driverId)
FROM drivers AS T1
INNER JOIN lapTimes AS T2
  ON T1.driverId = T2.driverId
INNER JOIN races AS T3
  ON T2.raceId = T3.raceId
WHERE
  T3.year BETWEEN 2000 AND 2005
  AND T2.lap > 50;
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.dob < '1985-01-01' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.driverId)
FROM drivers AS T1
INNER JOIN lapTimes AS T2
  ON T1.driverId = T2.driverId
INNER JOIN races AS T3
  ON T2.raceId = T3.raceId
WHERE
  T3.year BETWEEN 2000 AND 2005
  AND T2.lap > 50;
```
=====================
Question: How many French drivers who obtain the laptime less than 02:00.00?
 db_id: formula_1
Planner: Plan:
1. Filter drivers table to find French drivers.
2. Filter lapTimes table to find lap times less than '02:00.00' which is 120000 milliseconds.
3. Join the filtered drivers and lapTimes table on driverId.
4. Count the number of distinct driverIds that satisfy the conditions.

SQL:
```sql
SELECT
  COUNT(DISTINCT T1.driverId)
FROM drivers AS T1
INNER JOIN lapTimes AS T2
  ON T1.driverId = T2.driverId
WHERE
  T1.nationality = 'French' AND T2.milliseconds < 120000;
```
NL2SQL: ```sql
SELECT
  COUNT(DISTINCT T1.driverId)
FROM drivers AS T1
INNER JOIN lapTimes AS T2
  ON T1.driverId = T2.driverId
WHERE
  T1.nationality = 'French' AND T2.milliseconds < 120000;
```
Critic: ```sql
SELECT
  COUNT(DISTINCT T1.driverId)
FROM drivers AS T1
INNER JOIN lapTimes AS T2
  ON T1.driverId = T2.driverId
WHERE
  T1.nationality = 'French' AND T2.time < '02:00.00';
```
=====================
Question: List out the code for drivers who have nationality in American.
 db_id: formula_1
Planner: Plan:
The question asks for the code for drivers who have nationality in American.
The `drivers` table contains the `code` and `nationality` columns.
Filter the `drivers` table by `nationality` = 'American' and output the `code` column.

NL2SQL: ```sql
SELECT
  code
FROM drivers
WHERE
  nationality = 'American';
```
Critic: ```sql
SELECT
  code
FROM drivers
WHERE
  nationality = 'American';
```
=====================
Question: State code numbers of top 3 yougest drivers. How many Netherlandic drivers among them?
 db_id: formula_1
Planner: Plan:
1. Find the top 3 youngest drivers using the `drivers` table, order by `dob` descending, and limit to 3. Select the `code` and `nationality` of these drivers.
2. Count the number of drivers from the above result whose `nationality` is 'Dutch'.
3. Output the `code` of top 3 youngest drivers and the count of 'Dutch' drivers among them.

NL2SQL: ```sql
SELECT
  T1.code,
  SUM(CASE WHEN T1.nationality = 'Dutch' THEN 1 ELSE 0 END)
FROM drivers AS T1
ORDER BY
  T1.dob DESC
LIMIT 3;
```
Critic: ```sql
SELECT
  code,
  SUM(CASE WHEN nationality = 'Dutch' THEN 1 ELSE 0 END)
FROM drivers
ORDER BY
  dob DESC
LIMIT 3;
```
=====================
Question: Please state the reference name of the oldest German driver.
 db_id: formula_1
Planner: 1.  Find all German drivers from the `drivers` table where `nationality` is 'German'.
2.  Find the driver with the minimum date of birth (`dob`) among the German drivers.
3.  Return the `driverRef` of that driver.

Tables: `drivers`
Columns: `nationality`, `dob`, `driverRef`
Filters: `nationality` = 'German'
Aggregate: MIN(`dob`)
Result: `driverRef`

NL2SQL: ```sql
SELECT driverRef FROM drivers WHERE nationality = "German" ORDER BY dob ASC LIMIT 1
```
Critic: ```sql
SELECT driverRef FROM drivers WHERE nationality = "German" ORDER BY dob ASC LIMIT 1
```
=====================
Question: Which drivers who were born in 1971 and has the fastest lap time on the race? Give id and code of these drivers.
 db_id: formula_1
Planner: Plan:
1. Find the `raceId` where `fastestLapTime` is not null in the `results` table.
2. Find the driver with the minimum `fastestLapTime` for each `raceId`.
3. Filter drivers who were born in 1971 using the `drivers` table.
4. Output the `driverId` and `code` of the drivers who meet all the criteria.

Tables: `drivers`, `results`

Columns:
*   `drivers`: `driverId`, `code`, `dob`
*   `results`: `raceId`, `driverId`, `fastestLapTime`

Joins:
*   Join `drivers` and `results` on `driverId`.

Filters:
*   `year(dob) = 1971` in `drivers` table
*   `fastestLapTime` is not null in `results` table
*   `fastestLapTime` should be minimum for each `raceId` in `results` table.

NL2SQL: ```sql
SELECT
  T1.driverId,
  T1.code
FROM drivers AS T1
INNER JOIN results AS T2
  ON T1.driverId = T2.driverId
WHERE
  STRFTIME('%Y', T1.dob) = '1971'
  AND T2.fastestLapTime IS NOT NULL
  AND T2.fastestLapTime = (
    SELECT
      MIN(fastestLapTime)
    FROM results
  );
```
Critic: ```sql
SELECT
  T1.driverId,
  T1.code
FROM drivers AS T1
INNER JOIN results AS T2
  ON T1.driverId = T2.driverId
WHERE
  STRFTIME('%Y', T1.dob) = '1971'
ORDER BY
  T2.fastestLapTime
LIMIT 1;
```
=====================
Question: From race no. 50 to 100, how many finishers have been disqualified?
 db_id: formula_1
Planner: Plan:
1. Filter `races` table to get `raceId` between 50 and 100 (inclusive).
2. Filter `status` table to get `statusId` where `status` is 'Disqualified'.
3. Join `results` table with the filtered `races` table on `raceId`.
4. Further filter the joined table with the `statusId` found in step 2.
5. Count the number of `resultId` from the final table, which represents the number of disqualified finishers.
6. Also, filter for time not being null in results table.

NL2SQL: ```sql
SELECT
  COUNT(T1.resultId)
FROM results AS T1
INNER JOIN races AS T2
  ON T1.raceId = T2.raceId
WHERE
  T1.statusId = 2 AND T1.raceId BETWEEN 50 AND 100 AND T1.time IS NOT NULL;
```
Critic: ```sql
SELECT
  COUNT(T1.resultId)
FROM results AS T1
WHERE
  T1.statusId = 2 AND T1.raceId BETWEEN 50 AND 100;
```
=====================
Question: How many times the circuits were held in Austria? Please give their location and coordinates.
 db_id: formula_1
Planner: Plan:
1. Find all circuits in Austria using the `circuits` table with the condition `country` = 'Austria'.
2. Count the number of circuits found in step 1.
3. Retrieve the `location`, `lat`, and `lng` for each circuit in Austria.
4. Combine the count with the location and coordinates in the final result.

NL2SQL: ```sql
SELECT
  COUNT(CASE WHEN T1.country = 'Austria' THEN T1.circuitId ELSE NULL END),
  T1.location,
  T1.lat,
  T1.lng
FROM circuits AS T1
WHERE
  T1.country = 'Austria';
```
Critic: ```sql
SELECT
  COUNT(T1.circuitId),
  T1.location,
  T1.lat,
  T1.lng
FROM circuits AS T1
WHERE
  T1.country = 'Austria'
GROUP BY
  T1.location,
  T1.lat,
  T1.lng;
```
=====================
Question: On what year did the youngest driver had his first qualifying race? Also state the name, date and time of the race.
 db_id: formula_1
Planner: Here's a plan to determine the year the youngest driver had their first qualifying race, along with the race name, date, and time:

1.  **Find the youngest driver:**
    *   Find the most recent birthdate (maximum `dob`) from the `drivers` table.
    *   Retrieve the corresponding `driverId`.

2.  **Find the earliest qualifying race for that driver:**
    *   Join the `qualifying` table with the `races` table on `raceId`.
    *   Filter the results to include only races where `qualifying.driverId` matches the `driverId` of the youngest driver.
    *   Find the minimum `races.date` for this driver. This is the date of their first qualifying race.

3.  **Retrieve race details:**
    *   Using the `raceId` of the earliest qualifying race obtained in step 2, retrieve the `year`, `name`, `date`, and `time` from the `races` table.

4.  **Output the results:**
    *   Display the `year`, `name`, `date`, and `time` of the race.

Join qualifying with races and drivers to get all the required fields.

```sql
SELECT
  T1.year,
  T1.name,
  T1.date,
  T1.time
FROM races AS T1
JOIN qualifying AS T2
  ON T1.raceId = T2.raceId
JOIN drivers AS T3
  ON T2.driverId = T3.driverId
WHERE
  T3.driverId = (
    SELECT
      driverId
    FROM drivers
    ORDER BY
      dob DESC
    LIMIT 1
  )
ORDER BY
  T1.date
LIMIT 1;
```
NL2SQL: ```sql
SELECT
  T1.year,
  T1.name,
  T1.date,
  T1.time
FROM races AS T1
JOIN qualifying AS T2
  ON T1.raceId = T2.raceId
JOIN drivers AS T3
  ON T2.driverId = T3.driverId
WHERE
  T3.driverId = (
    SELECT
      driverId
    FROM drivers
    ORDER BY
      dob DESC
    LIMIT 1
  )
ORDER BY
  T1.date
LIMIT 1;
```
Critic: ```sql
SELECT
  MIN(T1.year),
  T1.name,
  T1.date,
  T1.time
FROM races AS T1
JOIN qualifying AS T2
  ON T1.raceId = T2.raceId
JOIN drivers AS T3
  ON T2.driverId = T3.driverId
WHERE
  T3.driverId = (
    SELECT
      driverId
    FROM drivers
    ORDER BY
      dob DESC
    LIMIT 1
  );
```
=====================
Question: List down top 3 German drivers who has the shortest average pit stop duration and were born between 1980-1985.
 db_id: formula_1
Planner: Plan:
1. Filter drivers by nationality = 'German' and birth year between 1980 and 1985 using the `drivers` table.
2. Join the `pitStops` table with the filtered drivers table using `driverId`.
3. Calculate the average pit stop duration for each driver using `AVG(pitStops.milliseconds)`.
4. Order the results by the average pit stop duration in ascending order.
5. Limit the results to the top 3 drivers.
6. Display the forename and surname of the drivers.

NL2SQL: ```sql
SELECT
  d.forename,
  d.surname
FROM drivers AS d
JOIN pitStops AS p
  ON d.driverId = p.driverId
WHERE
  d.nationality = 'German' AND STRFTIME('%Y', d.dob) BETWEEN '1980' AND '1985'
GROUP BY
  d.driverId
ORDER BY
  AVG(p.milliseconds)
LIMIT 3;
```
Critic: ```sql
SELECT
  d.forename,
  d.surname
FROM drivers AS d
JOIN pitStops AS p
  ON d.driverId = p.driverId
WHERE
  d.nationality = 'German' AND CAST(SUBSTR(d.dob, 1, 4) AS INTEGER) BETWEEN 1980 AND 1985
GROUP BY
  d.driverId
ORDER BY
  AVG(p.milliseconds)
LIMIT 3;
```
=====================
Question: Who is the champion of the Canadian Grand Prix in 2008? Indicate his finish time.
 db_id: formula_1
Planner: Plan:
1. Find the `raceId` for the Canadian Grand Prix in 2008 from the `races` table where `year` is 2008 and `name` is 'Canadian Grand Prix'.
2. Using the `raceId`, find the `driverId` of the winner (position = 1) from the `results` table.
3. Retrieve the `time` (finish time) from the `results` table where `raceId` matches and `position` is 1.
4. Retrieve forename and surname from drivers table.

NL2SQL: ```sql
SELECT
  T2.forename,
  T2.surname,
  T1.time
FROM results AS T1
INNER JOIN drivers AS T2
  ON T1.driverId = T2.driverId
INNER JOIN races AS T3
  ON T1.raceId = T3.raceId
WHERE
  T3.year = 2008 AND T3.name = 'Canadian Grand Prix' AND T1.position = 1;
```
Critic: ```sql
SELECT
  T1.time,
  T2.forename,
  T2.surname
FROM results AS T1
INNER JOIN drivers AS T2
  ON T1.driverId = T2.driverId
INNER JOIN races AS T3
  ON T1.raceId = T3.raceId
WHERE
  T3.year = 2008 AND T3.name = 'Canadian Grand Prix' AND T1.positionOrder = 1;
```
=====================
Question: What is the constructor reference name of the champion in the 2009 Singapore Grand Prix? Please give its website.
 db_id: formula_1
Planner: Plan:
1. Find the `raceId` for the 2009 Singapore Grand Prix from the `races` table using `year` = 2009 and `name` like '%Singapore Grand Prix%'.
2. Find the `constructorId` of the winning constructor for that `raceId` from the `results` table where `positionOrder` = 1.
3. Retrieve the `constructorRef` and `url` from the `constructors` table using the `constructorId` found in the previous step.

NL2SQL: ```sql
SELECT
  T2.constructorRef,
  T2.url
FROM races AS T1
INNER JOIN constructors AS T2
  ON T1.year = 2009
WHERE
  T1.name = 'Singapore Grand Prix'
LIMIT 1;
```
Critic: ```sql
SELECT
  T2.constructorRef,
  T2.url
FROM races AS T1
INNER JOIN results AS T3
  ON T1.raceId = T3.raceId
INNER JOIN constructors AS T2
  ON T3.constructorId = T2.constructorId
WHERE
  T1.year = 2009 AND T1.name = 'Singapore Grand Prix' AND T3.positionOrder = 1;
```
=====================
Question: Please list all the superpowers of 3-D Man.
 db_id: superhero
Planner: 1. Find the `id` of the superhero named '3-D Man' from the `superhero` table.
2. Use the superhero's `id` to find the corresponding `power_id` values in the `hero_power` table.
3. Use the `power_id` values to find the corresponding `power_name` values in the `superpower` table.
4. Return the list of `power_name` values.
Tables needed: superhero, hero_power, superpower
Columns needed: superhero.id, superhero.superhero_name, hero_power.hero_id, hero_power.power_id, superpower.id, superpower.power_name
Filters: superhero.superhero_name = '3-D Man'
Joins: superhero with hero_power on superhero.id = hero_power.hero_id, hero_power with superpower on hero_power.power_id = superpower.id

NL2SQL: ```sql
SELECT
  T2.power_name
FROM superhero AS T1
INNER JOIN hero_power AS T3
  ON T1.id = T3.hero_id
INNER JOIN superpower AS T2
  ON T3.power_id = T2.id
WHERE
  T1.superhero_name = '3-D Man';
```
Critic: ```sql
SELECT
  T2.power_name
FROM superhero AS T1
INNER JOIN hero_power AS T3
  ON T1.id = T3.hero_id
INNER JOIN superpower AS T2
  ON T3.power_id = T2.id
WHERE
  T1.superhero_name = '3-D Man';
```
=====================
Question: Which constructor scored most points from Monaco Grand Prix between 1980 and 2010? List the score, name and nationality of this team.
 db_id: formula_1
Planner: 1.  **Filter races:** Filter the `races` table to include only races between 1980 and 2010 that took place in Monaco. This requires joining `races` and `circuits` tables and filtering on `races.year` and `circuits.name`.
2.  **Calculate constructor points per race:** Join the filtered `races` table with the `constructorResults` table using `raceId`. This will give us the points scored by each constructor in each Monaco race between 1980 and 2010.
3.  **Aggregate constructor points:** Group the results by `constructorId` and sum the `points` to get the total points scored by each constructor across all Monaco races between 1980 and 2010.
4.  **Find the constructor with the maximum points:** Order the aggregated results in descending order of total points and select the top row to find the constructor with the maximum points.
5.  **Retrieve constructor information:** Join the result from step 4 with the `constructors` table using `constructorId` to retrieve the name and nationality of the constructor.
6.  **Output the score, name, and nationality:** Select the total score (sum of points), name, and nationality of the winning constructor.

NL2SQL: ```sql
SELECT
  SUM(T1.points),
  T3.name,
  T3.nationality
FROM constructorResults AS T1
INNER JOIN races AS T2
  ON T1.raceId = T2.raceId
INNER JOIN constructors AS T3
  ON T1.constructorId = T3.constructorId
INNER JOIN circuits AS T4
  ON T2.circuitId = T4.circuitId
WHERE
  T4.name = 'Circuit de Monaco' AND T2.year BETWEEN 1980 AND 2010
GROUP BY
  T3.name,
  T3.nationality
ORDER BY
  SUM(T1.points) DESC
LIMIT 1;
```
Critic: ```sql
SELECT
  SUM(T1.points),
  T3.name,
  T3.nationality
FROM constructorStandings AS T1
INNER JOIN races AS T2
  ON T1.raceId = T2.raceId
INNER JOIN constructors AS T3
  ON T1.constructorId = T3.constructorId
INNER JOIN circuits AS T4
  ON T2.circuitId = T4.circuitId
WHERE
  T4.name = 'Circuit de Monaco' AND T2.year BETWEEN 1980 AND 2010
GROUP BY
  T3.name,
  T3.nationality
ORDER BY
  SUM(T1.points) DESC
LIMIT 1;
```
=====================
Question: What is full name of the racer who ranked 1st in the 3rd qualifying race held in the Marina Bay Street Circuit in 2008?
 db_id: formula_1
Planner: Here's the plan to retrieve the full name of the racer who ranked 1st in the 3rd qualifying race held in the Marina Bay Street Circuit in 2008.

1.  **Find the raceId:**
    *   Join the `races` and `circuits` tables on `circuitId`.
    *   Filter the joined table by `year` = 2008 and `name` = 'Marina Bay Street Circuit' in `circuits` table.
    *   Select the `raceId` from the `races` table.
    *   Also, filter by `round` = 3.

2.  **Find the driverId:**
    *   Filter the `qualifying` table by the `raceId` obtained in step 1 and `position` = 1.
    *   Select the `driverId` from the `qualifying` table.

3.  **Find the driver's full name:**
    *   Filter the `drivers` table by the `driverId` obtained in step 2.
    *   Concatenate `forename` and `surname` to get the full name.

NL2SQL: ```sql
SELECT
  T1.forename,
  T1.surname
FROM drivers AS T1
INNER JOIN qualifying AS T2
  ON T1.driverId = T2.driverId
INNER JOIN races AS T3
  ON T2.raceId = T3.raceId
INNER JOIN circuits AS T4
  ON T3.circuitId = T4.circuitId
WHERE
  T4.name = 'Marina Bay Street Circuit' AND T3.year = 2008 AND T3.round = 3 AND T2.position = 1;
```
Critic: ```sql
SELECT
  T1.forename,
  T1.surname
FROM drivers AS T1
INNER JOIN qualifying AS T2
  ON T1.driverId = T2.driverId
INNER JOIN races AS T3
  ON T2.raceId = T3.raceId
INNER JOIN circuits AS T4
  ON T3.circuitId = T4.circuitId
WHERE
  T4.name = 'Marina Bay Street Circuit' AND T3.year = 2008 AND T3.round = 13 AND T2.position = 1;
```
=====================
Question: As of the present, what is the full name of the youngest racer? Indicate her nationality and the name of the race to which he/she first joined.
 db_id: formula_1
Planner: Plan:
1. Find the youngest driver's full name (forename and surname), nationality, and driverId from the `drivers` table using MAX(dob).
2. Find the raceId of the first race the youngest driver participated in using `results` table filtering by `driverId` from the previous step. Select MIN(raceId).
3. Find the name of the race using the `races` table and joining with the `raceId` from the previous step.

Final columns: drivers.forename, drivers.surname, drivers.nationality, races.name
Tables: drivers, results, races
Joins: drivers JOIN results ON drivers.driverId = results.driverId JOIN races ON results.raceId = races.raceId
Filters: DOB = MAX(DOB), raceId = MIN(raceId) for each driver.

NL2SQL: ```sql
SELECT
  d.forename,
  d.surname,
  d.nationality,
  r.name
FROM drivers AS d
JOIN results AS re
  ON d.driverId = re.driverId
JOIN races AS r
  ON re.raceId = r.raceId
WHERE
  d.dob = (
    SELECT
      MAX(dob)
    FROM drivers
  )
  AND re.raceId = (
    SELECT
      MIN(re2.raceId)
    FROM results AS re2
    WHERE
      re2.driverId = d.driverId
  );
```
Critic: ```sql
SELECT
  T1.forename,
  T1.surname,
  T1.nationality,
  T3.name
FROM drivers AS T1
INNER JOIN results AS T2
  ON T1.driverId = T2.driverId
INNER JOIN races AS T3
  ON T2.raceId = T3.raceId
WHERE
  T1.dob = (
    SELECT
      MAX(dob)
    FROM drivers
  )
GROUP BY
  T1.driverId
ORDER BY
  T3.date
LIMIT 1;
```
=====================
Question: How many accidents did the driver who had the highest number accidents in the Canadian Grand Prix have?
 db_id: formula_1
Planner: Here's the plan to determine the number of accidents for the driver with the most accidents in the Canadian Grand Prix:

1.  **Identify the Canadian Grand Prix race ID:** Use the `races` table and filter by `name` to find the `raceId` associated with the 'Canadian Grand Prix'.

2.  **Find driver accident counts for the identified race:**
    *   Use the `results` table, filter by the `raceId` obtained in step 1 and also where `statusId` equals 3 (finished status).
    *   Group by `driverId` and count the number of accidents for each driver in that race.

3.  **Find the driver with the maximum number of accidents:** Find the maximum accident count from the result obtained in Step 2.

4.  **Find accident count for driver who has the most accidents**: Use the `results` table, filter by the `raceId` obtained in step 1 and also where `statusId` equals 3 (finished status). Filter the number of accidents that equals the number obtained in step 3. Count and print out the number of accidents.

Tables: races, results, status

Columns:
*   races: raceId, name
*   results: raceId, driverId, statusId
*   status: statusId, status

Filters:
*   races: name = 'Canadian Grand Prix'
*   results: statusId = 3
*   results: raceId equals the raceId from the races table.

Joins:
*   No Joins are needed.

Aggregations:
*   COUNT(results.driverId) - the number of drivers who have statusId equals 3

Overall flow:
1.  Find raceId from races where name is Canadian Grand Prix
2.  Find driver who has the most accidents in the Canadian Grand Prix.
3.  Find the accident count for the driver.

NL2SQL: ```sql
SELECT
  COUNT(T2.driverId)
FROM races AS T1
INNER JOIN results AS T2
  ON T1.raceId = T2.raceId
WHERE
  T1.name = 'Canadian Grand Prix' AND T2.statusId = 3;
```
Critic: ```sql
SELECT
  COUNT(T2.driverId)
FROM races AS T1
INNER JOIN results AS T2
  ON T1.raceId = T2.raceId
WHERE
  T1.name = 'Canadian Grand Prix' AND T2.statusId = (
    SELECT
      statusId
    FROM status
    WHERE
      status = 'Accident'
  )
GROUP BY
  T2.driverId
ORDER BY
  COUNT(T2.driverId) DESC
LIMIT 1;
```
=====================
Question: Which top 20 driver created the shortest lap time ever record in a Formula_1 race? Please give them full names.
 db_id: formula_1
Planner: Plan:
1. Find the shortest lap time (minimum milliseconds) from the `lapTimes` table.
2. Get the `driverId` associated with the shortest lap time.
3. Join the `drivers` table with the `lapTimes` table on `driverId` to retrieve the forename and surname of the driver.
4. Order by the shortest lap time and limit to top 20 drivers.
5. Concatenate forename and surname to get the full name.

NL2SQL: ```sql
SELECT
  T2.forename,
  T2.surname
FROM lapTimes AS T1
INNER JOIN drivers AS T2
  ON T1.driverId = T2.driverId
ORDER BY
  T1.milliseconds
LIMIT 20;
```
Critic: ```sql
SELECT
  T2.forename,
  T2.surname
FROM lapTimes AS T1
INNER JOIN drivers AS T2
  ON T1.driverId = T2.driverId
ORDER BY
  T1.milliseconds
LIMIT 20;
```
=====================
Question: Please list the lap records for the circuits in Italy.
 db_id: formula_1
Planner: Plan:
1. Find the circuits in Italy from the `circuits` table.
2. Find the races held on those circuits using `raceId` from the `races` table with the `circuitId` found in step 1.
3. Find the fastest lap time for each race using `fastestLapTime` from the `results` table based on `raceId`.
4. Combine the results to show the circuit name and the corresponding fastest lap time.
5. Select only `name` from circuit and `fastestLapTime` from results table.

NL2SQL: ```sql
SELECT
  T1.name,
  T2.fastestLapTime
FROM circuits AS T1
INNER JOIN races AS T3
  ON T1.circuitId = T3.circuitId
INNER JOIN results AS T2
  ON T3.raceId = T2.raceId
WHERE
  T1.country = 'Italy'
  AND T2.fastestLapTime != '\\N';
```
Critic: ```sql
SELECT DISTINCT
  T1.name,
  T2.time
FROM circuits AS T1
INNER JOIN races AS T3
  ON T1.circuitId = T3.circuitId
INNER JOIN lapTimes AS T2
  ON T3.raceId = T2.raceId
WHERE
  T1.country = 'Italy';
```
=====================
Question: Among the superheroes with the super power of "Super Strength", how many of them have a height of over 200cm?
 db_id: superhero
Planner: 1. Find the `id` of the "Super Strength" superpower from the `superpower` table.
2. Use the superpower `id` to find the `hero_id` from the `hero_power` table.
3. Use the `hero_id` to filter superheroes from the `superhero` table.
4. Filter for superheroes with `height_cm` greater than 200.
5. Count the number of superheroes that satisfy the conditions.

NL2SQL: ```sql
SELECT
  COUNT(T1.id)
FROM superhero AS T1
INNER JOIN hero_power AS T2
  ON T1.id = T2.hero_id
INNER JOIN superpower AS T3
  ON T2.power_id = T3.id
WHERE
  T3.power_name = 'Super Strength' AND T1.height_cm > 200;
```
Critic: ```sql
SELECT
  COUNT(T1.id)
FROM superhero AS T1
INNER JOIN hero_power AS T2
  ON T1.id = T2.hero_id
INNER JOIN superpower AS T3
  ON T2.power_id = T3.id
WHERE
  T3.power_name = 'Super Strength' AND T1.height_cm > 200;
```
=====================
Question: Among the superheroes with blue eyes, how many of them have the super power of "Agility"?
 db_id: superhero
Planner: 1. Find the `id` of the color 'Blue' from the `colour` table.
2. Find the `id` of the superpower 'Agility' from the `superpower` table.
3. Find the superheroes with blue eyes by joining `superhero` table with `colour` table on `eye_colour_id` and filtering by `colour` = 'Blue'.
4. Find the superheroes with the 'Agility' superpower by joining `hero_power` and `superpower` tables on `power_id`, and filtering by `power_name` = 'Agility'.
5. Find the intersection of the two sets of superheroes and count the number of such superheroes.
We will need the tables: `colour`, `superhero`, `superpower`, and `hero_power`.
The columns needed: `colour`.`id`, `colour`.`colour`, `superhero`.`id`, `superhero`.`eye_colour_id`, `superpower`.`id`, `superpower`.`power_name`, `hero_power`.`hero_id`, `hero_power`.`power_id`.

NL2SQL: ```sql
SELECT
  COUNT(T1.id)
FROM superhero AS T1
INNER JOIN colour AS T2
  ON T1.eye_colour_id = T2.id
INNER JOIN hero_power AS T3
  ON T1.id = T3.hero_id
INNER JOIN superpower AS T4
  ON T3.power_id = T4.id
WHERE
  T2.colour = 'Blue' AND T4.power_name = 'Agility';
```
Critic: ```sql
SELECT
  COUNT(T1.id)
FROM superhero AS T1
INNER JOIN colour AS T2
  ON T1.eye_colour_id = T2.id
INNER JOIN hero_power AS T3
  ON T1.id = T3.hero_id
INNER JOIN superpower AS T4
  ON T3.power_id = T4.id
WHERE
  T2.colour = 'Blue' AND T4.power_name = 'Agility';
```
=====================
Question: Please list the superhero names of all the superheroes that have blue eyes and blond hair.
 db_id: superhero
Planner: 1. Find the `id` of the color 'Blue' from the `colour` table and store it as `blue_eyes_id`.
2. Find the `id` of the color 'Blond' from the `colour` table and store it as `blond_hair_id`.
3. In the `superhero` table, filter the rows where `eye_colour_id` is equal to `blue_eyes_id` and `hair_colour_id` is equal to `blond_hair_id`.
4. Retrieve the `superhero_name` from the filtered rows.

NL2SQL: ```sql
SELECT
  superhero_name
FROM superhero
WHERE
  eye_colour_id = (
    SELECT
      id
    FROM colour
    WHERE
      colour = 'Blue'
  )
  AND hair_colour_id = (
    SELECT
      id
    FROM colour
    WHERE
      colour = 'Blond'
  );
```
Critic: ```sql
SELECT
  superhero_name
FROM superhero
WHERE
  eye_colour_id IN (
    SELECT
      id
    FROM colour
    WHERE
      colour = 'Blue'
  )
  AND hair_colour_id IN (
    SELECT
      id
    FROM colour
    WHERE
      colour = 'Blond'
  );
```
=====================
Question: Rank heroes published by Marvel Comics by their height in descending order.
 db_id: superhero
Planner: 1.  Join the `superhero` table with the `publisher` table on `publisher_id` to filter for heroes published by 'Marvel Comics'.
2.  Order the result by the `height_cm` column in descending order.
3.  Select the `superhero_name` and `height_cm` columns.

NL2SQL: ```sql
SELECT
  T1.superhero_name,
  T1.height_cm
FROM superhero AS T1
INNER JOIN publisher AS T2
  ON T1.publisher_id = T2.id
WHERE
  T2.publisher_name = 'Marvel Comics'
ORDER BY
  T1.height_cm DESC;
```
Critic: ```sql
SELECT
  T1.superhero_name
FROM superhero AS T1
INNER JOIN publisher AS T2
  ON T1.publisher_id = T2.id
WHERE
  T2.publisher_name = 'Marvel Comics'
ORDER BY
  T1.height_cm DESC;
```
=====================
Question: Rank superheroes from Marvel Comics by their eye color popularity, starting with the most common color.
 db_id: superhero
Planner: 1.  Join `superhero` table with `colour` table on `eye_colour_id` = `id` to get the eye color of each superhero.
2.  Join the result with `publisher` table on `publisher_id` = `id` to filter superheroes from Marvel Comics.
3.  Filter by `publisher.publisher_name` = 'Marvel Comics'.
4.  Group by `colour.colour` and count the number of superheroes for each eye color.
5.  Order the result by the count in descending order.
6.  Select the eye color and the count.

NL2SQL: ```sql
SELECT
  T2.colour,
  COUNT(T1.id)
FROM superhero AS T1
INNER JOIN colour AS T2
  ON T1.eye_colour_id = T2.id
INNER JOIN publisher AS T3
  ON T1.publisher_id = T3.id
WHERE
  T3.publisher_name = 'Marvel Comics'
GROUP BY
  T2.colour
ORDER BY
  COUNT(T1.id) DESC;
```
Critic: ```sql
SELECT
  T2.colour,
  COUNT(T1.id)
FROM superhero AS T1
INNER JOIN colour AS T2
  ON T1.eye_colour_id = T2.id
INNER JOIN publisher AS T3
  ON T1.publisher_id = T3.id
WHERE
  T3.publisher_name = 'Marvel Comics'
GROUP BY
  T2.colour
ORDER BY
  COUNT(T1.id) DESC;
```
=====================
Question: List the superheroes from Marvel Comics who have the super power of 'Super Strength'.
 db_id: superhero
Planner: 1.  Find the publisher ID for 'Marvel Comics' from the `publisher` table.
2.  Find the superpower ID for 'Super Strength' from the `superpower` table.
3.  Using the publisher ID, filter the `superhero` table to get all superheroes from Marvel Comics.
4.  Using the superpower ID, find all superheroes with 'Super Strength' from the `hero_power` table.
5.  Join the filtered `superhero` table and the `hero_power` table on the superhero ID.
6.  Select the superhero name from the joined table.

NL2SQL: ```sql
SELECT
  T1.superhero_name
FROM superhero AS T1
INNER JOIN hero_power AS T2
  ON T1.id = T2.hero_id
INNER JOIN superpower AS T3
  ON T2.power_id = T3.id
INNER JOIN publisher AS T4
  ON T1.publisher_id = T4.id
WHERE
  T3.power_name = 'Super Strength' AND T4.publisher_name = 'Marvel Comics';
```
Critic: ```sql
SELECT
  T1.superhero_name
FROM superhero AS T1
INNER JOIN hero_power AS T2
  ON T1.id = T2.hero_id
INNER JOIN superpower AS T3
  ON T2.power_id = T3.id
INNER JOIN publisher AS T4
  ON T1.publisher_id = T4.id
WHERE
  T3.power_name = 'Super Strength' AND T4.publisher_name = 'Marvel Comics'
```
=====================
Question: Which publisher published the slowest superhero?
 db_id: superhero
Planner: 1.  Find the `id` of the 'Speed' attribute from the `attribute` table.
2.  Join `hero_attribute` with `superhero` on `hero_id`.
3.  Join the result with the `publisher` table on `publisher_id`.
4.  Filter the `hero_attribute` records to include only the rows where `attribute_id` matches the 'Speed' attribute `id` obtained in step 1.
5.  Find the minimum `attribute_value` for speed.
6.  Select the `publisher_name` associated with the minimum `attribute_value`.

NL2SQL: ```sql
SELECT
  T2.publisher_name
FROM hero_attribute AS T1
INNER JOIN superhero AS T3
  ON T1.hero_id = T3.id
INNER JOIN publisher AS T2
  ON T3.publisher_id = T2.id
INNER JOIN attribute AS T4
  ON T1.attribute_id = T4.id
WHERE
  T4.attribute_name = 'Speed'
ORDER BY
  T1.attribute_value
LIMIT 1;
```
Critic: ```sql
SELECT
  T2.publisher_name
FROM hero_attribute AS T1
INNER JOIN superhero AS T3
  ON T1.hero_id = T3.id
INNER JOIN publisher AS T2
  ON T3.publisher_id = T2.id
INNER JOIN attribute AS T4
  ON T1.attribute_id = T4.id
WHERE
  T4.attribute_name = 'Speed'
ORDER BY
  CAST(T1.attribute_value AS UNSIGNED)
LIMIT 1;
```
=====================
Question: How many gold-eyed superheroes did Marvel Comics publish?
 db_id: superhero
Planner: 1. Find the `id` of the color 'Gold' from the `colour` table.
2. Find the `id` of the publisher 'Marvel Comics' from the `publisher` table.
3. In the `superhero` table, count the number of superheroes where `eye_colour_id` matches the `id` of 'Gold' and `publisher_id` matches the `id` of 'Marvel Comics'.

NL2SQL: ```sql
SELECT
  COUNT(T1.id)
FROM superhero AS T1
INNER JOIN colour AS T2
  ON T1.eye_colour_id = T2.id
INNER JOIN publisher AS T3
  ON T1.publisher_id = T3.id
WHERE
  T2.colour = 'Gold' AND T3.publisher_name = 'Marvel Comics';
```
Critic: ```sql
SELECT
  COUNT(T1.id)
FROM superhero AS T1
INNER JOIN colour AS T2
  ON T1.eye_colour_id = T2.id
INNER JOIN publisher AS T3
  ON T1.publisher_id = T3.id
WHERE
  T2.colour = 'Gold' AND T3.publisher_name = 'Marvel Comics';
```
=====================
Question: Who is the dumbest superhero?
 db_id: superhero
Planner: Here's my plan to figure out who the dumbest superhero is:

1.  **Join `hero_attribute` with `attribute`**: Join these two tables on `attribute_id` to connect each superhero's attribute values with the names of the attributes.
2.  **Filter for 'Intelligence'**: Filter the joined table to include only rows where `attribute.attribute_name = 'Intelligence'`.
3.  **Find the Minimum Intelligence**:  Find the minimum `attribute_value` from the filtered data.
4.  **Join `superhero` with `hero_attribute`**: Join the table filtered on intelligence with table `superhero` on `id = hero_id`.
5.  **Output Superhero name**: Select the `superhero_name` of the superhero(s) with the minimum intelligence.

NL2SQL: ```sql
SELECT
  T1.superhero_name
FROM superhero AS T1
INNER JOIN hero_attribute AS T2
  ON T1.id = T2.hero_id
INNER JOIN attribute AS T3
  ON T2.attribute_id = T3.id
WHERE
  T3.attribute_name = 'Intelligence'
ORDER BY
  T2.attribute_value
LIMIT 1;
```
Critic: ```sql
SELECT
  T1.superhero_name
FROM superhero AS T1
INNER JOIN hero_attribute AS T2
  ON T1.id = T2.hero_id
INNER JOIN attribute AS T3
  ON T2.attribute_id = T3.id
WHERE
  T3.attribute_name = 'Intelligence'
ORDER BY
  T2.attribute_value
LIMIT 1;
```
=====================
Question: What is Copycat's race?
 db_id: superhero
Planner: 1. Find the id of the superhero named 'Copycat' from the `superhero` table.
2. Using the `race_id` from the superhero table, find the corresponding race from the `race` table.
3. Return the race.

NL2SQL: ```sql
SELECT
  T2.race
FROM superhero AS T1
INNER JOIN race AS T2
  ON T1.race_id = T2.id
WHERE
  T1.superhero_name = 'Copycat';
```
Critic: ```sql
SELECT
  T2.race
FROM superhero AS T1
INNER JOIN race AS T2
  ON T1.race_id = T2.id
WHERE
  T1.superhero_name = 'Copycat';
```
=====================
Question: Which superheroes have a durability attribute value of less than 50?
 db_id: superhero
Planner: 1. Filter the `attribute` table to find the `id` of the 'Durability' attribute.
2. Join the `hero_attribute` table with the `superhero` table on `hero_id`.
3. Filter the `hero_attribute` table by `attribute_id` using the `id` found in step 1 and `attribute_value` less than 50.
4. Select the `superhero_name` from the `superhero` table.

NL2SQL: ```sql
SELECT
  T1.superhero_name
FROM superhero AS T1
INNER JOIN hero_attribute AS T2
  ON T1.id = T2.hero_id
INNER JOIN attribute AS T3
  ON T2.attribute_id = T3.id
WHERE
  T3.attribute_name = 'Durability' AND T2.attribute_value < 50;
```
Critic: ```sql
SELECT
  T1.superhero_name
FROM superhero AS T1
INNER JOIN hero_attribute AS T2
  ON T1.id = T2.hero_id
INNER JOIN attribute AS T3
  ON T2.attribute_id = T3.id
WHERE
  T3.attribute_name = 'Durability' AND T2.attribute_value < 50;
```
=====================
Question: What are the names of the superheroes with the power of death touch?
 db_id: superhero
Planner: 1. Find the `id` of the superpower named 'Death Touch' in the `superpower` table.
2. Use the `id` found in step 1 to filter the `hero_power` table to find all `hero_id` values associated with the 'Death Touch' power.
3. Use the `hero_id` values found in step 2 to filter the `superhero` table and retrieve the `superhero_name` for those heroes.

NL2SQL: ```sql
SELECT
  T1.superhero_name
FROM superhero AS T1
INNER JOIN hero_power AS T2
  ON T1.id = T2.hero_id
INNER JOIN superpower AS T3
  ON T2.power_id = T3.id
WHERE
  T3.power_name = 'Death Touch';
```
Critic: ```sql
SELECT
  T1.superhero_name
FROM superhero AS T1
INNER JOIN hero_power AS T2
  ON T1.id = T2.hero_id
INNER JOIN superpower AS T3
  ON T2.power_id = T3.id
WHERE
  T3.power_name = "Death Touch";
```
=====================
Question: How many female superheroes have a strength value of 100?
 db_id: superhero
Planner: 1.  Join the `superhero` table with the `gender` table on `gender_id` to filter for female superheroes.
2.  Join the `hero_attribute` table with the `superhero` table on `hero_id`.
3.  Join the `attribute` table with the `hero_attribute` table on `attribute_id`.
4.  Filter the results to include only superheroes with `attribute_name` equal to 'Strength' and `attribute_value` equal to 100.
5.  Count the number of superheroes that meet these criteria.

NL2SQL: ```sql
SELECT
  COUNT(T1.id)
FROM superhero AS T1
INNER JOIN gender AS T2
  ON T1.gender_id = T2.id
INNER JOIN hero_attribute AS T3
  ON T1.id = T3.hero_id
INNER JOIN attribute AS T4
  ON T3.attribute_id = T4.id
WHERE
  T2.gender = 'Female' AND T4.attribute_name = 'Strength' AND T3.attribute_value = 100;
```
Critic: ```sql
SELECT
  COUNT(T1.id)
FROM superhero AS T1
INNER JOIN gender AS T2
  ON T1.gender_id = T2.id
INNER JOIN hero_attribute AS T3
  ON T1.id = T3.hero_id
INNER JOIN attribute AS T4
  ON T3.attribute_id = T4.id
WHERE
  T2.gender = 'Female' AND T4.attribute_name = 'Strength' AND T3.attribute_value = 100;
```
=====================
Question: What is the percentage of superheroes who act in their own self-interest or make decisions based on their own moral code? Indicate how many of the said superheroes were published by Marvel Comics.
 db_id: superhero
Planner: Here's the plan to answer the question:

1.  **Identify relevant tables:**
    *   `superhero`: Contains information about superheroes, including their publisher and alignment.
    *   `publisher`: Contains publisher names.
    *   `alignment`: Contains alignment information.

2.  **Filter for superheroes with 'Bad' alignment:**
    *   Filter the `superhero` table on `alignment_id`. To get the `id` for `alignment = 'Bad'` filter table `alignment` on the `alignment` column.

3.  **Calculate the total number of superheroes:**
    *   Count the total number of superheroes in the `superhero` table.

4.  **Calculate the percentage:**
    *   Divide the number of superheroes with 'Bad' alignment by the total number of superheroes.
    *   Multiply the result by 100 to get the percentage.

5.  **Filter for superheroes published by 'Marvel Comics':**
    *   Filter the `superhero` table on `publisher_id`. To get the `id` for `publisher_name = 'Marvel Comics'` filter table `publisher` on the `publisher_name` column.
    *   Count the number of superheroes published by Marvel with 'Bad' alignment.

6.  **Combine the results:**
    *   Present the percentage of superheroes with 'Bad' alignment and the number of 'Bad' superheroes published by Marvel.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.alignment = 'Bad' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id),
  SUM(CASE WHEN T1.alignment = 'Bad' AND T2.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END)
FROM alignment AS T1
INNER JOIN superhero AS T3
  ON T1.id = T3.alignment_id
INNER JOIN publisher AS T2
  ON T3.publisher_id = T2.id;
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.alignment = 'Neutral' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T3.id),
  SUM(CASE WHEN T1.alignment = 'Neutral' AND T2.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END)
FROM alignment AS T1
INNER JOIN superhero AS T3
  ON T1.id = T3.alignment_id
INNER JOIN publisher AS T2
  ON T3.publisher_id = T2.id;
```
=====================
Question: Between DC and Marvel Comics, which publisher has published more superheroes? Find the difference in the number of superheroes they have published.
 db_id: superhero
Planner: 1.  **Find the number of superheroes for each publisher:**
    *   Join the `superhero` table with the `publisher` table using `publisher_id`.
    *   Filter by `publisher_name` for 'DC Comics' and 'Marvel Comics'.
    *   Count the number of superheroes for each publisher.
2.  **Calculate the difference:**
    *   Subtract the number of superheroes published by 'DC Comics' from the number published by 'Marvel Comics'.
    *   Return the calculated difference.

NL2SQL: ```sql
SELECT SUM(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.publisher_name = 'DC Comics' THEN 1 ELSE 0 END) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id
```
Critic: ```sql
SELECT SUM(CASE WHEN publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END) - SUM(CASE WHEN publisher_name = 'DC Comics' THEN 1 ELSE 0 END) FROM publisher AS t1 INNER JOIN superhero AS t2 ON t1.id = t2.publisher_id
```
=====================
Question: Give the publisher ID of Star Trek.
 db_id: superhero
Planner: 1. Find the `id` from the `publisher` table where `publisher_name` is 'Star Trek'.
2. Return the `id`.

NL2SQL: ```sql
SELECT
  id
FROM publisher
WHERE
  publisher_name = 'Star Trek';
```
Critic: ```sql
SELECT
  id
FROM publisher
WHERE
  publisher_name = 'Star Trek';
```
=====================
Question: What is the total number of superheroes without full name?
 db_id: superhero
Planner: Plan:
1. Select from the `superhero` table.
2. Filter `superhero` table where `full_name` is NULL.
3. Count the number of superheroes that satisfy the condition.

NL2SQL: ```sql
SELECT
  COUNT(*)
FROM superhero
WHERE
  full_name IS NULL;
```
Critic: ```sql
SELECT count(*) FROM superhero WHERE full_name IS NULL
```
=====================
Question: What is the average weight of all female superheroes?
 db_id: superhero
Planner: 1.  Join the `superhero` table with the `gender` table on `gender_id` to filter for female superheroes.
2.  Filter the joined table to include only superheroes where the gender is 'Female'.
3.  Calculate the average weight (`weight_kg`) of the filtered superheroes using the AVG aggregate function.

NL2SQL: ```sql
SELECT AVG(T1.weight_kg) FROM superhero AS T1 JOIN gender AS T2 ON T1.gender_id = T2.id WHERE T2.gender = 'Female'
```
Critic: ```sql
SELECT AVG(T1.weight_kg) FROM superhero AS T1 INNER JOIN gender AS T2 ON T1.gender_id = T2.id WHERE T2.gender = 'Female'
```
=====================
Question: List down at least five superpowers of male superheroes.
 db_id: superhero
Planner: 1.  Find the `id` of the `gender` 'Male' from the `gender` table.
2.  Find the `hero_id` of superheroes whose `gender_id` matches the `id` obtained in the previous step using the `superhero` table.
3.  Find the `power_id` associated with the `hero_id` obtained in the previous step using the `hero_power` table.
4.  Find the `power_name` corresponding to the `power_id` obtained in the previous step using the `superpower` table.
5.  List at least five `power_name`.

NL2SQL: ```sql
SELECT DISTINCT
  T2.power_name
FROM superhero AS T1
INNER JOIN hero_power AS T3
  ON T1.id = T3.hero_id
INNER JOIN superpower AS T2
  ON T3.power_id = T2.id
INNER JOIN gender AS T4
  ON T1.gender_id = T4.id
WHERE
  T4.gender = 'Male'
LIMIT 5;
```
Critic: ```sql
SELECT DISTINCT
  T2.power_name
FROM superhero AS T1
INNER JOIN hero_power AS T3
  ON T1.id = T3.hero_id
INNER JOIN superpower AS T2
  ON T3.power_id = T2.id
INNER JOIN gender AS T4
  ON T1.gender_id = T4.id
WHERE
  T4.gender = 'Male'
LIMIT 5;
```
=====================
Question: Among the superheroes with height from 170 to 190, list the names of the superheroes with no eye color.
 db_id: superhero
Planner: 1. Select the superhero names from the `superhero` table.
2. Filter superheroes based on height (`height_cm` between 170 and 190).
3. Filter superheroes with no eye color. This involves joining the `superhero` table with the `colour` table on `eye_colour_id` and filtering for `colour` equal to 'No Colour'.

NL2SQL: ```sql
SELECT
  T1.superhero_name
FROM superhero AS T1
INNER JOIN colour AS T2
  ON T1.eye_colour_id = T2.id
WHERE
  T2.colour = 'No Colour' AND T1.height_cm BETWEEN 170 AND 190;
```
Critic: ```sql
SELECT
  superhero_name
FROM superhero
WHERE
  eye_colour_id IS NULL AND height_cm BETWEEN 170 AND 190;
```
=====================
Question: Provide the hair colour of the human superhero who is 185 cm tall.
 db_id: superhero
Planner: 1.  Filter the `superhero` table to find superheroes with `height_cm` equal to 185.
2.  Filter the `race` table to find the race id of human.
3.  Join the `superhero` table with the `race` table on `race_id` to ensure the superhero is human.
4.  Join the `superhero` table with the `colour` table on `hair_colour_id = colour.id` to find the hair color.
5.  Select the `colour` column from the `colour` table.


NL2SQL: ```sql
SELECT
  T2.colour
FROM superhero AS T1
INNER JOIN colour AS T2
  ON T1.hair_colour_id = T2.id
INNER JOIN race AS T3
  ON T1.race_id = T3.id
WHERE
  T3.race = 'Human' AND T1.height_cm = 185;
```
Critic: ```sql
SELECT
  T2.colour
FROM superhero AS T1
INNER JOIN colour AS T2
  ON T1.hair_colour_id = T2.id
INNER JOIN race AS T3
  ON T1.race_id = T3.id
WHERE
  T3.race = 'Human' AND T1.height_cm = 185;
```
=====================
Question: In superheroes with height between 150 to 180, what is the percentage of heroes published by Marvel Comics?
 db_id: superhero
Planner: Plan:
1. Filter superheroes whose height is between 150 and 180.
2. Join the superhero table with the publisher table on publisher_id to find the publisher of each superhero.
3. Count the total number of superheroes with height between 150 and 180.
4. Count the number of superheroes with height between 150 and 180 published by Marvel Comics.
5. Calculate the percentage of superheroes published by Marvel Comics.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id)
FROM superhero AS T1
INNER JOIN publisher AS T2
  ON T1.publisher_id = T2.id
WHERE
  T1.height_cm BETWEEN 150 AND 180;
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id)
FROM superhero AS T1
INNER JOIN publisher AS T2
  ON T1.publisher_id = T2.id
WHERE
  T1.height_cm BETWEEN 150 AND 180;
```
=====================
Question: Among the male superheroes, list the super hero names of superheroes with weight greater than the 79% average weight of all superheroes.
 db_id: superhero
Planner: 1. Calculate the average weight of all superheroes from the `superhero` table.
2. Filter superheroes to only include male superheroes. This requires joining `superhero` and `gender` table on `gender_id = id`.
3. Filter the male superheroes to include superheroes whose weight is greater than 79% of the average weight calculated in step 1.
4. Select the `superhero_name` for the filtered superheroes.

NL2SQL: ```sql
SELECT
  T1.superhero_name
FROM superhero AS T1
INNER JOIN gender AS T2
  ON T1.gender_id = T2.id
WHERE
  T2.gender = 'Male' AND T1.weight_kg > (
    SELECT
      AVG(weight_kg) * 0.79
    FROM superhero
  );
```
Critic: ```sql
SELECT
  T1.superhero_name
FROM superhero AS T1
INNER JOIN gender AS T2
  ON T1.gender_id = T2.id
WHERE
  T2.gender = 'Male' AND T1.weight_kg > (
    SELECT
      AVG(weight_kg) * 0.79
    FROM superhero
  );
```
=====================
Question: What are the superpowers of heroes with ID 1?
 db_id: superhero
Planner: 1.  Find the table containing information about superheroes and their superpowers. This is the `hero_power` table, which links `hero_id` to `power_id`.
2.  Find the table containing the superpower names. This is the `superpower` table.
3.  Join the `hero_power` table with the `superpower` table on `power_id` to get the superpower names for each superhero.
4.  Filter the results to only include heroes with `hero_id = 1`.
5.  Select the `power_name` column.

NL2SQL: ```sql
SELECT
  T2.power_name
FROM hero_power AS T1
INNER JOIN superpower AS T2
  ON T1.power_id = T2.id
WHERE
  T1.hero_id = 1;
```
Critic: ```sql
SELECT
  T2.power_name
FROM hero_power AS T1
INNER JOIN superpower AS T2
  ON T1.power_id = T2.id
WHERE
  T1.hero_id = 1;
```
=====================
Question: How many heroes have stealth power?
 db_id: superhero
Planner: 1. Find the `id` of the power named 'Stealth' in the `superpower` table.
2. Use the `id` found in step 1 to filter the `hero_power` table and find all `hero_id` that have the 'Stealth' power.
3. Count the distinct `hero_id` found in step 2. This gives the number of heroes with stealth power.

NL2SQL: ```sql
SELECT
  COUNT(DISTINCT hero_id)
FROM hero_power
WHERE
  power_id = (
    SELECT
      id
    FROM superpower
    WHERE
      power_name = 'Stealth'
  );
```
Critic: ```sql
SELECT
  COUNT(T1.hero_id)
FROM hero_power AS T1
INNER JOIN superpower AS T2
  ON T1.power_id = T2.id
WHERE
  T2.power_name = 'Stealth';
```
=====================
Question: What is the hero's full name with the highest attribute in strength?
 db_id: superhero
Planner: 1. Find the `id` of the 'strength' attribute from the `attribute` table.
2. Use the `hero_attribute` table to find the `hero_id` with the maximum `attribute_value` for the 'strength' attribute `id`.
3. Use the `superhero` table to find the `full_name` of the superhero with the `hero_id` found in step 2.

NL2SQL: ```sql
SELECT
  T1.full_name
FROM superhero AS T1
INNER JOIN hero_attribute AS T2
  ON T1.id = T2.hero_id
INNER JOIN attribute AS T3
  ON T2.attribute_id = T3.id
WHERE
  T3.attribute_name = 'Strength'
ORDER BY
  T2.attribute_value DESC
LIMIT 1;
```
Critic: ```sql
SELECT
  T1.full_name
FROM superhero AS T1
INNER JOIN hero_attribute AS T2
  ON T1.id = T2.hero_id
INNER JOIN attribute AS T3
  ON T2.attribute_id = T3.id
WHERE
  T3.attribute_name = 'strength'
ORDER BY
  T2.attribute_value DESC
LIMIT 1;
```
=====================
Question: Which superhero has the most durability published by Dark Horse Comics?
 db_id: superhero
Planner: 1. Find the `id` of 'Dark Horse Comics' from the `publisher` table.
2. Filter the `superhero` table using `publisher_id` to select superheroes published by 'Dark Horse Comics'.
3. Find the `id` of the 'durability' attribute from the `attribute` table.
4. Join `superhero` table with `hero_attribute` table on `superhero.id` = `hero_attribute.hero_id`.
5. Filter `hero_attribute` records where `attribute_id` equals the `id` of 'durability'.
6. Group by superhero name and find the max durability value.
7. Find the superhero name which has the maximum durability.

NL2SQL: ```sql
SELECT
  T1.superhero_name
FROM superhero AS T1
INNER JOIN hero_attribute AS T2
  ON T1.id = T2.hero_id
INNER JOIN attribute AS T3
  ON T2.attribute_id = T3.id
INNER JOIN publisher AS T4
  ON T1.publisher_id = T4.id
WHERE
  T3.attribute_name = 'Durability' AND T4.publisher_name = 'Dark Horse Comics'
ORDER BY
  T2.attribute_value DESC
LIMIT 1;
```
Critic: ```sql
SELECT
  T1.superhero_name
FROM superhero AS T1
INNER JOIN hero_attribute AS T2
  ON T1.id = T2.hero_id
INNER JOIN attribute AS T3
  ON T2.attribute_id = T3.id
INNER JOIN publisher AS T4
  ON T1.publisher_id = T4.id
WHERE
  T3.attribute_name = 'durability' AND T4.publisher_name = 'Dark Horse Comics'
ORDER BY
  T2.attribute_value DESC
LIMIT 1;
```
=====================
Question: List the eyes, hair and skin colour of all female superheroes published by Dark Horse Comics.
 db_id: superhero
Planner: 1.  Join the `superhero` table with the `publisher` table on `publisher_id` to filter for superheroes published by "Dark Horse Comics".
2.  Join the `superhero` table with the `gender` table on `gender_id` to filter for female superheroes.
3.  Join the `superhero` table with the `colour` table three times, aliasing `colour` as `eye_colour`, `hair_colour`, and `skin_colour` to retrieve the eye, hair, and skin colors respectively. The joins are on `eye_colour_id`, `hair_colour_id`, and `skin_colour_id`.
4.  Select the `colour` column from the `eye_colour`, `hair_colour`, and `skin_colour` tables to display the eye, hair, and skin colors.

NL2SQL: ```sql
SELECT
  eye_colour.colour,
  hair_colour.colour,
  skin_colour.colour
FROM superhero
JOIN publisher
  ON superhero.publisher_id = publisher.id
JOIN gender
  ON superhero.gender_id = gender.id
JOIN colour AS eye_colour
  ON superhero.eye_colour_id = eye_colour.id
JOIN colour AS hair_colour
  ON superhero.hair_colour_id = hair_colour.id
JOIN colour AS skin_colour
  ON superhero.skin_colour_id = skin_colour.id
WHERE
  publisher.publisher_name = 'Dark Horse Comics' AND gender.gender = 'Female';
```
Critic: ```sql
SELECT
  T1.colour,
  T2.colour,
  T3.colour
FROM colour AS T1
INNER JOIN superhero AS T4
  ON T1.id = T4.eye_colour_id
INNER JOIN colour AS T2
  ON T4.hair_colour_id = T2.id
INNER JOIN colour AS T3
  ON T4.skin_colour_id = T3.id
INNER JOIN publisher AS T5
  ON T4.publisher_id = T5.id
INNER JOIN gender AS T6
  ON T4.gender_id = T6.id
WHERE
  T5.publisher_name = 'Dark Horse Comics' AND T6.gender = 'Female';
```
=====================
Question: Which superhero has the same eyes, hair and skin colour? Indicate the publisher of the superhero.
 db_id: superhero
Planner: 1.  From the `superhero` table, filter the superheroes based on the condition that `eye_colour_id` is equal to `hair_colour_id` and `hair_colour_id` is equal to `skin_colour_id`.
2.  Join the `superhero` table with the `publisher` table using `publisher_id` to get the publisher information for the selected superheroes.
3.  Select the `superhero_name` and `publisher_name`.

NL2SQL: ```sql
SELECT
  T1.superhero_name,
  T2.publisher_name
FROM superhero AS T1
INNER JOIN publisher AS T2
  ON T1.publisher_id = T2.id
WHERE
  T1.eye_colour_id = T1.hair_colour_id AND T1.hair_colour_id = T1.skin_colour_id;
```
Critic: ```sql
SELECT
  T1.superhero_name,
  T2.publisher_name
FROM superhero AS T1
INNER JOIN publisher AS T2
  ON T1.publisher_id = T2.id
WHERE
  T1.eye_colour_id = T1.hair_colour_id AND T1.eye_colour_id = T1.skin_colour_id;
```
=====================
Question: What is the percentage of blue female superheroes among all female superheroes?
 db_id: superhero
Planner: Plan:
1. Find the id of the 'Female' gender from the `gender` table.
2. Find the id of the 'Blue' colour from the `colour` table.
3. Count the total number of female superheroes. This involves joining `superhero` and `gender` tables using `gender_id` and filtering by the female gender id.
4. Count the number of blue female superheroes. This involves joining `superhero`, `gender`, and `colour` tables. Filter by the female gender id and the blue colour id by using `skin_colour_id`.
5. Calculate the percentage of blue female superheroes by dividing the count of blue female superheroes by the total number of female superheroes and multiplying by 100.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.colour = 'Blue' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T2.id)
FROM colour AS T1
INNER JOIN superhero AS T2
  ON T1.id = T2.skin_colour_id
INNER JOIN gender AS T3
  ON T2.gender_id = T3.id
WHERE
  T3.gender = 'Female';
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.colour = 'Blue' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T2.id)
FROM colour AS T1
INNER JOIN superhero AS T2
  ON T1.id = T2.eye_colour_id
INNER JOIN gender AS T3
  ON T2.gender_id = T3.id
WHERE
  T3.gender = 'Female';
```
=====================
Question: How many powers does Amazo hero have?
 db_id: superhero
Planner: 1.  Find the `id` of the superhero named 'Amazo' from the `superhero` table.
2.  Use the superhero `id` to find all corresponding entries in the `hero_power` table.
3.  Count the number of entries found in `hero_power` table for the superhero. This count represents the number of powers the superhero has.

NL2SQL: ```sql
SELECT
  COUNT(T1.power_id)
FROM hero_power AS T1
INNER JOIN superhero AS T2
  ON T1.hero_id = T2.id
WHERE
  T2.superhero_name = 'Amazo';
```
Critic: ```sql
SELECT
  COUNT(T1.power_id)
FROM hero_power AS T1
INNER JOIN superhero AS T2
  ON T1.hero_id = T2.id
WHERE
  T2.superhero_name = 'Amazo';
```
=====================
Question: Provide the heights of the heroes whose eye colours are amber.
 db_id: superhero
Planner: 1. Find the `id` of the amber eye colour from the `colour` table.
2. Use the `id` found in the previous step to filter the `superhero` table, selecting rows where `eye_colour_id` matches the amber eye colour `id`.
3. Retrieve the `height_cm` column for the selected heroes.

NL2SQL: ```sql
SELECT
  T1.height_cm
FROM superhero AS T1
INNER JOIN colour AS T2
  ON T1.eye_colour_id = T2.id
WHERE
  T2.colour = 'Amber';
```
Critic: ```sql
SELECT
  height_cm
FROM superhero
WHERE
  eye_colour_id IN (
    SELECT
      id
    FROM colour
    WHERE
      colour = 'Amber'
  );
```
=====================
Question: List the heroes' names whose eyes and hair colours are both black.
 db_id: superhero
Planner: 1.  Join the `superhero` table with the `colour` table twice, once for eye color and once for hair color.
2.  Filter the results to include only superheroes where both eye color and hair color are black.
3.  Select the `superhero_name` from the `superhero` table.

NL2SQL: ```sql
SELECT
  T1.superhero_name
FROM superhero AS T1
INNER JOIN colour AS T2
  ON T1.eye_colour_id = T2.id
INNER JOIN colour AS T3
  ON T1.hair_colour_id = T3.id
WHERE
  T2.colour = 'Black' AND T3.colour = 'Black';
```
Critic: ```sql
SELECT
  superhero_name
FROM superhero
WHERE
  eye_colour_id IN (
    SELECT
      id
    FROM colour
    WHERE
      colour = 'Black'
  )
  AND hair_colour_id IN (
    SELECT
      id
    FROM colour
    WHERE
      colour = 'Black'
  );
```
=====================
Question: Describe the names of neutral alignment superheroes.
 db_id: superhero
Planner: 1. Select the `superhero_name` from the `superhero` table.
2. Join `superhero` table with `alignment` table using `alignment_id`.
3. Filter the result where `alignment` is equal to 'Neutral'.

NL2SQL: ```sql
SELECT
  T1.superhero_name
FROM superhero AS T1
INNER JOIN alignment AS T2
  ON T1.alignment_id = T2.id
WHERE
  T2.alignment = 'Neutral';
```
Critic: ```sql
SELECT
  superhero_name
FROM superhero
WHERE
  alignment_id = (
    SELECT
      id
    FROM alignment
    WHERE
      alignment = 'Neutral'
  );
```
=====================
Question: How many heroes have the highest attribute value in strength?
 db_id: superhero
Planner: Plan:
1. Find the id of 'Strength' from the `attribute` table.
2. Find the maximum `attribute_value` for 'Strength' from the `hero_attribute` table, using the id found in step 1 as `attribute_id`.
3. Count the number of heroes that have that maximum `attribute_value` for 'Strength'. Join `hero_attribute` and `attribute` table on `attribute_id` and filter by `attribute_name = 'Strength'`.
4. Return the count of heroes.

NL2SQL: ```sql
SELECT
  COUNT(T1.hero_id)
FROM hero_attribute AS T1
INNER JOIN attribute AS T2
  ON T1.attribute_id = T2.id
WHERE
  T2.attribute_name = 'Strength'
  AND T1.attribute_value = (
    SELECT
      MAX(T3.attribute_value)
    FROM hero_attribute AS T3
    INNER JOIN attribute AS T4
      ON T3.attribute_id = T4.id
    WHERE
      T4.attribute_name = 'Strength'
  );
```
Critic: ```sql
SELECT
  COUNT(hero_id)
FROM hero_attribute
WHERE
  attribute_id = (
    SELECT
      id
    FROM attribute
    WHERE
      attribute_name = 'Strength'
  )
  AND attribute_value = (
    SELECT
      MAX(attribute_value)
    FROM hero_attribute
    WHERE
      attribute_id = (
        SELECT
          id
        FROM attribute
        WHERE
          attribute_name = 'Strength'
      )
  );
```
=====================
Question: How many percent of female heroes were published by Marvel Comics?
 db_id: superhero
Planner: Plan:
1. Find the total number of female heroes. Join `superhero` with `gender` on `gender_id` to filter for female heroes (`gender.gender = 'Female'`). Count the number of such heroes.
2. Find the number of female heroes published by Marvel Comics. Join `superhero` with `gender` on `gender_id` and with `publisher` on `publisher_id`. Filter for female heroes (`gender.gender = 'Female'`) and heroes published by Marvel Comics (`publisher.publisher_name = 'Marvel Comics'`). Count the number of such heroes.
3. Calculate the percentage: (number of female heroes published by Marvel Comics / total number of female heroes) * 100.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.gender)
FROM gender AS T1
INNER JOIN superhero AS T3
  ON T1.id = T3.gender_id
INNER JOIN publisher AS T2
  ON T3.publisher_id = T2.id
WHERE
  T1.gender = 'Female';
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.gender)
FROM gender AS T1
INNER JOIN superhero AS T3
  ON T1.id = T3.gender_id
INNER JOIN publisher AS T2
  ON T3.publisher_id = T2.id
WHERE
  T1.gender = 'Female';
```
=====================
Question: Calculate the difference between Emil Blonsky's weight and Charles Chandler's weight.
 db_id: superhero
Planner: 1.  Find the weight of Emil Blonsky from the `superhero` table. Filter by `full_name` = 'Emil Blonsky' and select `weight_kg`.
2.  Find the weight of Charles Chandler from the `superhero` table. Filter by `full_name` = 'Charles Chandler' and select `weight_kg`.
3.  Calculate the difference between Emil Blonsky's weight and Charles Chandler's weight.

NL2SQL: ```sql
SELECT SUM(CASE WHEN full_name = 'Emil Blonsky' THEN weight_kg ELSE 0 END) - SUM(CASE WHEN full_name = 'Charles Chandler' THEN weight_kg ELSE 0 END) FROM superhero
```
Critic: ```sql
SELECT SUM(CASE WHEN full_name = 'Emil Blonsky' THEN weight_kg ELSE 0 END) - SUM(CASE WHEN full_name = 'Charles Chandler' THEN weight_kg ELSE 0 END) FROM superhero
```
=====================
Question: Calculate the average height for all superhero.
 db_id: superhero
Planner: 1. Select the average of the `height_cm` column from the `superhero` table.

NL2SQL: ```sql
SELECT avg(height_cm) FROM superhero
```
Critic: ```sql
SELECT avg(height_cm) FROM superhero
```
=====================
Question: What is Abomination's superpower?
 db_id: superhero
Planner: 1. Find the `id` of the superhero named 'Abomination' from the `superhero` table.
2. Use the `hero_id` to look up the `power_id` in the `hero_power` table.
3. Use the `power_id` to retrieve the `power_name` from the `superpower` table.

NL2SQL: ```sql
SELECT
  T2.power_name
FROM superhero AS T1
INNER JOIN hero_power AS T3
  ON T1.id = T3.hero_id
INNER JOIN superpower AS T2
  ON T3.power_id = T2.id
WHERE
  T1.superhero_name = 'Abomination';
```
Critic: ```sql
SELECT
  T2.power_name
FROM superhero AS T1
INNER JOIN hero_power AS T3
  ON T1.id = T3.hero_id
INNER JOIN superpower AS T2
  ON T3.power_id = T2.id
WHERE
  T1.superhero_name = 'Abomination';
```
=====================
Question: Which hero was the fastest?
 db_id: superhero
Planner: 1. Find the `id` of the `attribute` named 'Speed' in the `attribute` table.
2. Join the `superhero` table with the `hero_attribute` table on `superhero.id` = `hero_attribute.hero_id`.
3. Filter `hero_attribute` by the `attribute_id` found in step 1.
4. Find the superhero with the maximum `attribute_value`. Select the corresponding `superhero_name` from the `superhero` table.

NL2SQL: ```sql
SELECT
  T1.superhero_name
FROM superhero AS T1
INNER JOIN hero_attribute AS T2
  ON T1.id = T2.hero_id
INNER JOIN attribute AS T3
  ON T2.attribute_id = T3.id
WHERE
  T3.attribute_name = 'Speed'
ORDER BY
  T2.attribute_value DESC
LIMIT 1;
```
Critic: ```sql
SELECT
  t1.superhero_name
FROM superhero AS t1
INNER JOIN hero_attribute AS t2
  ON t1.id = t2.hero_id
INNER JOIN attribute AS t3
  ON t2.attribute_id = t3.id
WHERE
  t3.attribute_name = 'Speed'
ORDER BY
  t2.attribute_value DESC
LIMIT 1;
```
=====================
Question: State all of 3-D Man's attributes along with their values.
 db_id: superhero
Planner: 1.  Find the superhero ID for '3-D Man' from the `superhero` table.
2.  Use the superhero ID to find corresponding attribute IDs and attribute values in the `hero_attribute` table.
3.  Use the attribute IDs to find the attribute names in the `attribute` table.
4.  Present the attribute names and their corresponding values.

NL2SQL: ```sql
SELECT
  T1.attribute_name,
  T2.attribute_value
FROM attribute AS T1
INNER JOIN hero_attribute AS T2
  ON T1.id = T2.attribute_id
INNER JOIN superhero AS T3
  ON T2.hero_id = T3.id
WHERE
  T3.superhero_name = '3-D Man';
```
Critic: ```sql
SELECT
  T1.attribute_name,
  T2.attribute_value
FROM attribute AS T1
INNER JOIN hero_attribute AS T2
  ON T1.id = T2.attribute_id
INNER JOIN superhero AS T3
  ON T2.hero_id = T3.id
WHERE
  T3.superhero_name = '3-D Man';
```
=====================
Question: Which superheroes have blue eyes with brown hair?
 db_id: superhero
Planner: 1. Select the `superhero_name` from the `superhero` table.
2. Join the `superhero` table with the `colour` table on `eye_colour_id = colour.id` and filter for `colour = 'Blue'`.
3. Join the `superhero` table with the `colour` table again on `hair_colour_id = colour.id` and filter for `colour = 'Brown'`.

NL2SQL: ```sql
SELECT
  T1.superhero_name
FROM superhero AS T1
INNER JOIN colour AS T2
  ON T1.eye_colour_id = T2.id
INNER JOIN colour AS T3
  ON T1.hair_colour_id = T3.id
WHERE
  T2.colour = 'Blue' AND T3.colour = 'Brown';
```
Critic: ```sql
SELECT
  superhero_name
FROM superhero
WHERE
  eye_colour_id = (
    SELECT
      id
    FROM colour
    WHERE
      colour = 'Blue'
  )
  AND hair_colour_id = (
    SELECT
      id
    FROM colour
    WHERE
      colour = 'Brown'
  );
```
=====================
Question: What is the publisher for Hawkman, Karate Kid and Speedy?
 db_id: superhero
Planner: 1. Find the `id` from the `publisher` table.
2. Find the `id` from the `superhero` table using `superhero_name` in ('Hawkman', 'Karate Kid', 'Speedy').
3. Join the `superhero` table and `publisher` table on `publisher_id`.
4. Select the `publisher_name` from the `publisher` table with the condition that the `superhero_name` is in ('Hawkman', 'Karate Kid', 'Speedy').

NL2SQL: ```sql
SELECT
  t1.publisher_name
FROM publisher AS t1
INNER JOIN superhero AS t2
  ON t1.id = t2.publisher_id
WHERE
  t2.superhero_name IN ('Hawkman', 'Karate Kid', 'Speedy');
```
Critic: ```sql
SELECT DISTINCT
  T1.publisher_name
FROM publisher AS T1
INNER JOIN superhero AS T2
  ON T1.id = T2.publisher_id
WHERE
  T2.superhero_name IN ('Hawkman', 'Karate Kid', 'Speedy');
```
=====================
Question: Calculate the percentage of superheroes with blue eyes.
 db_id: superhero
Planner: 1. **Find the total number of superheroes:** This will be the denominator for the percentage calculation. We can get this by counting the number of rows in the `superhero` table.
2. **Find the number of superheroes with blue eyes:** This will be the numerator. We need to join the `superhero` table with the `colour` table on `eye_colour_id` to filter for superheroes with blue eyes (where `colour.colour` is 'Blue'). Then, count the number of such superheroes.
3. **Calculate the percentage:** Divide the number of superheroes with blue eyes by the total number of superheroes and multiply by 100.0.
4. **Select only the calculated percentage.**
Return the percentage.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T2.colour = 'Blue' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id)
FROM superhero AS T1
INNER JOIN colour AS T2
  ON T1.eye_colour_id = T2.id;
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T2.colour = 'Blue' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id)
FROM superhero AS T1
INNER JOIN colour AS T2
  ON T1.eye_colour_id = T2.id;
```
=====================
Question: Find the ratio between male superheroes and female superheroes.
 db_id: superhero
Planner: Plan:
1. Count the number of male superheroes. This can be done by joining the `superhero` table with the `gender` table on `gender_id` and filtering for `gender = 'Male'`.
2. Count the number of female superheroes. This can be done by joining the `superhero` table with the `gender` table on `gender_id` and filtering for `gender = 'Female'`.
3. Calculate the ratio between the number of male superheroes and the number of female superheroes.
4. Return the calculated ratio.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.gender = 'Male' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN T1.gender = 'Female' THEN 1 ELSE 0 END)
FROM gender AS T1
INNER JOIN superhero AS T2
  ON T1.id = T2.gender_id;
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.gender = 'Female' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN T1.gender = 'Male' THEN 1 ELSE 0 END)
FROM gender AS T1
INNER JOIN superhero AS T2
  ON T1.id = T2.gender_id;
```
=====================
Question: Provide the eye colour of the superhero who has Karen Beecher-Duncan as their full name.
 db_id: superhero
Planner: 1.  Find the superhero with the full name 'Karen Beecher-Duncan' from the `superhero` table.
2.  Get the `eye_colour_id` of that superhero.
3.  Find the eye colour from the `colour` table using the `eye_colour_id`.
4.  Return the eye colour.

Tables: `superhero`, `colour`

Columns:

*   `superhero`: `full_name`, `eye_colour_id`
*   `colour`: `id`, `colour`

Join:

*   `superhero` JOIN `colour` ON `superhero.eye_colour_id` = `colour.id`

Filters:

*   `superhero.full_name` = 'Karen Beecher-Duncan'

NL2SQL: ```sql
SELECT
  T2.colour
FROM superhero AS T1
INNER JOIN colour AS T2
  ON T1.eye_colour_id = T2.id
WHERE
  T1.full_name = 'Karen Beecher-Duncan';
```
Critic: ```sql
SELECT
  T2.colour
FROM superhero AS T1
INNER JOIN colour AS T2
  ON T1.eye_colour_id = T2.id
WHERE
  T1.full_name = 'Karen Beecher-Duncan';
```
=====================
Question: In superheroes with missing weight data, calculate the difference between the number of superheroes with blue eyes and no eye color.
 db_id: superhero
Planner: Plan:
1. Filter `superhero` table for rows where `weight_kg` is NULL or 0.
2. Join `colour` table with `superhero` table on `colour.id = superhero.eye_colour_id`.
3. Count the number of superheroes with blue eyes (where `colour.colour` is 'Blue') in the filtered data.
4. Count the number of superheroes with no eye color (where `colour.colour` is 'No Eyes') in the filtered data.
5. Calculate the difference between the two counts (Blue - No Eyes).
6. Return the calculated difference.

NL2SQL: ```sql
SELECT
  SUM(CASE WHEN T2.colour = 'Blue' THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.colour = 'No Eyes' THEN 1 ELSE 0 END)
FROM superhero AS T1
INNER JOIN colour AS T2
  ON T1.eye_colour_id = T2.id
WHERE
  T1.weight_kg IS NULL OR T1.weight_kg = 0;
```
Critic: ```sql
SELECT
  SUM(CASE WHEN T2.colour = 'Blue' THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.colour = 'No eyes' THEN 1 ELSE 0 END)
FROM superhero AS T1
INNER JOIN colour AS T2
  ON T1.eye_colour_id = T2.id
WHERE
  T1.weight_kg IS NULL;
```
=====================
Question: How many green-skinned villains are there in the superhero universe?
 db_id: superhero
Planner: 1.  Join the `superhero` table with the `colour` table on `skin_colour_id = colour.id`.
2.  Join the `superhero` table with the `alignment` table on `alignment_id = alignment.id`.
3.  Filter the results where `colour.colour = 'Green'` and `alignment.alignment = 'Bad'`.
4.  Count the number of superheroes that satisfy the conditions.

NL2SQL: ```sql
SELECT
  COUNT(T1.id)
FROM superhero AS T1
INNER JOIN colour AS T2
  ON T1.skin_colour_id = T2.id
INNER JOIN alignment AS T3
  ON T1.alignment_id = T3.id
WHERE
  T2.colour = 'Green' AND T3.alignment = 'Bad';
```
Critic: ```sql
SELECT
  COUNT(T1.id)
FROM superhero AS T1
INNER JOIN colour AS T2
  ON T1.skin_colour_id = T2.id
INNER JOIN alignment AS T3
  ON T1.alignment_id = T3.id
WHERE
  T2.colour = 'Green' AND T3.alignment = 'bad';
```
=====================
Question: Identify superheroes who can control wind and list their names in alphabetical order.
 db_id: superhero
Planner: 1. Find the `id` of the superpower "Wind Control" from the `superpower` table.
2. Using the `hero_power` table, find all `hero_id` values that have the `power_id` obtained in the previous step.
3. Using the `superhero` table, find the `superhero_name` for each `hero_id` obtained in the previous step.
4. Order the results alphabetically by `superhero_name`.

NL2SQL: ```sql
SELECT
  T1.superhero_name
FROM superhero AS T1
INNER JOIN hero_power AS T2
  ON T1.id = T2.hero_id
INNER JOIN superpower AS T3
  ON T2.power_id = T3.id
WHERE
  T3.power_name = 'Wind Control'
ORDER BY
  T1.superhero_name;
```
Critic: ```sql
SELECT
  T1.superhero_name
FROM superhero AS T1
INNER JOIN hero_power AS T2
  ON T1.id = T2.hero_id
INNER JOIN superpower AS T3
  ON T2.power_id = T3.id
WHERE
  T3.power_name = 'Wind Control'
ORDER BY
  T1.superhero_name;
```
=====================
Question: Identify the gender of the superhero who has the ability of Phoenix Force.
 db_id: superhero
Planner: 1. Find the `id` of the superpower named 'Phoenix Force' in the `superpower` table.
2. Use the `power_id` from step 1 to find the `hero_id` in the `hero_power` table.
3. Use the `hero_id` from step 2 to find the `gender_id` in the `superhero` table.
4. Use the `gender_id` from step 3 to find the `gender` in the `gender` table.
5. Return the `gender`.

NL2SQL: ```sql
SELECT
  T2.gender
FROM superhero AS T1
INNER JOIN gender AS T2
  ON T1.gender_id = T2.id
INNER JOIN hero_power AS T3
  ON T1.id = T3.hero_id
INNER JOIN superpower AS T4
  ON T3.power_id = T4.id
WHERE
  T4.power_name = 'Phoenix Force';
```
Critic: ```sql
SELECT
  T2.gender
FROM hero_power AS T1
INNER JOIN superpower AS T3
  ON T1.power_id = T3.id
INNER JOIN superhero AS T4
  ON T1.hero_id = T4.id
INNER JOIN gender AS T2
  ON T4.gender_id = T2.id
WHERE
  T3.power_name = 'Phoenix Force';
```
=====================
Question: Which publisher created more superheroes: DC or Marvel Comics? Find the difference in the number of superheroes.
 db_id: superhero
Planner: 1. Count the number of superheroes for 'DC Comics' using the `superhero` table, joining with the `publisher` table on `publisher_id`.
2. Count the number of superheroes for 'Marvel Comics' using the `superhero` table, joining with the `publisher` table on `publisher_id`.
3. Calculate the difference between the two counts.
4. Return the difference.

NL2SQL: ```sql
SELECT SUM(CASE WHEN T2.publisher_name = 'DC Comics' THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id
```
Critic: ```sql
SELECT SUM(CASE WHEN publisher_name = 'DC Comics' THEN 1 ELSE 0 END) - SUM(CASE WHEN publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END) FROM publisher AS t1 INNER JOIN superhero AS t2 ON t1.id = t2.publisher_id
```
=====================
Question: Which user has a higher reputation, Harlan or Jarrod Dixon?
 db_id: codebase_community
Planner: Plan:
1. Find the reputation of Harlan from the `users` table using the `DisplayName` column.
2. Find the reputation of Jarrod Dixon from the `users` table using the `DisplayName` column.
3. Compare the reputations of Harlan and Jarrod Dixon.
4. Return the name of the user with the higher reputation. I'll return the display names and reputations of both users, so the caller can determine which is higher.
SQL:
```sql
SELECT DisplayName, Reputation FROM users WHERE DisplayName = 'Harlan'
UNION ALL
SELECT DisplayName, Reputation FROM users WHERE DisplayName = 'Jarrod Dixon';
```
NL2SQL: ```sql
SELECT DisplayName, Reputation FROM users WHERE DisplayName = 'Harlan'
UNION ALL
SELECT DisplayName, Reputation FROM users WHERE DisplayName = 'Jarrod Dixon';
```
Critic: ```sql
SELECT
CASE
WHEN (SELECT Reputation FROM users WHERE DisplayName = 'Harlan') > (SELECT Reputation FROM users WHERE DisplayName = 'Jarrod Dixon') THEN 'Harlan'
ELSE 'Jarrod Dixon'
END AS HigherReputation;
```
=====================
Question: Please list the display names of all the users whose accounts were created in the year 2011.
 db_id: codebase_community
Planner: 1.  **Select the desired column:** We need to retrieve the `DisplayName` from the `users` table.
2.  **Filter based on the creation year:**  We need to filter the `users` table to include only records where the `CreationDate` falls within the year 2011. This can be done using a `WHERE` clause and the `year()` function.
3.  **Specify the table:** We are using the `users` table.

NL2SQL:
```sql
SELECT
  DisplayName
FROM users
WHERE
  STRFTIME('%Y', CreationDate) = '2011';
```
NL2SQL: ```sql
SELECT
  DisplayName
FROM users
WHERE
  STRFTIME('%Y', CreationDate) = '2011';
```
Critic: ```sql
SELECT
  DisplayName
FROM Users
WHERE
  STRFTIME('%Y', CreationDate) = '2011';
```
=====================
Question: How many users last accessed the website after 2014/9/1?
 db_id: codebase_community
Planner: 1.  **Identify the table:** The `users` table contains information about users, including their `LastAccessDate`.
2.  **Filter the data:** Filter the `users` table to include only users whose `LastAccessDate` is after '2014-09-01'.
3.  **Count the users:** Count the number of users that meet the criteria.

NL2SQL: ```sql
SELECT
  COUNT(Id)
FROM users
WHERE
  LastAccessDate > '2014-09-01';
```
Critic: ```sql
SELECT
  COUNT(Id)
FROM users
WHERE
  LastAccessDate > '2014-09-01';
```
=====================
Question: Who is the owner of the post "Eliciting priors from experts"?
 db_id: codebase_community
Planner: 1. Find the `Id` of the post with the title "Eliciting priors from experts" from the `posts` table.
2. Using the `OwnerUserId` from the identified post, find the corresponding `DisplayName` from the `users` table.
3. Return the `DisplayName` as the owner of the post.
Required tables: `posts`, `users`
Join condition: `posts.OwnerUserId` = `users.Id`
Selection condition: `posts.Title` = "Eliciting priors from experts"
Output column: `users.DisplayName`
NL2SQL: ```sql
SELECT
  T2.DisplayName
FROM posts AS T1
INNER JOIN users AS T2
  ON T1.OwnerUserId = T2.Id
WHERE
  T1.Title = 'Eliciting priors from experts';
```
Critic: ```sql
SELECT
  T2.DisplayName
FROM posts AS T1
INNER JOIN users AS T2
  ON T1.OwnerUserId = T2.Id
WHERE
  T1.Title = "Eliciting priors from experts";
```
=====================
Question: How many posts does the user csgillespie own?
 db_id: codebase_community
Planner: 1. Find the `Id` of the user with `DisplayName` 'csgillespie' from the `users` table.
2. Use the `Id` obtained in step 1 as the `OwnerUserId` to filter records in the `posts` table.
3. Count the number of posts that satisfy the condition in step 2.
4. Return the count.

Tables needed: `users`, `posts`
Columns needed: `users.DisplayName`, `users.Id`, `posts.OwnerUserId`, `posts.Id`
Filters: `users.DisplayName = 'csgillespie'`
Joins: None. We are using the Id from users as a filter on posts.
Aggregation: COUNT(posts.Id)

NL2SQL: ```sql
SELECT
  COUNT(p.Id)
FROM users AS u
JOIN posts AS p
  ON u.Id = p.OwnerUserId
WHERE
  u.DisplayName = 'csgillespie';
```
Critic: ```sql
SELECT
  COUNT(Id)
FROM posts
WHERE
  OwnerDisplayName = 'csgillespie';
```
=====================
Question: What is the display name of the user who last edited the post "Examples for teaching: Correlation does not mean causation"?
 db_id: codebase_community
Planner: 1. Find the `Id` of the post with `Title` = "Examples for teaching: Correlation does not mean causation" from the `posts` table.
2. Get the `LastEditorDisplayName` from the `posts` table where `Title` = "Examples for teaching: Correlation does not mean causation".

NL2SQL: ```sql
SELECT
  LastEditorDisplayName
FROM posts
WHERE
  Title = 'Examples for teaching: Correlation does not mean causation';
```
Critic: ```sql
SELECT
  T2.DisplayName
FROM posts AS T1
INNER JOIN users AS T2
  ON T1.LastEditorUserId = T2.Id
WHERE
  T1.Title = 'Examples for teaching: Correlation does not mean causation';
```
=====================
Question: Among the posts owned by an elder user, how many of them have a score of over 19?
 db_id: codebase_community
Planner: 1.  Filter users table to find elder users, i.e., those with `Age > 65`.
2.  Join the filtered users with the posts table on `users.Id = posts.OwnerUserId`.
3.  Filter the joined table where `posts.Score > 19`.
4.  Count the number of posts satisfying the condition.

NL2SQL: ```sql
SELECT
  COUNT(p.Id)
FROM Users AS u
JOIN Posts AS p
  ON u.Id = p.OwnerUserId
WHERE
  u.Age > 65 AND p.Score >= 20;
```
Critic: ```sql
SELECT
  COUNT(p.Id)
FROM Users AS u
JOIN Posts AS p
  ON u.Id = p.OwnerUserId
WHERE
  u.Age > 65 AND p.Score > 19;
```
=====================
Question: From which post is the tag "bayesian" excerpted from? Please give the body of the post.
 db_id: codebase_community
Planner: 1. Find the `ExcerptPostId` from the `tags` table where `TagName` is "bayesian".
2. Use the `ExcerptPostId` to find the corresponding `Body` from the `posts` table where `Id` matches the `ExcerptPostId`.

NL2SQL: ```sql
SELECT
  T2.Body
FROM tags AS T1
JOIN posts AS T2
  ON T1.ExcerptPostId = T2.Id
WHERE
  T1.TagName = 'bayesian';
```
Critic: ```sql
SELECT
  p.Body
FROM tags AS t
JOIN posts AS p
  ON t.ExcerptPostId = p.Id
WHERE
  t.TagName = 'bayesian';
```
=====================
Question: What is the average score of the posts owned by the user csgillespie?
 db_id: codebase_community
Planner: 1. Find the `Id` of the user with `DisplayName` 'csgillespie' from the `users` table.
2. Use the user's `Id` to filter posts in the `posts` table where `OwnerUserId` matches the user's `Id`.
3. Calculate the average `Score` of these posts.
4. Return the calculated average score.

NL2SQL: ```sql
SELECT AVG(Score) FROM posts WHERE OwnerUserId = (SELECT Id FROM users WHERE DisplayName = 'csgillespie');
```
Critic: ```sql
SELECT AVG(T1.Score) FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T2.DisplayName = 'csgillespie'
```
=====================
Question: Among the posts with a score of over 5, what is the percentage of them being owned by an elder user?
 db_id: codebase_community
Planner: Plan:
1. Filter the `posts` table to select posts with a `Score` greater than 5.
2. Join the filtered `posts` table with the `users` table using `OwnerUserId` from `posts` and `Id` from `users`.
3. Filter the joined table to count posts where `Age` from `users` is greater than 65.
4. Calculate the total number of posts with a `Score` greater than 5.
5. Divide the count of posts owned by elder users (age > 65) by the total count of posts with a score greater than 5.
6. Multiply the result by 100 to get the percentage.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T2.Age > 65 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.Id)
FROM posts AS T1
INNER JOIN users AS T2
  ON T1.OwnerUserId = T2.Id
WHERE
  T1.Score > 5;
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T2.Age > 65 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.Id)
FROM posts AS T1
INNER JOIN users AS T2
  ON T1.OwnerUserId = T2.Id
WHERE
  T1.Score > 5;
```
=====================
Question: User No.3025 gave a comment at 20:29:39 on 2014/4/23 to a post, how many favorite counts did that post get?
 db_id: codebase_community
Planner: Plan:
1. Find the `PostId` from the `comments` table where `UserId` is 3025 and `CreationDate` is '2014-04-23 20:29:39'.
2. Use the `PostId` obtained in the previous step to find the corresponding `FavoriteCount` from the `posts` table.
3. Return the `FavoriteCount`.

NL2SQL: ```sql
SELECT
  T2.FavoriteCount
FROM comments AS T1
INNER JOIN posts AS T2
  ON T1.PostId = T2.Id
WHERE
  T1.UserId = 3025 AND T1.CreationDate = '2014-04-23 20:29:39.0';
```
Critic: ```sql
SELECT
  p.FavoriteCount
FROM comments AS c
JOIN posts AS p
  ON c.PostId = p.Id
WHERE
  c.UserId = 3025 AND c.CreationDate = '2014-04-23 20:29:39';
```
=====================
Question: User No.23853 gave a comment to a post at 9:08:18 on 2013/7/12, was that post well-finished?
 db_id: codebase_community
Planner: 1. Find the PostId from the `Comments` table where `UserId` is 23853 and `CreationDate` is '2013-07-12 09:08:18.0'.
2. Use the `PostId` obtained in the previous step to query the `Posts` table.
3. Check the `ClosedDate` column in the `Posts` table. If `ClosedDate` is NULL, the post is well-finished (not closed).

Return 1 if it is well-finished, and 0 otherwise.

NL2SQL: ```sql
SELECT
  CASE
    WHEN T2.ClosedDate IS NULL
    THEN 1
    ELSE 0
  END
FROM Comments AS T1
INNER JOIN Posts AS T2
  ON T1.PostId = T2.Id
WHERE
  T1.UserId = 23853 AND T1.CreationDate = '2013-07-12 09:08:18.0';
```
Critic: ```sql
SELECT
  CASE
    WHEN T1.ClosedDate IS NULL
    THEN 0
    ELSE 1
  END
FROM Posts AS T1
INNER JOIN Comments AS T2
  ON T1.Id = T2.PostId
WHERE
  T2.UserId = 23853 AND T2.CreationDate = '2013-07-12 09:08:18.0';
```
=====================
Question: For the user with the display name of "Tiago Pasqualini", how many posts did he/she own?
 db_id: codebase_community
Planner: 1. Find the `Id` of the user with `DisplayName` equal to "Tiago Pasqualini" from the `users` table.
2. Count the number of posts where `OwnerUserId` is equal to the `Id` obtained in the previous step from the `posts` table.
3. Return the count of posts.

NL2SQL: ```sql
SELECT
  COUNT(p.Id)
FROM users AS u
JOIN posts AS p
  ON u.Id = p.OwnerUserId
WHERE
  u.DisplayName = 'Tiago Pasqualini';
```
Critic: ```sql
SELECT
  COUNT(p.Id)
FROM posts AS p
JOIN users AS u
  ON p.OwnerUserId = u.Id
WHERE
  u.DisplayName = 'Tiago Pasqualini';
```
=====================
Question: Provide the display name of the user who made the vote No.6347.
 db_id: codebase_community
Planner: Plan:
1. Filter the `votes` table to find the row where `Id` is 6347.
2. Get the `UserId` from the filtered row.
3. Use the `UserId` to find the corresponding user in the `users` table.
4. Retrieve the `DisplayName` from the `users` table.

NL2SQL: ```sql
SELECT
  T2.DisplayName
FROM votes AS T1
INNER JOIN users AS T2
  ON T1.UserId = T2.Id
WHERE
  T1.Id = 6347;
```
Critic: ```sql
SELECT
  T2.DisplayName
FROM votes AS T1
INNER JOIN Users AS T2
  ON T1.UserId = T2.Id
WHERE
  T1.Id = 6347;
```
=====================
Question: For the user No.24, how many times is the number of his/her posts compared to his/her votes?
 db_id: codebase_community
Planner: Plan:
1. Count the number of posts for user 24 from the `posts` table using `OwnerUserId = 24`.
2. Count the number of votes for user 24 from the `votes` table using `UserId = 24`.
3. Divide the post count by the vote count to get the desired ratio.
4. Return the ratio.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN p.OwnerUserId = 24 THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN v.UserId = 24 THEN 1 ELSE 0 END)
FROM posts AS p
JOIN votes AS v
  ON p.OwnerUserId = 24 AND v.UserId = 24;
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN p.OwnerUserId = 24 THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN v.UserId = 24 THEN 1 ELSE 0 END)
FROM posts AS p
CROSS JOIN votes AS v
WHERE
  p.OwnerUserId = 24 OR v.UserId = 24;
```
=====================
Question: How many views did the post titled 'Integration of Weka and/or RapidMiner into Informatica PowerCenter/Developer' get?
 db_id: codebase_community
Planner: Plan:
1. Select the `ViewCount` column from the `posts` table.
2. Filter the `posts` table to only include the row where the `Title` column is equal to 'Integration of Weka and/or RapidMiner into Informatica PowerCenter/Developer'.

NL2SQL: ```sql
SELECT
  ViewCount
FROM posts
WHERE
  Title = 'Integration of Weka and/or RapidMiner into Informatica PowerCenter/Developer';
```
Critic: ```sql
SELECT
  ViewCount
FROM posts
WHERE
  Title = 'Integration of Weka and/or RapidMiner into Informatica PowerCenter/Developer';
```
=====================
Question: Write the contents of comments with a score of 17.
 db_id: codebase_community
Planner: 1.  **Identify the table:** The question asks for the contents of comments, so we need the `comments` table.
2.  **Specify the filter:** We need to filter the `comments` table to include only comments with a score of 17. This means we need the condition `Score = 17`.
3.  **Select the column:** The question asks to write the contents of the comments, so we need to select the `Text` column.

NL2SQL: ```sql
SELECT
  Text
FROM Comments
WHERE
  Score = 17;
```
Critic: ```sql
SELECT
  Text
FROM Comments
WHERE
  Score = 17;
```
=====================
Question: Name the user that commented 'thank you user93!'
 db_id: codebase_community
Planner: Plan:
1. Filter the `comments` table to find the comment with `Text` equal to 'thank you user93!'.
2. Retrieve the `UserId` from the filtered comments.
3. Retrieve the `DisplayName` from the `users` table where `Id` matches the `UserId` obtained in step 2.

NL2SQL: ```sql
SELECT
  T1.DisplayName
FROM users AS T1
INNER JOIN comments AS T2
  ON T1.Id = T2.UserId
WHERE
  T2.Text = 'thank you user93!';
```
Critic: ```sql
SELECT
  T1.DisplayName
FROM users AS T1
INNER JOIN comments AS T2
  ON T1.Id = T2.UserId
WHERE
  T2.Text = 'thank you user93!';
```
=====================
Question: Which user made a post titled 'Understanding what Dassault iSight is doing?' and how much is the reputation of the user?
 db_id: codebase_community
Planner: 1. Find the `Id` of the post with the title 'Understanding what Dassault iSight is doing?' from the `posts` table.
2. Use the `OwnerUserId` from the `posts` table where title matches to find the `DisplayName` and `Reputation` from the `users` table.
3. Display the `DisplayName` and `Reputation`.

NL2SQL: ```sql
SELECT
  u.DisplayName,
  u.Reputation
FROM posts AS p
JOIN users AS u
  ON p.OwnerUserId = u.Id
WHERE
  p.Title = 'Understanding what Dassault iSight is doing?';
```
Critic: ```sql
SELECT
  T1.DisplayName,
  T1.Reputation
FROM Users AS T1
INNER JOIN Posts AS T2
  ON T1.Id = T2.OwnerUserId
WHERE
  T2.Title = 'Understanding what Dassault iSight is doing?';
```
=====================
Question: Who is the owner of the post titled 'Open source tools for visualizing multi-dimensional data?'
 db_id: codebase_community
Planner: We need to find the owner of a post with the title 'Open source tools for visualizing multi-dimensional data?'.
1. Find the `Id` of the post with the title 'Open source tools for visualizing multi-dimensional data?' from the `posts` table.
2. Use the `OwnerUserId` from the `posts` table to find the corresponding user in the `users` table.
3. Retrieve the `DisplayName` of the user from the `users` table.

Tables:
- posts
- users

Columns:
- posts.Id
- posts.Title
- posts.OwnerUserId
- users.Id
- users.DisplayName

Filters:
- posts.Title = 'Open source tools for visualizing multi-dimensional data?'

Joins:
- posts.OwnerUserId = users.Id

NL2SQL: ```sql
SELECT
  T2.DisplayName
FROM posts AS T1
INNER JOIN users AS T2
  ON T1.OwnerUserId = T2.Id
WHERE
  T1.Title = 'Open source tools for visualizing multi-dimensional data?';
```
Critic: ```sql
SELECT
  T2.DisplayName
FROM posts AS T1
INNER JOIN users AS T2
  ON T1.OwnerUserId = T2.Id
WHERE
  T1.Title = 'Open source tools for visualizing multi-dimensional data?';
```
=====================
Question: Write all the comments left by users who edited the post titled 'Why square the difference instead of taking the absolute value in standard deviation?'
 db_id: codebase_community
Planner: 1. Find the `Id` of the post titled 'Why square the difference instead of taking the absolute value in standard deviation?' from the `posts` table.
2. Find the `UserId` of users who edited that post by looking at the `LastEditorUserId` column in the `posts` table.
3. Retrieve comments posted by users who edited the post `Id` in the `comments` table.
4. Select the `Text` column (the comments) from the `comments` table.

NL2SQL: ```sql
SELECT
  T1.Text
FROM comments AS T1
INNER JOIN posts AS T2
  ON T1.PostId = T2.Id
WHERE
  T2.Title = 'Why square the difference instead of taking the absolute value in standard deviation?';
```
Critic: ```sql
SELECT
  PH.Comment
FROM PostHistory AS PH
JOIN Posts AS P
  ON PH.PostId = P.Id
WHERE
  P.Title = 'Why square the difference instead of taking the absolute value in standard deviation?'
  AND PH.Comment IS NOT NULL;
```
=====================
Question: Which user added a bounty amount of 50 to the post title mentioning variance?
 db_id: codebase_community
Planner: Here's my plan to retrieve the user who added a bounty of 50 to a post with "variance" in the title:

1.  **Identify relevant tables:**
    *   `Posts`: To filter posts containing "variance" in their titles.
    *   `Votes`: To filter votes with a bounty amount of 50.
    *   `Users`: To retrieve the display name of the user.

2.  **Filtering:**
    *   In the `Posts` table, filter for `Title` containing "variance".
    *   In the `Votes` table, filter for `BountyAmount` equal to 50.

3.  **Joining:**
    *   Join `Posts` and `Votes` on `Posts.Id = Votes.PostId`.
    *   Join the result with `Users` on `Votes.UserId = Users.Id`.

4.  **Selecting:**
    *   Select the `DisplayName` from the `Users` table.

NL2SQL:
```sql
SELECT
  T3.DisplayName
FROM Votes AS T1
INNER JOIN Posts AS T2
  ON T1.PostId = T2.Id
INNER JOIN Users AS T3
  ON T1.UserId = T3.Id
WHERE
  T1.BountyAmount = 50 AND T2.Title LIKE '%variance%';
```
NL2SQL: ```sql
SELECT
  T3.DisplayName
FROM Votes AS T1
INNER JOIN Posts AS T2
  ON T1.PostId = T2.Id
INNER JOIN Users AS T3
  ON T1.UserId = T3.Id
WHERE
  T1.BountyAmount = 50 AND T2.Title LIKE '%variance%';
```
Critic: ```sql
SELECT
  T2.DisplayName
FROM Votes AS T1
INNER JOIN Users AS T2
  ON T1.UserId = T2.Id
INNER JOIN Posts AS T3
  ON T1.PostId = T3.Id
WHERE
  T1.BountyAmount = 50 AND T3.Title LIKE '%variance%';
```
=====================
Question: Calculate the average view count of each post tagged as 'humor' and list the title and the comment of each post.
 db_id: codebase_community
Planner: Plan:
1. Find posts tagged as 'humor' from the `posts` table. Filter `posts` table where `Tags` contains '<humor>'.
2. Calculate the average view count of the posts identified in step 1.
3. Retrieve the Title from `posts` table.
4. Retrieve the comment from `comments` table by joining on `PostId`.
5. Combine the Title, Comment and the average view count.

NL2SQL: ```sql
SELECT
  p.Title,
  c.Text,
  AVG(p.ViewCount)
FROM posts AS p
JOIN comments AS c
  ON p.Id = c.PostId
WHERE
  p.Tags LIKE '%<humor>%'
GROUP BY
  p.Title,
  c.Text;
```
Critic: ```sql
SELECT
  p.Title,
  c.Text,
  AVG(p.ViewCount)
FROM posts AS p
JOIN comments AS c
  ON p.Id = c.PostId
WHERE
  p.Tags LIKE '%humor%'
GROUP BY
  p.Title,
  c.Text;
```
=====================
Question: How many users are awarded with more than 5 badges?
 db_id: codebase_community
Planner: Plan:
1.  Join the `badges` table on `UserId`.
2.  Group the joined table by `UserId` and count the number of badges for each user.
3.  Filter the grouped data to include only users with more than 5 badges.
4.  Count the number of distinct users that satisfy the condition.
5.  Return the count of users.

NL2SQL: ```sql
SELECT
  COUNT(DISTINCT UserId)
FROM (
  SELECT
    UserId
  FROM badges
  GROUP BY
    UserId
  HAVING
    COUNT(Name) > 5
) AS UserBadgeCounts;
```
Critic: ```sql
SELECT
  COUNT(DISTINCT UserId)
FROM badges
GROUP BY
  UserId
HAVING
  COUNT(*) > 5;
```
=====================
Question: Which user have only one post history per post and having at least 1000 views?
 db_id: codebase_community
Planner: Plan:
1. Find users with `Views` >= 1000 from the `users` table.
2. Find users who have only one post history per post, which requires counting distinct `PostId` for each `UserId` in the `postHistory` table and filtering for counts equal to 1.
3. Join the results to find the common users that meet both conditions.
4. Return the `DisplayName` of those users.
5. Tables needed: `users`, `postHistory`.
6. Columns needed: `users.Id`, `users.DisplayName`, `users.Views`, `postHistory.UserId`, `postHistory.PostId`.
7. Aggregation needed: COUNT(DISTINCT `postHistory.PostId`) GROUP BY `postHistory.UserId`.

NL2SQL: ```sql
SELECT
  u.DisplayName
FROM users AS u
JOIN (
  SELECT
    UserId
  FROM postHistory
  GROUP BY
    UserId
  HAVING
    COUNT(DISTINCT PostId) = 1
) AS ph
  ON u.Id = ph.UserId
WHERE
  u.Views >= 1000;
```
Critic: ```sql
SELECT
  u.DisplayName
FROM Users AS u
WHERE
  u.Id IN (
    SELECT
      ph.UserId
    FROM PostHistory AS ph
    GROUP BY
      ph.UserId
    HAVING
      COUNT(DISTINCT ph.PostId) = 1
  )
  AND u.Views >= 1000;
```
=====================
Question: What is the percentage difference of student badges given during 2010 and 2011?
 db_id: codebase_community
Planner: Plan:
1. Filter the `badges` table for badges with `Name` equal to 'Student'.
2. Count the number of 'Student' badges awarded in 2010.
3. Count the number of 'Student' badges awarded in 2011.
4. Calculate the percentage difference between the two counts.
5. Return the percentage difference.
Columns needed: Date, Name from table badges
Filters: Name = 'Student', Year(Date) = 2010, Year(Date) = 2011.
Aggregation: Count(Name) for 2010 and 2011.
Calculations: percentage difference = ((count_2011 - count_2010) / count_2010) * 100
Final Output: percentage difference.
```sql
WITH StudentBadges2010 AS (
  SELECT
    COUNT(Id) AS num_badges_2010
  FROM badges
  WHERE
    Name = 'Student' AND STRFTIME('%Y', Date) = '2010'
), StudentBadges2011 AS (
  SELECT
    COUNT(Id) AS num_badges_2011
  FROM badges
  WHERE
    Name = 'Student' AND STRFTIME('%Y', Date) = '2011'
)
SELECT
  CAST((
    (
      T2.num_badges_2011 - T1.num_badges_2010
    ) * 100
  ) AS REAL) / T1.num_badges_2010
FROM StudentBadges2010 AS T1, StudentBadges2011 AS T2;
```
NL2SQL: ```sql
WITH badges_2010 AS (
  SELECT
    COUNT(Id) AS count_2010
  FROM badges
  WHERE
    STRFTIME('%Y', Date) = '2010' AND Name = 'Student'
), badges_2011 AS (
  SELECT
    COUNT(Id) AS count_2011
  FROM badges
  WHERE
    STRFTIME('%Y', Date) = '2011' AND Name = 'Student'
)
SELECT
  (
    CAST(T2.count_2011 AS REAL) - T1.count_2010
  ) * 100 / T1.count_2010
FROM badges_2010 AS T1, badges_2011 AS T2;
```
Critic: ```sql
WITH badges_2010 AS (
  SELECT
    COUNT(Id) AS count_2010
  FROM badges
  WHERE
    STRFTIME('%Y', Date) = '2010' AND Name = 'Student'
), badges_2011 AS (
  SELECT
    COUNT(Id) AS count_2011
  FROM badges
  WHERE
    STRFTIME('%Y', Date) = '2011' AND Name = 'Student'
)
SELECT
  (
    (
      CAST(T2.count_2011 AS REAL) - T1.count_2010
    ) / T1.count_2010
  ) * 100
FROM badges_2010 AS T1, badges_2011 AS T2;
```
=====================
Question: What is the average of the up votes and the average user age for users creating more than 10 posts?
 db_id: codebase_community
Planner: Plan:
1. Find the users who have created more than 10 posts. This requires counting the number of posts per user.  We can use the `posts` table for this and group by `OwnerUserId`.
2. Calculate the average `UpVotes` and the average `Age` for those users. We will need to join the `users` table with the results from step 1.
3. Calculate average upvotes and average age.
4. Present the results.

NL2SQL: ```sql
SELECT
  AVG(T2.UpVotes),
  AVG(T2.Age)
FROM (
  SELECT
    OwnerUserId
  FROM posts
  GROUP BY
    OwnerUserId
  HAVING
    COUNT(OwnerUserId) > 10
) AS T1
JOIN users AS T2
  ON T1.OwnerUserId = T2.Id;
```
Critic: ```sql
SELECT
  AVG(UpVotes),
  AVG(Age)
FROM users
WHERE
  Id IN (
    SELECT
      OwnerUserId
    FROM posts
    GROUP BY
      OwnerUserId
    HAVING
      COUNT(OwnerUserId) > 10
  );
```
=====================
Question: Calculate the ratio of votes in 2010 and 2011.
 db_id: codebase_community
Planner: Plan:
1. Count the number of votes in 2010 from the `votes` table.
2. Count the number of votes in 2011 from the `votes` table.
3. Calculate the ratio of votes in 2010 to votes in 2011.
4. Return the calculated ratio.
Tables: `votes`
Columns: `CreationDate`, `Id`
Filters: YEAR(CreationDate) = 2010, YEAR(CreationDate) = 2011
Aggregations: COUNT(Id) for each year.
Calculations: ratio = COUNT(Id where YEAR(CreationDate) = 2010) / COUNT(Id where YEAR(CreationDate) = 2011)

NL2SQL: ```sql
SELECT CAST(SUM(CASE WHEN STRFTIME('%Y', CreationDate) = '2010' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN STRFTIME('%Y', CreationDate) = '2011' THEN 1 ELSE 0 END) FROM votes;
```
Critic: ```sql
SELECT CAST(SUM(CASE WHEN STRFTIME('%Y', CreationDate) = '2010' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN STRFTIME('%Y', CreationDate) = '2011' THEN 1 ELSE 0 END) FROM votes
```
=====================
Question: Which post by slashnick has the most answers count? State the post ID.
 db_id: codebase_community
Planner: Plan:
1. Find the `Id` of the user with `DisplayName` equal to 'slashnick' from the `users` table.
2. Find the post from the `posts` table. Filter by `OwnerUserId` and order by `AnswerCount` in descending order, and select the `Id`.
3. Return the `Id` of the post with the highest `AnswerCount` where the `OwnerUserId` matches the `Id` of 'slashnick'.

NL2SQL: ```sql
SELECT
  p.Id
FROM posts AS p
JOIN users AS u
  ON p.OwnerUserId = u.Id
WHERE
  u.DisplayName = 'slashnick'
ORDER BY
  p.AnswerCount DESC
LIMIT 1;
```
Critic: ```sql
SELECT
  p.Id
FROM posts AS p
JOIN users AS u
  ON p.OwnerUserId = u.Id
WHERE
  u.DisplayName = 'slashnick'
ORDER BY
  p.AnswerCount DESC
LIMIT 1;
```
=====================
Question: Among posts by Harvey Motulsky and Noah Snyder, which one has higher popularity?
 db_id: codebase_community
Planner: Plan:
1. Find the user IDs for 'Harvey Motulsky' and 'Noah Snyder' from the `users` table.
2. Filter the `posts` table to include only posts where the `OwnerUserId` matches the user IDs found in the previous step.
3. Determine the post with the maximum `ViewCount` from the filtered posts.
4. Return the title of the post.
5. Return the DisplayName of the user.

NL2SQL: ```sql
SELECT
  T1.Title,
  T2.DisplayName
FROM posts AS T1
INNER JOIN users AS T2
  ON T1.OwnerUserId = T2.Id
WHERE
  T2.DisplayName IN ('Harvey Motulsky', 'Noah Snyder')
ORDER BY
  T1.ViewCount DESC
LIMIT 1;
```
Critic: ```sql
SELECT
  p.Title,
  u.DisplayName
FROM posts AS p
JOIN users AS u
  ON p.OwnerUserId = u.Id
WHERE
  u.DisplayName IN ('Harvey Motulsky', 'Noah Snyder')
ORDER BY
  p.ViewCount DESC
LIMIT 1;
```
=====================
Question: State all the tags used by Mark Meckes in his posts that doesn't have comments.
 db_id: codebase_community
Planner: Plan:
1. Find the `UserId` of the user 'Mark Meckes' from the `Users` table.
2. Find the `PostId`s of the posts created by 'Mark Meckes' from the `Posts` table using the `OwnerUserId` column, filtering by user ID obtained in step 1.
3. Filter the posts to include only those with `CommentCount` equal to 0.
4. Extract the `Tags` from these posts.
5. Split the tags string into individual tags.
6. Return the distinct tags.

NL2SQL: ```sql
SELECT DISTINCT
  T2.TagName
FROM Posts AS T1
INNER JOIN Users AS T3
  ON T1.OwnerUserId = T3.Id
INNER JOIN Tags AS T2
  ON T2.Id = T1.Id
WHERE
  T3.DisplayName = 'Mark Meckes' AND T1.CommentCount = 0;
```
Critic: ```sql
SELECT DISTINCT
  T2.TagName
FROM Posts AS T1
INNER JOIN Users AS T3
  ON T1.OwnerUserId = T3.Id
INNER JOIN Tags AS T2
  ON T1.Tags LIKE '%' || T2.TagName || '%'
WHERE
  T3.DisplayName = 'Mark Meckes' AND T1.CommentCount = 0;
```
=====================
Question: Based on posts posted by Community, calculate the percentage of posts that use the R language.
 db_id: codebase_community
Planner: Plan:
1. Find posts with the tag 'r' using the `posts` and `tags` tables.
2. Filter posts where the OwnerDisplayName is 'Community'.
3. Calculate the number of posts with tag 'r' posted by 'Community'.
4. Calculate the total number of posts posted by 'Community'.
5. Calculate the percentage of posts with tag 'r' among all posts posted by 'Community'.
Columns needed:
- posts.Id
- posts.OwnerDisplayName
- posts.Tags
- tags.TagName
Filters:
- posts.OwnerDisplayName = 'Community'
- tags.TagName = 'r'
Joins:
- None, posts table contains all the necessary information
Aggregations:
- COUNT(posts.Id)
Calculations:
- percentage = (posts tagged with 'r' posted by 'Community') / (total posts posted by 'Community')

NL2SQL: ```sql
SELECT CAST(SUM(CASE WHEN Tags LIKE '%<r>%' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM posts WHERE OwnerDisplayName = 'Community'
```
Critic: ```sql
SELECT CAST(SUM(CASE WHEN Tags LIKE '%<r>%' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM posts
WHERE OwnerDisplayName = 'Community'
```
=====================
Question: Calculate the difference in view count from post posted by Mornington and view count from posts posted by Amos.
 db_id: codebase_community
Planner: Plan:
1. Find the user ID for 'Mornington' and 'Amos' from the `users` table.
2. Calculate the sum of `ViewCount` for posts authored by 'Mornington' from the `posts` table, using the user ID obtained in step 1.
3. Calculate the sum of `ViewCount` for posts authored by 'Amos' from the `posts` table, using the user ID obtained in step 1.
4. Subtract the sum of view counts for Amos's posts from the sum of view counts for Mornington's posts.
5. Return the difference.

NL2SQL: ```sql
SELECT
  (
    SELECT
      SUM(p.ViewCount)
    FROM posts AS p
    JOIN users AS u
      ON p.OwnerUserId = u.Id
    WHERE
      u.DisplayName = 'Mornington'
  ) - (
    SELECT
      SUM(p.ViewCount)
    FROM posts AS p
    JOIN users AS u
      ON p.OwnerUserId = u.Id
    WHERE
      u.DisplayName = 'Amos'
  );
```
Critic: ```sql
SELECT
  SUM(CASE WHEN T2.DisplayName = 'Mornington' THEN T1.ViewCount ELSE 0 END) - SUM(CASE WHEN T2.DisplayName = 'Amos' THEN T1.ViewCount ELSE 0 END)
FROM Posts AS T1
INNER JOIN Users AS T2
  ON T1.OwnerUserId = T2.Id;
```
=====================
Question: What is the average monthly number of links created in 2010 for posts that have no more than 2 answers?
 db_id: codebase_community
Planner: Plan:
1. Filter `posts` table to keep only posts with `AnswerCount` <= 2.
2. Filter `postLinks` table to keep only links created in 2010.
3. Join the filtered `posts` and `postLinks` tables on `posts.Id` = `postLinks.PostId`.
4. Count the number of links created.
5. Divide the count by 12 to get the average monthly number of links.

NL2SQL: ```sql
SELECT CAST(COUNT(T1.Id) AS REAL) / 12
FROM postLinks AS T1
INNER JOIN posts AS T2
  ON T1.PostId = T2.Id
WHERE
  STRFTIME('%Y', T1.CreationDate) = '2010' AND T2.AnswerCount <= 2;
```
Critic: ```sql
SELECT CAST(SUM(CASE WHEN T2.AnswerCount <= 2 THEN 1 ELSE 0 END) AS REAL) / 12
FROM postLinks AS T1
INNER JOIN posts AS T2
  ON T1.PostId = T2.Id
WHERE
  STRFTIME('%Y', T1.CreationDate) = '2010';
```
=====================
Question: When did 'chl' cast its first vote in a post?
 db_id: codebase_community
Planner: 1. Find the `UserId` of the user with `DisplayName` 'chl' from the `Users` table.
2. Use the `UserId` obtained in the previous step to filter the `Votes` table to find all votes cast by that user.
3. Find the minimum `CreationDate` from the filtered `Votes` table. This will give the date when the user cast their first vote.
4. Return the minimum `CreationDate`.

NL2SQL: ```sql
SELECT MIN(T2.CreationDate) FROM users AS T1 INNER JOIN votes AS T2 ON T1.Id = T2.UserId WHERE T1.DisplayName = 'chl'
```
Critic: ```sql
SELECT min(CreationDate) FROM Votes WHERE UserId = (SELECT Id FROM Users WHERE DisplayName = 'chl')
```
=====================
Question: What is the display name of the user who acquired the first Autobiographer badge?
 db_id: codebase_community
Planner: 1. Find the minimum date for the "Autobiographer" badge from the `badges` table.
2. Find the UserId associated with the minimum date from the `badges` table where the badge name is "Autobiographer".
3. Retrieve the DisplayName from the `users` table using the UserId obtained in the previous step.

NL2SQL: ```sql
SELECT
  T2.DisplayName
FROM badges AS T1
INNER JOIN users AS T2
  ON T1.UserId = T2.Id
WHERE
  T1.Name = 'Autobiographer'
ORDER BY
  T1.Date
LIMIT 1;
```
Critic: ```sql
SELECT
  T2.DisplayName
FROM badges AS T1
INNER JOIN Users AS T2
  ON T1.UserId = T2.Id
WHERE
  T1.Name = 'Autobiographer'
ORDER BY
  T1.Date
LIMIT 1;
```
=====================
Question: Among the users located in United Kingdom, how many users whose post have a total favorite amount of 4 or more?
 db_id: codebase_community
Planner: Plan:
1. Filter users based on the Location column in the `users` table to include only users from 'United Kingdom'.
2. Join the `users` table with the `posts` table on `users.Id = posts.OwnerUserId` to associate posts with their owners.
3. Filter the joined table such that `posts.FavoriteCount` is greater than or equal to 4.
4. Count the number of unique users satisfying both conditions.
5. Return this count.

NL2SQL: ```sql
SELECT
  COUNT(DISTINCT T1.Id)
FROM users AS T1
INNER JOIN posts AS T2
  ON T1.Id = T2.OwnerUserId
WHERE
  T1.Location = 'United Kingdom' AND T2.FavoriteCount >= 4;
```
Critic: ```sql
SELECT
  COUNT(DISTINCT T1.Id)
FROM users AS T1
INNER JOIN posts AS T2
  ON T1.Id = T2.OwnerUserId
WHERE
  T1.Location = 'United Kingdom' AND T2.FavoriteCount >= 4;
```
=====================
Question: Which post by Harvey Motulsky has the most views? Please give the id and title of this post.
 db_id: codebase_community
Planner: Plan:
1. Find the `Id` of the user named 'Harvey Motulsky' from the `users` table.
2. Find the posts created by this user from the `posts` table, filtering by `OwnerUserId` equal to the user's `Id` obtained in the previous step.
3. Determine the maximum `ViewCount` among the selected posts.
4. Select the `Id` and `Title` of the post that has the maximum `ViewCount`.

NL2SQL: ```sql
SELECT
  Id,
  Title
FROM posts
WHERE
  OwnerUserId = (
    SELECT
      Id
    FROM users
    WHERE
      DisplayName = 'Harvey Motulsky'
  )
ORDER BY
  ViewCount DESC
LIMIT 1;
```
Critic: ```sql
SELECT
  p.Id,
  p.Title
FROM posts AS p
JOIN users AS u
  ON p.OwnerUserId = u.Id
WHERE
  u.DisplayName = 'Harvey Motulsky'
ORDER BY
  p.ViewCount DESC
LIMIT 1;
```
=====================
Question: Which is the most valuable post in 2010? Please give its id and the owner's display name.
 db_id: codebase_community
Planner: Plan:
1. Filter posts to only include those created in 2010.
2. Select the Id and OwnerUserId of the post.
3. Join the `posts` table with the `users` table on `OwnerUserId = Id` to get the owner's display name.
4. Select the `Id` from `posts` and `DisplayName` from `users` table.
5. Order the results by the 'FavoriteCount' column in descending order.
6. Limit the result to the top 1 post to find the most valuable post.

NL2SQL: ```sql
SELECT
  p.Id,
  u.DisplayName
FROM posts AS p
JOIN users AS u
  ON p.OwnerUserId = u.Id
WHERE
  STRFTIME('%Y', p.CreaionDate) = '2010'
ORDER BY
  p.FavoriteCount DESC
LIMIT 1;
```
Critic: ```sql
SELECT
  p.Id,
  u.DisplayName
FROM posts AS p
JOIN users AS u
  ON p.OwnerUserId = u.Id
WHERE
  STRFTIME('%Y', p.CreaionDate) = '2010'
ORDER BY
  p.FavoriteCount DESC
LIMIT 1;
```
=====================
Question: What is the percentage of posts whose owners had a reputation of over 1000 in 2011?
 db_id: codebase_community
Planner: Plan:
1. Find the total number of posts created in 2011.
2. Find the number of posts created in 2011 whose owners had a reputation greater than 1000.
3. Calculate the percentage by dividing the number of posts from step 2 by the number of posts from step 1 and multiplying by 100.

Tables:
- posts: To filter posts by creation date (YEAR(CreationDate) = 2011) and get the OwnerUserId.
- users: To filter users with a reputation greater than 1000 (Reputation > 1000) and join with posts table on UserId.

Columns:
- posts.Id: To count the number of posts.
- posts.CreaionDate: To filter posts created in 2011.
- posts.OwnerUserId: To join with users table.
- users.Id: To join with posts table.
- users.Reputation: To filter users with a reputation greater than 1000.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T2.Reputation > 1000 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.Id)
FROM Posts AS T1
INNER JOIN Users AS T2
  ON T1.OwnerUserId = T2.Id
WHERE
  STRFTIME('%Y', T1.CreaionDate) = '2011';
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T2.Reputation > 1000 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.Id)
FROM Posts AS T1
INNER JOIN Users AS T2
  ON T1.OwnerUserId = T2.Id
WHERE
  STRFTIME('%Y', T1.CreaionDate) = '2011'
  AND T1.OwnerUserId IS NOT NULL;
```
=====================
Question: Identify the total views on the post 'Computer Game Datasets'. Name the user who posted it last time.
 db_id: codebase_community
Planner: Here's the plan to answer the question:

1.  **Find the post:** Use the `posts` table to find the post with the title 'Computer Game Datasets'.
2.  **Get the ViewCount:** Retrieve the `ViewCount` from the `posts` table for the identified post.
3.  **Find the last editor:** Use the `LastEditorUserId` from the `posts` table to find the user who last edited the post.
4.  **Get the user's display name:** Use the `users` table and the `LastEditorUserId` to find the `DisplayName` of the last editor.
5.  **Output:** Display the `ViewCount` and the `DisplayName`.

NL2SQL: ```sql
SELECT
  p.ViewCount,
  u.DisplayName
FROM posts AS p
JOIN users AS u
  ON p.LastEditorUserId = u.Id
WHERE
  p.Title = 'Computer Game Datasets';
```
Critic: ```sql
SELECT
  p.ViewCount,
  u.DisplayName
FROM posts AS p
JOIN users AS u
  ON p.LastEditorUserId = u.Id
WHERE
  p.Title = 'Computer Game Datasets';
```
=====================
Question: How many comments were added to the post with the highest score?
 db_id: codebase_community
Planner: Plan:
1. Find the maximum score from the `posts` table.
2. Find the `Id` of the post with the maximum score.
3. Count the number of comments associated with the post `Id` found in step 2 from the `comments` table.
4. Return the count of comments.

NL2SQL: ```sql
SELECT
  COUNT(c.Id)
FROM posts AS p
JOIN comments AS c
  ON p.Id = c.PostId
WHERE
  p.Score = (
    SELECT
      MAX(Score)
    FROM posts
  );
```
Critic: ```sql
SELECT
  CommentCount
FROM posts
ORDER BY
  Score DESC
LIMIT 1;
```
=====================
Question: Provide the text of the latest 10 comments to the post with the title 'Analysing wind data with R' and the display name of the user who left it.
 db_id: codebase_community
Planner: 1. Find the `PostId` of the post with the title 'Analysing wind data with R' from the `posts` table.
2. Retrieve the `Text`, `UserId`, and `CreationDate` of comments for the obtained `PostId` from the `comments` table.
3. Retrieve the `DisplayName` of users from the `users` table using `UserId` from the `comments` table.
4. Order the comments by `CreationDate` in descending order and limit the result to the latest 10 comments.
5. Output the `Text` of the comment and the `DisplayName` of the user.

NL2SQL: ```sql
SELECT
  c.Text,
  u.DisplayName
FROM comments AS c
JOIN posts AS p
  ON c.PostId = p.Id
JOIN users AS u
  ON c.UserId = u.Id
WHERE
  p.Title = 'Analysing wind data with R'
ORDER BY
  c.CreationDate DESC
LIMIT 10;
```
Critic: ```sql
SELECT
  T1.Text,
  T2.DisplayName
FROM Comments AS T1
INNER JOIN Posts AS T3
  ON T1.PostId = T3.Id
INNER JOIN Users AS T2
  ON T1.UserId = T2.Id
WHERE
  T3.Title = 'Analysing wind data with R'
ORDER BY
  T1.CreationDate DESC
LIMIT 10;
```
=====================
Question: Among all the posts posted by the most influential user, identify the percentage with a score above 50.
 db_id: codebase_community
Planner: Here's a plan to determine the percentage of posts with a score above 50 among the posts by the most influential user:

1.  **Identify the most influential user:** Find the user with the highest reputation from the `users` table.
2.  **Find posts by the most influential user:** Select all posts from the `posts` table where the `OwnerUserId` matches the `Id` of the most influential user.
3.  **Filter posts with a score above 50:** From the posts identified in step 2, filter for those with a `Score` greater than 50.
4.  **Calculate the percentage:** Divide the count of posts with a score above 50 (step 3) by the total number of posts by the most influential user (step 2) and multiply by 100.
5. Return this percentage.

I will use the following tables and columns:

*   `users`: `Id`, `Reputation`
*   `posts`: `Id`, `OwnerUserId`, `Score`

I'll use a subquery to find the most influential user and then join or filter the posts table based on that user's ID.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.Score > 50 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.Id)
FROM posts AS T1
WHERE
  T1.OwnerUserId = (
    SELECT
      Id
    FROM users
    ORDER BY
      Reputation DESC
    LIMIT 1
  );
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.Score > 50 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.Id)
FROM posts AS T1
WHERE
  T1.OwnerUserId = (
    SELECT
      Id
    FROM users
    ORDER BY
      Reputation DESC
    LIMIT 1
  );
```
=====================
Question: What is the excerpt post ID and wiki post ID of the tag named sample?
 db_id: codebase_community
Planner: Plan:
1. Filter the `tags` table to find the row where `TagName` is 'sample'.
2. Retrieve the `ExcerptPostId` and `WikiPostId` from the filtered row.

NL2SQL: ```sql
SELECT ExcerptPostId, WikiPostId
FROM tags
WHERE TagName = 'sample';
```
Critic: ```sql
SELECT ExcerptPostId, WikiPostId
FROM tags
WHERE TagName = 'sample';
```
=====================
Question: Give the user's reputation and up vote number of the user that commented "fine, you win :)".
 db_id: codebase_community
Planner: 1.  Find the `UserId` from the `comments` table where `Text` is 'fine, you win :)'.
2.  Retrieve the `Reputation` and `UpVotes` from the `users` table using the `UserId` obtained in step 1.

NL2SQL: ```sql
SELECT
  T1.Reputation,
  T1.UpVotes
FROM users AS T1
INNER JOIN comments AS T2
  ON T1.Id = T2.UserId
WHERE
  T2.Text = 'fine, you win :)';
```
Critic: ```sql
SELECT
  T1.Reputation,
  T1.UpVotes
FROM users AS T1
INNER JOIN Comments AS T2
  ON T1.Id = T2.UserId
WHERE
  T2.Text = 'fine, you win :)';
```
=====================
Question: Among the posts with views ranging from 100 to 150, what is the comment with the highest score?
 db_id: codebase_community
Planner: 1. Find posts with `ViewCount` between 100 and 150 from the `posts` table.
2. Get the `Id` of these posts.
3. Find the comments associated with these `PostId`s from the `comments` table.
4. Find the comment with the highest `Score` among the comments found in step 3.
5. Return the `Text` of that comment.

NL2SQL: ```sql
SELECT
  Text
FROM comments
WHERE
  PostId IN (
    SELECT
      Id
    FROM posts
    WHERE
      ViewCount BETWEEN 100 AND 150
  )
ORDER BY
  Score DESC
LIMIT 1;
```
Critic: ```sql
SELECT
  Text
FROM comments
WHERE
  PostId IN (
    SELECT
      Id
    FROM posts
    WHERE
      ViewCount BETWEEN 100 AND 150
  )
ORDER BY
  Score DESC
LIMIT 1;
```
=====================
Question: In posts with 1 comment, how many of the comments have 0 score?
 db_id: codebase_community
Planner: Plan:
1. Filter posts to only include those with `CommentCount = 1`.
2. Join the filtered posts with the `comments` table on `posts.Id = comments.PostId`.
3. Filter the joined table to include only comments with `Score = 0`.
4. Count the number of comments that satisfy the above conditions.
Tables:
- posts
- comments

Columns:
- posts.Id
- posts.CommentCount
- comments.PostId
- comments.Score

NL2SQL: ```sql
SELECT
  COUNT(T2.Id)
FROM posts AS T1
INNER JOIN comments AS T2
  ON T1.Id = T2.PostId
WHERE
  T1.CommentCount = 1 AND T2.Score = 0;
```
Critic: ```sql
SELECT
  COUNT(T1.Id)
FROM Comments AS T1
JOIN Posts AS T2
  ON T1.PostId = T2.Id
WHERE
  T2.CommentCount = 1 AND T1.Score = 0;
```
=====================
Question: Among the comments with scores between 5 to 10, what is the percentage of the users with 0 up votes?
 db_id: codebase_community
Planner: Here's the plan to calculate the percentage of users with 0 upvotes among comments with scores between 5 and 10:

1.  **Identify Comments within the Score Range:** Filter the `comments` table to select comments where the `Score` is between 5 and 10 (inclusive).
2.  **Extract User IDs:**  From the filtered comments, get the distinct `UserId` values. These are the users who made the relevant comments.
3.  **Find Users with Zero Upvotes:** Filter the `users` table to find users with `UpVotes = 0`.
4.  **Identify Users with Zero Upvotes who made qualifying comments:** Find the intersection of UserIds extracted at Step 2, with those UserIds identified at Step 3.
5.  **Calculate the Percentage:** Divide the count of the distinct users identified at Step 4. by the count of distinct user identified in Step 2, multiply by 100.
NL2SQL:
```sql
SELECT
  CAST(SUM(CASE WHEN T2.UpVotes = 0 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.UserId)
FROM comments AS T1
INNER JOIN users AS T2
  ON T1.UserId = T2.Id
WHERE
  T1.Score BETWEEN 5 AND 10;
```
NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T2.UpVotes = 0 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.UserId)
FROM comments AS T1
INNER JOIN users AS T2
  ON T1.UserId = T2.Id
WHERE
  T1.Score BETWEEN 5 AND 10
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T2.UpVotes = 0 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.UserId)
FROM comments AS T1
INNER JOIN users AS T2
  ON T1.UserId = T2.Id
WHERE
  T1.Score BETWEEN 5 AND 10;
```
=====================
Question: Which are the cards that have incredibly powerful foils.
 db_id: card_games
Planner: Plan:
1. Filter the `cards` table for cards where `cardKingdomFoilId` is not null and `cardKingdomId` is not null.
2. Select the `name` of the cards that satisfy the filter.

NL2SQL: ```sql
SELECT
  name
FROM cards
WHERE
  cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL;
```
Critic: ```sql
SELECT
  name
FROM cards
WHERE
  cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL;
```
=====================
Question: What are the borderless cards available without powerful foils?
 db_id: card_games
Planner: Plan:
1. Filter the `cards` table for cards with `borderColor` equal to 'borderless'.
2. Further filter the results to exclude cards that have a `cardKingdomFoilId` and `cardKingdomId` that are not null.
3. Select the `name` column from the filtered results.

NL2SQL: ```sql
SELECT
  name
FROM cards
WHERE
  borderColor = 'borderless' AND (
    cardKingdomFoilId IS NULL OR cardKingdomId IS NULL
  );
```
Critic: ```sql
SELECT
  name
FROM cards
WHERE
  borderColor = 'borderless' AND cardKingdomFoilId IS NULL;
```
=====================
Question: List all the mythic rarity print cards banned in gladiator format.
 db_id: card_games
Planner: Plan:
1. Join the `cards` table and the `legalities` table on the `uuid` column.
2. Filter the joined table where the `format` column in the `legalities` table is equal to 'gladiator'.
3. Filter the joined table where the `rarity` column in the `cards` table is equal to 'mythic'.
4. Filter the joined table where the `status` column in the `legalities` table is equal to 'Banned'.
5. Select the `name` column from the `cards` table.
NL2SQL: ```sql
SELECT
  T1.name
FROM cards AS T1
INNER JOIN legalities AS T2
  ON T1.uuid = T2.uuid
WHERE
  T2.format = 'gladiator' AND T1.rarity = 'mythic' AND T2.status = 'Banned';
```
Critic: ```sql
SELECT
  T1.name
FROM cards AS T1
INNER JOIN legalities AS T2
  ON T1.uuid = T2.uuid
WHERE
  T1.rarity = 'mythic' AND T2.format = 'Gladiator' AND T2.status = 'Banned';
```
=====================
Question: For artifact type of cards that do not have multiple faces on the same card, state its legalities status for vintage play format.
 db_id: card_games
Planner: Here's the plan to retrieve the legality status for artifact cards without multiple faces in the Vintage format:

1.  **Identify artifact cards:** Filter the `cards` table for cards where `types` contains 'Artifact'.
2.  **Exclude multi-faced cards:** Filter the `cards` table for cards where `side` is NULL.
3.  **Join with legalities:** Join the filtered `cards` table with the `legalities` table using the `uuid` column.
4.  **Filter for Vintage format:** Filter the `legalities` table for entries where `format` is 'Vintage'.
5.  **Retrieve the legality status:** Select the `status` column from the `legalities` table.

SQL query will return legalities status for vintage play format of artifact cards without multiple faces on the same card.

NL2SQL: ```sql
SELECT
  T2.status
FROM cards AS T1
INNER JOIN legalities AS T2
  ON T1.uuid = T2.uuid
WHERE
  T1.types = 'Artifact' AND T1.side IS NULL AND T2.format = 'Vintage';
```
Critic: ```sql
SELECT
  T2.status
FROM cards AS T1
INNER JOIN legalities AS T2
  ON T1.uuid = T2.uuid
WHERE
  T1.types = 'Artifact' AND T1.layout <> 'split' AND T2.format = 'Vintage';
```
=====================
Question: List all the card id and artist with unknown power which are legal for commander play format.
 db_id: card_games
Planner: Here's the plan to retrieve the card IDs and artists of cards with unknown power that are legal in the Commander format:

1.  **Join `cards` and `legalities` tables:** Join the `cards` table with the `legalities` table using the `uuid` column in `legalities` and the `uuid` column in `cards`.
2.  **Filter for Commander format:** Filter the results to include only records where `legalities.format` is 'Commander'.
3.  **Filter for legality status:** Filter the results further to include only records where `legalities.status` is 'Legal'.
4.  **Filter for unknown power:** Filter the results to include only records where `cards.power` is '*' or `cards.power` is NULL.
5.  **Select desired columns:** Select the `cards.id` and `cards.artist` columns for the final output.

NL2SQL: ```sql
SELECT
  c.id,
  c.artist
FROM cards AS c
JOIN legalities AS l
  ON c.uuid = l.uuid
WHERE
  l.format = 'Commander' AND l.status = 'Legal' AND (
    c.power = '*' OR c.power IS NULL
  );
```
Critic: ```sql
SELECT
  c.id,
  c.artist
FROM cards AS c
INNER JOIN legalities AS l
  ON c.uuid = l.uuid
WHERE
  l.format = 'Commander' AND l.status = 'Legal' AND (
    c.power IS NULL OR c.power = '*'
  );
```
=====================
Question: Find all cards illustrated by Stephen Daniel and describe the text of the ruling of these cards. State if these cards have missing or degraded properties and values.
 db_id: card_games
Planner: Here's the plan to answer the question:

1.  **Filter Cards by Artist:** We need to find all cards where the `artist` column in the `cards` table is 'Stephen Daniele'.
2.  **Retrieve UUIDs:** From the filtered cards, we need to retrieve the `uuid` of each card.
3.  **Join with Rulings:** Join the `cards` table with the `rulings` table using the `uuid` column in `cards` and the `uuid` column in `rulings`.
4.  **Select Card Name, Ruling Text and Content Warning**: Retrieve the card name, the ruling text and hasContentWarning from `cards` and `rulings` table

Final Answer:
The final query should select the name of the card, the text of the ruling, and if the card has content warning.

NL2SQL: ```sql
SELECT
  c.name,
  r.text,
  c.hasContentWarning
FROM cards AS c
JOIN rulings AS r
  ON c.uuid = r.uuid
WHERE
  c.artist = 'Stephen Daniele';
```
Critic: ```sql
SELECT
  c.name,
  r.text,
  CASE WHEN c.hasContentWarning = 1 THEN 'Yes' ELSE 'No' END AS hasContentWarning
FROM cards AS c
JOIN rulings AS r
  ON c.uuid = r.uuid
WHERE
  c.artist = 'Stephen Daniele';
```
=====================
Question: Name the card and artist with the most ruling information. Also state if the card is a promotional printing.
 db_id: card_games
Planner: Plan:
1. Join the `cards` and `rulings` tables on their common `uuid` column.
2. Group the result by card `name` and `artist`, and count the number of rulings for each group.
3. Find the maximum ruling count.
4. Filter the grouped results to include only the card with the maximum ruling count.
5. Select the card `name`, `artist`, and `isPromo` status for the result.

NL2SQL: ```sql
SELECT
  c.name,
  c.artist,
  c.isPromo
FROM cards AS c
JOIN rulings AS r
  ON c.uuid = r.uuid
GROUP BY
  c.name,
  c.artist,
  c.isPromo
ORDER BY
  COUNT(r.uuid) DESC
LIMIT 1;
```
Critic: ```sql
SELECT
  T1.name,
  T1.artist,
  T1.isPromo
FROM cards AS T1
INNER JOIN rulings AS T2
  ON T1.uuid = T2.uuid
GROUP BY
  T1.uuid
ORDER BY
  COUNT(T2.uuid) DESC
LIMIT 1;
```
=====================
Question: Calculate the percentage of the cards availabe in Chinese Simplified.
 db_id: card_games
Planner: 1.  Count the total number of cards. This can be done by counting the number of distinct `uuid`s in the `foreign_data` table.
2.  Count the number of cards available in 'Chinese Simplified'. This can be achieved by counting the number of `uuid`s in the `foreign_data` table where the `language` is 'Chinese Simplified'.
3.  Calculate the percentage by dividing the count of cards in 'Chinese Simplified' by the total count of cards and multiplying by 100.
Tables: foreign_data
Columns: uuid, language
Filters: language = 'Chinese Simplified'
Aggregations: COUNT(DISTINCT uuid)
Calculations: percentage = (COUNT(DISTINCT uuid) where language = 'Chinese Simplified') / (COUNT(DISTINCT uuid)) * 100
NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN language = 'Chinese Simplified' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id)
FROM foreign_data;
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN language = 'Chinese Simplified' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(uuid)
FROM foreign_data;
```
=====================
Question: How many cards have infinite power?
 db_id: card_games
Planner: 1.  Filter the `cards` table where `power` is equal to "*".
2.  Count the number of cards that satisfy the condition.

Final Answer:
```sql
SELECT count(*) FROM cards WHERE power = '*'
```
NL2SQL: ```sql
SELECT count(*) FROM cards WHERE power = '*'
```
Critic: ```sql
SELECT COUNT(*) FROM cards WHERE power = '*'
```
=====================
Question: What is the border color of card "Ancestor's Chosen"?
 db_id: card_games
Planner: 1.  **Find the card:** Use the `cards` table and filter by `name` to find the card named "Ancestor's Chosen".
2.  **Retrieve the border color:** Select the `borderColor` column from the `cards` table for the found card.

Plan:

```
SELECT borderColor FROM cards WHERE name = "Ancestor's Chosen"
```
NL2SQL: ```sql
SELECT borderColor FROM cards WHERE name = "Ancestor's Chosen"
```
Critic: ```sql
SELECT borderColor FROM cards WHERE name = "Ancestor's Chosen"
```
=====================
Question: What is the rule of playing card "Benalish Knight"?
 db_id: card_games
Planner: 1.  Find the uuid of the card named "Benalish Knight" in the `cards` table.
2.  Use the uuid to find the rulings from the `rulings` table.
3.  Return the `text` from the `rulings` table.

NL2SQL: ```sql
SELECT
  T1.text
FROM rulings AS T1
INNER JOIN cards AS T2
  ON T1.uuid = T2.uuid
WHERE
  T2.name = 'Benalish Knight';
```
Critic: ```sql
SELECT
  T1.text
FROM rulings AS T1
INNER JOIN cards AS T2
  ON T1.uuid = T2.uuid
WHERE
  T2.name = 'Benalish Knight';
```
=====================
Question: What is the percentage of borderless cards?
 db_id: card_games
Planner: 1.  Count the total number of cards in the `cards` table.
2.  Count the number of cards where `borderColor` is 'borderless'.
3.  Calculate the percentage of borderless cards by dividing the count of borderless cards by the total number of cards and multiplying by 100.
4.  Display the calculated percentage.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN borderColor = 'borderless' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id)
FROM cards;
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN borderColor = 'borderless' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id)
FROM cards;
```
=====================
Question: What is the percentage of cards whose language is French among the Story Spotlight cards?
 db_id: card_games
Planner: 1.  Find the total number of Story Spotlight cards. Filter the `cards` table where `isStorySpotlight = 1` and count the number of cards.
2.  Find the number of Story Spotlight cards in French. Join `cards` and `foreign_data` tables on their `uuid` column. Filter the joined table where `isStorySpotlight = 1` and `language = 'French'` and count the number of cards.
3.  Calculate the percentage. Divide the number of French Story Spotlight cards by the total number of Story Spotlight cards, and multiply by 100.
NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T2.language = 'French' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.uuid)
FROM cards AS T1
INNER JOIN foreign_data AS T2
  ON T1.uuid = T2.uuid
WHERE
  T1.isStorySpotlight = 1;
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T2.language = 'French' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id)
FROM cards AS T1
INNER JOIN foreign_data AS T2
  ON T1.uuid = T2.uuid
WHERE
  T1.isStorySpotlight = 1;
```
=====================
Question: How many cards with original type of "Summon - Angel" have subtype other than "Angel"?
 db_id: card_games
Planner: 1. Filter `cards` table by `originalType` = "Summon - Angel".
2. Filter the result where `subtypes` is not "Angel".
3. Count the number of cards that satisfy the conditions.
Columns needed: subtypes, originalType.
Tables needed: cards.

NL2SQL: ```sql
SELECT
  COUNT(*)
FROM cards
WHERE
  originalType = 'Summon - Angel' AND subtypes <> '["Angel"]';
```
Critic: ```sql
SELECT
  COUNT(*)
FROM cards
WHERE
  originalType = 'Summon - Angel' AND subtypes NOT LIKE '%Angel%';
```
=====================
Question: What are the cards belong to duel deck a? List the ID.
 db_id: card_games
Planner: The question asks for the IDs of cards that belong to duel deck 'a'.
1.  We need to select the `id` column from the `cards` table.
2.  We need to filter the `cards` table by the `duelDeck` column, where `duelDeck` is equal to 'a'.

NL2SQL: ```sql
SELECT
  id
FROM cards
WHERE
  duelDeck = 'a';
```
Critic: ```sql
SELECT
  id
FROM cards
WHERE
  duelDeck = 'a';
```
=====================
Question: How many of the banned cards are white border?
 db_id: card_games
Planner: 1.  Join the `cards` table and the `legalities` table on the `uuid` column.
2.  Filter for `legalities.status` equal to 'Banned'.
3.  Filter for `cards.borderColor` equal to 'white'.
4.  Count the number of cards that satisfy both conditions.
NL2SQL: ```sql
SELECT
  COUNT(T1.uuid)
FROM cards AS T1
INNER JOIN legalities AS T2
  ON T1.uuid = T2.uuid
WHERE
  T2.status = 'Banned' AND T1.borderColor = 'white';
```
Critic: ```sql
SELECT
  COUNT(T1.uuid)
FROM cards AS T1
INNER JOIN legalities AS T2
  ON T1.uuid = T2.uuid
WHERE
  T2.status = 'Banned' AND T1.borderColor = 'white';
```
=====================
Question: Among the Artifact cards, which are black color and comes with foreign languague translation?
 db_id: card_games
Planner: Here's my plan to answer this question:

1.  **Filter for Artifact Cards:** Start with the `cards` table and filter for cards where `types` contains 'Artifact'.
2.  **Filter for Black Color:** Filter the cards where `colors` contains 'B'.
3.  **Join with foreign_data:** Join the `cards` table with the `foreign_data` table on the `uuid` column.
4.  **Select Card Names:** Select the `name` column from the `cards` table to display the names of the cards that satisfy all the conditions.

Let's convert this plan into SQL.

NL2SQL: ```sql
SELECT
  c.name
FROM cards AS c
JOIN foreign_data AS fd
  ON c.uuid = fd.uuid
WHERE
  c.types LIKE '%Artifact%' AND c.colors LIKE '%B%';
```
Critic: ```sql
SELECT DISTINCT
  c.name
FROM cards AS c
JOIN foreign_data AS fd
  ON c.uuid = fd.uuid
WHERE
  c.types LIKE '%Artifact%' AND c.colors LIKE '%B%'
ORDER BY
  c.name;
```
=====================
Question: What is the mana cost of cards with a normal layout, a 2003 frame version, with a black border color, and available in paper and mtgo?
 db_id: card_games
Planner: 1.  Filter `cards` table by `layout` = 'normal', `frameVersion` = '2003', `borderColor` = 'black', and `availability` = 'paper,mtgo'.
2.  Select the `manaCost` column from the filtered table.
NL2SQL: ```sql
SELECT
  manaCost
FROM cards
WHERE
  layout = 'normal' AND frameVersion = '2003' AND borderColor = 'black' AND availability = 'paper,mtgo';
```
Critic: ```sql
SELECT
  manaCost
FROM cards
WHERE
  layout = 'normal' AND frameVersion = '2003' AND borderColor = 'black' AND availability LIKE '%paper%' AND availability LIKE '%mtgo%';
```
=====================
Question: What is the percentage of Story Spotlight cards that do not have a text box? List them by their ID.
 db_id: card_games
Planner: 1.  Filter the `cards` table for `isStorySpotlight = 1` to get all Story Spotlight cards.
2.  Calculate the total number of Story Spotlight cards.
3.  Filter the `cards` table for `isStorySpotlight = 1` AND `isTextless = 1` to get all Story Spotlight cards without a text box.
4.  Calculate the number of Story Spotlight cards without a text box.
5.  Calculate the percentage of Story Spotlight cards that don't have a text box.
6.  List them by their ID.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN isTextless = 1 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id),
  id
FROM cards
WHERE
  isStorySpotlight = 1
GROUP BY
  id;
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN text IS NULL OR text = '' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id),
  id
FROM cards
WHERE
  isStorySpotlight = 1
GROUP BY
  id;
```
=====================
Question: How many Brazilian Portuguese translated sets are inside the Commander block?
 db_id: card_games
Planner: 1.  Filter the `sets` table to find sets where the `block` is 'Commander'.
2.  Join the `sets` table with the `set_translations` table on `sets.code` = `set_translations.setCode`.
3.  Filter the joined table to find translations where the `language` is 'Portuguese (Brasil)'.
4.  Count the distinct `sets.code` to get the number of Brazilian Portuguese translated sets within the Commander block.

NL2SQL: ```sql
SELECT
  COUNT(DISTINCT T1.code)
FROM sets AS T1
INNER JOIN set_translations AS T2
  ON T1.code = T2.setCode
WHERE
  T1.block = 'Commander' AND T2.language = 'Portuguese (Brasil)';
```
Critic: ```sql
SELECT
  COUNT(DISTINCT T1.code)
FROM sets AS T1
INNER JOIN set_translations AS T2
  ON T1.code = T2.setCode
WHERE
  T1.block = 'Commander' AND T2.language = 'Brazilian Portuguese';
```
=====================
Question: Lists all types of cards in German.
 db_id: card_games
Planner: 1.  Find the card types (types column in the cards table)
2.  Find corresponding German translations of card types from the foreign_data table, where the language is German.
3.  Select the translated card types.
4.  Make sure to get distinct values.

NL2SQL: ```sql
SELECT DISTINCT
  T1.type
FROM foreign_data AS T1
INNER JOIN cards AS T2
  ON T1.uuid = T2.uuid
WHERE
  T1.language = 'German' AND T1.type IS NOT NULL;
```
Critic: ```sql
SELECT DISTINCT
  type
FROM foreign_data
WHERE
  language = 'German' AND type IS NOT NULL;
```
=====================
Question: How many unknown power cards contain info about the triggered ability
 db_id: card_games
Planner: 1.  Filter `cards` table to get cards with unknown power. This can be achieved by filtering records where `power` is NULL or '*'.
2.  Filter the cards obtained in the previous step such that the `text` contains 'triggered ability'.
3.  Count the number of cards obtained.

NL2SQL: ```sql
SELECT
  COUNT(id)
FROM cards
WHERE
  (
    power IS NULL
    OR power = '*'
  )
  AND text LIKE '%triggered ability%';
```
Critic: ```sql
SELECT
  COUNT(id)
FROM cards
WHERE
  (
    power IS NULL
    OR power = '*'
  )
  AND text LIKE '%triggered ability%';
```
=====================
Question: Indicates the number of cards with pre-modern format, ruling text "This is a triggered mana ability." that do not have multiple faces.
 db_id: card_games
Planner: Plan:
1. Join the `cards` table with the `legalities` table on their respective UUID columns to filter cards that are legal in the premodern format.
2. Filter the cards to only include those whose text contains 'This is a triggered mana ability.' and which don't have multiple faces (side is NULL).
3. Count the distinct card UUIDs that satisfy the above conditions.
4. Return the count.

NL2SQL: ```sql
SELECT
  COUNT(DISTINCT T1.uuid)
FROM cards AS T1
INNER JOIN legalities AS T2
  ON T1.uuid = T2.uuid
WHERE
  T2.format = 'premodern' AND T1.text LIKE '%This is a triggered mana ability.%' AND T1.side IS NULL;
```
Critic: ```sql
SELECT
  COUNT(DISTINCT T1.uuid)
FROM cards AS T1
INNER JOIN rulings AS T2
  ON T1.uuid = T2.uuid
INNER JOIN legalities AS T3
  ON T1.uuid = T3.uuid
WHERE
  T3.format = 'premodern' AND T2.text = 'This is a triggered mana ability.' AND T1.side IS NULL;
```
=====================
Question: What is the foreign name of the card in French of type Creature, normal layout and black border color, by artist Matthew D. Wilson?
 db_id: card_games
Planner: Here's my plan to answer the question:
1.  **Find the card:** Filter the `cards` table for cards that satisfy the following criteria:
    *   `type` contains 'Creature'.
    *   `layout` is 'normal'.
    *   `borderColor` is 'black'.
    *   `artist` is 'Matthew D. Wilson'.
2.  **Join with foreign data:** Join the `cards` table with the `foreign_data` table using the `uuid` column.
3.  **Filter for French language:** Filter the joined table for rows where the `language` column in the `foreign_data` table is 'French'.
4.  **Retrieve the foreign name:** Select the `name` column from the `foreign_data` table, which represents the foreign name of the card in French.

NL2SQL: ```sql
SELECT
  T2.name
FROM cards AS T1
INNER JOIN foreign_data AS T2
  ON T1.uuid = T2.uuid
WHERE
  T1.type LIKE '%Creature%' AND T1.layout = 'normal' AND T1.borderColor = 'black' AND T1.artist = 'Matthew D. Wilson' AND T2.language = 'French';
```
Critic: ```sql
SELECT
  T2.name
FROM cards AS T1
INNER JOIN foreign_data AS T2
  ON T1.uuid = T2.uuid
WHERE
  T1.types LIKE '%Creature%' AND T1.layout = 'normal' AND T1.borderColor = 'black' AND T1.artist = 'Matthew D. Wilson' AND T2.language = 'French';
```
=====================
Question: What language is the set of 180 cards that belongs to the Ravnica block translated into?
 db_id: card_games
Planner: Plan:
1. Find the set code for the Ravnica block using the `sets` table, filtering by `block = 'Ravnica'`.
2. Find the `language` from `set_translations` table where `setCode` matches set code from step 1.
3. Return the language.
I assume we are looking for translations of the set itself and not translations of the card data.
I assume we are looking for all languages that the sets in the Ravnica block were translated into.
NL2SQL: ```sql
SELECT DISTINCT
  T2.language
FROM sets AS T1
INNER JOIN set_translations AS T2
  ON T1.code = T2.setCode
WHERE
  T1.block = 'Ravnica' AND T1.baseSetSize = 180;
```
Critic: ```sql
SELECT DISTINCT
  T3.language
FROM cards AS T1
INNER JOIN sets AS T2
  ON T1.setCode = T2.code
INNER JOIN foreign_data AS T3
  ON T1.uuid = T3.uuid
WHERE
  T2.block = 'Ravnica'
LIMIT 1
```
=====================
Question: What percentage of cards with format commander and legal status do not have a content warning?
 db_id: card_games
Planner: 1.  **Join `cards` and `legalities`:** Join the `cards` table with the `legalities` table on the `uuid` column to link card information with legality information.
2.  **Filter:** Filter the results to include only cards where `format` is 'Commander' and `status` is 'Legal'.
3.  **Calculate counts:** Count the number of cards that satisfy the format and legality conditions and also have `hasContentWarning` equal to 0. Also, count the number of cards that satisfy the format and legality conditions.
4.  **Calculate percentage:** Divide the count of cards with `hasContentWarning` = 0 by the total count of cards satisfying the format and legality conditions. Multiply the result by 100 to express it as a percentage.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.hasContentWarning = 0 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.uuid)
FROM cards AS T1
INNER JOIN legalities AS T2
  ON T1.uuid = T2.uuid
WHERE
  T2.format = 'Commander' AND T2.status = 'Legal';
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.hasContentWarning = 0 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id)
FROM cards AS T1
INNER JOIN legalities AS T2
  ON T1.uuid = T2.uuid
WHERE
  T2.format = 'Commander' AND T2.status = 'Legal';
```
=====================
Question: What percentage of cards without power are in French?
 db_id: card_games
Planner: 1.  Find all cards without power. Use `cards` table and filter `power IS NULL OR power = '*'`. Store the `uuid`.
2.  Find all foreign data that corresponds to the cards in step 1 and are in French. Use `foreign_data` table and filter `language = 'French'`. Join with `cards` using `uuid`.
3.  Calculate the total number of cards without power from step 1.
4.  Calculate the number of cards without power that are in French from step 2.
5.  Calculate the percentage by dividing the number of French cards without power (step 4) by the total number of cards without power (step 3) and multiplying by 100.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.language = 'French' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.uuid)
FROM foreign_data AS T1
INNER JOIN cards AS T2
  ON T1.uuid = T2.uuid
WHERE
  T2.power IS NULL
  OR T2.power = '*';
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.language = 'French' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.uuid)
FROM foreign_data AS T1
INNER JOIN cards AS T2
  ON T1.uuid = T2.uuid
WHERE
  T2.power IS NULL;
```
=====================
Question: What is the language of the card with the multiverse number 149934?
 db_id: card_games
Planner: 1. Find the card with `multiverseid` = 149934 in the `foreign_data` table.
2. Retrieve the `language` from the matching row.

NL2SQL: ```sql
SELECT
  language
FROM foreign_data
WHERE
  multiverseid = 149934;
```
Critic: ```sql
SELECT
  T1.language
FROM foreign_data AS T1
INNER JOIN cards AS T2
  ON T1.uuid = T2.uuid
WHERE
  T2.multiverseId = 149934;
```
=====================
Question: What proportion of cards do not have a text box with a normal layout?
 db_id: card_games
Planner: Plan:
1. Calculate the total number of cards using COUNT(*).
2. Calculate the number of cards that are textless (isTextless = 1) and have a layout other than 'normal'.
3. Divide the number of cards calculated in step 2 by the total number of cards calculated in step 1 and multiply by 100 to get the proportion.
4. Return the proportion.

Tables and Columns:
- cards: Use this table to get the total counts of cards and to filter by 'isTextless' and 'layout'.
    - Columns: isTextless, layout, uuid
Filters:
- cards where isTextless = 1 and layout != 'normal'.
Aggregation:
- COUNT(*) on cards
- COUNT(CASE WHEN isTextless = 1 AND layout != 'normal' THEN 1 END) on cards
Calculation:
- (COUNT(CASE WHEN isTextless = 1 AND layout != 'normal' THEN 1 END) / COUNT(*)) * 100
NL2SQL: ```sql
SELECT CAST(SUM(CASE WHEN isTextless = 1 AND layout != 'normal' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM cards
```
Critic: ```sql
SELECT CAST(SUM(CASE WHEN isTextless = 1 AND layout = 'normal' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM cards
```
=====================
Question: What languages are available in the set known as Archenemy on the magic card market and having the code ARC?
 db_id: card_games
Planner: 1.  Find the set ID by filtering the `sets` table for `name` = 'Archenemy' and `code` = 'ARC'.
2.  Use the `setCode` from `sets` table, find languages in `set_translations` table.
3.  Select the distinct languages.

NL2SQL: ```sql
SELECT DISTINCT
  T1.language
FROM set_translations AS T1
INNER JOIN sets AS T2
  ON T1.setCode = T2.code
WHERE
  T2.name = 'Archenemy' AND T2.code = 'ARC';
```
Critic: ```sql
SELECT DISTINCT
  language
FROM set_translations
WHERE
  setCode = 'ARC';
```
=====================
Question: Which foreign language used by "A Pedra Fellwar"?
 db_id: card_games
Planner: Plan:
1. Find the uuid of the card named "A Pedra Fellwar" from the `cards` table.
2. Use the uuid to find the foreign languages used for that card in the `foreign_data` table.
3. Return the distinct languages found.

Required tables: `cards`, `foreign_data`
Required columns: `cards`.`uuid`, `cards`.`name`, `foreign_data`.`uuid`, `foreign_data`.`language`
Filters: `cards`.`name` = "A Pedra Fellwar"
Joins: `cards`.`uuid` = `foreign_data`.`uuid`
Final select columns: `foreign_data`.`language`
Distinct languages.

NL2SQL: ```sql
SELECT DISTINCT T2.language FROM cards AS T1 JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'A Pedra Fellwar'
```
Critic: ```sql
SELECT DISTINCT language FROM foreign_data WHERE name = 'A Pedra Fellwar'
```
=====================
Question: Which card costs more converted mana, "Serra Angel" or "Shrine Keeper"?
 db_id: card_games
Planner: 1.  Find the converted mana cost of the card named "Serra Angel".
2.  Find the converted mana cost of the card named "Shrine Keeper".
3.  Compare the converted mana costs and return the name of the card with the higher cost.

Tables:
*   `cards`: To retrieve the `convertedManaCost` and `name` of the cards.

Columns:
*   `cards.name`: To filter for "Serra Angel" and "Shrine Keeper".
*   `cards.convertedManaCost`: To compare the converted mana costs.

Filters:
*   `cards.name = "Serra Angel"`
*   `cards.name = "Shrine Keeper"`

NL2SQL: ```sql
SELECT name FROM cards WHERE name = 'Serra Angel' AND convertedManaCost > (SELECT convertedManaCost FROM cards WHERE name = 'Shrine Keeper')
UNION
SELECT name FROM cards WHERE name = 'Shrine Keeper' AND convertedManaCost > (SELECT convertedManaCost FROM cards WHERE name = 'Serra Angel')
```
Critic: ```sql
SELECT CASE WHEN (SELECT convertedManaCost FROM cards WHERE name = 'Serra Angel') > (SELECT convertedManaCost FROM cards WHERE name = 'Shrine Keeper') THEN 'Serra Angel' ELSE 'Shrine Keeper' END;
```
=====================
Question: What's the Italian name of the set of cards with "Ancestor's Chosen" is in?
 db_id: card_games
Planner: 1. Find the set code of the card named "Ancestor's Chosen" from the `cards` table.
2. Find the Italian translation of the set's name from the `set_translations` table using the set code obtained in step 1 and the language 'Italian'.
3. Return the Italian translation of the set name.

NL2SQL: ```sql
SELECT
  T2.translation
FROM cards AS T1
INNER JOIN set_translations AS T2
  ON T1.setCode = T2.setCode
WHERE
  T1.name = 'Ancestor''s Chosen' AND T2.language = 'Italian';
```
Critic: ```sql
SELECT
  T2.name
FROM cards AS T1
INNER JOIN sets AS T2
  ON T1.setCode = T2.code
WHERE
  T1.name = 'Ancestor''s Chosen';
```
=====================
Question: For the set of cards with "Ancestor's Chosen" in it, is there a Korean version of it?
 db_id: card_games
Planner: 1.  Find the UUID of the card named "Ancestor's Chosen" from the `cards` table.
2.  Check in the `foreign_data` table if there's any entry with the UUID found in the previous step and `language` as "Korean".
3.  Return "Yes" if a record is found, "No" otherwise.

Join: None.
Filters: cards table: name = 'Ancestor''s Chosen'.
foreign_data table: language = 'Korean'
Columns: cards table: uuid.
foreign_data table: language
NL2SQL: ```sql
SELECT
  CASE
    WHEN EXISTS(
      SELECT
        1
      FROM cards AS c
      JOIN foreign_data AS fd
        ON c.uuid = fd.uuid
      WHERE
        c.name = 'Ancestor''s Chosen' AND fd.language = 'Korean'
    )
    THEN 'Yes'
    ELSE 'No'
  END;
```
Critic: ```sql
SELECT
  CASE
    WHEN EXISTS(
      SELECT
        1
      FROM cards AS T1
      INNER JOIN foreign_data AS T2
        ON T1.uuid = T2.uuid
      WHERE
        T1.name = 'Ancestor''s Chosen' AND T2.language = 'Korean'
    )
    THEN 'Yes'
    ELSE 'No'
  END;
```
=====================
Question: Among the cards in the set "Hauptset Zehnte Edition", how many of them are designed by Adam Rex?
 db_id: card_games
Planner:  план:
The question asks for the number of cards designed by Adam Rex in the set "Hauptset Zehnte Edition".
1.  Find the set code for "Hauptset Zehnte Edition" using the `sets` table, filtering by `name`.
2.  Use the set code to filter the `cards` table to get the cards in that set.
3.  Filter the results based on the `artist` column to find cards designed by "Adam Rex".
4.  Count the number of cards.
Tables:
*   `sets`: To find the set code for "Hauptset Zehnte Edition".
*   `cards`: To find cards in the set and filter by artist.

Columns:
*   `sets.code`: To get the set code.
*   `sets.name`: To filter for "Hauptset Zehnte Edition".
*   `cards.setCode`: To filter cards by set code.
*   `cards.artist`: To filter cards by "Adam Rex".

Filters:
*   `sets.name` = "Hauptset Zehnte Edition"
*   `cards.artist` = "Adam Rex"

Joins:
*   No joins are needed as we can get all the information from `sets` and `cards` tables.
Aggregations:
*   `COUNT(*)` to count the number of cards.
NL2SQL: ```sql
SELECT
  COUNT(*)
FROM cards
WHERE
  artist = 'Adam Rex' AND setCode = (
    SELECT
      code
    FROM sets
    WHERE
      name = 'Tenth Edition'
  );
```
Critic: ```sql
SELECT
  COUNT(*)
FROM cards
WHERE
  artist = 'Adam Rex' AND setCode = '10E';
```
=====================
Question: What is the Simplified Chinese translation of the name of the set "Eighth Edition"?
 db_id: card_games
Planner: 1.  Find the set id of the set named "Eighth Edition" from the `sets` table.
2.  Use the set id to find the Simplified Chinese translation from the `set_translations` table where the language is 'Chinese Simplified'.
3.  Return the translation.

NL2SQL: ```sql
SELECT
  translation
FROM set_translations
WHERE
  setCode = (
    SELECT
      code
    FROM sets
    WHERE
      name = 'Eighth Edition'
  )
  AND language = 'Chinese Simplified';
```
Critic: ```sql
SELECT
  T1.translation
FROM set_translations AS T1
INNER JOIN sets AS T2
  ON T1.setCode = T2.code
WHERE
  T2.name = 'Eighth Edition' AND T1.language = 'Chinese Simplified';
```
=====================
Question: Did the set of cards with "Angel of Mercy" appear on Magic: The Gathering Online?
 db_id: card_games
Planner: 1. Find the `uuid` of the card named "Angel of Mercy" from the `cards` table.
2. Check if there is any set (table `sets`) that contains cards that have the `mtgoCode` is not null (meaning it appeared on Magic: The Gathering Online), and that card with uuid `uuid` is in that set.
3. Return the name of the card if it exists.
4. Consider the column `isOnlineOnly` in `cards` table to directly check if the card is available only online.
5. Also, consider joining tables `cards` and `sets` on `setCode` and `code` respectively. Then filter by `name` on `cards` and check if `isOnlineOnly` is 1 in `sets` table.

NL2SQL: ```sql
SELECT
  c.name
FROM cards AS c
JOIN sets AS s
  ON c.setCode = s.code
WHERE
  c.name = 'Angel of Mercy' AND s.isOnlineOnly = 1;
```
Critic: ```sql
SELECT
  CASE WHEN COUNT(T1.isOnlineOnly) > 0 THEN 'Yes' ELSE 'No' END
FROM sets AS T1
INNER JOIN cards AS T2
  ON T1.code = T2.setCode
WHERE
  T2.name = 'Angel of Mercy' AND T1.mtgoCode IS NOT NULL;
```
=====================
Question: Among the sets in the block "Ice Age", how many of them have an Italian translation?
 db_id: card_games
Planner: 1.  Find the sets that belong to the "Ice Age" block from the `sets` table.
2.  Join the `sets` table with the `set_translations` table on the set code to find the translations for each set.
3.  Filter the joined table to find sets with an Italian translation (language = 'Italian').
4.  Count the number of distinct sets that satisfy the condition.

Plan:
1. SELECT COUNT(DISTINCT sets.code)
2. FROM sets
3. JOIN set_translations ON sets.code = set_translations.setCode
4. WHERE sets.block = "Ice Age" AND set_translations.language = "Italian"

NL2SQL: ```sql
SELECT COUNT(DISTINCT sets.code)
FROM sets
JOIN set_translations ON sets.code = set_translations.setCode
WHERE sets.block = "Ice Age" AND set_translations.language = "Italian"
```
Critic: ```sql
SELECT COUNT(DISTINCT code) FROM sets WHERE block = "Ice Age" AND EXISTS (SELECT 1 FROM set_translations WHERE set_translations.setCode = sets.code AND language = "Italian")
```
=====================
Question: Is the set of cards with Adarkar Valkyrie only available outside the United States?
 db_id: card_games
Planner: Plan:
1. Find the card with the name 'Adarkar Valkyrie' from the `cards` table.
2. Get the set codes for 'Adarkar Valkyrie'.
3. Check if any of these sets have `isForeignOnly` equal to 1 in the `sets` table.
4. If at least one of the sets has `isForeignOnly` equal to 1, then the answer is yes. Otherwise, the answer is no.
Final Answer: The final answer is yes

NL2SQL: ```sql
SELECT
  CASE
    WHEN COUNT(T1.setCode) > 0
    THEN 'Yes'
    ELSE 'No'
  END
FROM cards AS T1
INNER JOIN sets AS T2
  ON T1.setCode = T2.code
WHERE
  T1.name = 'Adarkar Valkyrie' AND T2.isForeignOnly = 1;
```
Critic: ```sql
SELECT
  CASE
    WHEN SUM(CASE WHEN T2.isForeignOnly = 1 THEN 1 ELSE 0 END) > 0
    THEN 'Yes'
    ELSE 'No'
  END
FROM cards AS T1
INNER JOIN sets AS T2
  ON T1.setCode = T2.code
WHERE
  T1.name = 'Adarkar Valkyrie';
```
=====================
Question: Among the sets of cards that have an Italian translation, how many of them have a base set number of under 100?
 db_id: card_games
Planner: Plan:
1. Join `sets` and `set_translations` on `code` and `setCode` respectively.
2. Filter the joined table where `language` is 'Italian'.
3. Filter the joined table where `baseSetSize` is less than 100.
4. Count the distinct set codes.

NL2SQL: ```sql
SELECT
  COUNT(DISTINCT T1.code)
FROM sets AS T1
INNER JOIN set_translations AS T2
  ON T1.code = T2.setCode
WHERE
  T2.language = 'Italian' AND T1.baseSetSize < 100;
```
Critic: ```sql
SELECT
  COUNT(DISTINCT T1.code)
FROM sets AS T1
INNER JOIN set_translations AS T2
  ON T1.code = T2.setCode
WHERE
  T2.language = 'Italian' AND T1.baseSetSize < 100;
```
=====================
Question: Which of these artists have designed a card in the set Coldsnap, Jeremy Jarvis, Aaron Miller or Chippy?
 db_id: card_games
Planner: 1.  Find the set code for the set 'Coldsnap' from the 'sets' table.
2.  Filter the 'cards' table by the set code obtained in step 1.
3.  Filter the 'cards' table by artist names 'Jeremy Jarvis', 'Aaron Miller', and 'Chippy'.
4.  Return the distinct artist names.

NL2SQL: ```sql
SELECT DISTINCT artist FROM cards WHERE setCode = (SELECT code FROM sets WHERE name = 'Coldsnap') AND artist IN ('Jeremy Jarvis', 'Aaron Miller', 'Chippy')
```
Critic: ```sql
SELECT DISTINCT Artist FROM cards WHERE setCode = (SELECT Code FROM Sets WHERE Name = 'Coldsnap') AND Artist IN ('Jeremy Jarvis', 'Aaron Miller', 'Chippy')
```
=====================
Question: Among the cards with converted mana cost higher than 5 in the set Coldsnap, how many of them have unknown power?
 db_id: card_games
Planner: 1.  Find the set code for the set 'Coldsnap' from the `sets` table.
2.  Filter the `cards` table for cards with the set code found in step 1 and where the converted mana cost is greater than 5.
3.  Further filter the results from step 2 to only include cards where the power is unknown (either equal to "*" or NULL).
4.  Count the number of cards that satisfy the conditions.

Required tables: `cards`, `sets`
Required columns: `cards.setCode`, `cards.convertedManaCost`, `cards.power`, `sets.code`, `sets.name`
Filters: `sets.name = 'Coldsnap'`, `cards.convertedManaCost > 5`, `cards.power = '*' OR cards.power IS NULL`
Joins: None
Aggregations: `COUNT(*)`

NL2SQL: ```sql
SELECT
  COUNT(*)
FROM cards AS T1
INNER JOIN sets AS T2
  ON T1.setCode = T2.code
WHERE
  T2.name = 'Coldsnap' AND T1.convertedManaCost > 5 AND (
    T1.power = '*' OR T1.power IS NULL
  );
```
Critic: ```sql
SELECT
  COUNT(id)
FROM cards
WHERE
  setCode = 'CSP' AND convertedManaCost > 5 AND power = '*';
```
=====================
Question: What is the Italian flavor text of the card "Ancestor's Chosen"?
 db_id: card_games
Planner: 1.  Find the card "Ancestor's Chosen" in the `cards` table using the `name` column. Retrieve its `uuid`.
2.  Use the `uuid` from the `cards` table to find the corresponding entry in the `foreign_data` table.
3.  Filter the `foreign_data` table where `language` is 'Italian'.
4.  Retrieve the `flavorText` from the `foreign_data` table.

NL2SQL: ```sql
SELECT
  T2.flavorText
FROM cards AS T1
INNER JOIN foreign_data AS T2
  ON T1.uuid = T2.uuid
WHERE
  T1.name = 'Ancestor''s Chosen' AND T2.language = 'Italian';
```
Critic: ```sql
SELECT
  T2.flavorText
FROM cards AS T1
INNER JOIN foreign_data AS T2
  ON T1.uuid = T2.uuid
WHERE
  T1.name = "Ancestor's Chosen" AND T2.language = 'Italian';
```
=====================
Question: Please list the Italian text ruling of all the cards in the set Coldsnap.
 db_id: card_games
Planner: Plan:
1. Find the set code for the set 'Coldsnap' from the `sets` table.
2. Find the UUIDs of all cards in the set 'Coldsnap' from the `cards` table using the set code.
3. Find the Italian text ruling for the cards using the UUIDs and language = 'Italian' from the `foreign_data` table.
4. Return the Italian text rulings.

NL2SQL: ```sql
SELECT
  T1.text
FROM foreign_data AS T1
INNER JOIN cards AS T2
  ON T1.uuid = T2.uuid
INNER JOIN sets AS T3
  ON T2.setCode = T3.code
WHERE
  T3.name = 'Coldsnap' AND T1.language = 'Italian';
```
Critic: ```sql
SELECT
  T1.text
FROM foreign_data AS T1
INNER JOIN cards AS T2
  ON T1.uuid = T2.uuid
WHERE
  T2.setCode = 'CSP' AND T1.language = 'Italian';
```
=====================
Question: Please list the Italian names of the cards in the set Coldsnap with the highest converted mana cost.
 db_id: card_games
Planner: Plan:
1. Find the set code for the set 'Coldsnap' from the `sets` table.
2. Find the maximum converted mana cost of the cards in the 'Coldsnap' set from the `cards` table, filtering by the set code.
3. Find the Italian names of the cards in the 'Coldsnap' set from the `foreign_data` table, filtering by language = 'Italian' and setcode. Join with cards on uuid to filter for cards from the set Coldsnap and converted manacost equals max_convertedManaCost
4. Return the Italian card names.

NL2SQL: ```sql
SELECT
  T1.name
FROM foreign_data AS T1
JOIN cards AS T2
  ON T1.uuid = T2.uuid
WHERE
  T1.language = 'Italian' AND T2.setCode = 'CSP' AND T2.convertedManaCost = (
    SELECT
      MAX(convertedManaCost)
    FROM cards
    WHERE
      setCode = 'CSP'
  );
```
Critic: ```sql
SELECT
  T1.name
FROM foreign_data AS T1
JOIN cards AS T2
  ON T1.uuid = T2.uuid
WHERE
  T1.language = 'Italian' AND T2.setCode = 'CSP'
ORDER BY
  T2.convertedManaCost DESC
LIMIT 1;
```
=====================
Question: What is the percentage of the cards with a converted mana cost of 7 in the set Coldsnap?
 db_id: card_games
Planner: 1.  Find the cards from the set 'Coldsnap'. Use the `sets` table to find the `code` for 'Coldsnap', and then use the `cards` table to filter cards with `setCode` equal to that `code`.
2.  From the filtered cards, count the total number of cards.
3.  From the filtered cards, count the number of cards with `convertedManaCost` equal to 7.
4.  Calculate the percentage of cards with `convertedManaCost` equal to 7 by dividing the count of cards with `convertedManaCost` equal to 7 by the total number of cards and multiplying by 100.
5.  Return the calculated percentage.

Tables: cards, sets

Columns: sets.code, sets.name, cards.setCode, cards.convertedManaCost

Filters: sets.name = 'Coldsnap', cards.convertedManaCost = 7

Joins: cards.setCode = sets.code

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.convertedManaCost = 7 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id)
FROM cards AS T1
INNER JOIN sets AS T2
  ON T1.setCode = T2.code
WHERE
  T2.name = 'Coldsnap';
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.convertedManaCost = 7 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id)
FROM cards AS T1
WHERE
  T1.setCode = 'CSP';
```
=====================
Question: What is the percentage of incredibly powerful cards in the set Coldsnap?
 db_id: card_games
Planner: Plan:
1. Find the `code` for the set 'Coldsnap' from the `sets` table.
2. Find all cards from the `cards` table that have `setCode` equal to the `code` found in step 1.
3. Filter cards that have both `cardKingdomFoilId` and `cardKingdomId` not null (representing incredibly powerful cards).
4. Calculate the percentage of incredibly powerful cards by dividing the count of incredibly powerful cards by the total number of cards in the set and multiplying by 100.
5. Return the percentage.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.cardKingdomFoilId IS NOT NULL AND T1.cardKingdomId IS NOT NULL THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.uuid)
FROM cards AS T1
INNER JOIN sets AS T2
  ON T1.setCode = T2.code
WHERE
  T2.name = 'Coldsnap';
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.cardKingdomFoilId IS NOT NULL AND T1.cardKingdomId IS NOT NULL THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.uuid)
FROM cards AS T1
WHERE
  T1.setCode = 'CSP'
```
=====================
Question: Which of the play format has the highest number of banned status? Indicate the play format and the names of all the card meet the condition.
 db_id: card_games
Planner: Here's the plan to get the card play format with the highest number of banned cards:

1.  **Join `legalities` and `cards` tables:** Join `legalities` and `cards` on `legalities.uuid = cards.uuid` to link legality information with card details.
2.  **Filter for 'Banned' status:** Filter the joined table where `legalities.status = 'Banned'` to select only the banned cards.
3.  **Group by play format:** Group the results by `legalities.format` to count the number of banned cards for each format.
4.  **Find the maximum count:** Find the maximum count of banned statuses among all play formats.
5.  **Select the play format and card names:** Select the `legalities.format` with the maximum count and corresponding `cards.name`.

NL2SQL: ```sql
SELECT
  T1.format,
  T2.name
FROM legalities AS T1
INNER JOIN cards AS T2
  ON T1.uuid = T2.uuid
WHERE
  T1.status = 'Banned'
GROUP BY
  T1.format,
  T2.name
HAVING
  COUNT(T1.status) = (
    SELECT
      MAX(banned_count)
    FROM (
      SELECT
        format,
        COUNT(status) AS banned_count
      FROM legalities
      WHERE
        status = 'Banned'
      GROUP BY
        format
    )
  );
```
Critic: ```sql
SELECT
  T1.format,
  GROUP_CONCAT(T2.name)
FROM legalities AS T1
INNER JOIN cards AS T2
  ON T1.uuid = T2.uuid
WHERE
  T1.status = 'Banned'
GROUP BY
  T1.format
ORDER BY
  COUNT(T1.status) DESC
LIMIT 1;
```
=====================
Question: Which cards are ranked 1st on EDHRec? List all of the cards name and its banned play format.
 db_id: card_games
Planner: Plan:
1. Find cards with `edhrecRank` equal to 1 from the `cards` table.
2. Find the `uuid` for those cards.
3. Find the `format` and `status` for those cards from the `legalities` table where `status` is 'Banned' and join with the `uuid` from the cards table.
4. Output the `name` from the cards table and `format` from the `legalities` table.

NL2SQL: ```sql
SELECT
  c.name,
  l.format
FROM cards AS c
JOIN legalities AS l
  ON c.uuid = l.uuid
WHERE
  c.edhrecRank = 1 AND l.status = 'Banned';
```
Critic: ```sql
SELECT
  name,
  format
FROM cards AS T1
INNER JOIN legalities AS T2
  ON T1.uuid = T2.uuid
WHERE
  T1.edhrecRank = 1 AND T2.status = 'Banned';
```
=====================
Question: List the names of all the cards in the set Hour of Devastation and find the formats in which these cards are legal.
 db_id: card_games
Planner: Here's a plan to retrieve the card names from the "Hour of Devastation" set and the formats in which they are legal:

1.  **Identify the target set:** Use the `sets` table to find the set code for "Hour of Devastation".
2.  **Find cards in the set:** Use the `cards` table, filtering by the set code obtained in step 1, to get the UUID and names of all cards in that set.
3.  **Find legal formats for the cards:** Use the `legalities` table, filtering by the UUIDs obtained in step 2 and status = 'Legal', to find the formats in which the cards are legal.
4.  **Join the results:** Combine the card names from the `cards` table and the format information from the `legalities` table.
5.  **Display the results:**  Output the card names and the corresponding legal formats.

The tables involved are `sets`, `cards`, and `legalities`. We need to join `cards` and `legalities` on `uuid`. We will filter `sets` on `name` to get the `code`, and filter `cards` on `setCode` with the code we get. We will filter `legalities` on `status` = 'Legal'. We need to show `cards.name` and `legalities.format`.

NL2SQL: ```sql
SELECT
  c.name,
  l.format
FROM cards AS c
JOIN legalities AS l
  ON c.uuid = l.uuid
JOIN sets AS s
  ON c.setCode = s.code
WHERE
  s.name = 'Hour of Devastation' AND l.status = 'Legal';
```
Critic: ```sql
SELECT
  T1.name,
  T2.format
FROM cards AS T1
INNER JOIN legalities AS T2
  ON T1.uuid = T2.uuid
WHERE
  T1.setCode = 'HOU';
```
=====================
Question: Find and list the names of sets which doesn't have Japanese translation but have Korean translation.
 db_id: card_games
Planner: 1.  Find sets that do not have Japanese translations in `set_translations`.
2.  Find sets that have Korean translations in `set_translations`.
3.  Join the above two results on set code to find the sets that satisfy both conditions.
4.  Return the names of these sets from the `sets` table.
    *   Filter the `sets` table using the set codes found above.
    *   Select the `name` column from the `sets` table.

Tables: `sets`, `set_translations`
Filters:
*   `set_translations`: `language` NOT LIKE '%Japanese%'
*   `set_translations`: `language` = 'Korean'
Joins:
*   `sets` JOIN `set_translations` ON `sets.code` = `set_translations.setCode`

Columns:
*   `sets`: `name`
*   `set_translations`: `setCode`, `language`

NL2SQL: ```sql
SELECT
  name
FROM sets
WHERE
  code IN (
    SELECT
      setCode
    FROM set_translations
    WHERE
      language = 'Korean'
  )
  AND code NOT IN (
    SELECT
      setCode
    FROM set_translations
    WHERE
      language LIKE '%Japanese%'
  );
```
Critic: ```sql
SELECT
  name
FROM sets
WHERE
  code IN (
    SELECT
      setCode
    FROM set_translations
    WHERE
      language = 'Korean'
  )
  AND code NOT IN (
    SELECT
      setCode
    FROM set_translations
    WHERE
      language = 'Japanese'
  );
```
=====================
Question: List all the frame styles and cards Allen Williams worked on and find any banned cards if there are any.
 db_id: card_games
Planner: Plan:
1. Find the frame styles (frameVersion) and card names (name) for cards where the artist (artist) is 'Allen Williams' from the `cards` table.
2. Find any banned cards by joining the `cards` and `legalities` tables on the `uuid` column and filtering where `status` is 'Banned' in the `legalities` table. Select the `name` column from the `cards` table.
3. Combine the results.

NL2SQL: ```sql
SELECT
  c.frameVersion,
  c.name
FROM cards AS c
WHERE
  c.artist = 'Allen Williams'
UNION
SELECT
  c.frameVersion,
  c.name
FROM cards AS c
JOIN legalities AS l
  ON c.uuid = l.uuid
WHERE
  l.status = 'Banned' AND c.artist = 'Allen Williams';
```
Critic: ```sql
SELECT
  T1.frameVersion,
  T1.name
FROM cards AS T1
INNER JOIN legalities AS T2
  ON T1.uuid = T2.uuid
WHERE
  T1.artist = 'Allen Williams' AND T2.status = 'Banned';
```
=====================
Question: What is the most common bond type?
 db_id: toxicology
Planner: Plan:
1. Access the `bond` table.
2. Group the rows by `bond_type`.
3. Count the number of occurrences of each `bond_type`.
4. Order the counts in descending order.
5. Select the top `bond_type`.

NL2SQL: ```sql
SELECT bond_type FROM bond GROUP BY bond_type ORDER BY count(*) DESC LIMIT 1
```
Critic: ```sql
SELECT bond_type FROM bond GROUP BY bond_type ORDER BY COUNT(*) DESC LIMIT 1
```
=====================
Question: Calculate the average number of oxygen atoms in single-bonded molecules.
 db_id: toxicology
Planner: Plan:
1. Filter the `bond` table to select only single bonds (`bond_type` = '-').
2. Join the filtered `bond` table with the `molecule` table on `molecule_id`.
3. Join the `molecule` table with the `atom` table using `molecule_id`.
4. Filter the `atom` table to count only oxygen atoms where `element` is equal to 'O'.
5. Calculate the average number of oxygen atoms in those single-bonded molecules.
6. Return the average number of oxygen atoms.

NL2SQL: ```sql
SELECT avg(CASE WHEN T1.element = 'O' THEN 1 ELSE 0 END) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T3.bond_type = '-';
```
Critic: ```sql
SELECT avg(CASE WHEN T1.element = 'O' THEN 1 ELSE 0 END) FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.bond_type = '-';
```
=====================
Question: On average how many carcinogenic molecules are single bonded?
 db_id: toxicology
Planner: Plan:
1. Filter the `molecule` table to find carcinogenic molecules (label = '+').
2. Join the filtered `molecule` table with the `bond` table using `molecule_id`.
3. Filter the joined table to select only single bonds (bond_type = '-').
4. Calculate the average number of single bonds by counting the number of single bonds and dividing by the number of carcinogenic molecules.
   - Need to COUNT the DISTINCT molecule_ids which are carcinogenic and have a single bond.
   - Need to COUNT the number of bonds which are single bonds for carcinogenic molecules.
5. The output should be the average number of single bonds.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.bond_type = '-' THEN 1 ELSE 0 END) AS REAL) / COUNT(DISTINCT T1.molecule_id)
FROM bond AS T1
INNER JOIN molecule AS T2
  ON T1.molecule_id = T2.molecule_id
WHERE
  T2.label = '+';
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.bond_type = '-' THEN 1 ELSE 0 END) AS REAL) / COUNT(DISTINCT T2.molecule_id)
FROM bond AS T1
INNER JOIN molecule AS T2
  ON T1.molecule_id = T2.molecule_id
WHERE
  T2.label = '+';
```
=====================
Question: Find the triple-bonded molecules which are carcinogenic.
 db_id: toxicology
Planner: Plan:
1. Find the `molecule_id` of molecules that have triple bonds by filtering the `bond` table where `bond_type` is '#'.
2. Find the `molecule_id` of molecules that are carcinogenic by filtering the `molecule` table where `label` is '+'.
3. Join the results from steps 1 and 2 on `molecule_id` to find the `molecule_id` of molecules that are both triple-bonded and carcinogenic.
4. Return the `molecule_id`.

NL2SQL: ```sql
SELECT DISTINCT T1.molecule_id FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '#' AND T2.label = '+'
```
Critic: ```sql
SELECT DISTINCT T1.molecule_id FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '#' AND T2.label = '+'
```
=====================
Question: What is the percentage of carbon in double-bond molecules?
 db_id: toxicology
Planner: Plan:
1. Find the molecules with double bonds using the `bond` table and filtering by `bond_type = '='`.
2. Find all atoms within those double-bond molecules using the `atom` table and filtering by the molecule IDs obtained in step 1.
3. Count the total number of atoms in these double-bond molecules.
4. Count the number of carbon atoms (element = 'C') within those molecules.
5. Calculate the percentage of carbon atoms by dividing the count of carbon atoms by the total number of atoms and multiplying by 100.

Tables: bond, atom
Columns:
- bond: molecule_id, bond_type
- atom: molecule_id, element, atom_id
Filters:
- bond: bond_type = '='
- atom: element = 'C'
Joins:
- atom and bond tables on molecule_id
Aggregations:
- COUNT(atom_id)
- SUM(CASE WHEN element = 'C' THEN 1 ELSE 0 END)
Final Calculation:
- SUM(CASE WHEN element = 'C' THEN 1 ELSE 0 END) / COUNT(atom_id)

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.element = 'c' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.atom_id)
FROM atom AS T1
INNER JOIN bond AS T2
  ON T1.molecule_id = T2.molecule_id
WHERE
  T2.bond_type = '=';
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.element = 'c' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.atom_id)
FROM atom AS T1
INNER JOIN bond AS T2
  ON T1.molecule_id = T2.molecule_id
WHERE
  T2.bond_type = "=";
```
=====================
Question: What elements are in the TR004_8_9 bond atoms?
 db_id: toxicology
Planner: Plan:
1. Filter the `connected` table by `bond_id = 'TR004_8_9'` to find the `atom_id` and `atom_id2` connected by the specified bond.
2. Join the filtered `connected` table with the `atom` table twice, once for `atom_id` and once for `atom_id2` to retrieve the `element` for each atom.
3. Return the distinct `element` values.

NL2SQL: ```sql
SELECT DISTINCT T1.element FROM atom AS T1 JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T2.bond_id = "TR004_8_9" UNION SELECT DISTINCT T1.element FROM atom AS T1 JOIN connected AS T2 ON T1.atom_id = T2.atom_id2 WHERE T2.bond_id = "TR004_8_9"
```
Critic: ```sql
SELECT T1.element FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T2.bond_id = 'TR004_8_9' UNION SELECT T1.element FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id2 WHERE T2.bond_id = 'TR004_8_9'
```
=====================
Question: What elements are in a double type bond?
 db_id: toxicology
Planner: Plan:
1. Filter the `bond` table to get the `bond_id` where `bond_type` is '=', representing a double bond.
2. Join the `connected` table with the filtered `bond` table on `bond_id` to get `atom_id` and `atom_id2` associated with the double bonds.
3. Join the `atom` table with the `connected` table on `atom_id` to get the `element` of the first atom in the bond.
4. Join the `atom` table with the `connected` table on `atom_id2` to get the `element` of the second atom in the bond.
5. Return the distinct pairs of `element` values of the two atoms in the bond.

NL2SQL: ```sql
SELECT DISTINCT
  T1.element,
  T2.element
FROM atom AS T1
INNER JOIN connected AS T3
  ON T1.atom_id = T3.atom_id
INNER JOIN atom AS T2
  ON T3.atom_id2 = T2.atom_id
INNER JOIN bond AS T4
  ON T3.bond_id = T4.bond_id
WHERE
  T4.bond_type = '=';
```
Critic: ```sql
SELECT DISTINCT
  T1.element
FROM atom AS T1
INNER JOIN connected AS T2
  ON T1.atom_id = T2.atom_id
INNER JOIN bond AS T3
  ON T2.bond_id = T3.bond_id
WHERE
  T3.bond_type = '=';
```
=====================
Question: Which type of label is the most numerous in atoms with hydrogen?
 db_id: toxicology
Planner: Plan:
1. Filter the `atom` table to select atoms where the `element` is 'h'.
2. Join the filtered `atom` table with the `molecule` table on `molecule_id` to get the `label` for each hydrogen atom.
3. Group the results by `label` and count the number of hydrogen atoms for each label.
4. Find the label with the maximum count.
5. Return the label with the most hydrogen atoms.
Tables:
* atom
* molecule

Columns:
* atom.element
* atom.molecule_id
* molecule.molecule_id
* molecule.label

Joins:
* atom JOIN molecule ON atom.molecule_id = molecule.molecule_id

Filters:
* atom.element = 'h'

Aggregate Functions:
* COUNT(atom.atom_id)
* GROUP BY molecule.label
* MAX(COUNT(atom.atom_id))

NL2SQL: ```sql
SELECT label FROM molecule WHERE molecule_id IN (SELECT molecule_id FROM atom WHERE element = 'h') GROUP BY label ORDER BY count(*) DESC LIMIT 1
```
Critic: ```sql
SELECT T1.label FROM molecule AS T1 JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.element = 'h' GROUP BY T1.label ORDER BY COUNT(*) DESC LIMIT 1
```
=====================
Question: Which element is the least numerous in non-carcinogenic molecules?
 db_id: toxicology
Planner: Plan:
1. Find the non-carcinogenic molecules by filtering the `molecule` table where `label` is '-'.
2. Join the filtered `molecule` table with the `atom` table using `molecule_id` to get the element of each atom in non-carcinogenic molecules.
3. Group the results by element and count the number of occurrences of each element.
4. Find the element with the minimum count.
5. Output the element with the minimum count.

Tables:
- molecule: for filtering non-carcinogenic molecules
- atom: for extracting atom element

Columns:
- molecule.molecule_id: used for joining
- molecule.label: used for filtering non-carcinogenic molecules
- atom.molecule_id: used for joining
- atom.element: used for counting and finding the minimum count

NL2SQL: ```sql
SELECT element FROM atom WHERE molecule_id IN (SELECT molecule_id FROM molecule WHERE label = '-') GROUP BY element ORDER BY count(*) ASC LIMIT 1
```
Critic: ```sql
SELECT element FROM atom WHERE molecule_id IN (SELECT molecule_id FROM molecule WHERE label = '-') GROUP BY element ORDER BY count(*) ASC LIMIT 1
```
=====================
Question: What type of bond is there between the atoms TR004_8 and TR004_20?
 db_id: toxicology
Planner: Plan:
1. Find the `bond_id` that connects the two given atoms using the `connected` table.
2. Use the `bond_id` obtained in step 1 to find the `bond_type` from the `bond` table.
3. Return the `bond_type`.
Tables: connected, bond
Columns:
* connected: atom_id, atom_id2, bond_id
* bond: bond_id, bond_type
Filters:
* connected: atom_id = 'TR004_8' AND atom_id2 = 'TR004_20' OR atom_id = 'TR004_20' AND atom_id2 = 'TR004_8'
Joins:
* connected with bond on connected.bond_id = bond.bond_id
Output: bond_type

NL2SQL: ```sql
SELECT
  T2.bond_type
FROM connected AS T1
INNER JOIN bond AS T2
  ON T1.bond_id = T2.bond_id
WHERE
  T1.atom_id = 'TR004_8' AND T1.atom_id2 = 'TR004_20' OR T1.atom_id = 'TR004_20' AND T1.atom_id2 = 'TR004_8';
```
Critic: ```sql
SELECT
  T1.bond_type
FROM bond AS T1
INNER JOIN connected AS T2
  ON T1.bond_id = T2.bond_id
WHERE
  T2.atom_id = 'TR004_8' AND T2.atom_id2 = 'TR004_20' OR T2.atom_id = 'TR004_20' AND T2.atom_id2 = 'TR004_8';
```
=====================
Question: How many atoms with iodine and with sulfur type elements are there in single bond molecules?
 db_id: toxicology
Planner: Plan:
1. Filter the Atom table to select atoms with element 'i' or 's'.
2. Filter the Bond table to select bonds with bond_type '-'.
3. Join the filtered Atom table and Connected table on atom_id to find the atom ids that are involved in the single bonds.
4. Count the distinct atom_id that satisfy the conditions.
5. Return the count.

NL2SQL: ```sql
SELECT
  COUNT(DISTINCT T1.atom_id)
FROM atom AS T1
INNER JOIN connected AS T2
  ON T1.atom_id = T2.atom_id
INNER JOIN bond AS T3
  ON T2.bond_id = T3.bond_id
WHERE
  T1.element = 'i' OR T1.element = 's'
  AND T3.bond_type = '-';
```
Critic: ```sql
SELECT
  COUNT(DISTINCT T1.atom_id)
FROM atom AS T1
INNER JOIN bond AS T2
  ON T1.molecule_id = T2.molecule_id
WHERE
  (
    T1.element = 'i' OR T1.element = 's'
  )
  AND T2.bond_type = '-';
```
=====================
Question: What percentage of carcinogenic-type molecules does not contain fluorine?
 db_id: toxicology
Planner: Plan:
1. Find the carcinogenic molecules using the `molecule` table where `label` is '+'.
2. Find the molecules that contain fluorine atoms using the `atom` table where `element` is 'f'.
3. Join the results to count carcinogenic molecules that do not contain fluorine.
4. Calculate the percentage of carcinogenic molecules that do not contain fluorine. Divide the number of carcinogenic molecules without fluorine by the total number of carcinogenic molecules and multiply by 100.
5. Take into account that we need distinct molecule_ids.
Tables: molecule, atom
Columns: molecule.molecule_id, molecule.label, atom.molecule_id, atom.element
Filters: molecule.label = '+', atom.element = 'f'
Joins: None
Calculations: COUNT(DISTINCT CASE WHEN atom.element != 'f' THEN molecule.molecule_id END), COUNT(DISTINCT molecule.molecule_id)
Final Calculation: 100 * (COUNT(DISTINCT CASE WHEN atom.element != 'f' THEN molecule.molecule_id END) / COUNT(DISTINCT molecule.molecule_id))

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.element <> 'f' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.molecule_id)
FROM atom AS T1
INNER JOIN molecule AS T2
  ON T1.molecule_id = T2.molecule_id
WHERE
  T2.label = '+';
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.element <> 'f' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.molecule_id)
FROM atom AS T1
INNER JOIN molecule AS T2
  ON T1.molecule_id = T2.molecule_id
WHERE
  T2.label = '+';
```
=====================
Question: What is the percentage of carcinogenic molecules in triple type bonds?
 db_id: toxicology
Planner: Plan:
1. Filter the `molecule` table to find carcinogenic molecules (where `label` is '+').
2. Join the filtered `molecule` table with the `bond` table using `molecule_id`.
3. Filter the joined table to include only triple bonds (where `bond_type` is '#').
4. Calculate the percentage of triple bonds among carcinogenic molecules. This involves counting the number of triple bonds, counting the total number of bonds for carcinogenic molecules, and then dividing the former by the latter and multiplying by 100.
5. Return the calculated percentage.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.bond_type = '#' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.bond_id)
FROM bond AS T1
INNER JOIN molecule AS T2
  ON T1.molecule_id = T2.molecule_id
WHERE
  T2.label = '+';
```
Critic: ```sql
SELECT CAST(SUM(CASE WHEN T1.bond_type = '#' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.bond_id) FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+'
```
=====================
Question: Please list top three elements of the toxicology of the molecule TR000 in alphabetical order.
 db_id: toxicology
Planner: Plan:
1. Filter the `molecule` table to find the `molecule_id` equal to 'TR000'.
2. Use the `molecule_id` to filter the `atom` table.
3. Select the `element` column from the filtered `atom` table.
4. Find the distinct `element` values.
5. Order the elements alphabetically.
6. Limit the results to the top 3.

NL2SQL: ```sql
SELECT DISTINCT element FROM atom WHERE molecule_id = "TR000" ORDER BY element ASC LIMIT 3
```
Critic: ```sql
SELECT DISTINCT element FROM atom WHERE molecule_id = 'TR000' ORDER BY element ASC LIMIT 3
```
=====================
Question: What is the percentage of double bonds in the molecule TR008? Please provide your answer as a percentage with five decimal places.
 db_id: toxicology
Planner: Plan:
1. Filter the `bond` table to only include bonds from the molecule 'TR008'.
2. Count the total number of bonds for molecule 'TR008'.
3. Count the number of double bonds (bond_type = '=') for molecule 'TR008'.
4. Calculate the percentage of double bonds by dividing the number of double bonds by the total number of bonds, and multiplying by 100.
5. Round the percentage to five decimal places.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN bond_type = '=' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(bond_id)
FROM bond
WHERE
  molecule_id = 'TR008';
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN bond_type = '=' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(bond_id)
FROM bond
WHERE
  molecule_id = 'TR008';
```
=====================
Question: What is the percentage of molecules that are carcinogenic? Please provide your answer as a percentage with three decimal places.
 db_id: toxicology
Planner: Plan:
1. Count the total number of molecules from the 'molecule' table.
2. Count the number of molecules that are carcinogenic (where label = '+') from the 'molecule' table.
3. Calculate the percentage of carcinogenic molecules by dividing the count of carcinogenic molecules by the total number of molecules.
4. Format the result as a percentage with three decimal places.

NL2SQL: ```sql
SELECT CAST(SUM(CASE WHEN label = '+' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(molecule_id) FROM molecule
```
Critic: ```sql
SELECT CAST(SUM(CASE WHEN label = '+' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(molecule_id) FROM molecule
```
=====================
Question: How much of the hydrogen in molecule TR206 is accounted for? Please provide your answer as a percentage with four decimal places.
 db_id: toxicology
Planner: Plan:
1. Find the number of hydrogen atoms in molecule TR206. This involves filtering the `atom` table by `molecule_id = 'TR206'` and `element = 'H'`, and then counting the number of such atoms.
2. Find the total number of atoms in molecule TR206. This involves filtering the `atom` table by `molecule_id = 'TR206'` and counting all atoms.
3. Calculate the percentage of hydrogen atoms by dividing the number of hydrogen atoms (step 1) by the total number of atoms (step 2) and multiplying by 100.
4. Format the percentage to four decimal places.
Tables needed: `atom`
Columns needed: `atom_id`, `molecule_id`, `element`
Filters: `molecule_id = 'TR206'`, `element = 'H'`
Aggregations: COUNT, SUM
Operations: DIVIDE, MULTIPLY, FORMAT

NL2SQL: ```sql
SELECT CAST(SUM(CASE WHEN element = 'H' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(atom_id) FROM atom WHERE molecule_id = 'TR206'
```
Critic: ```sql
SELECT CAST(SUM(CASE WHEN element = 'H' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(atom_id) FROM atom WHERE molecule_id = 'TR206'
```
=====================
Question: What are the elements of the toxicology and label of molecule TR060?
 db_id: toxicology
Planner: Plan:
1. Find the molecule with molecule\_id = 'TR060' from the `molecule` table. Extract its label.
2. Find the atoms from the `atom` table where molecule\_id = 'TR060'. Extract the element of each such atom.
3. Return the element and label.
Tables:
- molecule
- atom
Columns:
- molecule.molecule\_id
- molecule.label
- atom.molecule\_id
- atom.element
Filters:
- molecule.molecule\_id = 'TR060'
- atom.molecule\_id = 'TR060'
Joins:
- None
Output:
- element
- label

NL2SQL: ```sql
SELECT
  T1.element,
  T2.label
FROM atom AS T1
INNER JOIN molecule AS T2
  ON T1.molecule_id = T2.molecule_id
WHERE
  T1.molecule_id = 'TR060';
```
Critic: ```sql
SELECT
  T1.element,
  T2.label
FROM atom AS T1
INNER JOIN molecule AS T2
  ON T1.molecule_id = T2.molecule_id
WHERE
  T1.molecule_id = "TR060";
```
=====================
Question: Which bond type accounted for the majority of the bonds found in molecule TR010 and state whether or not this molecule is carcinogenic?
 db_id: toxicology
Planner: Plan:
1. Find the count of each bond type for molecule TR010 from the `bond` table.
2. Determine the bond type with the maximum count.
3. Retrieve the carcinogenicity label for molecule TR010 from the `molecule` table.
4. Combine the results to output the majority bond type and the carcinogenicity label.
Tables: bond, molecule
Columns:
- bond: molecule_id, bond_type
- molecule: molecule_id, label
Filters:
- bond: molecule_id = 'TR010'
- molecule: molecule_id = 'TR010'
Joins: None
Aggregations: COUNT(bond_type), MAX(COUNT(bond_type))

NL2SQL: ```sql
SELECT
  (
    SELECT bond_type
    FROM bond
    WHERE
      molecule_id = 'TR010'
    GROUP BY
      bond_type
    ORDER BY
      COUNT(bond_type) DESC
    LIMIT 1
  ), label
FROM molecule
WHERE
  molecule_id = 'TR010';
```
Critic: ```sql
SELECT
  (
    SELECT bond_type
    FROM bond
    WHERE
      molecule_id = 'TR010'
    GROUP BY
      bond_type
    ORDER BY
      COUNT(*) DESC
    LIMIT 1
  ),
  label
FROM molecule
WHERE
  molecule_id = 'TR010';
```
=====================
Question: Please list top three molecules that have single bonds between two atoms and are not carcinogenic in alphabetical order.
 db_id: toxicology
Planner: Plan:
1. Find `molecule_id` with single bonds from the `bond` table where `bond_type` is '-'.
2. Filter molecules that are not carcinogenic by joining the `molecule` table on `molecule_id` and filtering where `label` is '-'.
3. Select distinct `molecule_id` and order alphabetically.
4. Limit the result to the top 3.

NL2SQL: ```sql
SELECT DISTINCT T1.molecule_id FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '-' AND T2.label = '-' ORDER BY T1.molecule_id ASC LIMIT 3
```
Critic: ```sql
SELECT DISTINCT T1.molecule_id FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '-' AND T2.label = '-' ORDER BY T1.molecule_id ASC LIMIT 3
```
=====================
Question: How many bonds which involved atom 12 does molecule TR009 have?
 db_id: toxicology
Planner: Plan:
1. Filter the `atom` table to find the `atom_id` associated with molecule TR009 and atom number 12. We'll need to check if the molecule id is TR009 and atom id contains 12
2. Filter the `connected` table for the `atom_id` found in the previous step in the columns `atom_id` or `atom_id2` to check which bonds include atom 12.
3. Count the number of such bonds.
4. Return the final count.

NL2SQL: ```sql
SELECT
  COUNT(bond_id)
FROM connected
WHERE
  atom_id = 'TR009_12' OR atom_id2 = 'TR009_12';
```
Critic: ```sql
SELECT
  COUNT(T1.bond_id)
FROM connected AS T1
INNER JOIN atom AS T2
  ON T1.atom_id = T2.atom_id
WHERE
  T2.molecule_id = 'TR009' AND (
    T1.atom_id = 'TR009_12' OR T1.atom_id2 = 'TR009_12'
  );
```
=====================
Question: What are the bond type and the atoms of the bond ID of TR001_6_9?
 db_id: toxicology
Planner: Plan:
1. Find the `bond_type` from the `bond` table using the given `bond_id`.
2. Find the `atom_id` and `atom_id2` from the `connected` table using the same `bond_id`.
3. Return the `bond_type` and `atom_id` and `atom_id2`.
Tables: `bond`, `connected`
Columns: `bond`.`bond_type`, `connected`.`atom_id`, `connected`.`atom_id2`
Filters: `bond`.`bond_id` = "TR001_6_9", `connected`.`bond_id` = "TR001_6_9"
Joins: None
Final Answer:
```nl2sql
SELECT T1.bond_type ,  T2.atom_id ,  T2.atom_id2 FROM bond AS T1 JOIN connected AS T2 ON T1.bond_id  =  T2.bond_id WHERE T1.bond_id  =  "TR001_6_9"
```
NL2SQL: ```sql
SELECT T1.bond_type, T2.atom_id, T2.atom_id2 FROM bond AS T1 JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T1.bond_id = "TR001_6_9"
```
Critic: ```sql
SELECT T1.bond_type, T2.atom_id, T2.atom_id2 FROM bond AS T1 JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T1.bond_id = "TR001_6_9"
```
=====================
Question: How many connections does the atom 19 have?
 db_id: toxicology
Planner: Plan:
1. Filter the `connected` table to find rows where `atom_id` or `atom_id2` matches the atom ID 'TR%_19'.
2. Count the number of rows that satisfy the condition. This count represents the number of connections for atom 19.
Tables: `connected`
Columns: `atom_id`, `atom_id2`
Filters: `atom_id` = 'TR%_19' or `atom_id2` = 'TR%_19'
Aggregation: COUNT(*)

NL2SQL: ```sql
SELECT count(*) FROM connected WHERE atom_id = 'TR%_19' OR atom_id2 = 'TR%_19'
```
Critic: ```sql
SELECT count(*) FROM connected WHERE atom_id = 'TR%_19' OR atom_id2 = 'TR%_19';
```
=====================
Question: List all the elements of the toxicology of the molecule "TR004".
 db_id: toxicology
Planner: Plan:
1. Find the `molecule_id` for the molecule "TR004" from the `molecule` table.
2. Use the `molecule_id` to find the corresponding `element` values from the `atom` table.
3. Return the list of `element` values.

Tables:
- molecule: To find the molecule_id of TR004.
- atom: To find elements with the molecule_id.

Columns:
- molecule.molecule_id: To filter molecule by id.
- atom.molecule_id: To join with molecule table.
- atom.element: To select element values.

Filters:
- molecule.molecule_id = "TR004"

Joins:
- Join `molecule` and `atom` tables on `molecule.molecule_id = atom.molecule_id`.

NL2SQL: ```sql
SELECT
  T1.element
FROM atom AS T1
INNER JOIN molecule AS T2
  ON T1.molecule_id = T2.molecule_id
WHERE
  T2.molecule_id = 'TR004';
```
Critic: ```sql
SELECT
  T1.element
FROM atom AS T1
WHERE
  T1.molecule_id = 'TR004';
```
=====================
Question: Among all the atoms from 21 to 25, list all the molecules that are carcinogenic.
 db_id: toxicology
Planner: Plan:
1. Filter the `atom` table to get the `molecule_id` of atoms with `atom_id` between 21 and 25.
2. Join the filtered `atom` table with the `molecule` table on `molecule_id`.
3. Filter the joined table for molecules where `label` is '+'.
4. Select the `molecule_id` from the resulting table.

NL2SQL: ```sql
SELECT DISTINCT T1.molecule_id FROM atom AS T1 JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE SUBSTR(T1.atom_id, 7, 2) BETWEEN '21' AND '25' AND T2.label = '+';
```
Critic: ```sql
SELECT DISTINCT T1.molecule_id FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE SUBSTR(T1.atom_id, 7, 2) BETWEEN '21' AND '25' AND T2.label = '+';
```
=====================
Question: What are the bonds that have phosphorus and nitrogen as their atom elements?
 db_id: toxicology
Planner: Plan:
1. Find the `atom_id`s of atoms with element 'p' and 'n' from the `atom` table.
2. Use the `connected` table to find the `bond_id`s that connect an atom with element 'p' and an atom with element 'n'. This requires two joins with the `connected` table.
3. Select the `bond_id` from the `bond` table.

Tables: `atom`, `connected`, `bond`
Columns: `atom`.`atom_id`, `atom`.`element`, `connected`.`atom_id`, `connected`.`atom_id2`, `connected`.`bond_id`, `bond`.`bond_id`
Filters: `atom`.`element` = 'p', `atom`.`element` = 'n'
Joins: `atom` with `connected` on `atom`.`atom_id` = `connected`.`atom_id`, `atom` with `connected` on `atom`.`atom_id` = `connected`.`atom_id2`, `connected` with `bond` on `connected`.`bond_id` = `bond`.`bond_id`
Final Output: `bond`.`bond_id`

NL2SQL: ```sql
SELECT DISTINCT T1.bond_id FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id INNER JOIN atom AS T3 ON T2.atom_id = T3.atom_id INNER JOIN atom AS T4 ON T2.atom_id2 = T4.atom_id WHERE T3.element = 'p' AND T4.element = 'n'
```
Critic: ```sql
SELECT DISTINCT T1.bond_id FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id INNER JOIN atom AS T3 ON T2.atom_id = T3.atom_id INNER JOIN atom AS T4 ON T2.atom_id2 = T4.atom_id WHERE T3.element = 'P' AND T4.element = 'N'
```
=====================
Question: Is the molecule with the most double bonds carcinogenic?
 db_id: toxicology
Planner: Plan:
1. Count the number of double bonds for each molecule using the `bond` table, filtering for `bond_type` equal to '=' and grouping by `molecule_id`.
2. Find the `molecule_id` with the maximum number of double bonds.
3. Check if the molecule with the maximum number of double bonds is carcinogenic by joining the result with the `molecule` table and checking the `label` column.

We need `bond` table to count the number of double bonds.
We need `molecule` table to check the `label` and to determine if a molecule is carcinogenic.
The tables are joined on `molecule_id`.
From `bond` table, we use `molecule_id` and `bond_type`.
From `molecule` table, we use `molecule_id` and `label`.
We filter based on `bond_type = '='` and `label = '+'`.

NL2SQL: ```sql
SELECT CASE WHEN T2.label = '+' THEN 'yes' ELSE 'no' END FROM (SELECT molecule_id FROM bond WHERE bond_type = '=' GROUP BY molecule_id ORDER BY count(*) DESC LIMIT 1) AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id
```
Critic: ```sql
SELECT CASE WHEN T2.label = '+' THEN 'yes' ELSE 'no' END FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '=' GROUP BY T2.label ORDER BY count(*) DESC LIMIT 1
```
=====================
Question: What is the average number of bonds the atoms with the element iodine have?
 db_id: toxicology
Planner: Plan:
1.  Find all atoms with the element 'I' using the `atom` table.
2.  For each of these atoms, find the bonds they are connected to using the `connected` table.
3.  Count the number of bonds connected to each iodine atom.
4.  Calculate the average number of bonds per iodine atom.
5.  The final query should return a single value representing the average number of bonds.
I need `atom` and `connected` table. `atom` table to filter atoms with element = 'I' and then use `connected` table to connect atom\_id and find the count of bonds.

NL2SQL: ```sql
SELECT CAST(COUNT(DISTINCT T1.bond_id) AS REAL) / COUNT(DISTINCT T2.atom_id) FROM connected AS T1 JOIN atom AS T2 ON T1.atom_id = T2.atom_id WHERE T2.element = 'I'
```
Critic: ```sql
SELECT CAST(SUM(CASE WHEN T2.element = 'I' THEN 1 ELSE 0 END) AS REAL) / COUNT(T2.element) FROM connected AS T1 JOIN atom AS T2 ON T1.atom_id = T2.atom_id
```
=====================
Question: List all the elements of atoms that can not bond with any other atoms.
 db_id: toxicology
Planner: Plan:
1. Find all atom_ids that appear in the `connected` table (either as atom_id or atom_id2).
2. Find all atoms from the `atom` table.
3. Filter the `atom` table to include only atoms whose `atom_id` is not in the set of `atom_id`s found in step 1.
4. Select the `element` column from the filtered `atom` table.
Tables: atom, connected
Columns: atom.atom_id, atom.element, connected.atom_id, connected.atom_id2
Filters: atom.atom_id NOT IN (connected.atom_id UNION connected.atom_id2)
Joins: None
Final Output: element

NL2SQL: ```sql
SELECT element FROM atom WHERE atom_id NOT IN (SELECT atom_id FROM connected UNION SELECT atom_id2 FROM connected)
```
Critic: ```sql
SELECT element FROM atom WHERE atom_id NOT IN (SELECT atom_id FROM connected UNION SELECT atom_id2 FROM connected)
```
=====================
Question: What are the atoms of the triple bond with the molecule "TR041"?
 db_id: toxicology
Planner: Plan:
1. Find the `bond_id` of bonds in the molecule "TR041" that are triple bonds (bond_type = '#') using the `bond` table.
2. Find the `atom_id`s connected by these `bond_id`s using the `connected` table.
3. Find the `element` of these `atom_id`s using the `atom` table.

Tables: `bond`, `connected`, `atom`
Columns:
*   `bond`: `molecule_id`, `bond_type`, `bond_id`
*   `connected`: `bond_id`, `atom_id`
*   `atom`: `atom_id`, `element`
Filters:
*   `bond`: `molecule_id` = "TR041", `bond_type` = '#'
Joins:
*   `bond` JOIN `connected` ON `bond`.`bond_id` = `connected`.`bond_id`
*   `connected` JOIN `atom` ON `connected`.`atom_id` = `atom`.`atom_id`

NL2SQL: ```sql
SELECT DISTINCT
  T3.element
FROM bond AS T1
INNER JOIN connected AS T2
  ON T1.bond_id = T2.bond_id
INNER JOIN atom AS T3
  ON T2.atom_id = T3.atom_id
WHERE
  T1.molecule_id = 'TR041' AND T1.bond_type = '#';
```
Critic: ```sql
SELECT DISTINCT
  T3.element
FROM bond AS T1
INNER JOIN connected AS T2
  ON T1.bond_id = T2.bond_id
INNER JOIN atom AS T3
  ON T2.atom_id = T3.atom_id
WHERE
  T1.molecule_id = 'TR041' AND T1.bond_type = '#'
UNION
SELECT DISTINCT
  T3.element
FROM bond AS T1
INNER JOIN connected AS T2
  ON T1.bond_id = T2.bond_id
INNER JOIN atom AS T3
  ON T2.atom_id2 = T3.atom_id
WHERE
  T1.molecule_id = 'TR041' AND T1.bond_type = '#';
```
=====================
Question: What are the elements of the atoms of TR144_8_19?
 db_id: toxicology
Planner: Plan:
1. Find the molecule ID associated with the given bond ID 'TR144_8_19' using the `bond` table.
2. Using the molecule ID found in step 1, find the elements of atoms in the `atom` table.
3. Return the elements.
Tables: `bond`, `atom`
Columns:
*   `bond`: `molecule_id`, `bond_id`
*   `atom`: `molecule_id`, `element`
Joins: None
Filters:
*   `bond`: `bond_id` = 'TR144_8_19'
*   `atom`: `molecule_id` = molecule ID from `bond` table.

NL2SQL: ```sql
SELECT DISTINCT
  T2.element
FROM bond AS T1
INNER JOIN atom AS T2
  ON T1.molecule_id = T2.molecule_id
WHERE
  T1.bond_id = 'TR144_8_19';
```
Critic: ```sql
SELECT DISTINCT T1.element FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.bond_id = "TR144_8_19"
```
=====================
Question: List the elements of all the triple bonds.
 db_id: toxicology
Planner: Plan:
1. Filter the `bond` table to get the `bond_id` of the bonds where `bond_type` is '#'.
2. Join the `connected` table with the filtered `bond` table on `bond_id`.
3. Join the `atom` table with the `connected` table on `atom_id` to get the `element` of the first atom.
4. Join the `atom` table with the `connected` table on `atom_id2` to get the `element` of the second atom.
5. Select distinct `element` from the first atom table.

NL2SQL: ```sql
SELECT DISTINCT
  T1.element
FROM atom AS T1
INNER JOIN connected AS T2
  ON T1.atom_id = T2.atom_id
INNER JOIN bond AS T3
  ON T2.bond_id = T3.bond_id
WHERE
  T3.bond_type = '#';
```
Critic: ```sql
SELECT DISTINCT
  T1.element
FROM atom AS T1
INNER JOIN connected AS T2
  ON T1.atom_id = T2.atom_id
INNER JOIN bond AS T3
  ON T2.bond_id = T3.bond_id
WHERE
  T3.bond_type = '#';
```
=====================
Question: What proportion of single bonds are carcinogenic? Please provide your answer as a percentage with five decimal places.
 db_id: toxicology
Planner: Plan:
1. Filter the `bond` table to select only single bonds (`bond_type` = '-').
2. Join the filtered `bond` table with the `molecule` table using `molecule_id`.
3. Count the total number of single bonds.
4. Count the number of single bonds that are carcinogenic (where `label` = '+').
5. Calculate the proportion of carcinogenic single bonds by dividing the count of carcinogenic single bonds by the total number of single bonds and multiplying by 100.
6. Round the result to five decimal places.

NL2SQL: ```sql
SELECT CAST(SUM(CASE WHEN T2.label = '+' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.bond_id) FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '-'
```
Critic: ```sql
SELECT CAST(SUM(CASE WHEN T2.label = '+' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.bond_id) FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '-'
```
=====================
Question: Calculate the total atoms with triple-bond molecules containing the element phosphorus or bromine.
 db_id: toxicology
Planner: Plan:
1. Filter the `bond` table to find `molecule_id` values where `bond_type` is '#'.
2. Filter the `atom` table to find `molecule_id` values where `element` is 'p' or 'br'.
3. Join the filtered tables on `molecule_id` to find the common `molecule_id` values.
4. From the joined table, count the total number of atoms.
5. Return the count.

NL2SQL: ```sql
SELECT
  SUM(CASE WHEN T1.element = 'p' THEN 1 ELSE 0 END) + SUM(CASE WHEN T1.element = 'br' THEN 1 ELSE 0 END)
FROM atom AS T1
INNER JOIN bond AS T2
  ON T1.molecule_id = T2.molecule_id
WHERE
  T2.bond_type = '#' AND (
    T1.element = 'p' OR T1.element = 'br'
  );
```
Critic: ```sql
SELECT
  SUM(CASE WHEN T1.element IN ('p', 'br') THEN 1 ELSE 0 END)
FROM atom AS T1
INNER JOIN molecule AS T3
  ON T1.molecule_id = T3.molecule_id
INNER JOIN bond AS T2
  ON T3.molecule_id = T2.molecule_id
WHERE
  T2.bond_type = '#';
```
=====================
Question: What is the composition of element chlorine in percentage among the single bond molecules?
 db_id: toxicology
Planner: Plan:
1. Filter the 'bond' table to select only single bonds (bond_type = '-').
2. Join the filtered 'bond' table with the 'connected' table using bond_id to determine the atoms involved in single bonds.
3. Join the 'connected' table with the 'atom' table on atom_id to identify atoms connected by single bonds.
4. Filter the 'atom' table to consider only chlorine atoms (element = 'Cl').
5. Count the number of chlorine atoms involved in single bonds and the total number of atoms involved in single bonds.
6. Calculate the percentage of chlorine atoms among all atoms involved in single bonds.
Return the percentage.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.element = 'Cl' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.atom_id)
FROM atom AS T1
INNER JOIN connected AS T2
  ON T1.atom_id = T2.atom_id
INNER JOIN bond AS T3
  ON T2.bond_id = T3.bond_id
WHERE
  T3.bond_type = '-';
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.element = 'Cl' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.atom_id)
FROM atom AS T1
INNER JOIN bond AS T2
  ON T1.molecule_id = T2.molecule_id
WHERE
  T2.bond_type = '-';
```
=====================
Question: What are the elements for bond id TR001_10_11?
 db_id: toxicology
Planner: Plan:
1. Find the `atom_id` and `atom_id2` connected by the given `bond_id` from the `connected` table.
2. Use the `atom_id` and `atom_id2` to find the corresponding `molecule_id` and `element` from the `atom` table.
3. Return the `element`.
Tables: `connected`, `atom`
Columns:
- `connected`: `bond_id`, `atom_id`, `atom_id2`
- `atom`: `atom_id`, `element`
Filters: `connected.bond_id` = 'TR001_10_11'
Joins: `connected.atom_id` = `atom.atom_id` OR `connected.atom_id2` = `atom.atom_id`
Return: `atom.element`

NL2SQL: ```sql
SELECT
  T1.element
FROM atom AS T1
INNER JOIN connected AS T2
  ON T1.atom_id = T2.atom_id
WHERE
  T2.bond_id = 'TR001_10_11'
UNION
SELECT
  T1.element
FROM atom AS T1
INNER JOIN connected AS T2
  ON T1.atom_id = T2.atom_id2
WHERE
  T2.bond_id = 'TR001_10_11';
```
Critic: ```sql
SELECT
  T1.element
FROM atom AS T1
INNER JOIN connected AS T2
  ON T1.atom_id = T2.atom_id1
WHERE
  T2.bond_id = 'TR001_10_11'
UNION
SELECT
  T1.element
FROM atom AS T1
INNER JOIN connected AS T2
  ON T1.atom_id = T2.atom_id2
WHERE
  T2.bond_id = 'TR001_10_11';
```
=====================
Question: What is the percentage of element chlorine in carcinogenic molecules?
 db_id: toxicology
Planner: Plan:
1. Find carcinogenic molecules from the `molecule` table where `label` is '+'.
2. Find atoms that belong to these carcinogenic molecules from the `atom` table.
3. Filter atoms to count only chlorine atoms (element = 'Cl').
4. Calculate the total number of atoms in carcinogenic molecules.
5. Calculate the percentage of chlorine atoms by dividing the number of chlorine atoms by the total number of atoms and multiplying by 100.
6. Handle the edge case where there are no atoms to prevent division by zero errors.
Tables: molecule, atom
Columns: molecule.molecule_id, molecule.label, atom.molecule_id, atom.element
Filters: molecule.label = '+', atom.element = 'Cl'
Joins: molecule JOIN atom ON molecule.molecule_id = atom.molecule_id
Aggregate functions: COUNT, SUM
Calculations: Percentage = (Number of Chlorine atoms / Total number of atoms) * 100

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.element = 'Cl' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.molecule_id)
FROM atom AS T1
INNER JOIN molecule AS T2
  ON T1.molecule_id = T2.molecule_id
WHERE
  T2.label = '+';
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.element = 'Cl' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.molecule_id)
FROM atom AS T1
INNER JOIN molecule AS T2
  ON T1.molecule_id = T2.molecule_id
WHERE
  T2.label = '+';
```
=====================
Question: Tally the toxicology element of the 4th atom of each molecule that was carcinogenic.
 db_id: toxicology
Planner: Plan:
1. Filter `molecule` table to find carcinogenic molecules (label = '+').
2. Join the filtered `molecule` table with the `atom` table on `molecule_id`.
3. Filter the joined table to select only the 4th atom of each molecule (substr(atom_id, 7, 1) = '4').
4. Select the `element` column from the filtered and joined table.
5. Count the occurrences of each element.
Tables: molecule, atom
Joins: molecule.molecule_id = atom.molecule_id
Filters: molecule.label = '+', substr(atom.atom_id, 7, 1) = '4'
Columns: atom.element
Aggregation: COUNT(atom.element)

NL2SQL: ```sql
SELECT element, COUNT(*) FROM molecule AS m JOIN atom AS a ON m.molecule_id = a.molecule_id WHERE m.label = '+' AND SUBSTR(a.atom_id, 7, 1) = '4' GROUP BY element
```
Critic: ```sql
SELECT element, COUNT(*) FROM molecule AS m JOIN atom AS a ON m.molecule_id = a.molecule_id WHERE m.label = '+' AND SUBSTR(a.atom_id, 7, 1) = '4' GROUP BY element
```
=====================
Question: What is the ratio of Hydrogen elements in molecule ID TR006? List the ratio with its label.
 db_id: toxicology
Planner: Plan:
1. Filter the `atom` table to get atoms with `molecule_id` = 'TR006'.
2. Calculate the number of Hydrogen atoms (element = 'H') in the filtered atoms.
3. Calculate the total number of atoms in the filtered atoms.
4. Calculate the ratio of Hydrogen atoms by dividing the number of Hydrogen atoms by the total number of atoms.
5. Output the calculated ratio with a label.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN element = 'H' THEN 1 ELSE 0 END) AS REAL) / COUNT(atom_id)
FROM atom
WHERE
  molecule_id = 'TR006';
```
Critic: ```sql
SELECT CAST(SUM(CASE WHEN element = 'H' THEN 1 ELSE 0 END) AS REAL) / COUNT(atom_id) FROM atom WHERE molecule_id = 'TR006'
```
=====================
Question: Which non-carcinogenic molecules consisted more than 5 atoms?
 db_id: toxicology
Planner: Plan:
1. Filter the `molecule` table to select non-carcinogenic molecules (label = '-').
2. Join the filtered `molecule` table with the `atom` table on `molecule_id`.
3. Group the results by `molecule_id` and count the number of atoms for each molecule.
4. Filter the grouped results to keep only molecules with more than 5 atoms (COUNT(atom_id) > 5).
5. Select the `molecule_id` of the molecules that satisfy the conditions.

NL2SQL: ```sql
SELECT T1.molecule_id FROM molecule AS T1 JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.label = '-' GROUP BY T1.molecule_id HAVING COUNT(T2.atom_id) > 5
```
Critic: ```sql
SELECT T1.molecule_id FROM molecule AS T1 JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.label = '-' GROUP BY T1.molecule_id HAVING COUNT(T2.atom_id) > 5
```
=====================
Question: How many schools with an average score in Math greater than 400 in the SAT test are exclusively virtual?
 db_id: california_schools
Planner: 1. Join the `schools` and `satscores` tables on a common key. Since `schools` has `CDSCode` as text and `satscores` does not have `CDSCode`, we should use `sname` from `satscores` and `School` from `schools` since they both represent school name.
2. Filter the joined table where `satscores.AvgScrMath` is greater than 400 and `schools.Virtual` is equal to 'Y'.
3. Count the number of schools that satisfy these conditions.

NL2SQL: ```sql
SELECT
  COUNT(T1.School)
FROM schools AS T1
INNER JOIN satscores AS T2
  ON T1.School = T2.sname
WHERE
  T2.AvgScrMath > 400 AND T1.Virtual = 'Y';
```
Critic: ```sql
SELECT
  COUNT(T1.School)
FROM schools AS T1
INNER JOIN satscores AS T2
  ON T1.School = T2.sname
WHERE
  T2.AvgScrMath > 400 AND T1.Virtual = 'F';
```
=====================
Question: Please list the codes of the schools with a total enrollment of over 500.
 db_id: california_schools
Planner: Plan:
1. Join the `frpm` and `schools` tables using the `CDSCode`.
2. Aggregate by `CDSCode` to calculate the total enrollment (`Enrollment (K-12)` + `Enrollment (Ages 5-17)`).
3. Filter the results to include only schools with a total enrollment greater than 500.
4. Select the `CDSCode` of the schools that meet the criteria.

NL2SQL: ```sql
SELECT
  T1.CDSCode
FROM frpm AS T1
INNER JOIN schools AS T2
  ON T1.CDSCode = T2.CDSCode
GROUP BY
  T1.CDSCode
HAVING
  SUM(T1."Enrollment (K-12)") + SUM(T1."Enrollment (Ages 5-17)") > 500;
```
Critic: ```sql
SELECT
  CDSCode
FROM frpm
GROUP BY
  CDSCode
HAVING
  SUM("Enrollment (K-12)") > 500;
```
=====================
Question: Among the schools with an SAT excellence rate of over 0.3, what is the highest eligible free rate for students aged 5-17?
 db_id: california_schools
Planner: 1.  Join the `satscores` table and the `frpm` table on the condition `satscores.cds = frpm.CDSCode`.
2.  Filter the joined table to include only schools where `satscores.NumGE1500 / satscores.NumTstTakr > 0.3`.
3.  Select the maximum value of `frpm.Percent (%) Eligible Free (Ages 5-17)` from the filtered table.


NL2SQL: ```sql
SELECT
  MAX(T2."Percent (%) Eligible Free (Ages 5-17)")
FROM satscores AS T1
INNER JOIN frpm AS T2
  ON T1.cds = T2.CDSCode
WHERE
  T1.NumGE1500 * 1.0 / T1.NumTstTakr > 0.3;
```
Critic: ```sql
SELECT
  MAX("Percent (%) Eligible Free (Ages 5-17)")
FROM frpm
WHERE
  "CDSCode" IN (
    SELECT
      CAST(cds AS INTEGER)
    FROM satscores
    WHERE
      CAST(NumGE1500 AS REAL) / CAST(NumTstTakr AS REAL) > 0.3
  );
```
=====================
Question: Rank schools by their average score in Writing where the score is greater than 499, showing their charter numbers.
 db_id: california_schools
Planner: Plan:
1. Join the `schools` table and the `satscores` table on the condition that `schools.CDSCode` equals `satscores.cds`.
2. Filter the results to include only schools where `AvgScrWrite` is greater than 499.
3. Group the results by `schools.CharterNum`.
4. Calculate the average `AvgScrWrite` for each school.
5. Order the results in descending order based on the average `AvgScrWrite`.
6. Select the `CharterNum` and the average `AvgScrWrite`.

NL2SQL: ```sql
SELECT
  s.CharterNum,
  AVG(sa.AvgScrWrite) AS average_writing_score
FROM schools AS s
JOIN satscores AS sa
  ON s.CDSCode = sa.cds
WHERE
  sa.AvgScrWrite > 499
GROUP BY
  s.CharterNum
ORDER BY
  average_writing_score DESC;
```
Critic: ```sql
SELECT
  T1.CharterNum,
  AVG(T2.AvgScrWrite)
FROM schools AS T1
INNER JOIN satscores AS T2
  ON T1.CDSCode = T2.cds
WHERE
  T2.AvgScrWrite > 499
  AND T1.CharterNum IS NOT NULL
GROUP BY
  T1.CharterNum
ORDER BY
  AVG(T2.AvgScrWrite) DESC;
```
=====================
Question: List the names of schools with more than 30 difference in enrollements between K-12 and ages 5-17? Please also give the full street adress of the schools.
 db_id: california_schools
Planner: Plan:
1. Select the school name and street address from the `schools` table.
2. Join the `schools` table with the `frpm` table on the `CDSCode` column.
3. Filter the results where the absolute difference between `Enrollment (K-12)` and `Enrollment (Ages 5-17)` in the `frpm` table is greater than 30.
4. Return the school name and street address for the filtered schools.

NL2SQL:
```sql
SELECT
  s.School,
  s.Street
FROM schools AS s
JOIN frpm AS f
  ON s.CDSCode = f.CDSCode
WHERE
  ABS(f."Enrollment (K-12)" - f."Enrollment (Ages 5-17)") > 30;
```
NL2SQL: ```sql
SELECT
  s.School,
  s.Street
FROM schools AS s
JOIN frpm AS f
  ON s.CDSCode = f.CDSCode
WHERE
  ABS(f."Enrollment (K-12)" - f."Enrollment (Ages 5-17)") > 30;
```
Critic: ```sql
SELECT
  School,
  Street
FROM schools
WHERE
  CDSCode IN (
    SELECT
      CDSCode
    FROM frpm
    WHERE
      ABS("Enrollment (K-12)" - "Enrollment (Ages 5-17)") > 30
  );
```
=====================
Question: Give the names of the schools with the percent eligible for free meals in K-12 is more than 0.1 and test takers whose test score is greater than or equal to 1500?
 db_id: california_schools
Planner: Here's the plan to retrieve the school names based on the given conditions:

1.  **Join Tables:** Join the `schools`, `frpm`, and `satscores` tables.
    *   `schools` and `frpm` will be joined on `CDSCode` to link school information with free meal eligibility data.
    *   `schools` and `satscores` will be joined on `School` name.
2.  **Filter Data:**
    *   Filter `frpm` table where `Percent (%) Eligible Free (K-12)` is greater than 0.1.
    *   Filter `satscores` table where `NumGE1500` is greater than or equal to 1.
3.  **Select School Names:** Retrieve the `School` column from the `schools` table.

NL2SQL: ```sql
SELECT
  T1.School
FROM schools AS T1
INNER JOIN frpm AS T2
  ON T1.CDSCode = T2.CDSCode
INNER JOIN satscores AS T3
  ON T1.School = T3.sname
WHERE
  T2."Percent (%) Eligible Free (K-12)" > 0.1 AND T3.NumGE1500 >= 1;
```
Critic: ```sql
SELECT DISTINCT
  T1.School
FROM schools AS T1
INNER JOIN frpm AS T2
  ON T1.CDSCode = T2.CDSCode
INNER JOIN satscores AS T3
  ON T1.School = T3.sname
WHERE
  T2."Percent (%) Eligible Free (K-12)" > 0.1 AND T3.NumGE1500 >= 1;
```
=====================
Question: Name schools in Riverside which the average of average math score for SAT is grater than 400, what is the funding type of these schools?
 db_id: california_schools
Planner: 1. **Filter schools in Riverside:** Use the `schools` table and filter by `City = 'Riverside'`.
2. **Calculate the average math SAT score for each school:** Join the `schools` and `satscores` tables on the appropriate school identifier (`CDSCode` from `schools` and `cds` from `satscores`). Group by school and calculate the average `AvgScrMath`.
3. **Filter schools with average math score greater than 400:** Filter the results from the previous step where the average math score is greater than 400.
4. **Get the funding type of the schools:** Retrieve the `FundingType` from the `schools` table for the schools that satisfy the above condition.
5. **Return the school name and the funding type.**

NL2SQL: ```sql
SELECT
  T1.School,
  T1.FundingType
FROM schools AS T1
INNER JOIN satscores AS T2
  ON T1.CDSCode = T2.cds
WHERE
  T1.City = 'Riverside'
GROUP BY
  T1.School
HAVING
  AVG(T2.AvgScrMath) > 400;
```
Critic: ```sql
SELECT DISTINCT
  T1.School,
  T1.FundingType
FROM schools AS T1
INNER JOIN satscores AS T2
  ON T1.CDSCode = T2.cds
WHERE
  T1.City = 'Riverside' AND T2.AvgScrMath > 400;
```
=====================
Question: State the names and full communication address of high schools in Monterey which has more than 800 free or reduced price meals for ages 15-17?
 db_id: california_schools
Planner: Here's a plan to retrieve the requested information:

1.  **Identify the relevant tables:**
    *   `schools`: Contains school names, addresses, city, zip and county information.
    *   `frpm`: Contains free or reduced price meal counts for schools, specifically the 'FRPM Count (Ages 5-17)' column.

2.  **Join the tables:**
    *   Join `schools` and `frpm` on the `CDSCode` to link school information with meal count data. Note `CDSCode` is Text in `schools` table and Integer in `frpm` table so it need type casting.

3.  **Filter the results:**
    *   Filter by `County = 'Monterey'` in `schools` table to only include high schools in Monterey county.
    *   Filter for schools that have a `FRPM Count (Ages 5-17)` greater than 800 in the `frpm` table.
    *   Filter `frpm` table to only include rows where `High Grade` is greater than or equal to 9 and `Low Grade` is less than or equal to 12.

4.  **Construct the output:**
    *   Concatenate the school's `Street`, `City`, `State`, and `Zip` from the `schools` table to create the full address.
    *   Select the `School` name from the `schools` table and the constructed address.

SQL:
```sql
SELECT
  s.School,
  s.Street || ', ' || s.City || ', ' || s.State || ', ' || s.Zip AS FullAddress
FROM schools AS s
JOIN frpm AS f
  ON CAST(s.CDSCode AS INTEGER) = f.CDSCode
WHERE
  s.County = 'Monterey'
  AND f."FRPM Count (Ages 5-17)" > 800
  AND f."High Grade" >= '09'
  AND f."Low Grade" <= '12';
```
NL2SQL: ```sql
SELECT
  s.School,
  s.Street || ', ' || s.City || ', ' || s.State || ', ' || s.Zip
FROM schools AS s
JOIN frpm AS f
  ON CAST(s.CDSCode AS INTEGER) = f.CDSCode
WHERE
  s.County = 'Monterey'
  AND f."FRPM Count (Ages 5-17)" > 800;
```
Critic: ```sql
SELECT
  s.School,
  s.Street || ', ' || s.City || ', ' || s.State || ', ' || s.Zip
FROM schools AS s
JOIN frpm AS f
  ON s.CDSCode = CAST(f.CDSCode AS TEXT)
WHERE
  s.County = 'Monterey'
  AND f."FRPM Count (Ages 5-17)" > 800;
```
=====================
Question: What is the average score in writing for the schools that were opened after 1991 or closed before 2000? List the school names along with the score. Also, list the communication number of the schools if there is any.
 db_id: california_schools
Planner: Plan:
1. Filter schools table for schools opened after 1991 or closed before 2000.
2. Join schools table with satscores table on school name.
3. Select the school name, average writing score, and phone number.
4. Calculate the average writing score.

NL2SQL: ```sql
SELECT
  s.School,
  AVG(sa.AvgScrWrite),
  s.Phone
FROM schools AS s
JOIN satscores AS sa
  ON s.School = sa.sname
WHERE
  s.OpenDate > '1991-12-31' OR s.ClosedDate < '2000-01-01'
GROUP BY
  s.School,
  s.Phone;
```
Critic: ```sql
SELECT
  T1.School,
  AVG(T2.AvgScrWrite),
  T1.Phone
FROM schools AS T1
INNER JOIN satscores AS T2
  ON T1.School = T2.sname
WHERE
  T1.OpenDate > '1991-12-31' OR T1.ClosedDate < '2000-01-01'
GROUP BY
  T1.School,
  T1.Phone;
```
=====================
Question: Consider the average difference between K-12 enrollment and 15-17 enrollment of schools that are locally funded, list the names and DOC type of schools which has a difference above this average.
 db_id: california_schools
Planner: Plan:
1. Calculate the difference between K-12 enrollment and 5-17 enrollment using `Enrollment (K-12)` - `Enrollment (Ages 5-17)` from the `frpm` table.
2. Filter the `schools` table for schools with `FundingType` = 'Locally Funded'.
3. Calculate the average of the enrollment differences for locally funded schools.
4. Select school names and DOC type for the schools where the enrollment difference is greater than the calculated average.
5. Join `frpm` and `schools` tables on the condition `frpm.CDSCode = schools.CDSCode`.
6. Aggregate result by `schools.School` and `schools.DOCType`.

NL2SQL: ```sql
SELECT
  T1.School,
  T1.DOCType
FROM schools AS T1
INNER JOIN frpm AS T2
  ON T1.CDSCode = T2.CDSCode
WHERE
  T1.FundingType = 'Locally Funded'
GROUP BY
  T1.School,
  T1.DOCType
HAVING
  AVG(T2."Enrollment (K-12)" - T2."Enrollment (Ages 5-17)") > (
    SELECT
      AVG(T2."Enrollment (K-12)" - T2."Enrollment (Ages 5-17)")
    FROM schools AS T1
    INNER JOIN frpm AS T2
      ON T1.CDSCode = T2.CDSCode
    WHERE
      T1.FundingType = 'Locally Funded'
  );
```
Critic: ```sql
SELECT
  T1.School,
  T1.DOCType
FROM schools AS T1
INNER JOIN frpm AS T2
  ON T1.CDSCode = T2.CDSCode
WHERE
  T1.FundingType = 'Locally Funded' AND (T2."Enrollment (K-12)" - T2."Enrollment (Ages 5-17)") > (
    SELECT
      AVG(T2."Enrollment (K-12)" - T2."Enrollment (Ages 5-17)")
    FROM schools AS T1
    INNER JOIN frpm AS T2
      ON T1.CDSCode = T2.CDSCode
    WHERE
      T1.FundingType = 'Locally Funded'
  );
```
=====================
Question: What is the eligible free rate of the 10th and 11th schools with the highest enrolment for students in grades 1 through 12?
 db_id: california_schools
Planner: Plan:
1. Join the `schools` and `frpm` tables on `CDSCode`.
2. Filter the data to include only schools where the `Low Grade` is less than or equal to '1' and the `High Grade` is greater than or equal to '12'.
3. Order the result by `Enrollment (K-12)` in descending order.
4. Limit the result to the 10th and 11th rows.
5. Select the `Percent (%) Eligible Free (K-12)` column.

NL2SQL: ```sql
SELECT
  "Percent (%) Eligible Free (K-12)"
FROM schools AS T1
INNER JOIN frpm AS T2
  ON T1.CDSCode = T2.CDSCode
WHERE
  T2."Low Grade" <= '1' AND T2."High Grade" >= '12'
ORDER BY
  T2."Enrollment (K-12)" DESC
LIMIT 2 OFFSET 9;
```
Critic: ```sql
SELECT
  "Percent (%) Eligible Free (K-12)"
FROM frpm
WHERE
  "Low Grade" <= '1' AND "High Grade" >= '12'
ORDER BY
  "Enrollment (K-12)" DESC
LIMIT 2 OFFSET 9;
```
=====================
Question: What is the eligible free or reduced price meal rate for the top 5 schools in grades 1-12 with the highest free or reduced price meal count of the schools with the ownership code 66?
 db_id: california_schools
Planner: Plan:
1. Filter the `schools` table for schools with `SOC` equal to 66.
2. Join the filtered `schools` table with the `frpm` table on `CDSCode`.
3. Filter the joined table for schools with `Low Grade` equal to 1 and `High Grade` equal to 12, to filter the grades 1-12.
4. Calculate the `FRPM Count (K-12)` for each school.
5. Calculate `Percent (%) Eligible FRPM` from `frpm` table.
6. Order the results by `FRPM Count (K-12)` in descending order.
7. Select the top 5 schools.
8. Output the `Percent (%) Eligible FRPM` for the top 5 schools.

NL2SQL: ```sql
SELECT
  T1."Percent (%) Eligible FRPM (K-12)"
FROM frpm AS T1
INNER JOIN schools AS T2
  ON T1.CDSCode = T2.CDSCode
WHERE
  T2.SOC = '66' AND T1.LowGrade = '1' AND T1.HighGrade = '12'
ORDER BY
  T1."FRPM Count (K-12)" DESC
LIMIT 5;
```
Critic: ```sql
SELECT
  T1."Percent (%) Eligible FRPM (K-12)"
FROM frpm AS T1
INNER JOIN schools AS T2
  ON T1.CDSCode = T2.CDSCode
WHERE
  T2.SOC = '66' AND T1.LowGrade = '1' AND T1.HighGrade = '12'
ORDER BY
  T1."FRPM Count (K-12)" DESC
LIMIT 5;
```
=====================
Question: What is the complete address of the school with the lowest excellence rate? Indicate the Street, City, Zip and State.
 db_id: california_schools
Planner: 1.  Calculate the excellence rate for each school by joining the `satscores` and `schools` tables. The join will happen on the school name since we do not have a common id. The excellence rate will be calculated as `NumGE1500` / `NumTstTakr`.
2.  Find the minimum excellence rate among all schools.
3.  Retrieve the `Street`, `City`, `Zip`, and `State` from the `schools` table for the school(s) with the minimum excellence rate.

NL2SQL: ```sql
SELECT
  T1.Street,
  T1.City,
  T1.Zip,
  T1.State
FROM schools AS T1
INNER JOIN satscores AS T2
  ON T1.School = T2.sname
ORDER BY
  CAST(T2.NumGE1500 AS REAL) / T2.NumTstTakr
LIMIT 1;
```
Critic: ```sql
SELECT
  Street,
  City,
  Zip,
  State
FROM schools
WHERE
  School IN (
    SELECT
      sname
    FROM satscores
    ORDER BY
      CAST(NumGE1500 AS REAL) / NumTstTakr
    LIMIT 1
  );
```
=====================
Question: Under whose administration is the school with the highest number of students scoring 1500 or more on the SAT? Indicate their full names.
 db_id: california_schools
Planner: Here's a plan to determine the administrator of the school with the highest number of students scoring 1500 or more on the SAT:

1.  **Find the school with the highest `NumGE1500`:**
    *   Table: `satscores`
    *   Column: `NumGE1500`
    *   Operation: Find the maximum value of `NumGE1500`.
    *   Get the `cds` (school code) of the school with the highest `NumGE1500`.

2.  **Retrieve school information from the `schools` table:**
    *   Table: `schools`
    *   Column: `CDSCode`
    *   Filter: `CDSCode` equals the `cds` obtained in step 1.
    *   Retrieve administrator's full name: `AdmFName1`, `AdmLName1`, `AdmFName2`, `AdmLName2`, `AdmFName3`, `AdmLName3`.

3. **Present the administrator's full name.**

NL2SQL:
```sql
SELECT
  CASE
    WHEN T1.AdmFName1 IS NOT NULL AND T1.AdmLName1 IS NOT NULL
    THEN T1.AdmFName1 || ' ' || T1.AdmLName1
    ELSE NULL
  END AS AdministratorFullName
FROM schools AS T1
INNER JOIN satscores AS T2
  ON T1.CDSCode = T2.cds
ORDER BY
  T2.NumGE1500 DESC
LIMIT 1;
```
NL2SQL: ```sql
SELECT
  T1.AdmFName1,
  T1.AdmLName1
FROM schools AS T1
INNER JOIN satscores AS T2
  ON T1.CDSCode = T2.cds
ORDER BY
  T2.NumGE1500 DESC
LIMIT 1;
```
Critic: ```sql
SELECT
  T1.AdmFName1,
  T1.AdmLName1
FROM schools AS T1
INNER JOIN satscores AS T2
  ON T1.CDSCode = T2.cds
WHERE
  T2.NumGE1500 = (
    SELECT
      MAX(NumGE1500)
    FROM satscores
  );
```
=====================
Question: What is the average number of test takers from Fresno schools that opened between 1/1/1980 and 12/31/1980?
 db_id: california_schools
Planner: 1.  **Join Tables:** Join the `schools` table and the `satscores` table. The join should use the `CDSCode` column from the `schools` table and the `cds` column from the `satscores` table.
2.  **Filter Schools:** Filter the joined table to include only schools in Fresno County (where `County` = 'Fresno'). Also filter schools that opened in 1980. `OpenDate` between '1980-01-01' and '1980-12-31'.
3.  **Calculate Average:** Calculate the average number of test takers (`NumTstTakr`) for the filtered schools.

NL2SQL: ```sql
SELECT AVG(T2.NumTstTakr)
FROM schools AS T1
INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds
WHERE
  T1.County = 'Fresno' AND T1.OpenDate BETWEEN '1980-01-01' AND '1980-12-31';
```
Critic: ```sql
SELECT
  AVG(s.NumTstTakr)
FROM schools AS sc
JOIN satscores AS s
  ON sc.CDSCode = s.cds
WHERE
  sc.County = 'Fresno' AND STRFTIME('%Y', sc.OpenDate) = '1980';
```
=====================
Question: What is the telephone number for the school with the lowest average score in reading in Fresno Unified?
 db_id: california_schools
Planner: Here's a plan to determine the phone number for the school with the lowest average reading score in the Fresno Unified School District:

1.  **Find schools in Fresno Unified:**
    *   Filter the `satscores` table to include only schools where `dname` (district name) is 'Fresno Unified'.
    *   Find the school with the lowest average reading score using `MIN(AvgScrRead)` from the filtered `satscores` records. We will need the school name `sname` for the school with the minimum `AvgScrRead`.

2.  **Get school phone number:**
    *   Join the `schools` table and the `satscores` table where `schools.School` is equal to `satscores.sname`
    *   Filter `schools` table so that schools.District is equal to 'Fresno Unified' and schools.School is equal to the school name from the previous step.
    *   Retrieve the `Phone` number from the `schools` table for that specific school.

NL2SQL: ```sql
SELECT
  T1.Phone
FROM schools AS T1
INNER JOIN satscores AS T2
  ON T1.School = T2.sname
WHERE
  T1.District = 'Fresno Unified'
ORDER BY
  T2.AvgScrRead
LIMIT 1;
```
Critic: ```sql
SELECT
  T1.Phone
FROM schools AS T1
INNER JOIN satscores AS T2
  ON T1.CDSCode = T2.cds
WHERE
  T1.District = 'Fresno Unified'
ORDER BY
  T2.AvgScrRead
LIMIT 1;
```
=====================
Question: List the names of virtual schools that are among the top 5 in their respective counties based on average reading scores.
 db_id: california_schools
Planner: Here's a plan to identify the top 5 virtual schools in each county based on average reading scores:

1.  **Join `schools` and `satscores`:** Join the `schools` and `satscores` tables on the appropriate school identifier (`sname` in `satscores` and `School` in `schools`, and `cname` in `satscores` and `County` in `schools`).
2.  **Filter for Virtual Schools:** Filter the joined table to include only virtual schools (`Virtual` = 'Yes' or similar, check for possible values).
3.  **Rank Schools by Reading Score within each County:** Use the `RANK()` window function to rank schools within each county based on their average reading scores (`AvgScrRead`). Partition by `County` from the `schools` table.
4.  **Filter for Top 5 Schools:** Filter the results to include only schools with a rank of 5 or less.
5.  **Select School Names:** Select the `School` name from `schools` table, display the name of top 5 schools in their respective counties.

NL2SQL: ```sql
SELECT
  s.School
FROM (
  SELECT
    s.School,
    s.County,
    AVG(sa.AvgScrRead) AS avg_reading_score,
    RANK() OVER (PARTITION BY s.County ORDER BY AVG(sa.AvgScrRead) DESC) AS rank_within_county
  FROM schools AS s
  JOIN satscores AS sa
    ON s.School = sa.sname AND s.County = sa.cname
  WHERE
    s.Virtual = 'Yes'
  GROUP BY
    s.School,
    s.County
) AS ranked_schools
WHERE
  rank_within_county <= 5;
```
Critic: ```sql
SELECT
  T1.School
FROM schools AS T1
INNER JOIN satscores AS T2
  ON T1.School = T2.sname AND T1.County = T2.cname
WHERE
  T1.Virtual = 'Yes'
GROUP BY
  T1.County,
  T1.School
ORDER BY
  AVG(T2.AvgScrRead) DESC
LIMIT 5;
```
=====================
Question: What is the average writing score of each of the schools managed by Ricci Ulrich? List the schools and the corresponding average writing scores.
 db_id: california_schools
Planner: Plan:
1. Find the schools managed by 'Ricci Ulrich' from the `schools` table using `AdmLName1` column.
2. Join the `schools` table with the `satscores` table on the `CDSCode` column from `schools` table and `cds` column from `satscores` table to get the writing scores for those schools.
3. Calculate the average writing score for each school.
4. Return the school name and the average writing score.
Required Tables:
- schools
- satscores

Required Columns:
- schools.School
- schools.AdmLName1
- schools.CDSCode
- satscores.sname
- satscores.cds
- satscores.AvgScrWrite

Filters:
- schools.AdmLName1 = 'Ulrich'
Joins:
- schools.CDSCode = satscores.cds
Aggregations:
- AVG(satscores.AvgScrWrite) grouped by schools.School
NL2SQL: ```sql
SELECT
  T1.School,
  AVG(T2.AvgScrWrite)
FROM schools AS T1
INNER JOIN satscores AS T2
  ON T1.CDSCode = T2.cds
WHERE
  T1.AdmLName1 = 'Ulrich'
GROUP BY
  T1.School;
```
Critic: ```sql
SELECT
  T1.School,
  AVG(T2.AvgScrWrite)
FROM schools AS T1
INNER JOIN satscores AS T2
  ON T1.School = T2.sname
WHERE
  T1.AdmLName1 = 'Ulrich' AND T1.AdmFName1 = 'Ricci'
GROUP BY
  T1.School;
```
=====================
Question: Which state special schools have the highest number of enrollees from grades 1 through 12?
 db_id: california_schools
Planner: Plan:
1. Filter the `schools` table for special schools by filtering `DOC` to be 31.
2. Join `schools` and `frpm` table on `CDSCode` to get enrollment information.
3. Filter `frpm` table for schools with at least grade 1 and up to grade 12 students based on `Low Grade` and `High Grade`.
4. Group the results by school name and state and calculate the sum of enrollment for each school.
5. Order the results by total enrollment in descending order.
6. Select the school name, state, and total enrollment.

NL2SQL: ```sql
SELECT
  s.School,
  s.State,
  SUM(f."Enrollment (K-12)") AS total_enrollment
FROM schools AS s
JOIN frpm AS f
  ON s.CDSCode = f.CDSCode
WHERE
  s.DOCType = 'State Special Schools'
  AND f.LowGrade = '1'
  AND f.HighGrade = '12'
GROUP BY
  s.School,
  s.State
ORDER BY
  total_enrollment DESC
LIMIT 1;
```
Critic: ```sql
SELECT
  s.School,
  SUM(f."Enrollment (K-12)") AS total_enrollment
FROM schools AS s
JOIN frpm AS f
  ON s.CDSCode = f.CDSCode
WHERE
  s.DOCType = 'State Special Schools'
GROUP BY
  s.School
ORDER BY
  total_enrollment DESC
LIMIT 1;
```
=====================
Question: What is the monthly average number of schools that opened in Alameda County under the jurisdiction of the Elementary School District in 1980?
 db_id: california_schools
Planner: Plan:
1. Filter the `schools` table for schools located in 'Alameda County'.
2. Filter the `schools` table by `OpenDate` to include only schools that opened in the year 1980.
3. From the filtered schools, count the number of schools that opened each month.
4. Calculate the monthly average of schools opened in Alameda County.
5. From the filtered schools, filter by DOC = 52, where DOC is District Ownership Code. From DOCtype, the value 52 means Elementary School District
6. Grouping by month, calculate the average monthly number of schools opened.
Final Answer:
```sql
SELECT CAST(COUNT(CASE WHEN strftime('%Y', OpenDate) = '1980' THEN CDSCode ELSE NULL END) AS REAL) / 12 FROM schools WHERE County = 'Alameda County' AND DOC = '52'
```
NL2SQL: ```sql
SELECT CAST(COUNT(CASE WHEN strftime('%Y', OpenDate) = '1980' THEN CDSCode ELSE NULL END) AS REAL) / 12 FROM schools WHERE County = 'Alameda County' AND DOC = '52'
```
Critic: ```sql
SELECT CAST(COUNT(CASE WHEN strftime('%Y', OpenDate) = '1980' THEN CDSCode ELSE NULL END) AS REAL) / 12 FROM schools WHERE County = 'Alameda County' AND DOCType = 'Elementary School District'
```
=====================
Question: What is the ratio of merged Unified School District schools in Orange County to merged Elementary School District schools?
 db_id: california_schools
Planner: Plan:
1. Filter the `schools` table for schools in Orange County.
2. Count the number of schools with `DOCType` equal to 'Unified School District' in Orange County.
3. Count the number of schools with `DOCType` equal to 'Elementary School District' in Orange County.
4. Calculate the ratio of the count of 'Unified School District' to the count of 'Elementary School District'.
5. Handle the case where the count of 'Elementary School District' is zero to avoid division by zero.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN DOCType = 'Unified School District' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN DOCType = 'Elementary School District' THEN 1 ELSE 0 END)
FROM schools
WHERE
  County = 'Orange County';
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN DOCType = 'Unified School District' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN DOCType = 'Elementary School District' THEN 1 ELSE 0 END)
FROM schools
WHERE
  County = 'Orange';
```
=====================
Question: What is the postal street address for the school with the 7th highest Math average? Indicate the school's name.
 db_id: california_schools
Planner: Plan:
1. Calculate the average Math SAT score for each school using the `satscores` table.
2. Rank the schools based on their average Math SAT scores in descending order.
3. Filter to get the school with the 7th highest average Math SAT score.
4. Retrieve the school name and street address from the `schools` table, joining on the school name. The tables `satscores` and `schools` have the school name, `sname` and `School` respectively that can be used to join them.

```nl2sql
SELECT T2.School, T2.Street FROM (SELECT sname, AvgScrMath, dense_rank() OVER (ORDER BY AvgScrMath DESC) AS rank_num FROM satscores) AS T1 JOIN schools AS T2 ON T1.sname = T2.School WHERE T1.rank_num = 7
```
NL2SQL: ```sql
SELECT T2.School, T2.Street FROM (SELECT sname, AvgScrMath, dense_rank() OVER (ORDER BY AvgScrMath DESC) AS rank_num FROM satscores) AS T1 JOIN schools AS T2 ON T1.sname = T2.School WHERE T1.rank_num = 7
```
Critic: ```sql
SELECT T1.Street, T1.School FROM schools AS T1 JOIN satscores AS T2 ON T1.School = T2.sname ORDER BY T2.AvgScrMath DESC LIMIT 6, 1
```
=====================
Question: What is the total number of non-chartered schools in the county of Los Angeles with a percent (%) of eligible free meals for grades 1 through 12 that is less than 0.18%?
 db_id: california_schools
Planner: 1.  **Filter schools table:** Filter the `schools` table to include only schools located in "Los Angeles" county and where `Charter` is 0 (non-charter schools).
2.  **Join schools and frpm tables:** Join the filtered `schools` table with the `frpm` table on the `CDSCode` to access free meal data.
3.  **Filter frpm table:** Filter the joined table with the condition that `Percent (%) Eligible Free (K-12)` is less than 0.18.
4.  **Count the schools:** Count the number of distinct schools based on `CDSCode` after applying all the filters.
5.  **Return the count:** Return the final count.

NL2SQL: ```sql
SELECT
  COUNT(T1.CDSCode)
FROM schools AS T1
INNER JOIN frpm AS T2
  ON T1.CDSCode = T2.CDSCode
WHERE
  T1.County = 'Los Angeles' AND T1.Charter = 0 AND T2."Percent (%) Eligible Free (K-12)" < 0.18;
```
Critic: ```sql
SELECT
  COUNT(T1.CDSCode)
FROM schools AS T1
INNER JOIN frpm AS T2
  ON T1.CDSCode = T2.CDSCode
WHERE
  T1.County = 'Los Angeles' AND T1.Charter = 0 AND T2."Percent (%) Eligible Free (K-12)" < 0.18;
```
=====================
Question: How many students from the ages of 5 to 17 are enrolled at the State Special School school in Fremont for the 2014-2015 academic year?
 db_id: california_schools
Planner: 1.  **Find the school:** Use the `schools` table to find the `CDSCode` for schools where `EdOpsCode` is 'SSS' (State Special School), `School` is 'State Special School', and `City` is 'Fremont'.
2.  **Filter by academic year:** Use the `frpm` table, filtering for the academic year 2014-2015 (`Academic Year` = 2015).
3.  **Join tables:** Join the `schools` table with the `frpm` table using `CDSCode`. The `CDSCode` in schools table is text and in frpm it is integer, so cast the `CDSCode` in `schools` table to integer.
4.  **Calculate the number of students:**  Select the `Enrollment (Ages 5-17)` column from the `frpm` table.
5.  **Handle edge cases:** In case the school 'State Special School' does not exists in Fremont, the count should be 0.
NL2SQL: ```sql
SELECT
  SUM(T1.`Enrollment (Ages 5-17)`)
FROM frpm AS T1
INNER JOIN schools AS T2
  ON CAST(T2.CDSCode AS INTEGER) = T1.CDSCode
WHERE
  T2.EdOpsCode = 'SSS'
  AND T2.School = 'State Special School'
  AND T2.City = 'Fremont'
  AND T1.`Academic Year` = 2015;
```
Critic: ```sql
SELECT
  SUM(T1.`Enrollment (Ages 5-17)`)
FROM frpm AS T1
INNER JOIN schools AS T2
  ON T2.CDSCode = T1.CDSCode
WHERE
  T2.EdOpsCode = 'SSS'
  AND T2.School = 'State Special School'
  AND T2.City = 'Fremont'
  AND T1.`Academic Year` = 2015;
```
=====================
Question: Which schools served a grade span of Kindergarten to 9th grade in the county of Los Angeles and what is its Percent (%) Eligible FRPM (Ages 5-17)?
 db_id: california_schools
Planner: Plan:
1. Filter the `schools` table to find schools where the `County` is 'Los Angeles' and the `GSserved` is 'K-9'.
2. Select the `School` name and `CDSCode` from the filtered `schools` table.
3. Join the `schools` table with the `frpm` table on `CDSCode`.
4. Select from `frpm` the column  `Percent (%) Eligible FRPM (Ages 5-17)`.
5. Display school name and its Percent (%) Eligible FRPM (Ages 5-17).

NL2SQL: ```sql
SELECT
  s.School,
  f."Percent (%) Eligible FRPM (Ages 5-17)"
FROM schools AS s
JOIN frpm AS f
  ON s.CDSCode = f.CDSCode
WHERE
  s.County = 'Los Angeles' AND s.GSserved = 'K-9';
```
Critic: ```sql
SELECT
  s.School,
  f."Percent (%) Eligible FRPM (Ages 5-17)"
FROM schools AS s
JOIN frpm AS f
  ON s.CDSCode = CAST(f.CDSCode AS TEXT)
WHERE
  s.County = 'Los Angeles' AND s.GSserved = 'K-9';
```
=====================
Question: Between San Diego and Santa Barbara, which county offers the most number of schools that does not offer physical building? Indicate the amount.
 db_id: california_schools
Planner: Plan:
1. Filter the schools table to find schools where Virtual = 'F' and County is either 'San Diego' or 'Santa Barbara'.
2. Group the filtered results by County and count the number of schools in each county.
3. Select the County with the maximum number of schools.
4. Return the County and the count of schools.
NL2SQL: ```sql
SELECT
  County,
  COUNT(*) AS num_schools
FROM schools
WHERE
  Virtual = 'F' AND County IN ('San Diego', 'Santa Barbara')
GROUP BY
  County
ORDER BY
  num_schools DESC
LIMIT 1;
```
Critic: ```sql
SELECT
  County,
  COUNT(*)
FROM schools
WHERE
  Virtual = 'Yes' AND County IN ('San Diego', 'Santa Barbara')
GROUP BY
  County
ORDER BY
  COUNT(*) DESC
LIMIT 1;
```
=====================
Question: What is the grade span offered in the school with the highest longitude?
 db_id: california_schools
Planner: 1. Find the school with the highest longitude using the `schools` table.
2. Retrieve the `GSoffered` (grade span offered) for that school.
3. Return the `GSoffered` value.
I need to use schools table and Longitude and GSoffered columns.
I need to use max function and where clause.
NL2SQL: ```sql
SELECT GSoffered FROM schools ORDER BY Longitude DESC LIMIT 1
```
Critic: ```sql
SELECT GSoffered FROM schools ORDER BY Longitude DESC LIMIT 1
```
=====================
Question: Of the schools that offers a magnet program serving a grade span of Kindergarten to 8th grade, how many offers Multiple Provision Types? List the number of cities that offers a Kindergarten to 8th grade span and indicate how many schools are there serving such grade span for each city.
 db_id: california_schools
Planner: Here's my plan to answer the question:

1.  **Find the number of schools offering a magnet program and serving grades K-8 with Multiple Provision Types:**

    *   Table: `schools` and `frpm`
    *   Filters: `schools.Magnet = 1` and `frpm.Low Grade = 'K'` and `frpm.High Grade = '8'` and `frpm.NSLP Provision Status = 'Multiple Provision Types'`
    *   Join: Join the `schools` and `frpm` tables on their common column `CDSCode`.
    *   Columns: `COUNT(DISTINCT schools.CDSCode)`

2.  **Find the number of cities offering K-8 grade span and the number of schools in each city:**

    *   Table: `schools` and `frpm`
    *   Filters: `frpm.Low Grade = 'K'` and `frpm.High Grade = '8'`
    *   Join: Join the `schools` and `frpm` tables on their common column `CDSCode`.
    *   Group by: `schools.City`
    *   Columns: `schools.City`, `COUNT(DISTINCT schools.CDSCode)`

NL2SQL: ```sql
SELECT
  COUNT(DISTINCT T1.CDSCode)
FROM schools AS T1
INNER JOIN frpm AS T2
  ON T1.CDSCode = T2.CDSCode
WHERE
  T1.Magnet = 1
  AND T2."Low Grade" = 'K'
  AND T2."High Grade" = '8'
  AND T2."NSLP Provision Status" = 'Multiple Provision Types';
SELECT
  T1.City,
  COUNT(DISTINCT T1.CDSCode)
FROM schools AS T1
INNER JOIN frpm AS T2
  ON T1.CDSCode = T2.CDSCode
WHERE
  T2."Low Grade" = 'K'
  AND T2."High Grade" = '8'
GROUP BY
  T1.City;
```
Critic: ```sql
SELECT
  COUNT(DISTINCT T1.CDSCode)
FROM schools AS T1
INNER JOIN frpm AS T2
  ON T1.CDSCode = T2.CDSCode
WHERE
  T1.Magnet = 1
  AND T2."Low Grade" = 'K'
  AND T2."High Grade" = '8'
  AND T2."NSLP Provision Status" = 'Multiple Provision Types';
SELECT
  T1.City,
  COUNT(T1.CDSCode)
FROM schools AS T1
INNER JOIN frpm AS T2
  ON T1.CDSCode = T2.CDSCode
WHERE
  T2."Low Grade" = 'K'
  AND T2."High Grade" = '8'
GROUP BY
  T1.City;
```
=====================
Question: What is the Percent (%) Eligible Free (K-12) in the school administered by an administrator whose first name is Alusine. List the district code of the school.
 db_id: california_schools
Planner: Here's my plan to get the requested information.

1.  **Join Tables:** Join the `schools` and `frpm` tables on their common field, `CDSCode`. Since the `CDSCode` is text in `schools` and integer in `frpm`, cast the `CDSCode` in schools table to integer during the join.
2.  **Filter Data:**
    *   Filter the `schools` table where `AdmFName1` is 'Alusine'.
3.  **Select and Rename Columns:**
    *   Select the `Percent (%) Eligible Free (K-12)` from the `frpm` table.
    *   Select the `District Code` from the `frpm` table.

NL2SQL: ```sql
SELECT
  T1.`Percent (%) Eligible Free (K-12)`,
  T1.`District Code`
FROM frpm AS T1
INNER JOIN schools AS T2
  ON CAST(T2.CDSCode AS INTEGER) = T1.CDSCode
WHERE
  T2.AdmFName1 = 'Alusine';
```
Critic: ```sql
SELECT
  T1.`Percent (%) Eligible Free (K-12)`,
  T1.`District Code`
FROM frpm AS T1
INNER JOIN schools AS T2
  ON T2.CDSCode = CAST(T1.CDSCode AS TEXT)
WHERE
  T2.AdmFName1 = 'Alusine';
```
=====================
Question: What are the valid e-mail addresses of the administrator of the school located in the San Bernardino county, City of San Bernardino City Unified that opened between 1/1/2009 to 12/31/2010 whose school types are public Intermediate/Middle Schools and Unified Schools?
 db_id: california_schools
Planner: 1.  **Filter schools table:**
    *   County = 'San Bernardino'
    *   District = 'San Bernardino City Unified'
    *   OpenDate between '2009-01-01' and '2010-12-31'
    *   SOCType = 'Public Intermediate/Middle School' or DOCType = 'Unified School'
2.  **Select AdmEmail1 column** from the filtered table.

NL2SQL: ```sql
SELECT AdmEmail1
FROM schools
WHERE County = 'San Bernardino'
AND District = 'San Bernardino City Unified'
AND OpenDate BETWEEN '2009-01-01' AND '2010-12-31'
AND (SOCType = 'Public Intermediate/Middle School' OR DOCType = 'Unified School');
```
Critic: ```sql
SELECT AdmEmail1
FROM schools
WHERE County = 'San Bernardino'
AND District = 'San Bernardino City Unified'
AND OpenDate BETWEEN '2009-01-01' AND '2010-12-31'
AND (SOCType = 'Public School' AND EILName = 'Intermediate/Middle School' OR DOCType = 'Unified School District');
```
=====================
Question: How many accounts who choose issuance after transaction are staying in East Bohemia region?
 db_id: financial
Planner: Plan:
1. Find accounts that have 'POPLATEK PO OBRATU' (issuance after transaction) in the `trans` table.
2. Find the `district_id` associated with these `account_id`s in the `account` table.
3. Find the region (`A3`) of these `district_id`s in the `district` table.
4. Filter the results to include only accounts in the 'East Bohemia' region.
5. Count the number of accounts that meet these criteria.
Final Answer:
The query should return the count of distinct account IDs that have transactions with `operation` = 'POPLATEK PO OBRATU' and are located in the 'East Bohemia' region.
```sql
SELECT
  COUNT(DISTINCT T1.account_id)
FROM account AS T1
INNER JOIN district AS T2
  ON T1.district_id = T2.district_id
INNER JOIN trans AS T3
  ON T1.account_id = T3.account_id
WHERE
  T2.A3 = 'East Bohemia' AND T3.operation = 'POPLATEK PO OBRATU';
```
NL2SQL: ```sql
SELECT
  COUNT(DISTINCT T1.account_id)
FROM account AS T1
INNER JOIN district AS T2
  ON T1.district_id = T2.district_id
INNER JOIN trans AS T3
  ON T1.account_id = T3.account_id
WHERE
  T2.A3 = 'East Bohemia' AND T3.operation = 'POPLATEK PO OBRATU';
```
Critic: ```sql
SELECT
  COUNT(DISTINCT T1.account_id)
FROM account AS T1
INNER JOIN district AS T2
  ON T1.district_id = T2.district_id
INNER JOIN trans AS T3
  ON T1.account_id = T3.account_id
WHERE
  T2.A3 = 'East Bohemia' AND T3.k_symbol = 'POPLATEK PO OBRATU';
```
=====================
Question: List out the no. of districts that have female average salary is more than 6000 but less than 10000?
 db_id: financial
Planner: Plan:
1. Filter the `client` table to select female clients (gender = 'F').
2. Join the `client` table with the `district` table using `district_id`.
3. Calculate the average salary for each district.
4. Filter the results to include only districts where the female average salary is greater than 6000 and less than 10000.
5. Count the number of distinct districts that meet the criteria.
6. Return the count.

```nl2sql
SELECT count(DISTINCT T1.district_id) FROM district AS T1 JOIN client AS T2 ON T1.district_id  =  T2.district_id WHERE T1.A11 > 6000 AND T1.A11 < 10000 AND T2.gender  =  'F'
```
NL2SQL: ```sql
SELECT count(DISTINCT T1.district_id) FROM district AS T1 JOIN client AS T2 ON T1.district_id = T2.district_id WHERE T2.gender = 'F' AND T1.A11 > 6000 AND T1.A11 < 10000
```
Critic: ```sql
SELECT count(DISTINCT T1.district_id) FROM district AS T1 JOIN client AS T2 ON T1.district_id = T2.district_id WHERE T2.gender = 'F' AND T1.A11 > 6000 AND T1.A11 < 10000
```
=====================
Question: How many male customers who are living in North Bohemia have average salary greater than 8000?
 db_id: financial
Planner: Plan:
1. Join the `client` table with the `district` table on `district_id` to get the region and average salary for each client.
2. Filter the results to include only male clients (`gender` = 'M') living in North Bohemia (`A3` = 'North Bohemia').
3. Filter the results further to include only clients with an average salary greater than 8000 (`A11` > 8000).
4. Count the number of clients that satisfy these conditions.

NL2SQL: ```sql
SELECT
  COUNT(DISTINCT T1.client_id)
FROM client AS T1
INNER JOIN district AS T2
  ON T1.district_id = T2.district_id
WHERE
  T1.gender = 'M' AND T2.A3 = 'North Bohemia' AND T2.A11 > 8000;
```
Critic: ```sql
SELECT
  COUNT(DISTINCT T1.client_id)
FROM client AS T1
INNER JOIN district AS T2
  ON T1.district_id = T2.district_id
WHERE
  T1.gender = 'M' AND T2.A3 = 'north Bohemia' AND T2.A11 > 8000;
```
=====================
Question: List out the account numbers of female clients who are oldest and has lowest average salary, calculate the gap between this lowest average salary with the highest average salary?
 db_id: financial
Planner: Here's a plan to address the question:

1.  **Identify the oldest female clients:**
    *   Join `client` and `disp` tables on `client_id`.
    *   Filter for female clients (`gender = 'F'`).
    *   Determine the maximum birth date (`MAX(birth_date)`) among female clients.
    *   Filter the joined table to keep only those female clients with the maximum birth date.
    *   Select the `account_id` of those clients.

2.  **Calculate the average salary for each account:**
    *   Join `account` and `district` tables on `district_id`.
    *   Calculate the average salary (`AVG(A11)`) for each `account_id`.
    *   Group the result by `account_id`.

3.  **Find the account(s) with the lowest average salary among the oldest female clients:**
    *   Combine the results from step 1 and 2, so we will have a table consisting of the account\_id of the oldest female clients, and the table consisting of the account\_id and average salary.
    *   Filter the accounts from step 2 that are also in the oldest female clients identified in step 1.
    *   Order the result by average salary (`AVG(A11)`) in ascending order and select the account\_id with the lowest salary.
    *   Save the lowest average salary.

4.  **Calculate the highest average salary:**
    *   Use the query in step 2
    *   Find the maximum value of average salary (`MAX(AVG(A11))`).

5.  **Calculate the gap:**
    *   Subtract the lowest average salary (from step 3) from the highest average salary (from step 4).
    *   Select the `account_id` from step 3.
    *   Output the account ID and the salary gap.

NL2SQL:
```sql
WITH OldestFemaleClients AS (
  SELECT
    d.account_id
  FROM client AS c
  JOIN disp AS d
    ON c.client_id = d.client_id
  WHERE
    c.gender = 'F' AND c.birth_date = (
      SELECT
        MIN(birth_date)
      FROM client
      WHERE
        gender = 'F'
    )
), AccountAvgSalaries AS (
  SELECT
    a.account_id,
    AVG(d.A11) AS avg_salary
  FROM account AS a
  JOIN district AS d
    ON a.district_id = d.district_id
  GROUP BY
    a.account_id
), LowestAvgSalary AS (
  SELECT
    account_id,
    avg_salary
  FROM AccountAvgSalaries
  WHERE
    account_id IN (
      SELECT
        account_id
      FROM OldestFemaleClients
    )
  ORDER BY
    avg_salary
  LIMIT 1
), MaxAvgSalary AS (
  SELECT
    MAX(avg_salary) AS max_avg_salary
  FROM AccountAvgSalaries
)
SELECT
  l.account_id,
  m.max_avg_salary - l.avg_salary AS salary_gap
FROM LowestAvgSalary AS l, MaxAvgSalary AS m;
```
NL2SQL: ```sql
WITH oldest_female_accounts AS (
  SELECT
    d.account_id
  FROM client AS c
  JOIN disp AS d
    ON c.client_id = d.client_id
  WHERE
    c.gender = 'F'
  ORDER BY
    c.birth_date
  LIMIT 1
), avg_salaries AS (
  SELECT
    a.account_id,
    AVG(d.A11) AS avg_salary
  FROM account AS a
  JOIN district AS d
    ON a.district_id = d.district_id
  GROUP BY
    a.account_id
), lowest_avg_salary_account AS (
  SELECT
    avg_salaries.account_id,
    avg_salaries.avg_salary
  FROM avg_salaries
  WHERE
    avg_salaries.account_id IN (
      SELECT
        account_id
      FROM oldest_female_accounts
    )
  ORDER BY
    avg_salaries.avg_salary
  LIMIT 1
), max_avg_salary AS (
  SELECT
    MAX(avg_salary) AS max_avg_salary
  FROM avg_salaries
)
SELECT
  lowest_avg_salary_account.account_id,
  (
    SELECT
      max_avg_salary
    FROM max_avg_salary
  ) - lowest_avg_salary_account.avg_salary
FROM lowest_avg_salary_account;
```
Critic: ```sql
WITH FemaleClients AS (
  SELECT
    c.client_id,
    c.birth_date
  FROM client AS c
  WHERE
    c.gender = 'F'
), AccountInfo AS (
  SELECT
    d.account_id,
    AVG(di.A11) AS avg_salary
  FROM disp AS d
  JOIN client AS c
    ON d.client_id = c.client_id
  JOIN account AS a
    ON d.account_id = a.account_id
  JOIN district AS di
    ON a.district_id = di.district_id
  GROUP BY
    d.account_id
), OldestFemale AS (
  SELECT
    client_id,
    MIN(birth_date) AS oldest_birth_date
  FROM FemaleClients
), LowestAvgSalary AS (
  SELECT
    ai.account_id,
    ai.avg_salary
  FROM AccountInfo AS ai
  JOIN disp AS d
    ON ai.account_id = d.account_id
  JOIN OldestFemale AS of
    ON d.client_id = of.client_id
  WHERE
    d.type = 'OWNER'
  ORDER BY
    ai.avg_salary
  LIMIT 1
), MaxAvgSalary AS (
  SELECT
    MAX(avg_salary) AS max_avg_salary
  FROM AccountInfo
)
SELECT
  las.account_id,
  ma.max_avg_salary - las.avg_salary AS salary_gap
FROM LowestAvgSalary AS las, MaxAvgSalary AS ma;
```
=====================
Question: List out the account numbers of clients who are youngest and have highest average salary?
 db_id: financial
Planner: Here's a plan to retrieve the account numbers of the youngest clients with the highest average salary:

1.  **Find the youngest birth date:** Determine the most recent birth date in the `client` table.

2.  **Find the highest average salary**: Find the highest average salary in the `district` table, as A11 refers to average salary.

3.  **Filter clients**: Select clients from the `client` table whose birth date matches the youngest birth date found in step 1.

4.  **Filter districts**: Select district id from the `district` table whose average salary matches the highest average salary found in step 2.

5.  **Join clients and disp**: Join the filtered clients with the `disp` table on `client_id` to get their associated `account_id`.

6.  **Join disp and account**: Join the filtered disp with the `account` table on `account_id` and the filtered districts on `district_id`

7.  **Select account numbers**: Select the `account_id` from the result.

NL2SQL: ```sql
SELECT
  T1.account_id
FROM disp AS T1
INNER JOIN client AS T2
  ON T1.client_id = T2.client_id
INNER JOIN account AS T3
  ON T1.account_id = T3.account_id
INNER JOIN district AS T4
  ON T3.district_id = T4.district_id
WHERE
  T2.birth_date = (
    SELECT
      MAX(birth_date)
    FROM client
  )
  AND T4.A11 = (
    SELECT
      MAX(A11)
    FROM district
  );
```
Critic: ```sql
SELECT
  T1.account_id
FROM disp AS T1
INNER JOIN client AS T2
  ON T1.client_id = T2.client_id
INNER JOIN account AS T3
  ON T1.account_id = T3.account_id
INNER JOIN district AS T4
  ON T3.district_id = T4.district_id
WHERE
  T2.birth_date = (
    SELECT
      MAX(birth_date)
    FROM client
  )
ORDER BY
  T4.A11 DESC
LIMIT 1;
```
=====================
Question: Among the accounts who have approved loan date in 1997, list out the accounts that have the lowest approved amount and choose weekly issuance statement.
 db_id: financial
Planner: Plan:
1. Filter loans approved in 1997.
2. Find the minimum loan amount among those loans.
3. Find the account IDs which have the minimum loan amount.
4. Find the accounts with "POPLATEK TYDNE" (weekly issuance) from the account table.
5. Output the account IDs which satisfies both conditions (minimum amount loans in 1997 and "POPLATEK TYDNE").
Tables:
loan, account
Columns:
loan.date, loan.amount, loan.account_id, account.account_id, account.frequency
Filters:
YEAR(loan.date) = 1997, account.frequency = 'POPLATEK TYDNE'
Aggregations:
MIN(loan.amount)
Joins:
None
Final Output:
account.account_id

NL2SQL: ```sql
SELECT DISTINCT T1.account_id FROM account AS T1 JOIN loan AS T2 ON T1.account_id = T2.account_id WHERE T1.frequency = 'POPLATEK TYDNE' AND STRFTIME('%Y', T2.date) = '1997' AND T2.amount = ( SELECT MIN(amount) FROM loan WHERE STRFTIME('%Y', DATE) = '1997' )
```
Critic: ```sql
SELECT T1.account_id FROM account AS T1 INNER JOIN loan AS T2 ON T1.account_id = T2.account_id WHERE T1.frequency = 'POPLATEK TYDNE' AND STRFTIME('%Y', T2.date) = '1997' ORDER BY T2.amount ASC LIMIT 1
```
=====================
Question: Among the accounts who have loan validity more than 12 months, list out the accounts that have the highest approved amount and have account opening date in 1993.
 db_id: financial
Planner: 1. **Filter loans:** Select loans with `duration` greater than 12 months.
2. **Filter accounts:** Select accounts opened in 1993 using the year from `date` column.
3. **Join loans and accounts:** Join the filtered loans and accounts using `account_id`.
4. **Order and Limit:** Order the joined table by loan `amount` in descending order to find the account with the highest approved loan amount and limit the result to the top account.
5. **Select account id:** Output the `account_id`.

NL2SQL: ```sql
SELECT
  T1.account_id
FROM loan AS T1
INNER JOIN account AS T2
  ON T1.account_id = T2.account_id
WHERE
  T1.duration > 12 AND STRFTIME('%Y', T2.date) = '1993'
ORDER BY
  T1.amount DESC
LIMIT 1;
```
Critic: ```sql
SELECT
  T1.account_id
FROM loan AS T1
INNER JOIN account AS T2
  ON T1.account_id = T2.account_id
WHERE
  T1.duration > 12 AND STRFTIME('%Y', T2.date) = '1993'
ORDER BY
  T1.amount DESC
LIMIT 1;
```
=====================
Question: Among the account opened, how many female customers who were born before 1950 and stayed in Sokolov?
 db_id: financial
Planner: Here's a plan to answer the question:

1.  **Identify relevant tables:** `client`, `district`, `account`, and `disp`.
2.  **Filter for female clients:** In the `client` table, filter for `gender = 'F'`.
3.  **Filter for clients born before 1950:** In the `client` table, filter for `birth_date < '1950-01-01'`.
4.  **Filter for clients in Sokolov:** In the `district` table, filter for `A2 = 'Sokolov'`.
5.  **Join `client` and `district`:** Join `client` and `district` tables on `client.district_id = district.district_id`.
6.  **Join with account table:** Join `account` and `disp` tables on `account.account_id = disp.account_id`, then join the table resulted from the previous step to the disp table on `client.client_id=disp.client_id`.
7.  **Count the distinct accounts:** Count the number of distinct `account.account_id`.

NL2SQL: ```sql
SELECT
  COUNT(DISTINCT T1.account_id)
FROM account AS T1
INNER JOIN disp AS T2
  ON T1.account_id = T2.account_id
INNER JOIN client AS T3
  ON T2.client_id = T3.client_id
INNER JOIN district AS T4
  ON T3.district_id = T4.district_id
WHERE
  T3.gender = 'F' AND T3.birth_date < '1950-01-01' AND T4.A2 = 'Sokolov';
```
Critic: ```sql
SELECT
  COUNT(DISTINCT T1.account_id)
FROM account AS T1
INNER JOIN disp AS T2
  ON T1.account_id = T2.account_id
INNER JOIN client AS T3
  ON T2.client_id = T3.client_id
INNER JOIN district AS T4
  ON T1.district_id = T4.district_id
WHERE
  T3.gender = 'F' AND T3.birth_date < '1950-01-01' AND T4.A2 = 'Sokolov';
```
=====================
Question: For the female client who was born in 1976/1/29, which district did she opened her account?
 db_id: financial
Planner: Plan:
1. Filter the `client` table to find the client with `gender` = 'F' and `birth_date` = '1976-01-29'.
2. Get the `district_id` from the filtered `client` table.
3. Join the `district` table with the `client` table using the `district_id`.
4. Select the `A2` column from the `district` table, which represents the district name.

NL2SQL: ```sql
SELECT
  T2.A2
FROM client AS T1
INNER JOIN district AS T2
  ON T1.district_id = T2.district_id
WHERE
  T1.gender = 'F' AND T1.birth_date = '1976-01-29';
```
Critic: ```sql
SELECT
  T2.A2
FROM client AS T1
INNER JOIN district AS T2
  ON T1.district_id = T2.district_id
WHERE
  T1.gender = 'F' AND T1.birth_date = '1976-01-29';
```
=====================
Question: For the branch which located in the south Bohemia with biggest number of inhabitants, what is the percentage of the male clients?
 db_id: financial
Planner: Here's a plan to determine the percentage of male clients for the branch in South Bohemia with the largest number of inhabitants:

1.  **Identify the District:**
    *   Filter the `district` table to find districts located in 'south Bohemia' using `A3 = 'south Bohemia'`.
    *   Order the filtered districts by `A4` (number of inhabitants) in descending order to find the district with the most inhabitants.
    *   Get the `district_id` of that district.

2.  **Count Total Clients in the District:**
    *   Filter the `client` table by the `district_id` found in step 1.
    *   Count the total number of clients in that district.

3.  **Count Male Clients in the District:**
    *   Filter the `client` table by the `district_id` found in step 1 and `gender = 'M'`.
    *   Count the number of male clients in that district.

4.  **Calculate the Percentage:**
    *   Divide the number of male clients (step 3) by the total number of clients (step 2).
    *   Multiply the result by 100 to express it as a percentage.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.gender = 'M' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.client_id)
FROM client AS T1
JOIN district AS T2
  ON T1.district_id = T2.district_id
WHERE
  T2.A3 = 'south Bohemia'
ORDER BY
  T2.A4 DESC
LIMIT 1;
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.gender = 'M' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.client_id)
FROM client AS T1
JOIN district AS T2
  ON T1.district_id = T2.district_id
WHERE
  T2.A3 = 'south Bohemia'
ORDER BY
  T2.A4 DESC
LIMIT 1;
```
=====================
Question: For the client whose loan was approved first in 1993/7/5, what is the increase rate of his/her account balance from 1993/3/22 to 1998/12/27?
 db_id: financial
Planner: Here's a plan to determine the increase rate of a client's account balance:

1.  **Find the account\_id of the client with the earliest loan approval date:**
    *   Use the `loan` table.
    *   Filter for the minimum `date` value.
    *   Select the corresponding `account_id`.

2.  **Find the balance on 1993/3/22 for that account\_id:**
    *   Use the `trans` table.
    *   Filter by the `account_id` from the previous step.
    *   Filter by the `date` being equal to '1993-03-22'.
    *   Select the `balance` on that date.

3.  **Find the balance on 1998/12/27 for that account\_id:**
    *   Use the `trans` table.
    *   Filter by the `account_id` from step 1.
    *   Filter by the `date` being equal to '1998-12-27'.
    *   Select the `balance` on that date.

4.  **Calculate the increase rate:**
    *   Use the two balances from steps 2 and 3.
    *   Apply the formula: `((balance_19981227 - balance_19930322) / balance_19930322) * 100`

NL2SQL:
```sql
WITH EarliestLoan AS (
  SELECT
    account_id
  FROM loan
  ORDER BY
    date
  LIMIT 1
), Balance1 AS (
  SELECT
    balance
  FROM trans
  WHERE
    account_id = (
      SELECT
        account_id
      FROM EarliestLoan
    )
    AND date = '1993-03-22'
), Balance2 AS (
  SELECT
    balance
  FROM trans
  WHERE
    account_id = (
      SELECT
        account_id
      FROM EarliestLoan
    )
    AND date = '1998-12-27'
)
SELECT
  (
    (
      SELECT
        balance
      FROM Balance2
    ) - (
      SELECT
        balance
      FROM Balance1
    )
  ) * 100.0 / (
    SELECT
      balance
    FROM Balance1
  );
```
NL2SQL: ```sql
WITH earliest_loan AS (
  SELECT
    account_id
  FROM loan
  ORDER BY
    date
  LIMIT 1
), balance_19930322 AS (
  SELECT
    balance
  FROM trans
  WHERE
    account_id = (
      SELECT
        account_id
      FROM earliest_loan
    )
    AND date = '1993-03-22'
), balance_19981227 AS (
  SELECT
    balance
  FROM trans
  WHERE
    account_id = (
      SELECT
        account_id
      FROM earliest_loan
    )
    AND date = '1998-12-27'
)
SELECT
  (
    (
      SELECT
        balance
      FROM balance_19981227
    ) - (
      SELECT
        balance
      FROM balance_19930322
    )
  ) * 100.0 / (
    SELECT
      balance
    FROM balance_19930322
  );
```
Critic: ```sql
WITH earliest_loan AS (
  SELECT
    account_id
  FROM loan
  ORDER BY
    date
  LIMIT 1
), balance_19930322 AS (
  SELECT
    balance
  FROM trans
  WHERE
    account_id = (
      SELECT
        account_id
      FROM earliest_loan
    )
    AND date <= '1993-03-22'
  ORDER BY
    date DESC
  LIMIT 1
), balance_19981227 AS (
  SELECT
    balance
  FROM trans
  WHERE
    account_id = (
      SELECT
        account_id
      FROM earliest_loan
    )
    AND date <= '1998-12-27'
  ORDER BY
    date DESC
  LIMIT 1
SELECT
  CAST((
    (
      SELECT
        balance
      FROM balance_19981227
    ) - (
      SELECT
        balance
      FROM balance_19930322
    )
  ) AS REAL) * 100 / (
    SELECT
      balance
    FROM balance_19930322
  );
```
=====================
Question: What is the percentage of loan amount that has been fully paid with no issue.
 db_id: financial
Planner: Plan:
1. Calculate the total loan amount.
2. Calculate the total loan amount for loans with status 'A' (contract finished, no problems).
3. Calculate the percentage of the total loan amount for loans with status 'A' by dividing result of step 2 by result of step 1, and multiplying by 100.
4. Return the calculated percentage.
Tables: loan
Columns: amount, status
Filters: status = 'A'
Aggregations: SUM, COUNT
Calculations: percentage = (SUM(amount where status = 'A') / SUM(amount)) * 100
NL2SQL: ```sql
SELECT CAST(SUM(CASE WHEN status = 'A' THEN amount ELSE 0 END) AS REAL) * 100 / SUM(amount) FROM loan
```
Critic: ```sql
SELECT CAST(SUM(CASE WHEN status = 'A' THEN amount ELSE 0 END) AS REAL) * 100 / SUM(amount) FROM loan
```
=====================
Question: For loan amount less than USD100,000, what is the percentage of accounts that is still running with no issue.
 db_id: financial
Planner: Plan:
1. Filter the `loan` table to include only loans with `amount` less than 100000.
2. Count the total number of loans that satisfy the condition in step 1.
3. Filter the `loan` table to include loans that satisfy the condition in step 1 and also have `status` equal to 'C'.
4. Count the number of loans that satisfy the conditions in step 3.
5. Calculate the percentage by dividing the count from step 4 by the count from step 2 and multiplying by 100.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN status = 'C' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*)
FROM loan
WHERE
  amount < 100000;
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN status = 'C' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*)
FROM loan
WHERE
  amount < 100000;
```
=====================
Question: For loans contracts which are still running where client are in debt, list the district of the and the state the percentage unemployment rate increment from year 1995 to 1996.
 db_id: financial
Planner: Plan:
1. Join the `loan` table with the `account` table on `account_id`.
2. Join the `client` table with the `district` table on `district_id`.
3. Filter the `loan` table where `status` is 'D'.
4. Calculate the percentage increment in unemployment rate from 1995 to 1996 using the formula: `((A13 - A12) / A12) * 100`.
5. Select the district and the calculated percentage increment in unemployment rate.
6. Output the result.

NL2SQL: ```sql
SELECT
  d.A5,
  ((
    d.A13 - d.A12
  ) / d.A12) * 100
FROM loan AS l
JOIN account AS a
  ON l.account_id = a.account_id
JOIN district AS d
  ON a.district_id = d.district_id
WHERE
  l.status = 'D';
```
Critic: ```sql
SELECT
  d.A5,
  ((
    d.A13 - d.A12
  ) / d.A12) * 100
FROM loan AS l
JOIN account AS a
  ON l.account_id = a.account_id
JOIN district AS d
  ON a.district_id = d.district_id
WHERE
  l.status = 'B';
```
=====================
Question: List the top nine districts, by descending order, from the highest to the lowest, the number of female account holders.
 db_id: financial
Planner: Plan:
1. Join `client` and `district` tables on `district_id` to link client gender and district information.
2. Filter for female clients (`gender` = 'F').
3. Group the results by `district_id` and `A2` (district name).
4. Count the number of female clients in each district.
5. Order the results in descending order based on the count of female clients.
6. Limit the results to the top 9 districts.
7. Select the district name (`A2`) and the count of female clients.

NL2SQL: ```sql
SELECT
  d.A2,
  COUNT(c.client_id) AS female_count
FROM client AS c
JOIN district AS d
  ON c.district_id = d.district_id
WHERE
  c.gender = 'F'
GROUP BY
  d.district_id,
  d.A2
ORDER BY
  female_count DESC
LIMIT 9;
```
Critic: ```sql
SELECT
  d.A2,
  COUNT(c.client_id) AS num_female_clients
FROM client AS c
JOIN district AS d
  ON c.district_id = d.district_id
WHERE
  c.gender = 'F'
GROUP BY
  d.A2
ORDER BY
  num_female_clients DESC
LIMIT 9;
```
=====================
Question: Between 1/1/1995 and 12/31/1997, how many loans in the amount of at least 250,000 per account that chose monthly statement issuance were approved?
 db_id: financial
Planner: 1.  Filter the `loan` table by `date` between '1995-01-01' and '1997-12-31' and `amount` greater than or equal to 250000.
2.  Filter the `account` table with `frequency` = 'POPLATEK MESICNE' which stands for monthly statement issuance.
3.  Join the filtered `loan` and `account` tables on `account_id`.
4.  Count the distinct `loan_id` from the joined table.


NL2SQL: ```sql
SELECT
  COUNT(DISTINCT T1.loan_id)
FROM loan AS T1
INNER JOIN account AS T2
  ON T1.account_id = T2.account_id
WHERE
  T1.date BETWEEN '1995-01-01' AND '1997-12-31'
  AND T1.amount >= 250000
  AND T2.frequency = 'POPLATEK MESICNE';
```
Critic: ```sql
SELECT
  COUNT(T1.loan_id)
FROM loan AS T1
INNER JOIN account AS T2
  ON T1.account_id = T2.account_id
WHERE
  T1.date BETWEEN '1995-01-01' AND '1997-12-31'
  AND T1.amount >= 250000
  AND T2.frequency = 'POPLATEK MESICNE';
```
=====================
Question: How many accounts have running contracts in Branch location 1?
 db_id: financial
Planner: 1. Find accounts with running contracts. Use `loan` table, filter by `status` in ('C', 'D'). Get `account_id`.
2. Find accounts in branch location 1. Use `account` table, filter by `district_id` = 1. Get `account_id`.
3. Find the intersection of the two sets of `account_id`s.
4. Count the number of distinct `account_id`s.

NL2SQL: ```sql
SELECT count(DISTINCT T1.account_id) FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE T1.status = 'C' OR T1.status = 'D' AND T2.district_id = 1
```
Critic: ```sql
SELECT count(DISTINCT T1.account_id) FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE T2.district_id = 1 AND (T1.status = 'C' OR T1.status = 'D')
```
=====================
Question: In the branch where the second-highest number of crimes were committed in 1995 occurred, how many male clients are there?
 db_id: financial
Planner: Here's a plan to answer the question:

1.  **Find the second-highest number of crimes in 1995:** Use the `district` table to find the second-highest value in the `A15` column.
2.  **Identify the district(s) with that crime count:**  Find the `district_id` in the `district` table where `A15` matches the second-highest crime count found in step 1.
3.  **Count male clients in that district(s):** Join the `client` table with the `district` table on `district_id`. Filter the results to include only the `district_id`(s) found in step 2 and where `gender` is 'M'. Count the number of clients.
NL2SQL:
```sql
SELECT
  COUNT(T1.client_id)
FROM client AS T1
INNER JOIN district AS T2
  ON T1.district_id = T2.district_id
WHERE
  T2.A15 = (
    SELECT
      MAX(A15)
    FROM district
    WHERE
      A15 < (
        SELECT
          MAX(A15)
        FROM district
      )
  )
  AND T1.gender = 'M';
```
NL2SQL: ```sql
SELECT
  COUNT(T1.client_id)
FROM client AS T1
INNER JOIN district AS T2
  ON T1.district_id = T2.district_id
WHERE
  T2.A15 = (
    SELECT
      MAX(A15)
    FROM district
    WHERE
      A15 < (
        SELECT
          MAX(A15)
        FROM district
      )
  )
  AND T1.gender = 'M'
```
Critic: ```sql
SELECT
  COUNT(T1.client_id)
FROM client AS T1
INNER JOIN district AS T2
  ON T1.district_id = T2.district_id
WHERE
  T2.district_id = (
    SELECT
      district_id
    FROM district
    ORDER BY
      A15 DESC
    LIMIT 1 OFFSET 1
  )
  AND T1.gender = 'M';
```
=====================
Question: Which are the top ten withdrawals (non-credit card) by district names for the month of January 1996?
 db_id: financial
Planner: Here's my plan to get the top ten withdrawal amounts by district for January 1996:

1.  **Filter Transactions:** Filter the `trans` table to include only withdrawals ('VYDAJ' in the `type` column) that occurred in January 1996 (date LIKE '1996-01%'). Also, exclude credit card transactions by filtering out rows where `operation` is not 'VYBER KARTOU'.
2.  **Join with Account:** Join the filtered transactions with the `account` table using `account_id` to get the `district_id` for each transaction.
3.  **Join with District:** Join the result with the `district` table using `district_id` to get the `A2` column which contains the district name.
4.  **Aggregate and Order:** Group the results by `A2` (district name), sum the `amount` for each district, order by the sum of the amount in descending order, and limit to the top 10.
5.  **Select the Result:** Select the district name (`A2`) and the sum of the withdrawal amounts.

NL2SQL: ```sql
SELECT
  d.A2,
  SUM(t.amount) AS total_withdrawal_amount
FROM trans AS t
JOIN account AS a
  ON t.account_id = a.account_id
JOIN district AS d
  ON a.district_id = d.district_id
WHERE
  t.type = 'VYDAJ' AND t.date LIKE '1996-01%' AND t.operation <> 'VYBER KARTOU'
GROUP BY
  d.A2
ORDER BY
  total_withdrawal_amount DESC
LIMIT 10;
```
Critic: ```sql
SELECT
  d.A2,
  SUM(t.amount) AS total_withdrawal_amount
FROM trans AS t
JOIN account AS a
  ON t.account_id = a.account_id
JOIN district AS d
  ON a.district_id = d.district_id
WHERE
  t.type = 'VYDAJ' AND STRFTIME('%Y-%m', t.date) = '1996-01' AND t.operation <> 'VYBER KARTOU'
GROUP BY
  d.A2
ORDER BY
  total_withdrawal_amount DESC
LIMIT 10;
```
=====================
Question: How many accounts have running contracts in Branch location 1?
 db_id: financial
Planner: 1. Find accounts in branch location 1. This requires joining the `account` table with the `district` table on `district_id` and filtering by `district_id = 1`.
2. From the filtered accounts, we need to find the number of accounts that have running contracts. This requires joining the filtered accounts with the `loan` table on `account_id` and filtering by `status = 'C'` or `status = 'D'`.
3. Count the number of distinct accounts that satisfy both conditions.

NL2SQL: ```sql
SELECT count(DISTINCT T1.account_id) FROM account AS T1 JOIN district AS T2 ON T1.district_id = T2.district_id JOIN loan AS T3 ON T1.account_id = T3.account_id WHERE T2.district_id = 1 AND (T3.status = 'C' OR T3.status = 'D')
```
Critic: ```sql
SELECT count(DISTINCT T1.account_id) FROM account AS T1 INNER JOIN loan AS T2 ON T1.account_id = T2.account_id WHERE T1.district_id = 1 AND T2.status = 'C'
```
=====================
Question: In the branch where the second-highest number of crimes were committed in 1995 occurred, how many male clients are there?
 db_id: financial
Planner: Here's a plan to answer the question:

1.  **Find the second-highest number of crimes in 1995:** Use the `district` table and the `A15` column to find the second-highest value.

2.  **Identify the district(s) with the second-highest number of crimes:** Filter the `district` table to find the `district_id` where `A15` equals the second-highest crime count.

3.  **Find clients in those districts:** Join the `client` table with the filtered `district` table using `district_id`.

4.  **Filter for male clients:** Filter the joined table to include only clients where `gender` is 'M'.

5.  **Count the number of male clients:** Count the distinct `client_id` values in the filtered table.

Tables: district, client
Columns: district.district_id, district.A15, client.district_id, client.gender, client.client_id
Filters: client.gender = 'M', district.A15 = second highest crime count in 1995
Joins: district JOIN client on district.district_id = client.district_id
Final step: COUNT(DISTINCT client.client_id)

NL2SQL: ```sql
SELECT COUNT(DISTINCT T1.client_id) FROM client AS T1 JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.gender = 'M' AND T2.A15 = (SELECT MAX(A15) FROM district WHERE A15 < (SELECT MAX(A15) FROM district))
```
Critic: ```sql
SELECT count(*) FROM client AS t1 JOIN district AS t2 ON t1.district_id = t2.district_id WHERE t1.gender = 'M' AND t2.A15 = (SELECT max(A15) FROM district WHERE A15 < (SELECT max(A15) FROM district))
```
=====================
Question: Who are the account holder identification numbers whose who have transactions on the credit card with the amount is less than the average, in 1998?
 db_id: financial
Planner: Here's a plan to identify the account holder identification numbers with credit card transactions below the average amount in 1998:

1.  **Calculate the average transaction amount for credit card transactions in 1998.**
    *   Table: `trans`
    *   Filters:
        *   `date` should be in 1998.
        *   `operation` should include 'VYBER KARTOU' to indicate a credit card transaction.
    *   Aggregate Function: `AVG(amount)`

2.  **Identify transactions below the average in 1998.**
    *   Table: `trans`
    *   Filters:
        *   `date` should be in 1998.
        *   `operation` should include 'VYBER KARTOU' to indicate a credit card transaction.
        *   `amount` should be less than the average calculated in step 1.
    *   Select: `account_id`

3.  **Get the `disp_id` from `account_id` from the transactions we picked**
    *   Table: `disp`
    *   Join: Join `trans` and `disp` on `account_id`.
    *   Select: `disp_id`

4.  **Get the `client_id` from `disp_id`.**
    *   Table: `disp`
    *   Filter: Filter on the `disp_id`s we got from step 3.
    *   Select: `client_id`

5.  **Return the `client_id`.**

NL2SQL: ```sql
SELECT DISTINCT T1.client_id
FROM disp AS T1
INNER JOIN trans AS T2 ON T1.account_id = T2.account_id
WHERE
  STRFTIME('%Y', T2.date) = '1998'
  AND T2.operation = 'VYBER KARTOU'
  AND T2.amount < (
    SELECT
      AVG(amount)
    FROM trans
    WHERE
      STRFTIME('%Y', date) = '1998'
      AND operation = 'VYBER KARTOU'
  );
```
Critic: ```sql
SELECT DISTINCT T1.client_id
FROM disp AS T1
INNER JOIN trans AS T2 ON T1.account_id = T2.account_id
WHERE
  CAST(strftime('%Y', T2.date) AS INTEGER) = 1998 AND T2.amount < (
    SELECT avg(amount)
    FROM trans
    WHERE
      CAST(strftime('%Y', date) AS INTEGER) = 1998
  );
```
=====================
Question: Please list the account types that are not eligible for loans, and the average income of residents in the district where the account is located exceeds $8000 but is no more than $9000.
 db_id: financial
Planner: Plan:
1. Find the `district_id` values where the average income (`A11`) is greater than 8000 and less than or equal to 9000 from the `district` table.
2. Find the `account_id` values that are not eligible for loan. This can be found from disp table where type is not OWNER. These accounts are not eligible for loans.
3. Use `account` table and filter accounts based on the district_id and account_id from step 1 and step 2 respectively. Select the frequency of the account, which represents the account types that are not eligible for loans.

NL2SQL: ```sql
SELECT DISTINCT T1.frequency FROM account AS T1 JOIN district AS T2 ON T1.district_id = T2.district_id JOIN disp AS T3 ON T1.account_id = T3.account_id WHERE T2.A11 > 8000 AND T2.A11 <= 9000 AND T3.type != 'OWNER'
```
Critic: ```sql
SELECT DISTINCT frequency FROM account AS T1 JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T2.A11 > 8000 AND T2.A11 <= 9000 AND T1.account_id NOT IN (SELECT account_id FROM loan)
```
=====================
Question: What is the average number of crimes committed in 1995 in regions where the number exceeds 4000 and the region has accounts that are opened starting from the year 1997?
 db_id: financial
Planner: Plan:
1. Find the `district_id` of districts where accounts were opened in 1997 or later. This requires filtering the `account` table by `date >= '1997-01-01'` and selecting the `district_id`.
2. Find the average number of crimes committed in 1995 for districts where the number of crimes exceeds 4000. This involves filtering the `district` table by `A15 > 4000` and selecting `district_id` and `A15`.
3. Join the results from steps 1 and 2 on `district_id`.
4. Calculate the average of `A15` for the matching districts.
5. Return the calculated average.

NL2SQL: ```sql
SELECT
  AVG(T1.A15)
FROM district AS T1
INNER JOIN account AS T2
  ON T1.district_id = T2.district_id
WHERE
  T2.date >= '1997-01-01' AND T1.A15 > 4000;
```
Critic: ```sql
SELECT
  AVG(A15)
FROM district
WHERE
  A15 > 4000
  AND district_id IN (
    SELECT
      district_id
    FROM account
    WHERE
      STRFTIME('%Y', date) >= '1997'
  );
```
=====================
Question: List all the withdrawals in cash transactions that the client with the id 3356 makes.
 db_id: financial
Planner: Plan:
1. Select the `trans_id` from the `trans` table.
2. Filter the `trans` table for transactions where `operation` is 'VYBER' which represents cash withdrawals.
3. Join `trans` table with the `disp` table on `account_id`.
4. Filter the results from the join to include only transactions where `client_id` is 3356.

NL2SQL: ```sql
SELECT
  t.trans_id
FROM trans AS t
JOIN disp AS d
  ON t.account_id = d.account_id
WHERE
  t.operation = 'VYBER' AND d.client_id = 3356;
```
Critic: ```sql
SELECT
  t.trans_id
FROM trans AS t
JOIN disp AS d
  ON t.account_id = d.account_id
WHERE
  d.client_id = 3356 AND t.operation = 'VYBER';
```
=====================
Question: What percentage of clients who opened their accounts in the district with an average salary of over 10000 are women?
 db_id: financial
Planner: 1. Find districts with an average salary greater than 10000 using the `district` table.
2. Find the total number of female clients who opened accounts in these districts. Join `client` and `account` tables via `district_id` and filter for gender='F' and use the result from step 1 to filter `district_id` in `account` table
3. Find the total number of clients (both male and female) who opened accounts in these districts. Join `client` and `account` tables via `district_id` and use the result from step 1 to filter `district_id` in `account` table
4. Divide the number of female clients (step 2) by the total number of clients (step 3) and multiply by 100 to get the percentage.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.gender = 'F' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.client_id)
FROM client AS T1
INNER JOIN account AS T2
  ON T1.district_id = T2.district_id
INNER JOIN district AS T3
  ON T2.district_id = T3.district_id
WHERE
  T3.A11 > 10000;
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.gender = 'F' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.client_id)
FROM client AS T1
INNER JOIN account AS T2
  ON T1.client_id = T2.account_id
INNER JOIN district AS T3
  ON T2.district_id = T3.district_id
WHERE
  T3.A11 > 10000;
```
=====================
Question: What was the growth rate of the total amount of loans across all accounts for a male client between 1996 and 1997?
 db_id: financial
Planner: Plan:
1. Find the `account_id` of male clients using the `client` and `disp` tables. Filter the `client` table for `gender = 'M'`. Join `client` and `disp` on `client_id`.
2. Find loans taken in 1996 and 1997. Extract the year from the `date` column of the `loan` table using the `strftime` function.
3. Filter `loan` table on `account_id` obtained from male clients
4. Calculate the sum of loan amounts for each year (1996 and 1997).
5. Calculate the growth rate using the formula: `(sum_1997 - sum_1996) / sum_1996 * 100`.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN STRFTIME('%Y', T1.date) = '1997' THEN T1.amount ELSE 0 END) - SUM(CASE WHEN STRFTIME('%Y', T1.date) = '1996' THEN T1.amount ELSE 0 END) AS REAL) * 100 / SUM(CASE WHEN STRFTIME('%Y', T1.date) = '1996' THEN T1.amount ELSE 0 END)
FROM loan AS T1
INNER JOIN disp AS T2
  ON T1.account_id = T2.account_id
INNER JOIN client AS T3
  ON T2.client_id = T3.client_id
WHERE
  T3.gender = 'M';
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN STRFTIME('%Y', T1.date) = '1997' THEN T1.amount ELSE 0 END) - SUM(CASE WHEN STRFTIME('%Y', T1.date) = '1996' THEN T1.amount ELSE 0 END) AS REAL) * 100 / SUM(CASE WHEN STRFTIME('%Y', T1.date) = '1996' THEN T1.amount ELSE 0 END)
FROM loan AS T1
INNER JOIN disp AS T2
  ON T1.account_id = T2.account_id
INNER JOIN client AS T3
  ON T2.client_id = T3.client_id
WHERE
  T3.gender = 'M';
```
=====================
Question: How often does account number 3 request an account statement to be released? What was the aim of debiting 3539 in total?
 db_id: financial
Planner: Plan:
1. Find the number of times account number 3 requested an account statement. This information is in the `trans` table. Filter `trans` table by `account_id = 3` and `operation = 'vyber'`. Count the number of rows.
2. Find the purpose of payments that sum up to 3539. This information is in the `order` table. Filter `order` table for `amount = 3539`. Output `k_symbol`.
Final Answer:
```sql
SELECT
  COUNT(CASE WHEN T1.account_id = 3 AND T1.operation = 'vyber' THEN 1 ELSE NULL END) AS account_statement_count,
  T2.k_symbol
FROM trans AS T1
JOIN "order" AS T2
  ON T1.account_id = T2.account_id
WHERE
  T2.amount = 3539;
```
NL2SQL: ```sql
SELECT
  COUNT(CASE WHEN account_id = 3 AND operation = 'vyber' THEN 1 ELSE NULL END)
FROM trans;
```
Critic: ```sql
SELECT
  COUNT(CASE WHEN account_id = 3 AND operation = 'VYBER' THEN 1 ELSE NULL END),
  SUM(CASE WHEN account_id = 3 THEN amount ELSE 0 END)
FROM trans
WHERE
  amount = 3539;
```
=====================
Question: What percentage of male clients request for weekly statements to be issued?
 db_id: financial
Planner: 1.  Find the `account_id`s for the clients who requested weekly statements using `account` table where `frequency` is 'POPLATEK TYDNE'.
2.  Find the `client_id`s that are associated with those `account_id`s from step 1 using the `disp` table.
3.  Find the male `client_id`s from `client` table where `gender` is 'M'.
4.  Calculate the number of male clients who requested weekly statements by finding the intersection of the `client_id` sets from steps 2 and 3.
5.  Calculate the total number of clients who requested weekly statements using the `client_id` set from step 2.
6.  Calculate the percentage of male clients who requested weekly statements by dividing the number of male clients who requested weekly statements (from step 4) by the total number of clients who requested weekly statements (from step 5) and multiplying by 100.

NL2SQL: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.gender = 'M' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.client_id)
FROM client AS T1
INNER JOIN disp AS T2
  ON T1.client_id = T2.client_id
INNER JOIN account AS T3
  ON T2.account_id = T3.account_id
WHERE
  T3.frequency = 'POPLATEK TYDNE';
```
Critic: ```sql
SELECT
  CAST(SUM(CASE WHEN T1.gender = 'M' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.client_id)
FROM client AS T1
INNER JOIN disp AS T2
  ON T1.client_id = T2.client_id
INNER JOIN account AS T3
  ON T2.account_id = T3.account_id
WHERE
  T3.frequency = 'weekly issuance';
```
=====================
Question: Name the account numbers of female clients who are oldest and have lowest average salary?
 db_id: financial
Planner: Here's a plan to address the question:

1.  **Identify Female Clients:** Filter the `client` table for records where `gender` is 'F'.

2.  **Find Oldest Female Clients:** Determine the maximum `birth_date` among the female clients and select the clients matching that birthdate.

3.  **Calculate Average Salary for each district:** Calculate the average salary from the `district` table

4.  **Link clients with district:** Join `client` table with `district` table via `district_id`

5.  **Find the Lowest Average Salary district:** Determine the minimum average salary among all districts using the `district` table.

6.  **Filter by district and oldest client**: Find the clients who belongs to the minimum average salary district and who are oldest.

7.  **Get the accounts for those clients**: select accounts from `disp` table using `client_id` of filtered data.

8.  **Extract Account Numbers:** Return the `account_id` from the result.

NL2SQL: ```sql
SELECT
  T1.account_id
FROM disp AS T1
INNER JOIN client AS T2
  ON T1.client_id = T2.client_id
INNER JOIN district AS T3
  ON T2.district_id = T3.district_id
WHERE
  T2.gender = 'F'
  AND T2.birth_date = (
    SELECT
      MIN(birth_date)
    FROM client
    WHERE
      gender = 'F'
  )
  AND T3.A11 = (
    SELECT
      MIN(A11)
    FROM district
  );
```
Critic: ```sql
SELECT
  T1.account_id
FROM disp AS T1
INNER JOIN client AS T2
  ON T1.client_id = T2.client_id
WHERE
  T2.gender = 'F'
ORDER BY
  T2.birth_date
LIMIT 1;
```
=====================
Question: What is the average amount of loan which are still on running contract with statement issuance after each transaction?
 db_id: financial
Planner: Here's the plan to answer the question:

1.  **Identify relevant loans:** Filter the `loan` table for loans with `status = 'C'`.
2.  **Identify relevant transactions:** Filter the `trans` table for transactions with `operation = 'POPLATEK PO OBRATU'`.
3.  **Calculate the average loan amount:** Calculate the average of the `amount` column from the filtered `loan` table.

Final Answer:
The query should calculate the average loan amount from the `loan` table, filtering for loans where the status is 'C' and transactions with operation is 'POPLATEK PO OBRATU'.

NL2SQL: ```sql
SELECT avg(amount)
FROM loan
WHERE status = 'C';
```
Critic: ```sql
SELECT AVG(T1.amount) FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE T2.frequency = 'POPLATEK PO OBRATU' AND T1.status = 'C'
```
=====================
Question: Provide the IDs and age of the client with high level credit card, which is eligible for loans.
 db_id: financial
Planner: 1.  Join the `client` table with the `disp` table on `client_id` to find the owner of the account.
2.  Join the `disp` table with the `card` table on `disp_id` to filter credit card to gold.
3.  Select `client_id` from the `client` table and calculate the age using `birth_date`.
4.  Filter the results to include only records where `card.type` is 'gold' and `disp.type` is 'OWNER'.

NL2SQL: ```sql
SELECT
  T1.client_id,
  CAST(SUBSTR(STRFTIME('%Y', 'now'), 3, 2) AS INTEGER) - CAST(SUBSTR(STRFTIME('%Y', T1.birth_date), 3, 2) AS INTEGER)
FROM client AS T1
INNER JOIN disp AS T2
  ON T1.client_id = T2.client_id
INNER JOIN card AS T3
  ON T2.disp_id = T3.disp_id
WHERE
  T3.type = 'gold' AND T2.type = 'OWNER';
```
Critic: ```sql
SELECT
  T1.client_id,
  CAST(SUBSTR(STRFTIME('%Y', 'now'), 3, 2) AS INTEGER) - CAST(SUBSTR(STRFTIME('%Y', T1.birth_date), 3, 2) AS INTEGER)
FROM client AS T1
INNER JOIN disp AS T2
  ON T1.client_id = T2.client_id
INNER JOIN card AS T3
  ON T2.disp_id = T3.disp_id
WHERE
  T3.type = 'gold' AND T2.type = 'OWNER';
```
